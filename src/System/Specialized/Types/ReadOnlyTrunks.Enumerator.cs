namespace System;

partial struct ReadOnlyTrunks<T>
{
	/// <summary>
	/// Represents an enumerator type that can iterate on each element of type <typeparamref name="T"/> stored in this collection.
	/// </summary>
	/// <param name="this">Indicates the instance of <see langword="this"/>.</param>
	/// <remarks>
	/// This enumerator code is generated by compiler. See <see href="http://tinyurl.com/trunks-enumerator">this link</see>.
	/// </remarks>
	public ref struct Enumerator(ReadOnlyTrunks<T> @this)
	{
		/// <summary>
		/// Indicates the copied instance.
		/// </summary>
		private readonly ReadOnlyTrunks<T> _this = @this;

		/// <summary>
		/// Indicates the state of the enumerator. The value can be described which type of the node is currently enumerated.
		/// </summary>
		private int _state;

		/// <summary>
		/// Indicates the index of the array iterated.
		/// </summary>
		private int _index;

		/// <summary>
		/// Indicates the temporary value.
		/// </summary>
		private int _tempValue;

		/// <summary>
		/// Indicates the temporary array of nodes.
		/// </summary>
		private TrunkNode<T>[]? _tempNodeArray;

		/// <summary>
		/// Indicates the temporary enumerator of <see cref="List{T}"/>.
		/// </summary>
		/// <seealso cref="List{T}.Enumerator"/>
		private List<T>.Enumerator _tempListEnumerator;

		/// <summary>
		/// Indicates the value array to be iterated.
		/// </summary>
		private T[]? _tempValueArray;


		/// <inheritdoc cref="IEnumerator.Current"/>
		public T Current { get; private set; }


		/// <inheritdoc cref="IEnumerator.MoveNext"/>
		public bool MoveNext()
		{
			switch (_state)
			{
				default:
				{
					return false;
				}
				case 0:
				{
					(_state, _tempNodeArray, _tempValue) = (-1, _this._trunks, 0);
					goto CoreIteration;
				}
				case 1:
				{
					_state = -1;
					goto SetPointerNext;
				}
				case 2:
				{
					_ = (_state = -1, _index++);
					goto SwitchToEnumeratingArray;
				}
				case 3:
				{
					_state = -3;
					goto SwitchToEnumeratingList;
				}
			}

		CoreIteration:
			if (_tempValue < _tempNodeArray!.Length)
			{
				scoped ref readonly var trunkNode = ref _tempNodeArray[_tempValue];
				switch (trunkNode.Type)
				{
					case TrunkNodeType.Value:
					{
						Debug.Assert(trunkNode.IsSingleValue);
						(Current, _state) = (trunkNode.Value, 1);
						return true;
					}
					case TrunkNodeType.Array:
					{
						break;
					}
					case TrunkNodeType.List:
					{
						Debug.Assert(!trunkNode.IsSingleValue);
						(_tempListEnumerator, _state) = (((List<T>)trunkNode.ValueRef).GetEnumerator(), -3);
						goto SwitchToEnumeratingList;
					}
					default:
					{
						goto SetPointerNext;
					}
				}

				Debug.Assert(!trunkNode.IsSingleValue);
				(_tempValueArray, _index) = ((T[])trunkNode.ValueRef, 0);
				goto SwitchToEnumeratingArray;
			}

			_tempNodeArray = null;
			return false;


		SwitchToEnumeratingArray:
			if (_index < _tempValueArray!.Length)
			{
				(Current, _state) = (_tempValueArray[_index], 2);
				return true;
			}

			_tempValueArray = null;
			goto SetPointerNext;

		SwitchToEnumeratingList:
			if (_tempListEnumerator.MoveNext())
			{
				(Current, _state) = (_tempListEnumerator.Current, 3);
				return true;
			}
			_tempListEnumerator = default;
			goto SetPointerNext;

		SetPointerNext:
			_tempValue++;
			goto CoreIteration;
		}
	}
}

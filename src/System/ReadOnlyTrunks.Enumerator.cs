namespace System;

public partial struct ReadOnlyChunk<T>
{
	/// <summary>
	/// Represents an enumerator type that can iterate on each element of type <typeparamref name="T"/> stored in this collection.
	/// </summary>
	/// <param name="this">Indicates the instance of <see langword="this"/>.</param>
	/// <remarks>
	/// This enumerator code is generated by compiler. See <see href="http://tinyurl.com/trunks-enumerator">this link</see>.
	/// </remarks>
	public ref struct Enumerator(ReadOnlyChunk<T> @this) : IEnumerator<T>
	{
		/// <summary>
		/// Indicates the copied instance.
		/// </summary>
		private readonly ReadOnlyChunk<T> _this = @this;

		/// <summary>
		/// Indicates the state of the enumerator. The value can be described which type of the node is currently enumerated.
		/// </summary>
		private int _state;

		/// <summary>
		/// Indicates the index of the array iterated.
		/// </summary>
		private int _index;

		/// <summary>
		/// Indicates the temporary value.
		/// </summary>
		private int _tempValue;

		/// <summary>
		/// Indicates the temporary array of nodes.
		/// </summary>
		private ChunkNode<T>[]? _tempNodeArray;

		/// <summary>
		/// Indicates the temporary enumerator of <see cref="List{T}"/>.
		/// </summary>
		/// <seealso cref="List{T}.Enumerator"/>
		private List<T>.Enumerator _tempListEnumerator;

		/// <summary>
		/// Indicates the value array to be iterated.
		/// </summary>
		private T[]? _tempValueArray;


		/// <inheritdoc cref="IEnumerator.Current"/>
		public T Current { get; private set; }

		/// <inheritdoc/>
		readonly object? IEnumerator.Current => Current;


		/// <inheritdoc cref="IEnumerator.MoveNext"/>
		public bool MoveNext()
		{
			switch (_state)
			{
				default:
				{
					return false;
				}
				case 0:
				{
					(_state, _tempNodeArray, _tempValue) = (-1, _this._chunks, 0);
					goto CoreIteration;
				}
				case 1:
				{
					_state = -1;
					goto SetPointerNext;
				}
				case 2:
				{
					_ = (_state = -1, _index++);
					goto SwitchToEnumeratingArray;
				}
				case 3:
				{
					_state = -3;
					goto SwitchToEnumeratingList;
				}
			}

		CoreIteration:
			if (_tempValue < _tempNodeArray!.Length)
			{
				ref readonly var node = ref _tempNodeArray[_tempValue];
				switch (node.Type)
				{
					case ChunkNodeType.Value:
					{
						Debug.Assert(node.IsSingleValue);
						(Current, _state) = (node.Value, 1);
						return true;
					}
					case ChunkNodeType.Array:
					{
						break;
					}
					case ChunkNodeType.List:
					{
						Debug.Assert(!node.IsSingleValue);
						(_tempListEnumerator, _state) = (((List<T>)node.ValueRef).GetEnumerator(), -3);
						goto SwitchToEnumeratingList;
					}
					default:
					{
						goto SetPointerNext;
					}
				}

				Debug.Assert(!node.IsSingleValue);
				(_tempValueArray, _index) = ((T[])node.ValueRef, 0);
				goto SwitchToEnumeratingArray;
			}

			_tempNodeArray = null;
			return false;


		SwitchToEnumeratingArray:
			if (_index < _tempValueArray!.Length)
			{
				(Current, _state) = (_tempValueArray[_index], 2);
				return true;
			}

			_tempValueArray = null;
			goto SetPointerNext;

		SwitchToEnumeratingList:
			if (_tempListEnumerator.MoveNext())
			{
				(Current, _state) = (_tempListEnumerator.Current, 3);
				return true;
			}
			_tempListEnumerator = default;
			goto SetPointerNext;

		SetPointerNext:
			_tempValue++;
			goto CoreIteration;
		}

		/// <inheritdoc/>
		readonly void IDisposable.Dispose() { }

		/// <inheritdoc/>
		[DoesNotReturn]
		readonly void IEnumerator.Reset() => throw new NotImplementedException();
	}
}

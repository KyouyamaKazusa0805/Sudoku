namespace Sudoku.SourceGeneration.Handlers;

using DataPair = (INamedTypeSymbol TypeSymbol, string Expression);

internal static class SyntaxExpressionHandler
{
	private const string FormulaPropertyName = "Formula";


	public static DataPair? Check(GeneratorSyntaxContext gsc, CancellationToken ct = default)
	{
		if (gsc is not { SemanticModel: { Compilation: var compilation } model, Node: var node })
		{
			return null;
		}

		if (compilation.GetTypeByMetadataName("Sudoku.Measuring.Factor") is not { } factorTypeSymbol)
		{
			return null;
		}

		if (model.GetDeclaredSymbol(node, ct) is not INamedTypeSymbol { BaseType: var baseType } typeSymbol)
		{
			return null;
		}

		if (!SymbolEqualityComparer.Default.Equals(baseType, factorTypeSymbol))
		{
			return null;
		}

		var propertySymbol = (
			from symbol in typeSymbol.GetMembers().OfType<IPropertySymbol>()
			where symbol.Name == FormulaPropertyName
			select symbol
		).FirstOrDefault();
		if (propertySymbol is not { DeclaringSyntaxReferences: { Length: not 0 } syntaxRefs })
		{
			return null;
		}

		foreach (var syntaxRef in syntaxRefs)
		{
			if (syntaxRef.GetSyntax(ct) is PropertyDeclarationSyntax
				{
					Identifier.ValueText: FormulaPropertyName,
					ExpressionBody.Expression: LambdaExpressionSyntax { ExpressionBody: { } expression }
				})
			{
				return (typeSymbol, expression.ToString());
			}
		}
		return null;
	}

	public static void Output(SourceProductionContext spc, ImmutableArray<DataPair> values)
	{
		var code = new List<string>();
		foreach (var (type, expression) in values)
		{
			code.Add(
				$$""""
				partial class {{type.Name}}
				{
					/// <inheritdoc/>
					public override string FormulaExpressionString
						=> """
						{{expression}}
						""";
				}
				""""
			);
		}

		spc.AddSource(
			"FormulaExpressionStringValues.g.cs",
			$$"""
			{{Banner.AutoGenerated}}

			#nullable enable

			namespace Sudoku.Measuring.Factors;

			{{string.Join("\r\n\r\n", code)}}
			"""
		);
	}
}

namespace Sudoku.SourceGeneration.Handlers;

using DataTriplet = (string Name, INamedTypeSymbol ContainingType, MethodDeclarationSyntax DeclarationSyntax);

internal static class FunctionRawStringHandler
{
	public static DataTriplet? Check(GeneratorAttributeSyntaxContext gasc, CancellationToken ct = default)
	{
		if (gasc is not
			{
				SemanticModel.Compilation: var compilation,
				TargetSymbol: IMethodSymbol { ContainingType: var containingType, IsStatic: true } targetMethodSymbol,
				TargetNode: MethodDeclarationSyntax
				{
					TypeParameterList: null,
					Modifiers: var modifiers,
					Identifier.ValueText: var methodName,
					ReturnType: var returnType,
					ParameterList: var parameterList,
					ExpressionBody: var expressionBody,
					Body: var blockBody
				}
			})
		{
			return null;
		}

		var attributeTypeSymbol = compilation.GetTypeByMetadataName("Sudoku.Measuring.ExportFunctionAttribute");
		if (attributeTypeSymbol is null)
		{
			return null;
		}

		foreach (var attributeData in targetMethodSymbol.GetAttributes())
		{
			if (attributeData is not
				{
					AttributeClass: var attributeType,
					ConstructorArguments: [{ Type.SpecialType: SpecialType.System_String, Value: var identifier }]
				})
			{
				continue;
			}

			if (!SymbolEqualityComparer.Default.Equals(attributeType, attributeTypeSymbol))
			{
				continue;
			}

			var targetMethodName = identifier as string ?? methodName;
			var result = SyntaxFactory.MethodDeclaration(returnType, targetMethodName)
				.WithModifiers(modifiers)
				.WithParameterList(parameterList);
			return (
				targetMethodName,
				containingType,
				blockBody is not null
					? result.WithBody(blockBody)
					: result
						.WithExpressionBody(expressionBody!)
						.WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken))
			);
		}
		return null;
	}

	public static void Output(SourceProductionContext spc, ImmutableArray<DataTriplet> values)
	{
		var code = new List<string>();
		foreach (var group in values.GroupBy<DataTriplet, INamedTypeSymbol>(static value => value.ContainingType, SymbolEqualityComparer.Default))
		{
			var finalText = string.Join(
				"\r\n\r\n",
				from triplet in @group
				let syntax = triplet.DeclarationSyntax
				select $$""""
						[ExportedMember]
						{{syntax.Modifiers}} string __{{syntax.Identifier}}_RawSyntaxText
							=> """
							{{string.Join("\r\n\t\t", syntax.ToString().Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries))}}
							""";
				""""
			);
			code.Add(
				$$"""
				namespace {{group.Key.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)["global::".Length..]}}
				{
					partial class {{group.Key.Name}}
					{
				{{finalText}}
					}
				}
				"""
			);
		}

		spc.AddSource(
			"FunctionSyntaxText.g.cs",
			$$"""
			{{Banner.AutoGenerated}}

			#nullable enable
			
			#pragma warning disable CS1591

			{{string.Join("\r\n\r\n", code)}}
			"""
		);
	}
}

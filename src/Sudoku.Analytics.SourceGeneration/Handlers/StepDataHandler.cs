namespace Sudoku.SourceGeneration.Handlers;

[SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking", Justification = "<Pending>")]
internal static class StepDataHandler
{
	private const string TypesName = "types";

	private const string GlobalConfigName = "global-config";

	private const string AppendHeaderPropertyName = "append-header";

	private const string NamespacePropertyName = "namespace";

	private const string ValuePropertyName = "value";

	private const string ModifierAttributeName = "modifier";

	private const string TypeNameAttributeName = "name";

	private const string CommentNameAttributeName = "comment-name";

	private const string BaseTypeAttributeName = "base-type";

	private const string BaseInterfacesName = "interfaces";

	private const string BaseParametersName = "parameters";

	private const string ConstructorParameterName = "parameter";

	private const string PrimaryParameterName = "primary-parameter";

	private const string ConstantParameterName = "constant";

	private const string TypeAttributeName = "type";

	private const string NamePropertyName = "name";

	private const string OrderPropertyName = "order";

	private const string BaseOrderPropertyName = "base-order";

	private const string CommentPropertyName = "comment";

	private const string KeyPropertyName = "key";

	private const string RangePropertyName = "range";

	private const string TypeSummaryFormat = "/// Represents a data structure that describes for a technique of <b>{0}</b>.";

	private const string TypeRemarksFormat = """
		/// <b>
		/// A part of members in this type are implemented by source generator, meaning you cannot modify them inside this.
		/// Please visit source code for source generator to modify the handling logic if you persist.
		/// </b>
		""";


	private static readonly DiagnosticDescriptor SD0001 = new(
		nameof(SD0001),
		$"'descendant::{BaseParametersName}' is null",
		$"'descendant::{BaseParametersName}' is null. It seems that you may create parameter values globally, without creating '<parameters>' tag surround them. Please check your configuration on XML file and try again.",
		"Sudoku.Xml",
		DiagnosticSeverity.Error,
		true
	);


	public static void Output(SourceProductionContext spc, (Compilation Compilation, ImmutableArray<AdditionalText> AdditionalFiles) pair)
	{
		var xmlFile = new XmlDocument();
		xmlFile.Load(pair.AdditionalFiles[0].Path);
		var root = xmlFile.DocumentElement;
		var typesNode = root.SelectSingleNode($"descendant::{TypesName}");
		GetGlobalConfigInfo(
			root.SelectSingleNode($"descendant::{GlobalConfigName}").ChildNodes,
			pair.Compilation,
			out var appendHeader,
			out var @namespace
		);
		var nodes =
			from XmlNode node in typesNode.ChildNodes
			where node is not XmlComment and { Name: TypeAttributeName }
			select node;
		var typeDeclarations = g(nodes);
		if (typeDeclarations is null)
		{
			return;
		}

		spc.AddSource(
			"StepTypesDeclarations.g.cs",
			$$"""
			{{(appendHeader ? $"{Banner.AutoGenerated}\r\n\r\n" : string.Empty)}}#nullable enable

			#pragma warning disable CS9195

			using System.CodeDom.Compiler;
			using System.Runtime.CompilerServices;

			namespace {{@namespace}};

			{{string.Join("\r\n\r\n", typeDeclarations)}}
			"""
		);


		IEnumerable<string>? g(IEnumerable<XmlNode> typeNodes)
		{
			const string interfaceListSeparator = ",\r\n\t";
			var result = new List<string>();
			foreach (var typeNode in typeNodes)
			{
				var modifier = $"{typeNode.Attributes[ModifierAttributeName]?.Value} " ?? string.Empty;
				var typeName = typeNode.Attributes[TypeNameAttributeName].Value;
				var commentName = typeNode.Attributes[CommentNameAttributeName].Value;
				var baseTypeName = typeNode.Attributes[BaseTypeAttributeName].Value;
				var summaryFormatted = string.Format(TypeSummaryFormat, commentName);
				var interfaceNames = typeNode.SelectSingleNode($"descendant::{BaseInterfacesName}") switch
				{
					{ ChildNodes: var childNodes } => (from XmlNode n in childNodes select n.InnerText).ToArray(),
					_ => []
				};
				var interfacesString = interfaceNames.Length switch
				{
					0 => string.Empty,
					_ => $"{interfaceListSeparator}{string.Join(interfaceListSeparator, interfaceNames)}"
				};
				var parameters = getParameters(typeNode);
				if (parameters is null)
				{
					return null;
				}

				var constructorParametersOrdered = (
					from parameter in parameters
					where parameter.ConstructorOrder is not null
					orderby parameter.ConstructorOrder!.Value
					select parameter
				).ToArray();
				var baseConstructorParametersOrdered = (
					from parameter in parameters
					where parameter.BaseConstructorOrder is not null
					orderby parameter.BaseConstructorOrder!.Value
					select parameter
				).ToArray();

				var xmlParamsStr = string.Join("\r\n", from parameter in constructorParametersOrdered select parameter.XmlDocValue);
				var ctorParamsStr = string.Join(",\r\n", from p in constructorParametersOrdered select p.ConstructorParameterValue);
				var baseCtorParamsStr = string.Join(",\r\n", from p in baseConstructorParametersOrdered select p.BaseConstructorParameterValue);
				var propsStr = string.Join("\r\n\r\n", from p in parameters.OfType<PrimaryConstructorParameter>() select p.PropertyValue);
				result.Add(
					$$"""
					/// <summary>
					{{summaryFormatted}}
					/// </summary>
					{{xmlParamsStr}}
					/// <remarks>
					{{TypeRemarksFormat}}
					/// </remarks>
					public {{modifier}}partial class {{typeName}}(
					{{ctorParamsStr}}
					) :
						{{baseTypeName}}(
					{{baseCtorParamsStr}}
						){{interfacesString}}
					{
					{{propsStr}}
					}
					"""
				);
			}
			return result;
		}

		List<Parameter>? getParameters(XmlNode typeNode)
		{
			var parametersNode = typeNode.SelectSingleNode($"descendant::{BaseParametersName}");
			if (parametersNode is null)
			{
				spc.ReportDiagnostic(Diagnostic.Create(SD0001, null, messageArgs: null));
				return null;
			}

			var result = new List<Parameter>();
			foreach (XmlNode parameterNode in parametersNode.ChildNodes)
			{
				switch (parameterNode.Name)
				{
					case ConstructorParameterName:
					{
						var order = int.Parse(parameterNode.Attributes[OrderPropertyName].Value);
						var baseOrder = parameterNode.Attributes[BaseOrderPropertyName]?.Value is { } baseOrderValue ? int.Parse(baseOrderValue) : default(int?);
						var name = parameterNode.Attributes[NamePropertyName].Value;
						var value = parameterNode.SelectSingleNode($"descendant::{ValuePropertyName}")?.InnerText ?? name;
						var parameterType = parameterNode.Attributes[TypeAttributeName]?.Value;
						var baseType = parameterNode.Attributes[BaseTypeAttributeName]?.Value;
						result.Add(new ConstructorParameter(order, baseOrder, name, value, parameterType, baseType));
						break;
					}
					case PrimaryParameterName:
					{
						var order = int.Parse(parameterNode.Attributes[OrderPropertyName].Value);
						var baseOrder = parameterNode.Attributes[BaseOrderPropertyName]?.Value is { } baseOrderValue ? int.Parse(baseOrderValue) : default(int?);
						var name = parameterNode.Attributes[NamePropertyName].Value;
						var value = parameterNode.SelectSingleNode($"descendant::{ValuePropertyName}")?.InnerText ?? name;
						var commentRaw = parameterNode.SelectSingleNode($"descendant::{CommentPropertyName}").InnerXml;
						var comment = commentRaw.Contains("\r\n")
							? string.Join(
								"\r\n",
								from line in commentRaw.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries)
								select $"/// {line.Trim()}"
							)
							: $"/// {commentRaw.Trim()}";
						var parameterType = parameterNode.Attributes[TypeAttributeName].Value;
						var baseType = parameterNode.Attributes[BaseTypeAttributeName]?.Value;
						var key = parameterNode.SelectSingleNode($"descendant::{KeyPropertyName}").InnerText;
						var range = parameterNode.SelectSingleNode($"descendant::{RangePropertyName}")?.InnerText;
						var rangeMin = range?[..range.IndexOf('-')];
						var rangeMax = range?[(range.IndexOf('-') + 1)..];
						result.Add(new PrimaryConstructorParameter(order, baseOrder, name, value, comment, parameterType, baseType, key, rangeMin, rangeMax));
						break;
					}
					case ConstantParameterName:
					{
						var baseOrder = int.Parse(parameterNode.Attributes[BaseOrderPropertyName].Value);
						var name = parameterNode.Attributes[NamePropertyName].Value;
						result.Add(new ConstantParameter(baseOrder, name));
						break;
					}
				}
			}
			return result;
		}
	}

	/// <summary>
	/// Try to get global config.
	/// </summary>
	/// <param name="nodes">The nodes from XML file.</param>
	/// <param name="compilation">The compilation instance.</param>
	/// <param name="appendHeader">Indicates whether the source generator will append header.</param>
	/// <param name="namespace">The namespace.</param>
	private static void GetGlobalConfigInfo(XmlNodeList nodes, Compilation compilation, out bool appendHeader, out string @namespace)
	{
		var nodesArray = (from XmlNode node in nodes select node).ToArray();
		appendHeader = bool.Parse((from node in nodesArray where node.Name == AppendHeaderPropertyName select node.InnerText).First());
		@namespace = (from node in nodesArray where node.Name == NamespacePropertyName select node.InnerText).First();
	}
}

/// <summary>
/// Represents a parameter.
/// </summary>
/// <param name="ConstructorOrder">
/// Indicates the order that describes what place the parameter will be inserted into the constructor parameter list.
/// </param>
/// <param name="BaseConstructorOrder">
/// Indicates the order that describes what place the parameter will be inserted into the base constructor parameter list.
/// </param>
file abstract record Parameter(int? ConstructorOrder, int? BaseConstructorOrder)
{
	/// <summary>
	/// Indicates the referenced original property name.
	/// </summary>
	public abstract string? XmlDocValue { get; }

	/// <summary>
	/// Indicates constructor parameter string.
	/// </summary>
	public abstract string? ConstructorParameterValue { get; }

	/// <summary>
	/// Indicates base constructor parameter string.
	/// </summary>
	public abstract string BaseConstructorParameterValue { get; }

	/// <summary>
	/// Indicates property string.
	/// </summary>
	public abstract string? PropertyValue { get; }
}

/// <summary>
/// Represents a constructor parameter.
/// </summary>
/// <param name="ConstructorOrder"><inheritdoc/></param>
/// <param name="BaseConstructorOrder"><inheritdoc/></param>
/// <param name="Name">Indicates the parameter name.</param>
/// <param name="ValueExpression">Indicates the parameter value.</param>
/// <param name="ParameterType">Indicates the parameter type.</param>
/// <param name="BaseType">Indicates the base type.</param>
file sealed record ConstructorParameter(
	int? ConstructorOrder,
	int? BaseConstructorOrder,
	string Name,
	string? ValueExpression,
	string? ParameterType,
	string? BaseType
) : Parameter(ConstructorOrder, BaseConstructorOrder)
{
	/// <inheritdoc/>
	public string PropertyName => $"{char.ToUpper(Name[0])}{Name[1..]}";

	/// <inheritdoc/>
	public override string XmlDocValue
		=> $"""
		/// <param name="{Name}"><inheritdoc cref="{(BaseType is null ? IsReserved ? $"Step.{PropertyName}" : PropertyName : $"{BaseType}.{PropertyName}")}" path="/summary"/></param>
		""";

	/// <inheritdoc/>
	public override string ConstructorParameterValue
		=> Name switch
		{
			"conclusions" => "\tConclusion[] conclusions",
			"views" => "\tView[]? views",
			"options" => "\tStepSearcherOptions options",
			_ => $"\t{ParameterType!} {Name}"
		};

	/// <inheritdoc/>
	public override string BaseConstructorParameterValue => $"\t\t{ValueExpression ?? Name}";

	/// <inheritdoc/>
	public override string? PropertyValue => null;

	/// <summary>
	/// Indicates whether the property is reserved one.
	/// </summary>
	private bool IsReserved => Name is "conclusions" or "views" or "options";
}

/// <summary>
/// Represents a primary constructor parameter.
/// </summary>
/// <param name="ConstructorOrder"><inheritdoc/></param>
/// <param name="BaseConstructorOrder"><inheritdoc/></param>
/// <param name="Name">Indicates the parameter name.</param>
/// <param name="ValueExpression">Indicates the parameter value.</param>
/// <param name="Comment">Indicates the comment.</param>
/// <param name="ParameterType">Indicates the parameter type.</param>
/// <param name="BaseType">Indicates the base type.</param>
/// <param name="ResourceKey">Indicates the resource key.</param>
/// <param name="RangeMin">Indicates the minimal value that the property can be reached.</param>
/// <param name="RangeMax">Indicates the maximal value that the property can be reached.</param>
file sealed record PrimaryConstructorParameter(
	int? ConstructorOrder,
	int? BaseConstructorOrder,
	string Name,
	string? ValueExpression,
	string Comment,
	string ParameterType,
	string? BaseType,
	string ResourceKey,
	string? RangeMin,
	string? RangeMax
) : Parameter(ConstructorOrder, BaseConstructorOrder)
{
	/// <inheritdoc/>
	public string PropertyName => $"{char.ToUpper(Name[0])}{Name[1..]}";

	/// <inheritdoc/>
	public override string XmlDocValue
		=> $"""
		/// <param name="{Name}"><inheritdoc cref="{(BaseType is null ? PropertyName : $"{BaseType}.{PropertyName}")}" path="/summary"/></param>
		""";

	/// <inheritdoc/>
	public override string ConstructorParameterValue => $"\t{ParameterType} {Name}";

	/// <inheritdoc/>
	public override string BaseConstructorParameterValue => $"\t\t{ValueExpression ?? Name}";

	/// <inheritdoc/>
	public override string PropertyValue
		=> $$"""
			/// <summary>
			{{Comment}}
			/// </summary>
			[CompilerGenerated]
			[GeneratedCode("{{nameof(StepDataHandler)}}", "{{Value}}")]
			[FactorProperty<{{ParameterTypeModifiersRemoved}}>(ResourceKey = "{{ResourceKey}}"{{MinMaxValueString}})]
			public {{ParameterTypeModifiersRemoved}} {{PropertyName}} { get; } = {{Name}};
		""";

	/// <summary>
	/// The internal min-max value string.
	/// </summary>
	private string MinMaxValueString
		=> (RangeMin, RangeMax) is not (not null, not null) ? string.Empty : $", MinValue = {RangeMin}, MaxValue = {RangeMax}";

	/// <summary>
	/// Indicates the real parameter type name, removing modifiers.
	/// </summary>
	private string ParameterTypeModifiersRemoved => ParameterType.IndexOf(' ') != -1 ? ParameterType.Split(' ')[^1] : ParameterType;
}

/// <summary>
/// Represents a constant.
/// </summary>
/// <param name="BaseConstructorOrder"><inheritdoc/></param>
/// <param name="ValueExpression">Indicates the parameter value.</param>
file sealed record ConstantParameter(int? BaseConstructorOrder, string ValueExpression) : Parameter(null, BaseConstructorOrder)
{
	/// <inheritdoc/>
	public override string? XmlDocValue => null;

	/// <inheritdoc/>
	public override string? ConstructorParameterValue => null;

	/// <inheritdoc/>
	public override string BaseConstructorParameterValue => $"\t\t{ValueExpression}";

	/// <inheritdoc/>
	public override string? PropertyValue => null;
}

namespace Sudoku.SourceGeneration;

/// <summary>
/// Represents a source generator type that runs multiple different usage of source output services on compiling code.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class StepSearcherDefaultImportingGenerator : IIncrementalGenerator
{
	private const string AreasPropertyName = "Areas";

	private const string StepSearcherTypeName = "Sudoku.Analytics.StepSearcher";

	private const string StepSearcherRunningAreaTypeName = "Sudoku.Analytics.StepSearchers.StepSearcherRunningArea";

	private const string BuiltInStepSearcherAttributeName = "global::Sudoku.Analytics.StepSearchers.AssemblyStepSearcherAttribute<>";


	/// <inheritdoc/>
	public void Initialize(IncrementalGeneratorInitializationContext context)
		=> context.RegisterSourceOutput(context.CompilationProvider, Output);


	private static void Output(SourceProductionContext spc, Compilation compilation)
	{
		// Checks whether the assembly has marked any attributes.
		if (compilation.Assembly.GetAttributes() is not { IsDefaultOrEmpty: false } attributesData)
		{
			return;
		}

		var stepSearcherBaseType = compilation.GetTypeByMetadataName(StepSearcherTypeName);
		if (stepSearcherBaseType is null)
		{
			return;
		}

		var runningAreaTypeSymbol = compilation.GetTypeByMetadataName(StepSearcherRunningAreaTypeName)!;
		var runningAreasFields = new Dictionary<int, string>();
		foreach (var fieldSymbol in runningAreaTypeSymbol.GetMembers().OfType<IFieldSymbol>())
		{
			if (fieldSymbol is { ConstantValue: int value, Name: var fieldName })
			{
				runningAreasFields.Add(value, fieldName);
			}
		}

		// Gather the valid attributes data.
		var foundAttributesData = new List<CollectedResult>();
		var priorityValue = 0;
		foreach (var attributeData in attributesData)
		{
			// Check validity.
#pragma warning disable format
			if (attributeData is not
				{
					AttributeClass:
					{
						IsGenericType: true,
						TypeArguments: [
							INamedTypeSymbol
							{
								IsRecord: false,
								ContainingNamespace: var containingNamespace,
								Name: var stepSearcherName,
								BaseType: { } baseType
							}
						]
					} attributeClassSymbol,
					ConstructorArguments: [{ Type.TypeKind: TypeKind.Struct, Value: int dl }],
					NamedArguments: var namedArguments
				})
#pragma warning restore format
			{
				continue;
			}

			// Checks whether the type is valid.
			var unboundAttributeTypeSymbol = attributeClassSymbol.ConstructUnboundGenericType();
			if (unboundAttributeTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) != BuiltInStepSearcherAttributeName)
			{
				continue;
			}

			// Adds the necessary info into the collection.
			foundAttributesData.Add(new(containingNamespace, baseType, priorityValue++, dl, stepSearcherName, namedArguments));
		}

		// Iterate on each valid attribute data, and checks the inner value to be used by the source generator to output.
		var generatedCodeSnippets = new List<string>();
		foreach (var (@namespace, baseType, priority, level, name, namedArguments) in foundAttributesData)
		{
			// Checks whether the attribute has configured any extra options.
			var nullableRunningArea = default(int?);
			if (namedArguments is not [])
			{
				foreach (var (k, v) in namedArguments)
				{
					if (k == AreasPropertyName && v is { Value: int value })
					{
						nullableRunningArea = value;
					}
				}
			}

			// Gather the extra options on step searcher.
			var runningAreaStr = nullableRunningArea switch
			{
				{ } runningArea => createRunningAreasExpression(runningArea, runningAreasFields),
				_ => null
			};

			var sb = new StringBuilder().Append(level);
			if (runningAreaStr is not null)
			{
				sb.Append(", ").Append(runningAreaStr);
			}

			// Output the generated code.
			var namespaceString = @namespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)["global::".Length..];
			var baseTypeFullName = baseType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			generatedCodeSnippets.Add(
				$$"""
				namespace {{namespaceString}}
				{
					[method: global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{typeof(StepSearcherDefaultImportingGenerator).FullName}}", "{{Value}}")]
					[method: global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
					partial class {{name}}() :
						{{baseTypeFullName}}({{priority}}, {{sb}});
				}
				"""
			);
		}

		spc.AddSource(
			"StepSearcherImports.g.cs",
			$$"""
			{{Banner.AutoGenerated}}

			#pragma warning disable CS1591
			#nullable enable

			{{string.Join("\r\n\r\n", generatedCodeSnippets)}}
			"""
		);


		static string createRunningAreasExpression(int field, IDictionary<int, string> runningAreasFields)
		{
			var l = field;
			if (l == 0)
			{
				return "0";
			}

			var targetList = new List<string>();
			for (var (temp, i) = (l, 0); temp != 0; temp >>= 1, i++)
			{
				if ((temp & 1) != 0)
				{
					targetList.Add($"global::Sudoku.Analytics.StepSearchers.StepSearcherRunningArea.{runningAreasFields[1 << i]}");
				}
			}
			return string.Join(" | ", targetList);
		}
	}


	private sealed record CollectedResult(
		INamespaceSymbol Namespace,
		INamedTypeSymbol BaseType,
		int PriorityValue,
		int StepSearcherLevel,
		string TypeName,
		ImmutableArray<KeyValuePair<string, TypedConstant>> NamedArguments
	);
}

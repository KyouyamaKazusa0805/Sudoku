<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Core</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Algorithm.Generating.GeneratorProgress">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GeneratorProgress.#ctor(System.Int32)">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.GeneratorProgress.Count">
            <summary>The number of puzzles generated currently.</summary>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator">
            <summary>
            Defines a puzzle generator that makes the given pattern as a hard one.
            A <b>hard pattern</b> doesn't mean the puzzle will be hard or fiendish.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.BlockFactor">
            <summary>
            Indicates the block factor.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.SwappingFactor">
            <summary>
            Indicates the swapping factor.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.Solver">
            <summary>
            Indicates the inner solver that can fast solve a sudoku puzzle, to check the validity
            of a puzzle being generated.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.Rng">
            <summary>
            Indicates the random number generator.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.GenerateAnswerGrid(System.Char*,System.Char*)">
            <summary>
            Generates the answer sudoku grid via the specified puzzle and the solution variable pointer.
            </summary>
            <param name="pPuzzle">The pointer that points to the puzzle.</param>
            <param name="pSolution">
            The pointer that points to the solution. The result value will be changed here.
            </param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.CreatePattern(System.Int32*)">
            <summary>
            Creates a start pattern based on a base pattern.
            </summary>
            <param name="pattern">The base pattern.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.RecreatePattern(System.Int32*)">
            <summary>
            To re-create the pattern.
            </summary>
            <param name="pattern">The pointer that points to an array of the pattern values.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.CheckDuplicate(System.Char*,System.Int32)">
            <summary>
            Check whether the digit in its peer cells has duplicate ones.
            </summary>
            <param name="ptrGrid">The pointer that points to a grid.</param>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator">
            <summary>
            Represents a generator that is implemented by HoDoKu.
            </summary>
            <remarks><b>
            This type is special: we strongly recommend use <see langword="static"/> method
            <see cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)"/> or <see cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,Sudoku.Concepts.CellMap@,System.Threading.CancellationToken)"/>
            instead of calling parameterless constructor due to the internal mechanism.
            </b></remarks>
            <seealso cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)"/>
            <seealso cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,Sudoku.Concepts.CellMap@,System.Threading.CancellationToken)"/>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.MaxTries">
            <summary>
            Maximum number of tries when generating a puzzle using a pattern.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Rng">
            <summary>
            A random generator for creating new puzzles.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.FastSolver">
            <summary>
            Indicates the internal fast solver.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._generateIndices">
            <summary>
            The order in which cells are set when generating a full grid.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._stack">
            <summary>
            The recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._newFullSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._newValidSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator" />.
            </summary>
            <remarks>
            <target name="constructor">
				<i>
					The feature "Custom parameterless struct constructor" makes the parameterless struct constructor
					different with <c>default(T)</c>. If you has defined a parameterless struct constructor,
					<c>new T()</c> is no longer with the same meaning as <c>default(T)</c>.
				</i>
			</target>
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,Sudoku.Concepts.CellMap@,System.Threading.CancellationToken)">
            <summary>
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)" path="/summary"/>
            </summary>
            <param name="symmetricType">
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)" path="/param[@name='symmetricType']"/>
            </param>
            <param name="pattern">The pattern indicating the states of selection on all cells.</param>
            <param name="cancellationToken">
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)" path="/param[@name='cancellationToken']"/>
            </param>
            <returns><inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)" path="/returns"/></returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.GenerateInitPos(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            Takes a full sudoku from <see cref="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._newFullSudoku"/> and generates a valid puzzle by deleting cells.
            If a deletion produces a grid with more than one solution it is of course undone.
            </summary>
            <param name="symmetricType">
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)" path="/param[@name='symmetricType']"/>
            </param>
            <param name="cancellationToken">
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)" path="/param[@name='cancellationToken']"/>
            </param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.GenerateInitPos(Sudoku.Concepts.CellMap@,System.Threading.CancellationToken)">
            <summary>
            Takes a full sudoku from <see cref="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._newFullSudoku"/> and generates a valid puzzle by deleting the cells indicated
            by <paramref name="pattern"/>. If the resulting puzzle is invalid, <see langword="false"/> is returned and the caller
            is responsible for continuing the search.
            </summary>
            <param name="pattern">The pattern.</param>
            <param name="cancellationToken">
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)" path="/param[@name='cancellationToken']"/>
            </param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the pattern is valid to be used.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.GenerateForFullGrid">
            <summary>
            Generate a solution grid.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the generation operation is succeeded.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)" path="/summary"/>
            </summary>
            <param name="symmetricType">The symmetric type to be specified. The value is <see cref="F:Sudoku.Concepts.SymmetricType.Central"/> by default.</param>
            <param name="cancellationToken">
            <inheritdoc
                cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"
                path="/param[@name='cancellationToken']"/>
            </param>
            <returns><inheritdoc cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)" path="/returns"/></returns>
            <exception cref="T:System.ArgumentException">Throws when the argument <paramref name="symmetricType"/> holds multiple flags.</exception>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.IPuzzleGenerator">
            <summary>
            Represents an instance that has ability to create a new sudoku puzzle game, allow cancelling.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <summary>
            Creates a sudoku grid puzzle.
            </summary>
            <param name="progress">
            <inheritdoc
                cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"
                path="/param[@name='progress']"/>
            </param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>
            The result puzzle generated. If canceled, the return value will be <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </returns>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.RecursionStackEntry">
            <summary>
            One entry in recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Candidates">
            <summary>
            The candidates for cells <see cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Cell"/>.
            </summary>
            <seealso cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Cell"/>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Cell">
            <summary>
            The index of the cell that's being tried.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.CandidateIndex">
            <summary>
            The index of the last tried candidate in <see cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Candidates"/>.
            </summary>
            <seealso cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Candidates"/>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.SudokuGrid">
            <summary>
            The current state of the sudoku.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.BacktrackingSolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using backtracking algorithm.
            </summary>
            <remarks>
            <para>
            Please note that the current type has no optimization on solving. Therefore sometimes the puzzle will be
            extremely slowly to be solved although it is not very hard by manually solved.
            One of the examples satisfying the above condition is:
            <code>
            ..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9
            </code>
            The current solver may spend about 4.5 min on solving this puzzle.
            </para>
            <para>
            For more information, please visit
            <see href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms#cite_note-difficult_17_clue-1">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.BacktrackingSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BacktrackingSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            To solve the specified grid.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Different with other methods whose containing type is <see cref="T:Sudoku.Analytics.ISolver"/>,
            this argument can be used no matter what the result value will be.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.BitwiseSolver">
            <summary>
            Indicates the solver that is able to solve a sudoku puzzle, and then get the solution of that sudoku.
            </summary>
            <remarks>
            The reason why the type name contains the word <i>bitwise</i> is that the solver uses the bitwise algorithm
            to handle a sudoku grid, which is more efficient.
            </remarks>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver.BufferLength">
            <summary>
            The buffer length of a solution puzzle.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver.BitSet27">
            <summary>
            All pencil marks set - 27 bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._stack">
            <summary>
            Stack to store current and previous states.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._singleApplied">
            <summary>
            Nasty global flag telling if <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.ApplySingleOrEmptyCells"/> found anything.
            </summary>
            <seealso cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.ApplySingleOrEmptyCells"/>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._solution">
            <summary>
            Pointer to where to store the first solution. This value can be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._numSolutions">
            <summary>
            The number of solutions found so far.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._limitSolutions">
            <summary>
            The max number of solution we're looking for.
            </summary>
            <remarks>
            For the consideration on the performance, I have refused to use auto-implemented property instead.
            </remarks>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._g">
            <summary>
            Pointer to the currently active slot.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.BitwiseSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The pointer to the puzzle.</param>
            <param name="solution">The solution. <see langword="null"/> if you don't want to use the value.</param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="puzzle"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(System.String,System.Char*,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The puzzle.</param>
            <param name="solution">The solution. <see langword="null"/> if you don't want to use the value.</param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(System.String,System.String@,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The puzzle.</param>
            <param name="solution">
            The solution. The value keeps <see langword="null"/> if you doesn't want to use this result.
            </param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.Char*)">
            <summary>
            Same as <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="grid"/> is <see langword="null"/>.
            </exception>
            <seealso cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String)">
            <summary>
            Same as <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <seealso cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)">
            <summary>
            Check the validity of the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="solutionIfUnique">The solution if the puzzle is unique.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(Sudoku.Concepts.Grid@)">
            <summary>
            To solve the puzzle, and get the solution.
            </summary>
            <param name="puzzle">The puzzle to solve.</param>
            <returns>The solution. If failed to solve, <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.</returns>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.ClearStack">
            <summary>
            To clear the field <see cref="F:Sudoku.Algorithm.Solving.BitwiseSolver._stack"/>.
            </summary>
            <seealso cref="F:Sudoku.Algorithm.Solving.BitwiseSolver._stack"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.SetSolvedDigit(System.Int32,System.Int32)">
            <summary>
            Set a cell as solved - used in <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.EliminateDigit(System.Int32,System.Int32)">
            <summary>
            Eliminate a digit - used in <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.SetSolvedMask(System.Int32,System.UInt32)">
            <summary>
            Set a cell as solved - used in various guess routines.
            </summary>
            <param name="band">The band.</param>
            <param name="mask">The mask.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.InitSudoku(System.Char*)">
            <summary>
            Setup everything and load the puzzle.
            </summary>
            <param name="puzzle">The pointer that points to a puzzle buffer.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Update">
            <summary>
            Core of fast processing.
            </summary>
            <returns>The <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.ApplySingleOrEmptyCells">
            <summary>
            Find singles, bi-value cells, and impossible cells.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.InternalSolve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The internal solving method.
            </summary>
            <param name="puzzle">The pointer to the puzzle string.</param>
            <param name="solutionPtr">The pointer to the solution string.</param>
            <param name="limit">The limitation for the number of all final solutions.</param>
            <returns>The number of solutions found.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.ExtractSolution(System.Char*)">
            <summary>
            Extract solution as a string.
            </summary>
            <param name="solution">
            The solution pointer. <b>The buffer should be at least <see cref="F:Sudoku.Algorithm.Solving.BitwiseSolver.BufferLength"/>
            of value of length.</b>
            </param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.GuessBiValueInCell">
            <summary>
            Try both options for cells with exactly two pencil marks.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.GuessFirstCell">
            <summary>
            Guess all possibilities in first unsolved cell.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Guess">
            <summary>
            Either already solved, or guess and recurse.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.FullUpdate">
            <summary>
            Get as far as possible without guessing.
            </summary>
            <returns>A <see cref="T:System.Byte"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.BitPos(System.UInt32)">
            <summary>
            Get the bit position.
            </summary>
            <param name="map">The map.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.StringLengthOf(System.Char*)">
            <summary>
            Get the length of the specified string which is represented by a <see cref="T:System.Char"/>*.
            </summary>
            <param name="ptr">The pointer.</param>
            <returns>The total length.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="ptr"/> is <see langword="null"/>.
            </exception>
            <remarks>
            In C#, this function is unsafe because the implementation of
            <see cref="T:System.String"/> types between C and C# is totally different.
            In C, <see cref="T:System.String"/> is like a <see cref="T:System.Char"/>* or a
            <see cref="T:System.Char"/>[], they ends with the terminator symbol <c>'\0'</c>.
            However, C# not.
            </remarks>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.Constants">
            <target name="class" when="constant">
				<summary>
					Provides with constants and read-only values used by code in the current file.
				</summary>
			</target>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.BitwiseSolverState">
            <summary>
            Represents a data structure, used by type <see cref="T:Sudoku.Algorithm.Solving.BitwiseSolver" />, describing state for a current grid using binary values.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped in" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.BitwiseSolver" />
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.Bands">
            <summary>
            Pencil marks in bands by digit.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.PrevBands">
            <summary>
            Value of bands last time it was calculated.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.UnsolvedCells">
            <summary>
            Bit vector of unsolved cells.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.UnsolvedRows">
            <summary>
            Bit vector of unsolved rows - three bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.Pairs">
            <summary>
            Bit vector of cells with exactly two pencil marks.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.ColumnNode">
            <summary>
            Represents a column node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.ColumnNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithm.Solving.ColumnNode"/> instance via the specified ID value.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.ColumnNode.Size">
            <summary>
            Indicates the size of the node.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DancingLinkNode">
            <summary>
            Represents a dancing link node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinkNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithm.Solving.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinkNode.#ctor(System.Int32,Sudoku.Algorithm.Solving.ColumnNode)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithm.Solving.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="id">The ID value.</param>
            <param name="column">The column node.</param>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Id">
            <summary>
            Indicates the ID of the node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Column">
            <summary>
            Indicates the current column node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Left">
            <summary>
            Indicates the pointer that points to the left node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Right">
            <summary>
            Indicates the pointer that points to the right node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Up">
            <summary>
            Indicates the pointer that points to the up node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Down">
            <summary>
            Indicates the pointer that points to the down node.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DancingLinksSolver">
            <summary>
            Defines a solver that uses the dancing links algorithm.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._answerNodesStack">
            <summary>
            Indicates the stack that stores the raw data for the solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._solutionCount">
            <summary>
            indicates the number of all found solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._solution">
            <summary>
            Indicates the found solution.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._root">
            <summary>
            Indicates the root node of the full link map.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinksSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Search">
            <summary>
            Try to search the full dancing link map and get the possible solution.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle has multiple solutions.</exception>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Cover(Sudoku.Algorithm.Solving.DancingLinkNode)">
            <summary>
            Cover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Uncover(Sudoku.Algorithm.Solving.DancingLinkNode)">
            <summary>
            Uncover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.RecordSolution(System.Collections.Generic.Stack{Sudoku.Algorithm.Solving.DancingLinkNode},Sudoku.Concepts.Grid@)">
            <summary>
            Try to gather all possible solutions, and determine whether the puzzle is valid.
            </summary>
            <param name="answer">The answers found.</param>
            <param name="result">The solution if the puzzle is unique.</param>
            <exception cref="T:System.InvalidOperationException">
            Throws when the puzzle has no possible solutions.
            </exception>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.ChooseNextColumn">
            <summary>
            Try to choose the next column node.
            </summary>
            <returns>The chosen next column node.</returns>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DancingLink">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="root">The root node.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.#ctor(Sudoku.Algorithm.Solving.ColumnNode)">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="root">The root node.</param>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLink.Root">
            <summary>
            Indicates the root node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.CreateLinkedList(System.Int32[])">
            <summary>
            Creates the links.
            </summary>
            <param name="gridArray">The grid array.</param>
            <returns>The column node for the root node.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.LinkRow(System.ValueTuple{Sudoku.Algorithm.Solving.DancingLinkNode,Sudoku.Algorithm.Solving.DancingLinkNode,Sudoku.Algorithm.Solving.DancingLinkNode,Sudoku.Algorithm.Solving.DancingLinkNode}@)">
            <summary>
            Links the row.
            </summary>
            <param name="d">The matrix row instance.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.LinkRowToColumn(Sudoku.Algorithm.Solving.DancingLinkNode)">
            <summary>
            Links the row to the column.
            </summary>
            <param name="section">The section.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.FormLinks(System.Collections.Generic.List{Sudoku.Algorithm.Solving.ColumnNode},System.Int32,System.Int32,System.Int32)">
            <summary>
            To form the links via the specified columns, the cell index and the digit used.
            </summary>
            <param name="columns">The columns having been stored.</param>
            <param name="x">The current row index.</param>
            <param name="y">The current column index.</param>
            <param name="d">The current digit.</param>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DictionaryQuerySolver">
            <summary>
            Defines a <see cref="T:System.Collections.Generic.Dictionary`2"/>-based LINQ solver that solves a sudoku grid,
            using a different algorithm with the other one of type <see cref="T:Sudoku.Algorithm.Solving.EnumerableQuerySolver"/>.
            </summary>
            <remarks>
            <para>
            This algorithm is originally written by Python, posted from <see href="http://norvig.com/sudo.py">here</see>
            by Richard Birkby, June 2007. For more information, please visit
            <see href="http://norvig.com/sudoku.html">this link</see>.
            </para>
            <para>
            Also, <see href="https://bugzilla.mozilla.org/attachment.cgi?id=266577">this link</see> is for the same algorithm
            written by JavaScript 1.8+.
            </para>
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.EnumerableQuerySolver"/>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Rows">
            <summary>
            Indicates the characters of all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Columns">
            <summary>
            Indicates the characters of all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Digits">
            <summary>
            Indicates the characters of all digits.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Coordinates">
            <summary>
            Indicates all possible coordinates.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Peers">
            <summary>
            Indicates the peers.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Houses">
            <summary>
            Indicates the houses.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DictionaryQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            To solve the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="result">The result.</param>
            <returns>
            <para>
            The method will return <see langword="false"/> if the puzzle has more than one solution,
            or <see langword="null"/> if the puzzle cannot be solved.
            </para>
            <para>
            Please note that the method cannot return <see langword="true"/>
            due to not being aware of the uniqueness of the puzzle.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.AllNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether all elements in this collection are not <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the element in the sequence.</typeparam>
            <param name="sequence">The whole sequence.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Zip(System.String[],System.String[])">
            <summary>
            To zip two lists of <see cref="T:System.String"/>s.
            </summary>
            <param name="a">The first array.</param>
            <param name="b">The second array.</param>
            <returns>The final zipped collection.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.ParseGrid(System.String)">
            <summary>
            Given a string of 81 digits (or <c>'.'</c>, <c>'0'</c> or <c>'-'</c>),
            and return a dictionary of a key-value pair of cell and the candidates.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Search(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Using depth-first search and propagation to try all possible values.
            </summary>
            <returns>A first found solution.</returns>
            <remarks>
            This algorithm is hard to determine whether the puzzle has multiple solutions, due to DFS.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Assign(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate all the other values (except d) from <c>values[s]</c> and propagate.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Eliminate(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate d from <c>values[s]</c>; propagate when values or places <![CDATA[<=]]> 2.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.EnumerableQuerySolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using LINQ.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.EnumerableQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.EnumerableQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Analytics.AnalyzerProgress">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="StepSearcherName">Indicates the currently used step searcher.</param>
            <param name="Percent">The percent value.</param>
            <seealso cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Analytics.AnalyzerProgress.#ctor(System.String,System.Double)">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="StepSearcherName">Indicates the currently used step searcher.</param>
            <param name="Percent">The percent value.</param>
            <seealso cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Analytics.AnalyzerProgress.StepSearcherName">
            <summary>Indicates the currently used step searcher.</summary>
        </member>
        <member name="P:Sudoku.Analytics.AnalyzerProgress.Percent">
            <summary>The percent value.</summary>
        </member>
        <member name="T:Sudoku.Analytics.Conclusion">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <remarks>
            Two <see cref="T:Sudoku.Analytics.Conclusion"/>s can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
            <param name="mask">
            Indicates the mask that holds the information for the cell, digit and the conclusion type.
            The bits distribution is like:
            <code><![CDATA[
            16       8       0
             |-------|-------|
             |     |---------|
            16    10         0
                   |   used  |
            ]]></code>
            </param>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.#ctor(System.Int32)">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <remarks>
            Two <see cref="T:Sudoku.Analytics.Conclusion"/>s can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
            <param name="mask">
            Indicates the mask that holds the information for the cell, digit and the conclusion type.
            The bits distribution is like:
            <code><![CDATA[
            16       8       0
             |-------|-------|
             |     |---------|
            16    10         0
                   |   used  |
            ]]></code>
            </param>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.#ctor(Sudoku.Analytics.ConclusionType,System.Int32)">
            <summary>
            Initializes an instance with a conclusion type and a candidate offset.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="candidate">The candidate offset.</param>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.#ctor(Sudoku.Analytics.ConclusionType,System.Int32,System.Int32)">
            <summary>
            Initializes the <see cref="T:Sudoku.Analytics.Conclusion"/> instance via the specified cell, digit and the conclusion type.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.Cell">
            <summary>
            Indicates the cell.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.Digit">
            <summary>
            Indicates the digit.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.Candidate">
            <summary>
            Indicates the candidate.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.ConclusionType">
            <summary>
            The conclusion type to control the action of applying.
            If the type is <see cref="F:Sudoku.Analytics.ConclusionType.Assignment"/>, this conclusion will be set value (Set a digit into a cell);
            otherwise, a candidate will be removed.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Deconstruct(Sudoku.Analytics.ConclusionType@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Deconstruct(Sudoku.Analytics.ConclusionType@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Equals(Sudoku.Analytics.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.CompareTo(Sudoku.Analytics.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.op_OnesComplement(Sudoku.Analytics.Conclusion)">
            <summary>
            Negates the current conclusion instance, changing the conclusion type from <see cref="F:Sudoku.Analytics.ConclusionType.Assignment"/> to <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/>,
            or from <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/> to <see cref="F:Sudoku.Analytics.ConclusionType.Assignment"/>.
            </summary>
            <param name="current">The current conclusion instance to be negated.</param>
            <returns>The negation.</returns>
        </member>
        <member name="F:Sudoku.Analytics.Conclusion._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.ToString">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.op_Equality(Sudoku.Analytics.Conclusion,Sudoku.Analytics.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.op_Inequality(Sudoku.Analytics.Conclusion,Sudoku.Analytics.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Analytics.Converter">
            <summary>
            The file-local type that provides the basic operation for serialization or deserialization for type <see cref="T:Sudoku.Analytics.Conclusion"/>.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Analytics.Conclusion,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionType">
            <summary>
            Provides a conclusion type.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionType.Assignment">
            <summary>
            Indicates the conclusion is a value filling into a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionType.Elimination">
            <summary>
            Indicates the conclusion is a candidate being remove from a cell.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Analytics.ConclusionType"/>.
            </summary>
            <seealso cref="T:Sudoku.Analytics.ConclusionType"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionTypeExtensions.Notation(Sudoku.Analytics.ConclusionType)">
            <summary>
            Gets the notation of the conclusion type.
            </summary>
            <param name="this">The conclusion type kind.</param>
            <returns>The string representation of the conclusion kind.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.Analytics.IAnalyzer`2">
            <summary>
            Represents with an analyzer, which can solve a puzzle, and return not only a <see cref="T:Sudoku.Concepts.Grid"/> as its solution,
            but a <typeparamref name="TResult"/> instance encapsulating all possible status of the analysis.
            </summary>
            <typeparam name="TSelf">The type of the solver itself.</typeparam>
            <typeparam name="TResult">The type of the target result.</typeparam>
        </member>
        <member name="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)">
            <summary>
            Analyze the specified puzzle, and return a <typeparamref name="TResult"/> instance indicating the analyzed result.
            </summary>
            <param name="puzzle">The puzzle to be analyzed.</param>
            <param name="progress">A <see cref="T:System.IProgress`1"/> instance that is used for reporting the status.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current analyzing operation.</param>
            <returns>The solver result that provides the information after analyzing.</returns>
        </member>
        <member name="T:Sudoku.Analytics.IAnalyzerResult`2">
            <summary>
            Represents an instance that describes the result after executed the method
            <see cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <typeparam name="TSolver">The solver's type.</typeparam>
            <typeparam name="TSelf">The type of the target result itself.</typeparam>
            <seealso cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.IsSolved">
            <summary>
            Indicates whether the solver has solved the puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.ElapsedTime">
            <summary>
            Indicates the elapsed time used during solving the puzzle. The value may not be an useful value.
            Some case if the puzzle doesn't contain a valid unique solution, the value may be
            <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
            <seealso cref="F:System.TimeSpan.Zero"/>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.Puzzle">
            <summary>
            Indicates the original puzzle to be solved.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.Solution">
            <summary>
            Indicates the result sudoku grid solved. If the solver can't solve this puzzle, the value will be
            <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.UnhandledException">
            <summary>
            Indicates the unhandled exception thrown.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.ISolver">
            <summary>
            Represents a solver that can provide with a basic function to solve a sudoku puzzle given with a <see cref="T:Sudoku.Concepts.Grid"/> instance,
            and returns its solution grid.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.ISolver.UriLink">
            <summary>
            Indicates the URI link that links to the introduction of the algorithm.
            </summary>
            <remarks>
            This property is reserved as information that is offered to the algorithm learners.
            </remarks>
        </member>
        <member name="M:Sudoku.Analytics.ISolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            Solve the specified grid, and return the solution via argument <paramref name="result"/>
            with returning a <see cref="T:System.Boolean"/>? value indicating the solved status.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Please note that if the return value is not <see langword="true"/>,
            the value should be a discard and should not be used, because the argument
            keeps a memory-randomized value currently.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Compatibility.Hodoku.HodokuAliasedNamesAttribute">
            <summary>
            Defines an attribute that is applied to a field of technique,
            indicating the aliased name (or names) of specified technique that is defined by Hodoku.
            </summary>
            <param name="aliases">Indicates the aliased names of the technique.</param>
        </member>
        <member name="M:Sudoku.Compatibility.Hodoku.HodokuAliasedNamesAttribute.#ctor(System.String[])">
            <summary>
            Defines an attribute that is applied to a field of technique,
            indicating the aliased name (or names) of specified technique that is defined by Hodoku.
            </summary>
            <param name="aliases">Indicates the aliased names of the technique.</param>
        </member>
        <member name="P:Sudoku.Compatibility.Hodoku.HodokuAliasedNamesAttribute.Aliases">
            <summary>
            The generated property declaration for parameter <c>aliases</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Compatibility.Hodoku.HodokuDifficultyLevel">
            <summary>
            The difficulty level defined by Hodoku.
            </summary>
        </member>
        <member name="F:Sudoku.Compatibility.Hodoku.HodokuDifficultyLevel.Easy">
            <summary>
            Indicates the level is easy.
            </summary>
        </member>
        <member name="F:Sudoku.Compatibility.Hodoku.HodokuDifficultyLevel.Medium">
            <summary>
            Indicates the level is medium.
            </summary>
        </member>
        <member name="F:Sudoku.Compatibility.Hodoku.HodokuDifficultyLevel.Hard">
            <summary>
            Indicates the level is hard.
            </summary>
        </member>
        <member name="F:Sudoku.Compatibility.Hodoku.HodokuDifficultyLevel.Unfair">
            <summary>
            Indicates the level is unfair.
            </summary>
        </member>
        <member name="F:Sudoku.Compatibility.Hodoku.HodokuDifficultyLevel.Extreme">
            <summary>
            Indicates the level is extreme.
            </summary>
        </member>
        <member name="T:Sudoku.Compatibility.Hodoku.HodokuDifficultyRatingAttribute">
            <summary>
            Defines an attribute that is applied to a field in technique, indicating difficulty rating value defined by Hodoku.
            </summary>
            <param name="difficultyRating">Indicates the difficulty rating.</param>
            <param name="difficultyLevel">Indicates the difficulty level.</param>
        </member>
        <member name="M:Sudoku.Compatibility.Hodoku.HodokuDifficultyRatingAttribute.#ctor(System.Int32,Sudoku.Compatibility.Hodoku.HodokuDifficultyLevel)">
            <summary>
            Defines an attribute that is applied to a field in technique, indicating difficulty rating value defined by Hodoku.
            </summary>
            <param name="difficultyRating">Indicates the difficulty rating.</param>
            <param name="difficultyLevel">Indicates the difficulty level.</param>
        </member>
        <member name="P:Sudoku.Compatibility.Hodoku.HodokuDifficultyRatingAttribute.DifficultyRating">
            <summary>
            The generated property declaration for parameter <c>difficultyRating</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Compatibility.Hodoku.HodokuDifficultyRatingAttribute.DifficultyLevel">
            <summary>
            The generated property declaration for parameter <c>difficultyLevel</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Compatibility.Hodoku.HodokuTechniquePrefixAttribute">
            <summary>
            Defines an attribute that is applied to a field in technique, indicating a compatible prefix value defined by Hodoku.
            </summary>
            <param name="prefix">Indicates the prefix value.</param>
        </member>
        <member name="M:Sudoku.Compatibility.Hodoku.HodokuTechniquePrefixAttribute.#ctor(System.String)">
            <summary>
            Defines an attribute that is applied to a field in technique, indicating a compatible prefix value defined by Hodoku.
            </summary>
            <param name="prefix">Indicates the prefix value.</param>
        </member>
        <member name="P:Sudoku.Compatibility.Hodoku.HodokuTechniquePrefixAttribute.Prefix">
            <summary>
            The generated property declaration for parameter <c>prefix</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerAliasedNamesAttribute">
            <summary>
            Defines an attribute that is applied to a field of technique,
            indicating the aliased name (or names) of specified technique that is defined by Sudoku Explainer.
            </summary>
            <param name="aliases">Indicates the aliased names of the technique.</param>
        </member>
        <member name="M:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerAliasedNamesAttribute.#ctor(System.String[])">
            <summary>
            Defines an attribute that is applied to a field of technique,
            indicating the aliased name (or names) of specified technique that is defined by Sudoku Explainer.
            </summary>
            <param name="aliases">Indicates the aliased names of the technique.</param>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerAliasedNamesAttribute.Aliases">
            <summary>
            The generated property declaration for parameter <c>aliases</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute">
            <summary>
            Defines an attribute that is applied to a field in technique, indicating difficulty rating value defined by Sudoku Explainer.
            </summary>
        </member>
        <member name="M:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.#ctor(System.Double)">
            <summary>
            Initializes a <see cref="T:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute"/> via the specified difficulty rating value.
            </summary>
            <param name="difficultyRating">
            The difficulty rating value. Assign <see cref="F:System.Double.NaN"/> if you don't know the real value.
            </param>
        </member>
        <member name="M:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a <see cref="T:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute"/> via the specified difficulty rating values
            as a range.
            </summary>
            <param name="minDifficultyRating">
            The minimum difficulty rating value of the range that the specified technique can be reached.
            Assign <see cref="F:System.Double.NaN"/> if you don't know the real value.
            </param>
            <param name="maxDifficultyRating">
            The maximum difficulty rating value of the range that the specified technique can be reached.
            Assign <see cref="F:System.Double.NaN"/> if you don't know the real value.
            </param>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.IsAdvancedDefined">
            <summary>
            Indicates whether the specified technique is defined by advanced version of Sudoku Explainer,
            which is not original program, or other implementations compatible with original Sudoku Explainer's
            rating system.
            </summary>
            <remarks>
            The default value is <see langword="false"/>.
            </remarks>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.IsRange">
            <summary>
            Indicates whether the value is not accurate one to measure the technique's difficulty.
            If the value is <see langword="true"/>, the difficulty rating is the minimum value
            (in other words, threshold) of the difficulty corresponding to specified technique.
            </summary>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.DifficultyRating">
            <summary>
            Indicates the difficulty rating.
            </summary>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.DifficultyRatingMaximumThreshold">
            <summary>
            <para>Indicates the maximum possible difficulty rating value that a technique can be reached.</para>
            <para>
            The value is <see langword="null"/> by default, but if the property <see cref="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.IsRange"/>
            is set to <see langword="true"/>, this value will not be <see langword="null"/>.
            </para>
            </summary>
        </member>
        <member name="M:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingAttribute.Deconstruct(System.Half@,System.Nullable{System.Half}@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange">
            <summary>
            Defines a range of difficulty rating value that is applied to a technique implemented by Sudoku Explainer.
            </summary>
            <param name="min">Indicates the minimum possible value.</param>
            <param name="max">Indicates the maximum possible value.</param>
        </member>
        <member name="M:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange.#ctor(System.Half,System.Half)">
            <summary>
            Defines a range of difficulty rating value that is applied to a technique implemented by Sudoku Explainer.
            </summary>
            <param name="min">Indicates the minimum possible value.</param>
            <param name="max">Indicates the maximum possible value.</param>
        </member>
        <member name="M:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange.#ctor(System.Half)">
            <summary>
            Initializes a <see cref="T:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange"/> instance
            via the specified difficulty rating value.
            </summary>
            <param name="min">The difficulty rating value.</param>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange.IsRange">
            <summary>
            Indicates whether the current range is a real range, i.e. property <see cref="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange.Max"/> holds different value
            with <see cref="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange.Min"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange.Min">
            <summary>
            The generated property declaration for parameter <c>min</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Compatibility.SudokuExplainer.SudokuExplainerDifficultyRatingRange.Max">
            <summary>
            The generated property declaration for parameter <c>max</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap">
            <summary>
            Encapsulates a binary series of candidate status table.
            </summary>
            <remarks>
            <para>
            This type holds a <see langword="static readonly" /> field called <see cref="F:Sudoku.Concepts.CandidateMap.Empty" />,
            it is the only field provided to be used as the entry to create or update collection.
            If you want to add elements into it, you can use <see cref="M:Sudoku.Concepts.CandidateMap.Add(System.Int32)" />, <see cref="M:Sudoku.Concepts.CandidateMap.AddRange(System.Collections.Generic.IEnumerable{System.Int32})" />
            or just <see cref="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Int32)" /> or <see cref="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Collections.Generic.IEnumerable{System.Int32})" />:
            <code><![CDATA[
            var map = CandidateMap.Empty;
            map += 0; // Adds 'r1c1(1)' into the collection.
            map.Add(1); // Adds 'r1c1(2)' into the collection.
            map.AddRange([2, 3, 4]); // Adds 'r1c1(345)' into the collection.
            map |= anotherMap; // Adds a list of another instance of type 'CandidateMap' into the current collection.
            ]]></code>
            </para>
            <para>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped in" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`2.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.MaxValue">
            <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MaxValue"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.MinValue">
            <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MinValue"/>
            <remarks>
            This value is equivalent to <see cref="F:Sudoku.Concepts.CandidateMap.Empty"/>.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap._bits">
            <summary>
            Indicates the internal bits. 12 is for floor(729 / <see langword="sizeof"/>(<see cref="T:System.Int64"/>) <![CDATA[<<]]> 6).
            </summary>
            <seealso cref="P:Sudoku.Concepts.IBitStatusMap`2.Shifting"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via a list of candidate offsets
            represented as a RxCy notation defined by <see cref="T:Sudoku.Text.Notations.RxCyNotation"/>.
            </summary>
            <param name="segments">The candidate offsets, represented as a RxCy notation.</param>
            <seealso cref="T:Sudoku.Text.Notations.RxCyNotation"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.Int32,System.Boolean)">
            <summary>
            Indicates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance with the peer candidates of the specified candidate and a <see cref="T:System.Boolean"/>
            value indicating whether the map will process itself with <see langword="true"/> value.
            </summary>
            <param name="candidate">The candidate.</param>
            <param name="withItself">Indicates whether the map will process itself with <see langword="true"/> value.</param>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CandidateMap}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CandidateMap}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CopyTo(System.Int32*,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Contains(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString(Sudoku.Text.Formatting.ICandidateMapFormatter)">
            <summary>
            Gets <see cref="T:System.String"/> representation of the current <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, using pre-defined formatters.
            </summary>
            <param name="candidateMapFormatter">
            The <see cref="T:Sudoku.Concepts.CandidateMap"/> formatter instance to format the current instance.
            </param>
            <returns>The <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Add(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.AddRange(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveRange(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Remove(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#ISimpleFormattable#ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#ExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#IntersectWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#UnionWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IParsable{Sudoku#Concepts#CandidateMap}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LogicalNot(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_True(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_False(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_OnesComplement(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Division(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Collections.Generic.ValueList{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Collections.Generic.IEnumerable{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_ExclusiveOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <summary>
            Expands the operator to <c><![CDATA[(a & b).PeerIntersection & b]]></c>.
            </summary>
            <param name="base">The base map.</param>
            <param name="template">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IDivisionOperators{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CellMap}#op_Division(Sudoku.Concepts.CandidateMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap}#op_Addition(Sudoku.Concepts.CandidateMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CandidateMap,System#Collections#Generic#IEnumerable{System#Int32},Sudoku#Concepts#CandidateMap}#op_Addition(Sudoku.Concepts.CandidateMap,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap}#op_Subtraction(Sudoku.Concepts.CandidateMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CandidateMap,System#Collections#Generic#IEnumerable{System#Int32},Sudoku#Concepts#CandidateMap}#op_Subtraction(Sudoku.Concepts.CandidateMap,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Implicit(Sudoku.Concepts.CandidateMap@)~System.Int32[]">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Implicit(System.Span{System.Int32})~Sudoku.Concepts.CandidateMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Implicit(System.ReadOnlySpan{System.Int32})~Sudoku.Concepts.CandidateMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Explicit(System.Int32[])~Sudoku.Concepts.CandidateMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#op_Implicit(System.Span{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#op_Implicit(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#op_Explicit(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#op_Explicit(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32}#op_Explicit(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.InternalBuffer">
            <summary>
            Indicates the internal buffer type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.InternalBuffer._firstElement">
            <summary>
            Indicates the first element of the whole buffer.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Equality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Inequality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap._count">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Concepts.CandidateMap.Count"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CandidateMap.Count"/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CandidateMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMap">
            <summary>
            Encapsulates a binary series of cell status table.
            </summary>
            <remarks>
            <para>
            This type holds a <see langword="static readonly" /> field called <see cref="F:Sudoku.Concepts.CellMap.Empty" />,
            it is the only field provided to be used as the entry to create or update collection.
            If you want to add elements into it, you can use <see cref="M:Sudoku.Concepts.CellMap.Add(System.Int32)" />, <see cref="M:Sudoku.Concepts.CellMap.AddRange(System.Collections.Generic.IEnumerable{System.Int32})" />
            or just <see cref="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Int32)" /> or <see cref="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Collections.Generic.IEnumerable{System.Int32})" />:
            <code><![CDATA[
            var map = CellMap.Empty;
            map += 0; // Adds 'r1c1' into the collection.
            map.Add(1); // Adds 'r1c2' into the collection.
            map.AddRange([2, 3, 4]); // Adds 'r1c345' into the collection.
            map |= anotherMap; // Adds a list of another instance of type 'CellMap' into the current collection.
            ]]></code>
            If you want to learn more information about this type, please visit
            <see href="https://sunnieshine.github.io/Sudoku/data-structures/cells">this wiki page</see>.
            </para>
            <para>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped in" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Shifting">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`2.Shifting"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`2.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._high">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._low">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a list of offsets represented as a RxCy notation defined by <see cref="T:Sudoku.Text.Notations.RxCyNotation"/>.
            </summary>
            <param name="segments">The cell offsets, represented as a RxCy notation.</param>
            <seealso cref="T:Sudoku.Text.Notations.RxCyNotation"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.InOneHouse">
            <summary>
            Same as the method <see cref="M:Sudoku.Concepts.CellMap.AllSetsAreInOneHouse(System.Int32@)"/>, but this property doesn't contain
            the <see langword="out"/> argument, as the optimization.
            </summary>
            <seealso cref="M:Sudoku.Concepts.CellMap.AllSetsAreInOneHouse(System.Int32@)"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.IsInIntersection">
            <summary>
            Determines whether the current list of cells are all lie in an intersection area,
            i.e. a locked candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.BlockMask">
            <summary>
            Indicates the mask of block that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>{ 0, 1, 27, 28 }</c>, all spanned blocks are 0 and 3, so the return
            mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.RowMask">
            <summary>
            Indicates the mask of row that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>{ 0, 1, 27, 28 }</c>, all spanned rows are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ColumnMask">
            <summary>
            Indicates the mask of column that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>{ 0, 1, 27, 28 }</c>, all spanned columns are 0 and 1, so the return mask is <c>0b000000011</c> (i.e. 3).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CoveredLine">
            <summary>
            Indicates the covered line.
            </summary>
            <remarks>
            If the covered house can't be found, it'll return <see cref="F:Sudoku.SolutionWideReadOnlyFields.InvalidTrailingZeroCountMethodFallback"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionWideReadOnlyFields.InvalidTrailingZeroCountMethodFallback"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CoveredHouses">
            <summary>
            Indicates all houses covered. This property is used to check all houses that all cells
            of this instance covered. For example, if the cells are <c>{ 0, 1 }</c>, the property
            <see cref="P:Sudoku.Concepts.CellMap.CoveredHouses"/> will return the house index 0 (block 1) and 9 (row 1);
            however, if cells spanned two houses or more (e.g. cells <c>{ 0, 1, 27 }</c>),
            this property won't contain any houses.
            </summary>
            <remarks>
            The return value will be a <see cref="T:System.Int32"/> value indicating each houses. Bits set 1 are covered houses.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Houses">
            <summary>
            All houses that the map spanned. This property is used to check all houses that all cells of
            this instance spanned. For example, if the cells are <c>{ 0, 1 }</c>, the property
            <see cref="P:Sudoku.Concepts.CellMap.Houses"/> will return the house index 0 (block 1), 9 (row 1), 18 (column 1)
            and 19 (column 2).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ExpandedPeers">
            <summary>
            Gets the expanded peers of the current map.
            </summary>
            <remarks>
            An <b>Expanded Peers</b> is a list of cells that contains all peer cells of each cell
            appeared in the current collection. For example, if a collection contains cells <c>r1c123</c>,
            this collection will be the result of the expression <c>PeersMap[r1c1] | PeersMap[r1c2] | PeersMap[r1c3]</c>,
            where the member <c>PeersMap</c> corresponds to the array <see cref="F:Sudoku.SolutionWideReadOnlyFields.PeersMap"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionWideReadOnlyFields.PeersMap"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CellMap}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CellMap}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CopyTo(System.Int32*,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.AllSetsAreInOneHouse(System.Int32@)">
            <summary>
            Indicates whether all cells in this instance are in one house.
            </summary>
            <param name="houseIndex">
            The house index whose corresponding house covered.
            If the return value is <see langword="false"/>, this value will be the constant -1.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <remarks>
            If you don't want to use the <see langword="out"/> parameter value, please
            use the property <see cref="P:Sudoku.Concepts.CellMap.InOneHouse"/> to improve the performance.
            </remarks>
            <seealso cref="P:Sudoku.Concepts.CellMap.InOneHouse"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Contains(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CompareTo(Sudoku.Concepts.CellMap@)">
            <summary>
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/summary"/>
            </summary>
            <param name="other">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/param[@name='other']"/>
            </param>
            <returns>
            The result value only contains 3 possible values: 1, 0 and -1. The comparison rule is:
            <list type="number">
            <item>
            If <see langword="this"/> holds more cells than <paramref name="other"/>, then return 1
            indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <see langword="this"/> holds less cells than <paramref name="other"/>, then return -1
            indicating <paramref name="other"/> is greater.
            </item>
            <item>
            If they two hold same cells, then checks for indices held:
            <list type="bullet">
            <item>
            If <see langword="this"/> holds a cell whose index is greater than all cells appeared in <paramref name="other"/>,
            then return 1 indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <paramref name="other"/> holds a cell whose index is greater than all cells
            appeared in <paramref name="other"/>, then return -1 indicating <paramref name="other"/> is greater.
            </item>
            </list>
            </item>
            </list>
            If all rules are compared, but they are still considered equal, then return 0.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(Sudoku.Text.Formatting.ICellMapFormatter)">
            <summary>
            Gets <see cref="T:System.String"/> representation of the current <see cref="T:Sudoku.Concepts.CellMap"/> instance, using pre-defined formatters.
            </summary>
            <param name="cellMapFormatter">
            The <see cref="T:Sudoku.Concepts.CellMap"/> formatter instance to format the current instance.
            </param>
            <returns>The <see cref="T:System.String"/> result.</returns>
            <remarks>
            <para>
            The target and supported types are stored in namespace <see cref="N:Sudoku.Text.Formatting"/>.
            If you don't remember the full format strings, you can try this method instead by passing
            actual <see cref="T:Sudoku.Text.Formatting.ICellMapFormatter"/> instances.
            </para>
            <para>
            For example, by using Susser formatter <see cref="T:Sudoku.Text.Formatting.RxCyFormat"/> instances:
            <code><![CDATA[
            // Suppose the variable is of type 'CellMap'.
            var cells = ...;
            
            // Creates a RxCyFormat-based formatter.
            var formatter = RxCyFormat.Default;
            
            // Using this method to get the target string representation.
            string targetStr = cells.ToString(formatter);
            
            // Output the result.
            Console.WriteLine(targetStr);
            ]]></code>
            </para>
            <para>
            In some cases we suggest you use this method instead of calling <see cref="M:Sudoku.Concepts.CellMap.ToString(System.String)"/>
            and <see cref="M:Sudoku.Concepts.CellMap.ToString(System.String,System.IFormatProvider)"/> because you may not remember all possible string formats.
            </para>
            <para>
            In addition, the method <see cref="M:Sudoku.Concepts.CellMap.ToString(System.String,System.IFormatProvider)"/> is also compatible with this method.
            If you forget to call this one, you can also use that method to get the same target result by passing first argument
            named <c>format</c> with <see langword="null"/> value:
            <code><![CDATA[
            string targetStr = cells.ToString(null, formatter);
            ]]></code>
            </para>
            </remarks>
            <seealso cref="N:Sudoku.Text.Formatting"/>
            <seealso cref="T:Sudoku.Text.Formatting.ICellMapFormatter"/>
            <seealso cref="T:Sudoku.Text.Formatting.RxCyFormat"/>
            <seealso cref="M:Sudoku.Concepts.CellMap.ToString(System.String)"/>
            <seealso cref="M:Sudoku.Concepts.CellMap.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Select``1(System.Func{System.Int32,``0})">
            <summary>
            Projects each element in the current instance into the target-typed <typeparamref name="TResult"/> array,
            using the specified function to convert.
            </summary>
            <typeparam name="TResult">The type of target value.</typeparam>
            <param name="selector">The selector.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Add(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.AddRange(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Remove(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.RemoveRange(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IComparable#CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IComparable{Sudoku#Concepts#CellMap}#CompareTo(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#ExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#IntersectWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#UnionWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int64,System.Int64)">
            <summary>
            Initializes an instance with two binary values.
            </summary>
            <param name="high">Higher 40 bits.</param>
            <param name="low">Lower 41 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes an instance with three binary values.
            </summary>
            <param name="high">Higher 27 bits.</param>
            <param name="mid">Medium 27 bits.</param>
            <param name="low">Lower 27 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByInt128(System.Int128@)">
            <summary>
            Initializes an instance with an <see cref="T:System.Int128"/> integer.
            </summary>
            <param name="llong">The <see cref="T:System.Int128"/> integer.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IParsable{Sudoku#Concepts#CellMap}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LogicalNot(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_True(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_False(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_OnesComplement(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_ExclusiveOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Modulus(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <summary>
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/summary"/>
            </summary>
            <param name="base">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='base']"/>
            </param>
            <param name="template">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='template']"/>
            </param>
            <returns><inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/returns"/></returns>
            <remarks>
            <para>
            The operator is commonly used for checking eliminations, especially in type 2 of deadly patterns. 
            </para>
            <para>
            For example, if we should check the eliminations
            of digit <c>d</c>, we may use the expression
            <code><![CDATA[
            (urCells & grid.CandidatesMap[d]).PeerIntersection & grid.CandidatesMap[d]
            ]]></code>
            to express the eliminations are the peer intersection of cells of digit <c>d</c>
            appeared in <c>urCells</c>. This expression can be simplified to
            <code><![CDATA[
            urCells % grid.CandidatesMap[d]
            ]]></code>
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Multiply(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Expands via the specified digit.
            </summary>
            <param name="base">The base map.</param>
            <param name="digit">The digit.</param>
            <returns>The result instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Division(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Get the sub-view mask of this map.
            </summary>
            <param name="map">The map.</param>
            <param name="houseIndex">The house index.</param>
            <returns>The mask.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IDivisionOperators{Sudoku#Concepts#CellMap,System#Int32,System#Int16}#op_Division(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap}#op_Addition(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CellMap,System#Collections#Generic#IEnumerable{System#Int32},Sudoku#Concepts#CellMap}#op_Addition(Sudoku.Concepts.CellMap,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap}#op_Subtraction(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CellMap,System#Collections#Generic#IEnumerable{System#Int32},Sudoku#Concepts#CellMap}#op_Subtraction(Sudoku.Concepts.CellMap,System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IMultiplyOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CandidateMap}#op_Multiply(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Implicit(Sudoku.Concepts.CellMap@)~System.Int32[]">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Implicit(System.Span{System.Int32})~Sudoku.Concepts.CellMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Implicit(System.ReadOnlySpan{System.Int32})~Sudoku.Concepts.CellMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.Int32[])~Sudoku.Concepts.CellMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(Sudoku.Concepts.CellMap@)~System.Int128">
            <summary>
            Implicit cast from <see cref="T:Sudoku.Concepts.CellMap"/> to <see cref="T:System.Int128"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.Int128@)~Sudoku.Concepts.CellMap">
            <summary>
            Explicit cast from <see cref="T:System.Int128"/> to <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <param name="llong">The <see cref="T:System.Int128"/> integer.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_CheckedExplicit(System.Int128@)~Sudoku.Concepts.CellMap">
            <summary>
            Explicit cast from <see cref="T:System.Int128"/> to <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <param name="llong">The <see cref="T:System.Int128"/> integer.</param>
            <exception cref="T:System.OverflowException">
            Throws when the base argument <paramref name="llong"/> is greater than the maximum value
            corresponding to <see cref="P:System.Numerics.IMinMaxValue`1.MaxValue"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#op_Implicit(System.Span{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#op_Implicit(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#op_Explicit(System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#op_Explicit(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32}#op_Explicit(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Equality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Inequality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Equality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_GreaterThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._count">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Concepts.CellMap.Count"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CellMap.Count"/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CellMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellStatus">
            <summary>
            Represents a cell status.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Undefined">
            <summary>
            Indicates the cell status is invalid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Empty">
            <summary>
            Indicates that the cell is empty.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Modifiable">
            <summary>
            Indicates the current cell has been filled a value that is not given from initial grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Given">
            <summary>
            Indicates the current cell has been filled a value that cannot be modified because it exists in initial grid.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Conjugate">
            <summary>
            Represents a <see href="https://sunnieshine.github.io/Sudoku/terms/conjugate-pair">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32)">
            <summary>
            Represents a <see href="https://sunnieshine.github.io/Sudoku/terms/conjugate-pair">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with from and to cell offset and a digit.
            </summary>
            <param name="from">The from cell.</param>
            <param name="to">The to cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with the map and the digit.
            The map should contains two cells, the first one is the start one, and the second one is the end one.
            </summary>
            <param name="map">The map.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.From">
            <summary>
            Indicates the cell that starts with the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.To">
            <summary>
            Indicates the cell that ends with the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Line">
            <summary>
            Indicates the line that two cells lie in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Houses">
            <summary>
            Indicates the house that two cells lie in.
            </summary>
            <remarks><inheritdoc cref="P:Sudoku.Concepts.CellMap.CoveredHouses"/></remarks>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Map">
            <summary>
            Indicates the whole map.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="F:Sudoku.Concepts.Conjugate._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Equality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Inequality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.Grid">
            <summary>
            Represents a sudoku grid that uses the mask list to construct the data structure.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped in" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.Grid.CandidateEnumerator">
            <summary>
            Defines the default enumerator that iterates the <see cref="T:Sudoku.Concepts.Grid"/> through the candidates in the current <see cref="T:Sudoku.Concepts.Grid"/> instance.
            </summary>
            <param name="arr">The reference to an array.</param>
            <see cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CandidateEnumerator.#ctor(System.Int16@)">
            <summary>
            Defines the default enumerator that iterates the <see cref="T:Sudoku.Concepts.Grid"/> through the candidates in the current <see cref="T:Sudoku.Concepts.Grid"/> instance.
            </summary>
            <param name="arr">The reference to an array.</param>
            <see cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CandidateEnumerator._start">
            <summary>
            The pointer to the start value.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CandidateEnumerator._refCurrent">
            <summary>
            The current pointer.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CandidateEnumerator._currentMask">
            <summary>
            Indicates the current mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CandidateEnumerator._currentIndex">
            <summary>
            The current index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidateEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CandidateEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>If the enumerator was successfully advanced to the next element.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>If the enumerator has passed the end of the collection.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CandidateEnumerator.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.DefaultMask">
            <summary>
            Indicates the default mask of a cell (an empty cell, with all 9 candidates left).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.MaxCandidatesMask">
            <summary>
            Indicates the maximum candidate mask that used.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyMask">
            <summary>
            Indicates the empty mask, modifiable mask and given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.ModifiableMask">
            <summary>
            Indicates the modifiable mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.GivenMask">
            <summary>
            Indicates the given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyString">
            <summary>
            Indicates the empty grid string.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.ValueChanged">
            <summary>
            Indicates the event triggered when the value is changed.
            </summary>
            <remarks>
            <feature name="function-pointer">
			<b>
				<i>
					This member is only exposed for user for knowing the data structure backing implementation,
					so it is disallowed to invoke it.
				</i>
			</b>
		</feature>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Grid.RefreshingCandidates">
            <summary>
            Indicates the event triggered when should re-compute candidates.
            </summary>
            <remarks>
            <feature name="function-pointer">
			<b>
				<i>
					This member is only exposed for user for knowing the data structure backing implementation,
					so it is disallowed to invoke it.
				</i>
			</b>
		</feature>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Empty">
            <summary>
            The empty grid that is valid during implementation or running the program (all values are <see cref="F:Sudoku.Concepts.Grid.DefaultMask"/>, i.e. empty cells).
            </summary>
            <remarks>
            This field is initialized by the static constructor of this structure.
            </remarks>
            <seealso cref="F:Sudoku.Concepts.Grid.DefaultMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Undefined">
            <summary>
            Indicates the default grid that all values are initialized 0.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.BackingSolver">
            <summary>
            Indicates the backing solver.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid._values">
            <summary>
            Indicates the inner array that stores the masks of the sudoku grid, which stores the in-time sudoku grid inner information.
            </summary>
            <remarks>
            The field uses the mask table of length 81 to indicate the status and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
             | 16  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0 |
             |-------------------|-----------|-----------------------------------|
             |   |   |   |   |   | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
             '-------------------|-----------|-----------------------------------'
                                 \___________/\__________________________________/
                                      (2)                     (1)
            </code>
            Here the 9 bits in (1) indicate whether each digit is possible candidate in the current cell for each bit respectively,
            and the higher 3 bits in (2) indicate the cell status. The possible cell status are:
            <list type="table">
            <listheader>
            <term>Status name</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Empty cell (i.e. <see cref="F:Sudoku.Concepts.CellStatus.Empty"/>)</term>
            <description>The cell is currently empty, and wait for being filled.</description>
            </item>
            <item>
            <term>Modifiable cell (i.e. <see cref="F:Sudoku.Concepts.CellStatus.Modifiable"/>)</term>
            <description>The cell is filled by a digit, but the digit isn't the given by the initial grid.</description>
            </item>
            <item>
            <term>Given cell (i.e. <see cref="F:Sudoku.Concepts.CellStatus.Given"/>)</term>
            <description>The cell is filled by a digit, which is given by the initial grid and can't be modified.</description>
            </item>
            </list>
            </remarks>
            <seealso cref="T:Sudoku.Concepts.CellStatus"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.#ctor(System.Int32@,Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid" /> instance via the pointer of the first element of the cell digit,
            and the creating option.
            </summary>
            <param name="firstElement">
            <para>The reference of the first element.</para>
            <para>
            <target name="in-parameter">
				<i>
					Please note that the parameter is an <see langword="in" /> parameter, which has the same meaning
					for <see langword="ref readonly" /> returns or locals. You can treat it as the first element
					in an array of elements. Different with <see langword="ref" /> parameter, <see langword="in" />
					modifier has the same semantic as <see langword="ref readonly var" />
					instead of <see langword="ref var" />.
				</i>
			</target>
            </para>
            </param>
            <param name="creatingOption">The creating option.</param>
            <remarks>
            <target name="method">
				<i>
					C# 7.3 introduces a new keyword <see langword="in" /> as the parameter modifier to make the parameter
					pass by reference and be read-only. Therefore, this keyword contains 2 usages:
					<list type="number">
						<item>
							Ensure the argument to <b>be read-only</b> and cannot be modified. Otherwise,
							a new copied instance will be created to prevent any modifications on the original variable.
						</item>
						<item>
							Ensure the argument to <b>pass by reference</b> in order to treat it as the pointer or array of elements
							of this type, and treat the argument as the first element of the whole element series.
						</item>
					</list>
					From the above meaning on this keyword, we can conclude that
					we should regard it as <see langword="ref readonly" /> parameters,
					but C# requires us using the keyword <see langword="in" /> as the modifier
					on a parameter rather than <see langword="ref readonly" />.
				</i>
			</target>
            </remarks>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="firstElement" /> is <see langword="null" /> reference.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsSolved">
            <summary>
            Indicates the grid has already solved. If the value is <see langword="true"/>,
            the grid is solved; otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsUndefined">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Grid.Undefined"/>, which means the grid
            holds totally same value with <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsEmpty">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Grid.Empty"/>, which means the grid
            holds totally same value with <see cref="F:Sudoku.Concepts.Grid.Empty"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsValid">
            <summary>
            Indicates whether the puzzle has a unique solution.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsMinimal">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesCount">
            <summary>
            Indicates the number of total candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivensCount">
            <summary>
            Indicates the total number of given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiablesCount">
            <summary>
            Indicates the total number of modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptiesCount">
            <summary>
            Indicates the total number of empty cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.NullHouses">
            <summary>
            <para>Indicates which houses are null houses.</para>
            <para>A <b>Null House</b> is a house whose hold cells are all empty cells.</para>
            <para>
            The property returns a <see cref="T:System.Int32"/> value as a mask that contains all possible house indices.
            For example, if the row 5, column 5 and block 5 (1-9) are null houses, the property will return
            the result <see cref="T:System.Int32"/> value, <c>000010000_000010000_000010000</c> as binary.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivenCells">
            <summary>
            Gets a cell list that only contains the given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiableCells">
            <summary>
            Gets a cell list that only contains the modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid is empty.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.BivalueCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid contain two candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesMap">
            <summary>
            Indicates the map of possible positions of the existence of the candidate value for each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.DigitsMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of each digit. The return value will
            be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, this property contains all givens, modifiables and
            empty cells only if it contains the digit in the mask.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ValuesMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of that value of each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, the value only contains the given or modifiable
            cells whose mask contain the set bit of that digit.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ConjugatePairs">
            <summary>
            Indicates all possible conjugate pairs appeared in this grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetGrid">
            <summary>
            Gets the grid where all modifiable cells are empty cells (i.e. the initial one).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.SolutionGrid">
            <summary>
            Indicates the solution of the current grid. If the puzzle has no solution or multiple solutions,
            this property will return <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Collections#Generic#IReadOnlyCollection{System#Int32}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Numerics#IMinMaxValue{Sudoku#Concepts#Grid}#MinValue">
            <summary>
            Indicates the minimum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm. For more information, please visit type <see cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>.
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Numerics#IMinMaxValue{Sudoku#Concepts#Grid}#MaxValue">
            <summary>
            Indicates the maximum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm. For more information, please visit type <see cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>.
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Grid"/> instance hold the same values as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.DuplicateWith(System.Int32,System.Int32)">
            <summary>
            Determine whether the digit in the target cell may be duplicated with a certain cell in the peers of the current cell,
            if the digit is filled into the cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ExactlyValidate(Sudoku.Concepts.Grid@,System.Nullable{System.Boolean}@)">
            <summary>
            <para>
            Determines whether the current grid is valid, checking on both normal and sukaku cases
            and returning a <see cref="T:System.Boolean"/>? value indicating whether the current sudoku grid is valid
            only on sukaku case.
            </para>
            <para>
            For more information, please see the introduction about the parameter
            <paramref name="sukaku"/>.
            </para>
            </summary>
            <param name="solutionIfValid">
            The solution if the puzzle is valid; otherwise, <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </param>
            <param name="sukaku">Indicates whether the current mode is sukaku mode.<list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle is a sukaku puzzle.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle is a normal sudoku puzzle.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle is invalid.</description>
            </item>
            </list>
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CheckMinimal(System.Int32@)">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
            <param name="firstCandidateMakePuzzleNotMinimal">
            <para>
            Indicates the first found candidate that can make the puzzle not minimal, which means
            if we remove the digit in the cell, the puzzle will still keep unique.
            </para>
            <para>If the return value is <see langword="true"/>, this argument will be -1.</para>
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle is invalid (i.e. not unique).</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetCandidateIsOn(System.Int32,System.Int32)">
            <summary>
            Sets a candidate existence case with a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="cell"><inheritdoc cref="M:Sudoku.Concepts.Grid.SetCandidateIsOn(System.Int32,System.Int32,System.Boolean)" path="/param[@name='cell']"/></param>
            <param name="digit"><inheritdoc cref="M:Sudoku.Concepts.Grid.SetCandidateIsOn(System.Int32,System.Int32,System.Boolean)" path="/param[@name='digit']"/></param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32)">
            <summary>
            Indicates whether the current grid contains the specified candidate offset.
            </summary>
            <param name="candidate">The candidate offset.</param>
            <returns><inheritdoc cref="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)" path="/returns"/></returns>
            <remarks><inheritdoc cref="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)" path="/remarks"/></remarks>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)">
            <summary>
            Indicates whether the current grid contains the digit in the specified cell.
            </summary>
            <param name="cell">The cell offset.</param>
            <param name="digit">The digit.</param>
            <returns>
            The method will return a <see cref="T:System.Boolean"/>? value
            (containing three possible cases: <see langword="true"/>, <see langword="false"/> and <see langword="null"/>).
            All values corresponding to the cases are below:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Case description on this value</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>
            The cell is an empty cell <b>and</b> contains the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            The cell is an empty cell <b>but doesn't</b> contain the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The cell is <b>not</b> an empty cell.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Note that the method will return a <see cref="T:System.Boolean"/>?, so you should use the code
            '<c>grid.Exists(cell, digit) is true</c>' or '<c>grid.Exists(cell, digit) == true</c>'
            to decide whether a condition is true.
            </para>
            <para>
            In addition, because the type is <see cref="T:System.Boolean"/>? rather than <see cref="T:System.Boolean"/>,
            the result case will be more precisely than the indexer <see cref="M:Sudoku.Concepts.Grid.GetCandidateIsOn(System.Int32,System.Int32)"/>,
            which is the main difference between this method and that indexer.
            </para>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Grid.GetCandidateIsOn(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToArray">
            <summary>
            Serializes this instance to an array, where all digit value will be stored.
            </summary>
            <returns>
            This array. All elements are between 0 and 9, where 0 means the cell is <see cref="F:Sudoku.Concepts.CellStatus.Empty"/> now.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetCandidates(System.Int32)">
            <summary>
            Get the candidate mask part of the specified cell.
            </summary>
            <param name="cell">The cell offset you want to get.</param>
            <returns>
            <para>
            The candidate mask. The return value is a 9-bit <see cref="T:System.Int16"/>
            value, where each bit will be:
            <list type="table">
            <item>
            <term><c>0</c></term>
            <description>The cell <b>doesn't contain</b> the possibility of the digit.</description>
            </item>
            <item>
            <term><c>1</c></term>
            <description>The cell <b>contains</b> the possibility of the digit.</description>
            </item>
            </list>
            </para>
            <para>
            For example, if the result mask is 266 (i.e. <c>0b<b>1</b>00_00<b>1</b>_0<b>1</b>0</c> in binary),
            the value will indicate the cell contains the digit 2, 4 and 9.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigitsUnion(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.GetDigitsUnion(Sudoku.Concepts.CellMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigitsUnion(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigitsUnion(Sudoku.Concepts.CellMap@,System.Boolean)">
            <summary>
            <inheritdoc cref="M:Sudoku.Concepts.Grid.GetDigitsUnion(Sudoku.Concepts.CellMap@)" path="/summary"/>
            </summary>
            <param name="cells"><inheritdoc cref="M:Sudoku.Concepts.Grid.GetDigitsUnion(Sudoku.Concepts.CellMap@)" path="/param[@name='cells']"/></param>
            <param name="withValueCells">
            Indicates whether the value cells (given or modifiable ones) will be included to be gathered.
            If <see langword="true"/>, all value cells (no matter what kind of cell) will be summed up.
            </param>
            <returns><inheritdoc cref="M:Sudoku.Concepts.Grid.GetDigitsUnion(Sudoku.Concepts.CellMap@)" path="/returns"/></returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigitsIntersection(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid,
            to determine which digits are not used.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(Sudoku.Text.Formatting.IGridFormatter)">
            <summary>
            Gets <see cref="T:System.String"/> representation of the current grid, using pre-defined grid formatters.
            </summary>
            <param name="gridFormatter">
            The grid formatter instance to format the current grid.
            </param>
            <returns>The <see cref="T:System.String"/> result.</returns>
            <remarks>
            <para>
            The target and supported types are stored in namespace <see cref="N:Sudoku.Text.Formatting"/>.
            If you don't remember the full format strings, you can try this method instead by passing
            actual <see cref="T:Sudoku.Text.Formatting.IGridFormatter"/> instances.
            </para>
            <para>
            For example, by using Susser formatter <see cref="T:Sudoku.Text.Formatting.SusserFormat"/> instances:
            <code><![CDATA[
            // Suppose the variable is of type 'Grid'.
            var grid = ...;
            
            // Creates a Susser-based formatter, with placeholder text as '0',
            // missing candidates output and modifiable distinction.
            var formatter = SusserFormat.Default with
            {
                Placeholder = '0',
                WithCandidates = true,
                WithModifiables = true
            };
            
            // Using this method to get the target string representation.
            string targetStr = grid.ToString(formatter);
            
            // Output the result.
            Console.WriteLine(targetStr);
            ]]></code>
            </para>
            <para>
            In some cases we suggest you use this method instead of calling <see cref="M:Sudoku.Concepts.Grid.ToString(System.String)"/>
            and <see cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/> because you may not remember all possible string formats.
            </para>
            <para>
            In addition, the method <see cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/> is also compatible with this method.
            If you forget to call this one, you can also use that method to get the same target result by passing first argument
            named <c>format</c> with <see langword="null"/> value:
            <code><![CDATA[
            string targetStr = grid.ToString(null, formatter);
            ]]></code>
            </para>
            </remarks>
            <seealso cref="N:Sudoku.Text.Formatting"/>
            <seealso cref="T:Sudoku.Text.Formatting.IGridFormatter"/>
            <seealso cref="T:Sudoku.Text.Formatting.SusserFormat"/>
            <seealso cref="M:Sudoku.Concepts.Grid.ToString(System.String)"/>
            <seealso cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetStatus(System.Int32)">
            <summary>
            Get the cell status at the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The cell status.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigit(System.Int32)">
            <summary>
            Try to get the digit filled in the specified cell.
            </summary>
            <param name="cell">The cell used.</param>
            <returns>The digit that the current cell filled. If the cell is empty, return -1.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified cell keeps a wrong cell status value. For example, <see cref="F:Sudoku.Concepts.CellStatus.Undefined"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.EnumerateCandidates">
            <summary>
            Try to enumerate all possible candidates in the current grid.
            </summary>
            <returns>
            An enumerator that allows us using <see langword="foreach"/> statement
            to iterate all possible candidates in the current grid.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.EnumerateMasks">
            <summary>
            Try to enumerate the mask table of the current grid.
            </summary>
            <returns>
            An enumerator that allows us using <see langword="foreach" /> statement
            to iterate all masks in the current grid. The mask list must contain 81 masks.
            </returns>
            <remarks>
            <para>
            Please note that the iterator will iterate all masks by reference, which means
            you can apply <see langword="ref" /> and <see langword="ref readonly" /> modifier
            onto the iteration variable:
            <code><![CDATA[
            // 'Mask' is a type alias for type 'short'.
            foreach (ref readonly Mask mask in grid)
            {
                // Do something.
            }
            ]]></code>
            </para>
            <para>
            <target name="foreach-variables">
				<para>
					<i>
						Iteration variable are implicitly <see langword="scoped" />, which means you cannot return it outside the method
						or other members that can return.
					</i>
				</para>
			</target>
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Select``1(System.Func{System.Int32,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
            <typeparam name="TResult">
            The type of the value returned by <paramref name="selector"/>.
            This type must be an <see langword="unmanaged"/> type in order to make optimization
            in the future release of C# versions.
            </typeparam>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>
            An array of <typeparamref name="TResult"/> elements converted.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Reset">
            <summary>
            Reset the sudoku grid, to set all modifiable values to empty ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Fix">
            <summary>
            To fix the current grid (all modifiable values will be changed to given ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Unfix">
            <summary>
            To unfix the current grid (all given values will be changed to modifiable ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Apply(Sudoku.Analytics.Conclusion)">
            <summary>
            Try to apply the specified conclusion.
            </summary>
            <param name="conclusion">The conclusion to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Apply(Sudoku.Analytics.Conclusion[])">
            <summary>
            Try to apply the specified array of conclusions.
            </summary>
            <param name="conclusions">The conclusions to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetStatus(System.Int32,Sudoku.Concepts.CellStatus)">
            <summary>
            Set the specified cell to the specified status.
            </summary>
            <param name="cell">The cell.</param>
            <param name="status">The status.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetMask(System.Int32,System.Int16)">
            <summary>
            Set the specified cell to the specified mask.
            </summary>
            <param name="cell">The cell.</param>
            <param name="mask">The mask to set.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetDigit(System.Int32,System.Int32)">
            <summary>
            Set the specified digit into the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">
            <para>
            The value you want to set. The value should be between 0 and 8.
            If assigning -1, the grid will execute an implicit behavior that candidates in <b>all</b> empty cells will be re-computed.
            </para>
            <para>
            The values set into the grid will be regarded as the modifiable values.
            If the cell contains a digit, it will be covered when it is a modifiable value.
            If the cell is a given cell, the setter will do nothing.
            </para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetCandidateIsOn(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the target candidate status.
            </summary>
            <param name="cell">The cell offset between 0 and 80.</param>
            <param name="digit">The digit between 0 and 8.</param>
            <param name="isOn">
            The case you want to set. <see langword="false"/> means that this candidate
            doesn't exist in this current sudoku grid; otherwise, <see langword="true"/>.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetMap()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Grid.EmptyCells"/> and <see cref="P:Sudoku.Concepts.Grid.BivalueCells"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The map.</returns>
            <seealso cref="P:Sudoku.Concepts.Grid.EmptyCells"/>
            <seealso cref="P:Sudoku.Concepts.Grid.BivalueCells"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetMaps()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, <see cref="P:Sudoku.Concepts.Grid.DigitsMap"/> and <see cref="P:Sudoku.Concepts.Grid.ValuesMap"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The map indexed by each digit.</returns>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
            <seealso cref="P:Sudoku.Concepts.Grid.DigitsMap"/>
            <seealso cref="P:Sudoku.Concepts.Grid.ValuesMap"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Preserve(Sudoku.Concepts.CellMap@)">
            <summary>
            Gets a sudoku grid, removing all value digits not appearing in the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int32[],Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using grid values.
            </summary>
            <param name="gridValues">The array of grid values.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int16[])">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance with the specified mask array.
            </summary>
            <param name="masks">The masks.</param>
            <exception cref="T:System.ArgumentException">Throws when <see cref="P:System.Array.Length"/> is not 81.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int32},Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the array of cell digits
            of type <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <param name="gridValues">The list of cell digits.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String)">
            <inheritdoc/>
            <remarks>
            We suggest you use <see cref="M:Sudoku.Concepts.Grid.op_Explicit(System.String)~Sudoku.Concepts.Grid"/> to achieve same goal if the passing argument is a constant.
            For example:
            <code><![CDATA[
            var grid1 = (Grid)"123456789456789123789123456214365897365897214897214365531642978642978531978531642";
            var grid2 = (Grid)"987654321654321987321987654896745213745213896213896745579468132468132579132579468";
            var grid3 = Grid.Parse(stringCode); // 'stringCode' is a string, not null.
            ]]></code>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Grid.op_Explicit(System.String)~Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String,System.Boolean)">
            <summary>
            <para>
            Parses a string value and converts to this type.
            </para>
            <para>
            If you want to parse a PM grid, you should decide the mode to parse.
            If you use compatible mode to parse, all single values will be treated as
            given values; otherwise, recommended mode, which uses '<c><![CDATA[<d>]]></c>'
            or '<c>*d*</c>' to represent a value be a given or modifiable one. The decision
            will be indicated and passed by the second parameter <paramref name="compatibleFirst"/>.
            </para>
            </summary>
            <param name="str">The string.</param>
            <param name="compatibleFirst">
            Indicates whether the parsing operation should use compatible mode to check PM grid.
            </param>
            <returns>The result instance had converted.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String,Sudoku.Text.Parsing.GridParsingOption)">
            <summary>
            Parses a string value and converts to this type, using a specified grid parsing type.
            </summary>
            <param name="str">The string.</param>
            <param name="gridParsingOption">The grid parsing type.</param>
            <returns>The result instance had converted.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
            <para>Parses a string value and converts to this type.</para>
            <para>
            If you want to parse a PM grid, we recommend you use the method
            <see cref="M:Sudoku.Concepts.Grid.Parse(System.String,Sudoku.Text.Parsing.GridParsingOption)"/> instead of this method.
            </para>
            </summary>
            <param name="str">The string.</param>
            <returns>The result instance had converted.</returns>
            <seealso cref="M:Sudoku.Concepts.Grid.Parse(System.String,Sudoku.Text.Parsing.GridParsingOption)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Text.Parsing.GridParsingOption,Sudoku.Concepts.Grid@)">
            <summary>
            Try to parse a string and converts to this type, and returns a
            <see cref="T:System.Boolean"/> value indicating the result of the conversion.
            </summary>
            <param name="str">The string.</param>
            <param name="option">The grid parsing type.</param>
            <param name="result">
            The result parsed. If the conversion is failed, this argument will be <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.Utf8String,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.Utf8String,Sudoku.Text.Parsing.GridParsingOption,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Text.Parsing.GridParsingOption,Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#IParsable{Sudoku#Concepts#Grid}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#IParsable{Sudoku#Concepts#Grid}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Explicit(System.String)~Sudoku.Concepts.Grid">
            <summary>
            Implicit cast from <see cref="T:System.String"/> code to its equivalent <see cref="T:Sudoku.Concepts.Grid"/> instance representation.
            </summary>
            <param name="gridCode">The grid code.</param>
            <remarks>
            <para>
            This explicit operator has same meaning for method <see cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/>. You can also use
            <see cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/> to get the same result as this operator.
            </para>
            <para>
            If the argument being passed is <see langword="null"/>, this operator will return <see cref="F:Sudoku.Concepts.Grid.Undefined"/>
            as the final result, whose behavior is the only one that is different with method <see cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/>.
            That method will throw a <see cref="T:System.FormatException"/> instance to report the invalid argument being passed.
            </para>
            </remarks>
            <exception cref="T:System.FormatException">
            See exception thrown cases for method <see cref="M:System.ISimpleParsable`1.Parse(System.String)"/>.
            </exception>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
            <seealso cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/>
            <seealso cref="M:System.ISimpleParsable`1.Parse(System.String)"/>
        </member>
        <member name="T:Sudoku.Concepts.Grid.MaskEnumerator">
            <summary>
            Defines the default enumerator that iterates the <see cref="T:Sudoku.Concepts.Grid"/> through the masks in the current <see cref="T:Sudoku.Concepts.Grid"/> instance.
            </summary>
            <param name="arr">The pointer to an array.</param>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.MaskEnumerator.#ctor(System.Int16@)">
            <summary>
            Defines the default enumerator that iterates the <see cref="T:Sudoku.Concepts.Grid"/> through the masks in the current <see cref="T:Sudoku.Concepts.Grid"/> instance.
            </summary>
            <param name="arr">The pointer to an array.</param>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.MaskEnumerator._refCurrent">
            <summary>
            The current pointer.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.MaskEnumerator._currentIndex">
            <summary>
            The current index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.MaskEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.MaskEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>If the enumerator was successfully advanced to the next element.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>If the enumerator has passed the end of the collection.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.MaskEnumerator.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Equality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Inequality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Equality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Inequality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Throws when the target text is <see langword="null"/>.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Grid,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellFilteringMethods">
            <summary>
            Represents a list of methods to filter the cells, used by <see cref="M:Sudoku.Concepts.Grid.GetMap()"/>
            or <see cref="M:Sudoku.Concepts.Grid.GetMaps()"/>.
            </summary>
            <seealso cref="M:Sudoku.Concepts.Grid.GetMap()"/>
            <seealso cref="M:Sudoku.Concepts.Grid.GetMaps()"/>
        </member>
        <member name="T:Sudoku.Concepts.GridCreatingOption">
            <summary>
            Indicates the grid creating option.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.None">
            <summary>
            Indicates the option is none.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.MinusOne">
            <summary>
            Indicates each value should minus one before creation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridTransformations">
            <summary>
            Provides methods for <see cref="T:Sudoku.Concepts.Grid"/> instances on transformations.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.ClockwiseTable">
            <summary>
            The table of clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.CounterclockwiseTable">
            <summary>
            The table of counter-clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.PiRotateTable">
            <summary>
            The table of pi-rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.SwappableHouses">
            <summary>
            Indicates the swappable pairs, which means the swappable houses.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorLeftRight(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror left-right the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorTopBottom(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror top-bottom the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorDiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.Transpose(Sudoku.Concepts.Grid@)">
            <summary>
            Transpose the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorAntidiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror anti-diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.RotateClockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid clockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.RotateCounterclockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid counterclockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.RotatePi(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid <c><see cref="F:System.Math.PI"/></c> degrees.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.SwapTwoHouses(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap to houses.
            </summary>
            <param name="this">The grid.</param>
            <param name="houseIndex1">The house 1 to be swapped.</param>
            <param name="houseIndex2">The house 2 to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when two specified house argument is not in valid range (0..27),
            two houses are not in same house type, or are not swappable.
            </exception>
            <remarks>
            This method will return the reference that is same as the argument <paramref name="this"/>,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.Swap``1(``0@,``0@)">
            <summary>
            Swaps the two elements.
            </summary>
            <typeparam name="T">The type of two elements.</typeparam>
            <param name="left">The left-side instance to be swapped.</param>
            <param name="right">The right-side instance to be swapped.</param>
        </member>
        <member name="T:Sudoku.Concepts.HouseType">
            <summary>
            Represents a <see href="https://sunnieshine.github.io/Sudoku/terms/house">house type</see>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Block">
            <summary>
            Indicates the house type is a block.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Row">
            <summary>
            Indicates the house type is a row.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Column">
            <summary>
            Indicates the house type is a column.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.HouseTypeExtensions">
            <summary>
            Provides extension methods on <see cref="T:Sudoku.Concepts.HouseType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.HouseType"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.CopyHouseInfo(System.Int32,System.Int32@)">
            <summary>
            Gets the row, column and block value and copies to the specified array that represents by a pointer
            of 3 elements, where the first element stores the block index, second element stores the row index
            and the third element stores the column index.
            </summary>
            <param name="cell">The cell. The available values must be between 0 and 80.</param>
            <param name="reference">
            The specified reference to the first element in a sequence. The sequence type can be an array or a <see cref="T:System.Span`1"/>,
            only if the sequence can store at least 3 values.
            </param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="reference"/> references to <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.ToHouseIndex(System.Byte,Sudoku.Concepts.HouseType)">
            <summary>
            Get the house index (0..27 for block 1-9, row 1-9 and column 1-9)
            for the specified cell and the house type.
            </summary>
            <param name="cell">The cell. The available values must be between 0 and 80.</param>
            <param name="houseType">The house type.</param>
            <returns>The house index. The return value must be between 0 and 26.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="houseType"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.ToHouseIndex(System.Int32,Sudoku.Concepts.HouseType)">
            <inheritdoc cref="M:Sudoku.Concepts.HouseTypeExtensions.ToHouseIndex(System.Byte,Sudoku.Concepts.HouseType)"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.ToHouseIndices(System.Byte)">
            <summary>
            Get the house indices for the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.ToHouseIndices(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.HouseTypeExtensions.ToHouseIndices(System.Byte)"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.ToHouseType(System.Int32)">
            <summary>
            Get the house type for the specified house index.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>
            The house type. The possible return values are:
            <list type="table">
            <listheader>
            <term>House indices</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 0 and < 9]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Block"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 9 and < 18]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Row"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 18 and < 27]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Column"/></description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetLabel(Sudoku.Concepts.HouseType)">
            <summary>
            Try to get the label of the specified house type.
            </summary>
            <param name="this">The house type.</param>
            <returns>A character that represents a house type.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="T:Sudoku.Concepts.IBitStatusMap`2">
            <summary>
            Extracts a base type that describes status table from elements of <typeparamref name="TSelf"/> type.
            </summary>
            <typeparam name="TSelf">The type of the instance that implements this interface type.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.Shifting">
            <summary>
            Indicates the size of each unit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.Count">
            <summary>
            Indicates the number of the values stored in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.StringChunks">
            <summary>
            Gets all chunks of the current collection, meaning a list of <see cref="T:System.String"/> values that can describe
            all cell and candidate indices, grouped with same row/column.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.PeerIntersection">
            <summary>
            Indicates the peer intersection of the current instance.
            </summary>
            <remarks>
            A <b>Peer Intersection</b> is a set of cells that all cells from the base collection can be seen.
            For more information please visit <see href="https://sunnieshine.github.io/Sudoku/terms/peer">this link</see>.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ICollection{TElement}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ICollection{TElement}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.Empty">
            <summary>
            Indicates the empty instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IAdditiveIdentity{TSelf,TSelf}#AdditiveIdentity">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.Add(`1)">
            <summary>
            Adds a new offset into the current collection.
            </summary>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.AddRange(System.ReadOnlySpan{`1})">
            <summary>
            Set the specified offsets as <see langword="true"/> value.
            </summary>
            <param name="offsets">The offsets to add.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.AddRange(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:Sudoku.Concepts.IBitStatusMap`2.AddRange(System.ReadOnlySpan{`1})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.Remove(`1)">
            <summary>
            Set the specified offset as <see langword="false"/> value.
            </summary>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.RemoveRange(System.ReadOnlySpan{`1})">
            <summary>
            Set the specified offsets as <see langword="false"/> value.
            </summary>
            <param name="offsets">The offsets to remove.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.RemoveRange(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:Sudoku.Concepts.IBitStatusMap`2.RemoveRange(System.ReadOnlySpan{`1})"/>
            <remarks>
            Different with the method <see cref="M:Sudoku.Concepts.IBitStatusMap`2.RemoveRange(System.Collections.Generic.IEnumerable{`1})"/>, this method
            also checks for the validity of each offsets.
            If the value is below 0 or greater than 80 (for cell offsets) or below 0 or greater than 728 (for candidate offsets),
            this method will throw an exception to report about this.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Throws when found at least one cell offset invalid.</exception>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.Clear">
            <summary>
            Clear all bits.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.CopyTo(`1*,System.Int32)">
            <summary>
            Copies the current instance to the target array specified as an <typeparamref name="TElement"/>*.
            </summary>
            <param name="arr">The pointer that points to an array of type <typeparamref name="TElement"/>.</param>
            <param name="length">The length of that array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="arr"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Throws when the capacity isn't enough to store all values.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.CopyTo(`1[],System.Int32)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.CopyTo(System.Span{`1})">
            <summary>
            Copies the current instance to the target <see cref="T:System.Span`1"/> instance.
            </summary>
            <param name="span">
            The target <see cref="T:System.Span`1"/> instance.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.ForEach(System.Action{`1})">
            <summary>
            Iterates on each element in this collection.
            </summary>
            <param name="action">The visitor that handles for each element in this collection.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.ExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.IntersectWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.UnionWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.Contains(`1)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="offset">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.Equals(`0@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.ToArray">
            <summary>
            Get all offsets whose bits are set <see langword="true"/>.
            </summary>
            <returns>An array of offsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.Slice(System.Int32,System.Int32)">
            <summary>
            Slices the current instance, and get the new instance with some of elements between two indices.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The number of elements.</param>
            <returns>The target instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ICollection{TElement}#Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ICollection{TElement}#CopyTo(`1[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#ExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#IntersectWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#UnionWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ICollection{TElement}#Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IReadOnlySet{TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#IEquatable{TSelf}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#ISet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IReadOnlySet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IReadOnlySet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IReadOnlySet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IReadOnlySet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#IParsable{TSelf}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_LogicalNot(`0@)">
            <summary>
            Determines whether the current collection is empty.
            </summary>
            <param name="offsets">The cells to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <remarks>
            The type of the current collection supports using <see cref="T:System.Boolean"/>-like expression to determine whether the collection is not empty,
            for example:
            <code><![CDATA[
            if (collection)
                // ...
            ]]></code>
            The statement <c>collection</c> will be expanded to <c>collection.Count != 0</c>. Therefore, the negation operator <c>!</c>
            will invert the result of above expression. This is why I use <see langword="operator"/> <c>!</c> to determine on this.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_OnesComplement(`0@)">
            <summary>
            Reverse status for all offsets, which means all <see langword="true"/> bits
            will be set <see langword="false"/>, and all <see langword="false"/> bits
            will be set <see langword="true"/>.
            </summary>
            <param name="offsets">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_True(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is not empty.
            </summary>
            <param name="cells">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_False(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is empty.
            </summary>
            <param name="cells">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Addition(`0@,`1)">
            <summary>
            Adds the specified <paramref name="offset"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be added.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Addition(`0@,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Adds the specified list of <paramref name="offsets"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offsets">A list of cells to be added.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Subtraction(`0@,`1)">
            <summary>
            Removes the specified <paramref name="offset"/> from the <paramref name="collection"/>,
            and returns the removed result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Subtraction(`0@,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Get a <typeparamref name="TSelf"/> that contains all <paramref name="collection"/> instance
            but not in <paramref name="offsets"/> instance.
            </summary>
            <param name="collection">The left instance.</param>
            <param name="offsets">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Subtraction(`0@,`0@)">
            <summary>
            Get a <typeparamref name="TSelf"/> that contains all <paramref name="left"/> instance
            but not in <paramref name="right"/> instance.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_BitwiseAnd(`0@,`0@)">
            <summary>
            Get the elements that both <paramref name="left"/> and <paramref name="right"/> contain.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_BitwiseOr(`0@,`0@)">
            <summary>
            Combine the elements from <paramref name="left"/> and <paramref name="right"/>,
            and return the merged result.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_ExclusiveOr(`0@,`0@)">
            <summary>
            Get the elements that either <paramref name="left"/> or <paramref name="right"/> contains.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_BitwiseAnd(`0@,System.Int32)">
            <summary>
            Gets the subsets of the current collection via the specified size indicating the number of elements of the each subset.
            </summary>
            <param name="offsets">Indicates the base template cells.</param>
            <param name="subsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="subsetSize"/> &gt; <paramref name="offsets"/>.Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term><c><paramref name="subsetSize"/> == <paramref name="offsets"/>.Count</c></term>
            <description>
            Will return an array that contains only one element, same as the argument <paramref name="offsets"/>.
            </description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.NotSupportedException">
            Throws when both <paramref name="offsets"/> count and <paramref name="subsetSize"/> are greater than 30.
            </exception>
            <remarks>
            For example, if the argument <paramref name="offsets"/> is <c>r1c1</c>, <c>r1c2</c> and <c>r1c3</c>
            and the argument <paramref name="subsetSize"/> is 2, the expression <c><![CDATA[cells & 2]]></c>
            will be an array of 3 elements given below: <c>r1c12</c>, <c>r1c13</c> and <c>r1c23</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_BitwiseOr(`0@,System.Int32)">
            <summary>
            Gets all subsets of the current collection via the specified size
            indicating the <b>maximum</b> number of elements of the each subset.
            </summary>
            <param name="offsets">Indicates the base template cells.</param>
            <param name="subsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="subsetSize"/> &gt; <paramref name="offsets"/>.Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
            <remarks>
            For example, the expression <c>cells | 3</c> is equivalent to all possible cases
            coming from <c><![CDATA[cells & 1]]></c>,
            <c><![CDATA[cells & 2]]></c> and <c><![CDATA[cells & 3]]></c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Equality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Inequality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_OnesComplement(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#ISubtractionOperators{TSelf,TSelf,TSelf}#op_Subtraction(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_ExclusiveOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.System#Numerics#IModulusOperators{TSelf,TSelf,TSelf}#op_Modulus(`0,`0)">
            <summary>
            Expands the operator to <c><![CDATA[(a & b).PeerIntersection & b]]></c>.
            </summary>
            <param name="left">The base map.</param>
            <param name="right">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Implicit(`0@)~`1[]">
            <summary>
            Implicit cast from <typeparamref name="TSelf"/> to <typeparamref name="TElement"/>[].
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Implicit(System.Span{`1})~`0">
            <summary>
            Implicit cast from <see cref="T:System.Span`1"/> to <typeparamref name="TSelf"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Implicit(System.ReadOnlySpan{`1})~`0">
            <summary>
            Implicit cast from <see cref="T:System.ReadOnlySpan`1"/> to <typeparamref name="TSelf"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Explicit(`1[])~`0">
            <summary>
            Explicit cast from <typeparamref name="TElement"/>[] to <typeparamref name="TSelf"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Explicit(`0@)~System.Span{`1}">
            <summary>
            Explicit cast from <typeparamref name="TSelf"/> to <see cref="T:System.Span`1"/> of element type <typeparamref name="TElement"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`2.op_Explicit(`0@)~System.ReadOnlySpan{`1}">
            <summary>
            Explicit cast from <typeparamref name="TSelf"/> to <see cref="T:System.ReadOnlySpan`1"/> of element type <typeparamref name="TElement"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="T:Sudoku.Concepts.Inference">
            <summary>
            Defines an inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Strong">
            <summary>
            Indicates the inference is strong inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Weak">
            <summary>
            Indicates the inference is weak inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.StrongGeneralized">
            <summary>
            Indicates the inference is strong inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.WeakGeneralized">
            <summary>
            Indicates the inference is weak inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.ConjugatePair">
            <summary>
            Indicates the inference is conjugate pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Default">
            <summary>
            Indicates the inference is the default case that doesn't belong to above.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.InferenceExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Inference"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Inference"/>
        </member>
        <member name="M:Sudoku.Concepts.InferenceExtensions.ConnectingNotation(Sudoku.Concepts.Inference)">
            <summary>
            Gets connecting notation of the inference.
            </summary>
            <param name="this">The inference instance.</param>
            <returns>The connecting notation of the inference.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in the enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.LockedTarget">
            <summary>
            Defines the data structure that stores a set of cells and a digit, indicating the information
            about the locked candidate node.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cells">Indicates the cells used.</param>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped in" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.#ctor(System.Int32,Sudoku.Concepts.CellMap)">
            <summary>
            Defines the data structure that stores a set of cells and a digit, indicating the information
            about the locked candidate node.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cells">Indicates the cells used.</param>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped in" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.LockedTarget"/> instance via the specified cell and the specified digit used.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cell">Indicates the cell used.</param>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.IsSole">
            <summary>
            Indicates whether the number of cells is 1.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.DigitString">
            <summary>
            The digit string value.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Deconstruct(Sudoku.Concepts.CellMap@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Equals(Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#IEquatable{Sudoku#Concepts#LockedTarget}#Equals(Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.Digit">
            <summary>
            The generated property declaration for parameter <c>digit</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.Cells">
            <summary>
            The generated property declaration for parameter <c>cells</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.ToString">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.op_Equality(Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.op_Inequality(Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Numerics#IEqualityOperators{Sudoku#Concepts#LockedTarget,Sudoku#Concepts#LockedTarget,System#Boolean}#op_Equality(Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Numerics#IEqualityOperators{Sudoku#Concepts#LockedTarget,Sudoku#Concepts#LockedTarget,System#Boolean}#op_Inequality(Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.SymmetricType">
            <summary>
            Represents a symmetric type that can describe which one a pattern or a puzzle uses.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.None">
            <summary>
            Indicates none of symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.Central">
            <summary>
            Indicates the central symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.Diagonal">
            <summary>
            Indicates the diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.AntiDiagonal">
            <summary>
            Indicates the anti-diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.XAxis">
            <summary>
            Indicates the x-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.YAxis">
            <summary>
            Indicates the y-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.AxisBoth">
            <summary>
            Indicates both X-axis and Y-axis symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.DiagonalBoth">
            <summary>
            Indicates both diagonal and anti-diagonal symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.All">
            <summary>
            Indicates all symmetry types should be satisfied.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.SymmetricTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.SymmetricType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.SymmetricType"/>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.Concepts.SymmetricType,System.Int32,System.Int32)">
            <summary>
            Get the cells that is used for swapping via the specified symmetric type, and the specified row and column value.
            </summary>
            <param name="this">The symmetric type.</param>
            <param name="row">The row value.</param>
            <param name="column">The column value.</param>
            <returns>The cells.</returns>
        </member>
        <member name="T:Sudoku.IO.GridLibrary">
            <summary>
            Defines a <see cref="T:Sudoku.Concepts.Grid"/> library that stores in a file, using lines to describe puzzles.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="ignoreOption">Ignoring option.</param>
            <exception cref="T:System.ArgumentException">Throws when the specified file path is invalid or the file does not exist.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="ignoreOption"/> is not defined in enumeration type.
            </exception>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.#ctor(System.String,Sudoku.IO.GridLibraryIgnoringOption)">
            <summary>
            Defines a <see cref="T:Sudoku.Concepts.Grid"/> library that stores in a file, using lines to describe puzzles.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="ignoreOption">Ignoring option.</param>
            <exception cref="T:System.ArgumentException">Throws when the specified file path is invalid or the file does not exist.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="ignoreOption"/> is not defined in enumeration type.
            </exception>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.IO.GridLibrary.Solver">
            <summary>
            Indicates the solver to verify the puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.IO.GridLibrary.PuzzlesCount">
            <summary>
            Indicates the number of puzzles stored in this library.
            </summary>
        </member>
        <member name="P:Sudoku.IO.GridLibrary.FilePath">
            <summary>
            Indicates the file path.
            </summary>
        </member>
        <member name="P:Sudoku.IO.GridLibrary.IgnoringOption">
            <summary>
            Indicates the ignore option that will be used for ignoring on iteration of library file.
            </summary>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.Equals(Sudoku.IO.GridLibrary)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.GetAsyncEnumerator(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.FilterAsync(System.Func{Sudoku.Concepts.Grid,System.Threading.CancellationToken,System.Boolean},System.Action,System.Threading.CancellationToken)">
            <summary>
            Reads the library file, and then parses puzzles into <see cref="T:Sudoku.Concepts.Grid"/> instances, and finally filters
            <see cref="T:Sudoku.Concepts.Grid"/> instances when puzzles don't pass the verification.
            </summary>
            <param name="gridFilter">The grid filter.</param>
            <param name="failedCallback">Indicates the failed action.</param>
            <param name="cancellationToken">The cancellation token that is used for cancelling the asynchronous operation.</param>
            <returns>An <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/> instance that iterates on filtered <see cref="T:Sudoku.Concepts.Grid"/> instances.</returns>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.ToString">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.op_Equality(Sudoku.IO.GridLibrary,Sudoku.IO.GridLibrary)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.IO.GridLibrary.op_Inequality(Sudoku.IO.GridLibrary,Sudoku.IO.GridLibrary)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.IO.GridLibraryIgnoringOption">
            <summary>
            Indicates the option that will be used for ignoring <see cref="T:Sudoku.Concepts.Grid"/> puzzles in the target file.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.IO.GridLibraryIgnoringOption.Never">
            <summary>
            Indicates the puzzle will be never ignored.
            </summary>
        </member>
        <member name="F:Sudoku.IO.GridLibraryIgnoringOption.NotUnique">
            <summary>
            Indicates the puzzle will be ignored when it is not unique.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator">
            <summary>
            Represents a combination generator that iterations each combination of bits for the specified number of bits, and how many 1's in it.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents a combination generator that iterations each combination of bits for the specified number of bits, and how many 1's in it.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.Enumerator">
            <summary>
            Indicates the enumerator of the current instance.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.Enumerator.#ctor(System.Int32,System.Int32)">
            <summary>
            Indicates the enumerator of the current instance.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.Enumerator._mask">
            <summary>
            The mask.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.Enumerator._isLast">
            <summary>
            Indicates whether that the value is the last one.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskCombinationsGenerator.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.MaskOperations">
            <summary>
            Provides with a set of methods that operates with mask defined in basic sudoku concepts, as data structures.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToStatus(System.Int16)">
            <summary>
            To get the cell status for a mask value. The mask is an inner representation to describe a cell's state.
            For more information please visit the details of the design for type <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The mask.</param>
            <returns>The cell status.</returns>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.GetMaskSubsets(System.Int16)">
            <summary>
            Get all mask combinations.
            </summary>
            <param name="value">The mask.</param>
            <returns>The result list.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.GetMaskSubsets(System.Int16,System.Int32)">
            <summary>
            Get all mask combinations.
            </summary>
            <param name="value">The mask.</param>
            <param name="size">The size.</param>
            <returns>The result list.</returns>
        </member>
        <member name="T:Sudoku.SolutionWideReadOnlyFields">
            <summary>
            Provides with solution-wide read-only fields used.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.InvalidTrailingZeroCountMethodFallback">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L586">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.InvalidTrailingZeroCountMethodFallbackLong">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L647">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.AllRowsMask">
            <summary>
            Indicates the mask that means all rows.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.AllColumnsMask">
            <summary>
            Indicates the mask that means all columns.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.AllHousesMask">
            <summary>
            Indicates the mask that means all houses.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.HouseFirst">
            <summary>
            Indicates the first cell offset for each house.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.Peers">
            <summary>
            <para>Indicates a table for each cell's peers.</para>
            </summary>
            <example>
            '<c>Peers[0]</c>': the array of peers for the cell 0 (row 1 column 1).
            </example>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.HouseCells">
            <summary>
            <para>
            The map of all cell offsets in its specified house.
            The indices is between 0 and 26, where:
            <list type="table">
            <item>
            <term><c>0..9</c></term>
            <description>Block 1 to 9.</description>
            </item>
            <item>
            <term><c>9..18</c></term>
            <description>Row 1 to 9.</description>
            </item>
            <item>
            <term><c>18..27</c></term>
            <description>Column 1 to 9.</description>
            </item>
            </list>
            </para>
            </summary>
            <example>
            '<c>HouseCells[0]</c>': all cell offsets in the house 0 (block 1).
            </example>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.HousesMap">
            <summary>
            Indicates all grid maps that a grid contains.
            </summary>
            <example>
            '<c>HouseMaps[0]</c>': The map containing all cells in the block 1.
            </example>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.CellsMap">
            <summary>
            Indicates the map of length 81, indicating the <see cref="T:Sudoku.Concepts.CellMap"/> instances that only contain one cell.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.PeersMap">
            <summary>
            Indicates the peer maps using <see cref="F:Sudoku.SolutionWideReadOnlyFields.Peers"/> table.
            </summary>
            <seealso cref="F:Sudoku.SolutionWideReadOnlyFields.Peers"/>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.Chutes">
            <summary>
            Indicates the chute maps.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.HouseTypes">
            <summary>
            Indicates the possible house types to iterate.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.BlockTable">
            <summary>
            Indicates a block list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.RowTable">
            <summary>
            Indicates a row list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.ColumnTable">
            <summary>
            Indicates a column list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.Combinatorial">
            <summary>
            Indicates the combinatorial numbers from <c>C(1, 1)</c> to <c>C(30, 30)</c>.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionWideReadOnlyFields.ChuteHouses">
            <summary>
            Indicates the chute houses.
            </summary>
        </member>
        <member name="M:Sudoku.SolutionWideReadOnlyFields.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Text.Formatting.CellMapBinaryFormat">
            <summary>
            Defines a formatter that formats a <see cref="T:Sudoku.Concepts.CellMap"/>, converting into a <see cref="T:System.String"/> of a list of binary value
            to display all values.
            </summary>
            <param name="WithSeparator">
            <para>Indicates whether the formatter will emit a separator between two adjacent 27-bit chunks.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Text.Formatting.CellMapBinaryFormat.#ctor(System.Boolean)">
            <summary>
            Defines a formatter that formats a <see cref="T:Sudoku.Concepts.CellMap"/>, converting into a <see cref="T:System.String"/> of a list of binary value
            to display all values.
            </summary>
            <param name="WithSeparator">
            <para>Indicates whether the formatter will emit a separator between two adjacent 27-bit chunks.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
        </member>
        <member name="P:Sudoku.Text.Formatting.CellMapBinaryFormat.WithSeparator">
            <summary>
            <para>Indicates whether the formatter will emit a separator between two adjacent 27-bit chunks.</para>
            <para>The default value is <see langword="true"/>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.CellMapBinaryFormat.Default">
            <inheritdoc cref="P:Sudoku.Text.Formatting.ICellMapFormatter.Instance"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.CellMapBinaryFormat.Sudoku#Text#Formatting#ICellMapFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.CellMapBinaryFormat.ToString(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.CellMapFormatterFactory">
            <summary>
            Indicates the factory that creates the cell map formatter.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.CellMapFormatterFactory.GetBuiltInFormatter(System.String)">
            <summary>
            Get a built-in <see cref="T:Sudoku.Text.Formatting.ICellMapFormatter"/> instance according to the specified format.
            </summary>
            <param name="format">The format.</param>
            <returns>The grid formatter.</returns>
            <exception cref="T:System.FormatException">Throws when the format string is invalid.</exception>
        </member>
        <member name="T:Sudoku.Text.Formatting.CellMapTableFormat">
            <summary>
            Defines a formatter that formats a <see cref="T:Sudoku.Concepts.CellMap"/>, converting into a table <see cref="T:System.String"/> value to display all values.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.CellMapTableFormat.Default">
            <inheritdoc cref="P:Sudoku.Text.Formatting.ICellMapFormatter.Instance"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.CellMapTableFormat.Sudoku#Text#Formatting#ICellMapFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.CellMapTableFormat.ToString(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.ConclusionFormatter">
            <summary>
            Provides with a formatter that can format a list of <see cref="T:Sudoku.Analytics.Conclusion"/>s,
            represented as a <see cref="T:System.String"/> value.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.ConclusionFormatter.#ctor">
            <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="M:Sudoku.Text.Formatting.ConclusionFormatter.Format(Sudoku.Analytics.Conclusion[],System.String,System.Boolean)">
            <summary>
            Formats a list of conclusions as the string representation.
            </summary>
            <param name="conclusions">The list of conclusions to be formatted.</param>
            <param name="separator">The separator.</param>
            <param name="shouldSort">
            Indicates whether the list of conclusions should be sorted before formatting.
            </param>
            <returns>The <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.ConclusionFormatter.Format(Sudoku.Analytics.Conclusion[],Sudoku.Text.Formatting.FormattingMode)">
            <inheritdoc cref="M:Sudoku.Text.Formatting.ConclusionFormatter.Format(Sudoku.Analytics.Conclusion[],System.String,System.Boolean)"/>
            <param name="conclusions"><inheritdoc/></param>
            <param name="formattingMode">The formatting mode.</param>
            <returns><inheritdoc/></returns>
            <exception cref="T:System.NotSupportedException">
            Throws when the argument <paramref name="formattingMode"/> is <see cref="F:Sudoku.Text.Formatting.FormattingMode.Full"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="formattingMode"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Text.Formatting.ConclusionFormatter.Sudoku#Text#Formatting#ICollectionFormatter{Sudoku#Analytics#Conclusion}#Format(System.Collections.Generic.IEnumerable{Sudoku.Analytics.Conclusion},System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.ConclusionFormatter.Sudoku#Text#Formatting#ICollectionFormatter{Sudoku#Analytics#Conclusion}#Format(System.Collections.Generic.IEnumerable{Sudoku.Analytics.Conclusion},Sudoku.Text.Formatting.FormattingMode)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.DigitMaskFormatter">
            <summary>
            Provides with a formatter that can format a mask that represents for a list of digits.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.DigitMaskFormatter.#ctor">
            <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="M:Sudoku.Text.Formatting.DigitMaskFormatter.Format(System.Int16,System.String)">
            <summary>
            Gets a <see cref="T:System.String"/> value that can describes for a list of digits that is represented as a <see cref="T:System.Int16"/> mask.
            </summary>
            <param name="digitsMask">The digits mask.</param>
            <param name="separator">The separator used.</param>
            <returns>The <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.DigitMaskFormatter.Format(System.Int16,Sudoku.Text.Formatting.FormattingMode)">
            <inheritdoc cref="M:Sudoku.Text.Formatting.DigitMaskFormatter.Format(System.Int16,System.String)"/>
            <param name="digitsMask"><inheritdoc/></param>
            <param name="formattingMode">The formatting mode.</param>
            <returns><inheritdoc/></returns>
            <exception cref="T:System.NotSupportedException">
            Throws when the argument <paramref name="formattingMode"/> is <see cref="F:Sudoku.Text.Formatting.FormattingMode.Full"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="formattingMode"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Text.Formatting.DigitMaskFormatter.Sudoku#Text#Formatting#ICollectionFormatter{System#Int32}#Format(System.Collections.Generic.IEnumerable{System.Int32},System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.DigitMaskFormatter.Sudoku#Text#Formatting#ICollectionFormatter{System#Int32}#Format(System.Collections.Generic.IEnumerable{System.Int32},Sudoku.Text.Formatting.FormattingMode)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.ExcelFormat">
            <summary>
            Represents with Excel formatter.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.ExcelFormat.Tab">
            <summary>
            Indicates the tab character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.ExcelFormat.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.ExcelFormat.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.ExcelFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.ExcelFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.ExtendedFormatAttribute">
            <summary>
            Indicates the extended format.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.ExtendedFormatAttribute.#ctor(System.String)">
            <summary>
            Initializes an <see cref="T:Sudoku.Text.Formatting.ExtendedFormatAttribute"/> instance via the format.
            </summary>
            <param name="format">The format.</param>
        </member>
        <member name="P:Sudoku.Text.Formatting.ExtendedFormatAttribute.Format">
            <summary>
            Indicates the extended format.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Formatting.FormattingMode">
            <summary>
            Represents for a formatting mode (simple, normal or full). The modes will correspond to the methods
            <c>ToSimpleString</c>, <c>ToString</c> and <c>ToFullString</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.FormattingMode.Simple">
            <summary>
            Indicates the formatting mode is simple, which means the result string will be more simple
            that options <see cref="F:Sudoku.Text.Formatting.FormattingMode.Normal"/> or <see cref="F:Sudoku.Text.Formatting.FormattingMode.Full"/> behaves.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.FormattingMode.Normal">
            <summary>
            Indicates the formatting mode is normal, which means all important data will be displayed.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.FormattingMode.Full">
            <summary>
            Indicates the formatting mode is full, which means all possible data will be displayed.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Formatting.GridFormatterFactory">
            <summary>
            Indicates the factory that creates the grid formatter.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.GridFormatterFactory.GetBuiltInFormatter(System.String)">
            <summary>
            Get a built-in <see cref="T:Sudoku.Text.Formatting.IGridFormatter"/> instance according to the specified format.
            </summary>
            <param name="format">The format.</param>
            <returns>The grid formatter.</returns>
            <exception cref="T:System.FormatException">Throws when the format string is invalid.</exception>
        </member>
        <member name="T:Sudoku.Text.Formatting.GridMaskFormat">
            <summary>
            Represents with a grid mask formatter.
            </summary>
            <param name="Separator">
            <para>Indicates the mask separator.</para>
            <para>The default value is a comma followed by a space: <c>", "</c>.</para>
            </param>
            <remarks>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Formatting.GridMaskFormat.#ctor(System.String)">
            <summary>
            Represents with a grid mask formatter.
            </summary>
            <param name="Separator">
            <para>Indicates the mask separator.</para>
            <para>The default value is a comma followed by a space: <c>", "</c>.</para>
            </param>
            <remarks>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </remarks>
        </member>
        <member name="P:Sudoku.Text.Formatting.GridMaskFormat.Separator">
            <summary>
            <para>Indicates the mask separator.</para>
            <para>The default value is a comma followed by a space: <c>", "</c>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.GridMaskFormat.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.GridMaskFormat.Separator"/>: <c>", "</c></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.GridMaskFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.GridMaskFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.HodokuLibraryFormat">
            <summary>
            Provides with a formatter that allows a <see cref="T:Sudoku.Concepts.Grid"/> instance being formatted as Hodoku library format.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Text.Formatting.HodokuLibraryFormat.FormatPrefix">
            <summary>
            Indicates the format prefix.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.HodokuLibraryFormat.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.HodokuLibraryFormat.FormatSuffix">
            <summary>
            Indicates the format suffix.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.HodokuLibraryFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.HodokuLibraryFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.HouseFormatter">
            <summary>
            Provides with a formatter that can format a mask that represents for a list of houses.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.HouseFormatter.#ctor">
            <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="M:Sudoku.Text.Formatting.HouseFormatter.Format(System.Int32)">
            <summary>
            Gets a <see cref="T:System.String"/> value that can describes for a list of houses that is represented
            as an <see cref="T:System.Int32"/> mask.
            </summary>
            <param name="housesMask">The houses mask.</param>
            <returns>The <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.HouseFormatter.Format(System.Int32,Sudoku.Text.Formatting.FormattingMode)">
            <inheritdoc cref="M:Sudoku.Text.Formatting.HouseFormatter.Format(System.Int32)"/>
            <param name="houseMask"><inheritdoc/></param>
            <param name="formattingMode">The formatting mode.</param>
            <returns><inheritdoc/></returns>
            <exception cref="T:System.NotSupportedException">
            Throws when the argument <paramref name="formattingMode"/> is <see cref="F:Sudoku.Text.Formatting.FormattingMode.Full"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="formattingMode"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Text.Formatting.HouseFormatter.Format(System.ReadOnlySpan{System.Int32})">
            <summary>
            <para>
            Gets a <see cref="T:System.String"/> value that can describes for a list of houses that is represented
            as a <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Int32"/> elements.
            </para>
            <para>
            Although the argument <paramref name="houses"/> is of type <see cref="T:System.ReadOnlySpan`1"/>, you can still
            pass an array of <see cref="T:System.Int32"/> elements as the value.
            </para>
            </summary>
            <param name="houses">The houses.</param>
            <returns>The <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.HouseFormatter.Sudoku#Text#Formatting#ICollectionFormatter{System#Int32}#Format(System.Collections.Generic.IEnumerable{System.Int32},System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.HouseFormatter.Sudoku#Text#Formatting#ICollectionFormatter{System#Int32}#Format(System.Collections.Generic.IEnumerable{System.Int32},Sudoku.Text.Formatting.FormattingMode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.HouseFormatter.GetLabel(System.Int32)">
            <summary>
            Get the label of each house.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>The label.</returns>
        </member>
        <member name="T:Sudoku.Text.Formatting.ICandidateMapFormatter">
            <summary>
            Represents with a formatter type that formats and parses a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance,
            converting it into an equivalent <see cref="T:System.String"/> value.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.ICandidateMapFormatter.Instance">
            <inheritdoc cref="P:Sudoku.Text.Formatting.IGridFormatter.Instance"/>
        </member>
        <member name="M:Sudoku.Text.Formatting.ICandidateMapFormatter.ToString(Sudoku.Concepts.CandidateMap@)">
            <summary>
            Try to format a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance into the specified target-formatted <see cref="T:System.String"/> representation.
            </summary>
            <param name="candidateMap">A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance to be formatted.</param>
            <returns>A <see cref="T:System.String"/> representation as result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.ICandidateMapFormatter.System#IFormatProvider#GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.ICellMapFormatter">
            <summary>
            Represents with a formatter type that formats and parses a <see cref="T:Sudoku.Concepts.CellMap"/> instance,
            converting it into an equivalent <see cref="T:System.String"/> value.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.ICellMapFormatter.Instance">
            <inheritdoc cref="P:Sudoku.Text.Formatting.IGridFormatter.Instance"/>
        </member>
        <member name="M:Sudoku.Text.Formatting.ICellMapFormatter.ToString(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to format a <see cref="T:Sudoku.Concepts.CellMap"/> instance into the specified target-formatted <see cref="T:System.String"/> representation.
            </summary>
            <param name="cellMap">A <see cref="T:Sudoku.Concepts.CellMap"/> instance to be formatted.</param>
            <returns>A <see cref="T:System.String"/> representation as result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.ICellMapFormatter.System#IFormatProvider#GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.ICellMapFormatter.System#ICustomFormatter#Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.ICollectionFormatter`1">
            <summary>
            Defines a formatter that can create a <see cref="T:System.String"/> value representing the current instances
            of type <typeparamref name="TElement"/>.
            </summary>
            <typeparam name="TElement">The type of the elements in the collection.</typeparam>
        </member>
        <member name="M:Sudoku.Text.Formatting.ICollectionFormatter`1.Format(System.Collections.Generic.IEnumerable{`0},System.String)">
            <summary>
            Try to format a list of <typeparamref name="TElement"/> instances, split by <paramref name="separator"/>s
            between two adjacent elements.
            </summary>
            <param name="elements">The elements to be formatted.</param>
            <param name="separator">
            The separator that will be inserted into each two adjacent elements in this collection.
            </param>
            <returns>A <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.ICollectionFormatter`1.Format(System.Collections.Generic.IEnumerable{`0},Sudoku.Text.Formatting.FormattingMode)">
            <summary>
            Try to format a list of <typeparamref name="TElement"/> instances using the specified formatting mode.
            </summary>
            <param name="elements">The elements to be formatted.</param>
            <param name="formattingMode">
            The formatting mode. The default value is <see cref="F:Sudoku.Text.Formatting.FormattingMode.Simple"/>.
            </param>
            <returns>A <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="T:Sudoku.Text.Formatting.IGridFormatter">
            <summary>
            <para>
            Defines a grid formatter that can convert the current <see cref="T:Sudoku.Concepts.Grid"/> instance into a valid and parsable <see cref="T:System.String"/> text value
            representing this instance. This type is used as arguments being passed in method <see cref="M:Sudoku.Concepts.Grid.ToString(Sudoku.Text.Formatting.IGridFormatter)"/>.
            </para>
            <!--THE FOLLOWING COMMENT BLOCK IS TEMPORARILY DISABLED! THE TEXT ARE TOO LONG TO BE DISPLAYED ONTO TOOLTIP IN VISUAL STUDIO!-->
            <!--
            <para>
            The built-in derived types are:
            <list type="table">
            <listheader>
            <term>Formatter type</term>
            <description>Description about this type</description>
            </listheader>
            <item>
            <term><see cref="SusserFormat"/> (Recommend)</term>
            <description>
            Represents with a formatter using Susser formatting rule.
            </description>
            </item>
            <item>
            <term><see cref="SusserFormatTreatingValuesAsGivens"/></term>
            <description>
            Represents with a formatter using Susser formatting rule. Different with <see cref="SusserFormat"/>,
            this formatter will remove all modifiable tokens.
            </description>
            </item>
            <item>
            <term><see cref="SusserFormatEliminationsOnly"/></term>
            <description>
            Represents with a formatter using Susser formatting rule. Different with <see cref="SusserFormat"/>,
            this formatter only contains pre-eliminations. The so-called <b>pre-eliminations</b> means the eliminations
            that had already been eliminated before the current grid formed.
            </description>
            </item>
            <item>
            <term><see cref="PencilMarkFormat"/> (Recommend)</term>
            <description>
            Represents with a formatter using a multiple-line formatting rule, displaying candidates as a list of digits.
            This formatter is useful on globalized Sudoku BBS.
            </description>
            </item>
            <item>
            <term><see cref="HodokuLibraryFormat"/></term>
            <description>
            Represents with a formatter using Hodoku Library formatting rule.
            </description>
            </item>
            <item>
            <term><see cref="MultipleLineFormat"/></term>
            <description>
            Represents with a formatter using multiple-line formatting rule, without displaying candidates.
            </description>
            </item>
            <item>
            <term><see cref="SukakuFormat"/></term>
            <description>
            Represents with a formatter using Sukaku game formatting rule, treating all cells (no matter what kind of the cell it is) as candidate lists.
            </description>
            </item>
            <item>
            <term><see cref="GridMaskFormat"/></term>
            <description>
            Represents with a formatter using masks formatting rule, treating the current grid as 81 <see cref="short"/> masks
            as the inner raw value. For more information about the data structure of type <see cref="Grid"/>, please visit that type.
            </description>
            </item>
            <item>
            <term><see cref="ExcelFormat"/></term>
            <description>
            Represents with a formatter using Excel formatting rule, using multiple lines to distinct sudoku lines
            and using tab characters <c>'\t'</c> as separators inserted into a pair of adjacent cells.
            </description>
            </item>
            <item>
            <term><see cref="OpenSudokuFormat"/></term>
            <description>
            Represents with a formatter using OpenSudoku formatting rule, using a triplet to display the detail of a cell,
            separated by pipe operator <c>'|'</c>.
            </description>
            </item>
            </list>
            </para>
            -->
            <para>
            If you want to control the customized formatting on <see cref="T:Sudoku.Concepts.Grid"/> instances, this type will be very useful.
            For more information about this type and its derived (implemented) types, please visit the documentation comments
            of members <see cref="M:Sudoku.Concepts.Grid.ToString(Sudoku.Text.Formatting.IGridFormatter)"/> and <see cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>,
            specially for arguments in those members.
            </para>
            <para>
            In addition, you can also define your own formatter, by using this type, you can just implement this interface:
            <code><![CDATA[
            // We suggest you use record types instead of classes, in order to define a default-implemented type by compiler.
            // In addition, using record types can also help you define more properties, especially for initialization-only properties,
            // by adding your own properties followed by the type name, just like defining a parameter list:
            //
            //     public sealed record Record(int Property1, double Property2, string Property3);
            //                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            //                                         Initialization-only Properties
            //
            // This syntax feature is called "Record", introduced by C# 9; such properties are called "Initialization-only Properties"
            // (or "Init-only Properties" as its abbreviation), introduced by C# 9.
            public sealed record CustomFormatter : IGridFormatter // Implements this interface type.
            {
                // Define a singleton instance that is the only way to visit the type.
                public static readonly CustomFormatter Default = new();
            
                // Hides the interface implementation by using explicit interface implementation of static members.
                // This kind of usage is based on a new C# syntax feature called "DIM of Static Members", introduced by C# 11.
                static IGridFormatter IGridFormatter.Instance => Default;
            
                // Here we should implement this method, as the default way to create a string representation describing the grid.
                // Keyword 'scoped' is limited the reference only being scoped inside the method, which means you cannot
                // assign the reference (no matter whether the reference is read-only or not) outside the method, e.g. as return value,
                // or assigning it to the field if the type is a ref struct.
                // This kind of usage is based on a new C# syntax feature called "Ref Fields and Scoping", introduced by C# 11.
                public string ToString(scoped in Grid grid)
                {
                    // Define your own logic here.
                }
            }
            ]]></code>
            </para>
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
            <seealso cref="M:Sudoku.Concepts.Grid.ToString(Sudoku.Text.Formatting.IGridFormatter)"/>
            <seealso cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.IGridFormatter.Instance">
            <summary>
            Indicates the singleton instance.
            </summary>
            <remarks>
            The main idea of this property is to tell you the implementation type should disallow
            users calling parameterless constructors. Although C# does not restrict with it, you should disallow it,
            in order to provide users with better utility experience.
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Formatting.IGridFormatter.ToString(Sudoku.Concepts.Grid@)">
            <summary>
            Try to format a <see cref="T:Sudoku.Concepts.Grid"/> instance into the specified target-formatted <see cref="T:System.String"/> representation.
            </summary>
            <param name="grid">A <see cref="T:Sudoku.Concepts.Grid"/> instance to be formatted.</param>
            <returns>A <see cref="T:System.String"/> representation as result.</returns>
        </member>
        <member name="M:Sudoku.Text.Formatting.IGridFormatter.System#IFormatProvider#GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.IGridFormatter.System#ICustomFormatter#Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.K9Format">
            <summary>
            Defines a formatter that uses <b>K9</b> rule to format a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <remarks>
            <inheritdoc cref="T:Sudoku.Text.Notations.K9Notation" path="/remarks"/>
            </remarks>
        </member>
        <member name="F:Sudoku.Text.Formatting.K9Format.Default">
            <inheritdoc cref="P:Sudoku.Text.Formatting.ICellMapFormatter.Instance"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.K9Format.Sudoku#Text#Formatting#ICellMapFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Formatting.K9Format.Sudoku#Text#Formatting#ICandidateMapFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.K9Format.ToString(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.K9Format.ToString(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.K9Format.System#IFormatProvider#GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.MultipleLineFormat">
            <summary>
            Represents with a multiple-line formatter.
            </summary>
            <param name="SubtleGridLines"><inheritdoc cref="P:Sudoku.Text.Formatting.PencilMarkFormat.SubtleGridLines" path="/summary"/></param>
            <param name="TreatValueAsGiven"><inheritdoc cref="P:Sudoku.Text.Formatting.PencilMarkFormat.TreatValueAsGiven" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Text.Formatting.MultipleLineFormat.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Represents with a multiple-line formatter.
            </summary>
            <param name="SubtleGridLines"><inheritdoc cref="P:Sudoku.Text.Formatting.PencilMarkFormat.SubtleGridLines" path="/summary"/></param>
            <param name="TreatValueAsGiven"><inheritdoc cref="P:Sudoku.Text.Formatting.PencilMarkFormat.TreatValueAsGiven" path="/summary"/></param>
        </member>
        <member name="P:Sudoku.Text.Formatting.MultipleLineFormat.SubtleGridLines">
            <summary><inheritdoc cref="P:Sudoku.Text.Formatting.PencilMarkFormat.SubtleGridLines" path="/summary"/></summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.MultipleLineFormat.TreatValueAsGiven">
            <summary><inheritdoc cref="P:Sudoku.Text.Formatting.PencilMarkFormat.TreatValueAsGiven" path="/summary"/></summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.MultipleLineFormat.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.MultipleLineFormat.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.MultipleLineFormat.Default">
            <summary>
            Indicates the default instance. The property set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.MultipleLineFormat.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Formatting.MultipleLineFormat.SubtleGridLines"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.MultipleLineFormat.TreatValueAsGiven"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.MultipleLineFormat.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Text.Formatting.MultipleLineFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.MultipleLineFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Text.Formatting.MultipleLineFormat._placeholder">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Text.Formatting.MultipleLineFormat.Placeholder"/>.
            </summary>
            <seealso cref="P:Sudoku.Text.Formatting.MultipleLineFormat.Placeholder"/>
        </member>
        <member name="T:Sudoku.Text.Formatting.OpenSudokuFormat">
            <summary>
            Represents with OpenSudoku formatter.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.OpenSudokuFormat.Terminator">
            <summary>
            Indicates the string terminator character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.OpenSudokuFormat.Separator">
            <summary>
            Indicates the separator character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.OpenSudokuFormat.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.OpenSudokuFormat.One">
            <summary>
            Indicates the one character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.OpenSudokuFormat.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.OpenSudokuFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.OpenSudokuFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.PencilMarkFormat">
            <summary>
            Represents with a pencil-marked formatter.
            </summary>
            <param name="SubtleGridLines">
            <para>Indicates whether need to handle all grid outlines while outputting.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="TreatValueAsGiven">
            <para>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>' instead
            of '<c>*digit*</c>'.
            </para>
            <para>
            The value has 3 possible cases:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The formatter will treat all value cells as given one, no matter what kind of value cell it is, given or modifiable.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The formatter will tell with givens and modifiables.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            The formatter will <b>not</b> check its value states. It will be displayed and handled as candidate cells,
            using a single digit to display the cell.
            </description>
            </item>
            </list>
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Text.Formatting.PencilMarkFormat.#ctor(System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Represents with a pencil-marked formatter.
            </summary>
            <param name="SubtleGridLines">
            <para>Indicates whether need to handle all grid outlines while outputting.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="TreatValueAsGiven">
            <para>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>' instead
            of '<c>*digit*</c>'.
            </para>
            <para>
            The value has 3 possible cases:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The formatter will treat all value cells as given one, no matter what kind of value cell it is, given or modifiable.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The formatter will tell with givens and modifiables.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            The formatter will <b>not</b> check its value states. It will be displayed and handled as candidate cells,
            using a single digit to display the cell.
            </description>
            </item>
            </list>
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="P:Sudoku.Text.Formatting.PencilMarkFormat.SubtleGridLines">
            <summary>
            <para>Indicates whether need to handle all grid outlines while outputting.</para>
            <para>The default value is <see langword="true"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.PencilMarkFormat.TreatValueAsGiven">
            <summary>
            <para>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>' instead
            of '<c>*digit*</c>'.
            </para>
            <para>
            The value has 3 possible cases:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The formatter will treat all value cells as given one, no matter what kind of value cell it is, given or modifiable.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The formatter will tell with givens and modifiables.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            The formatter will <b>not</b> check its value states. It will be displayed and handled as candidate cells,
            using a single digit to display the cell.
            </description>
            </item>
            </list>
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.PencilMarkFormat.Default">
            <summary>
            Indicates the default instance. The property set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.PencilMarkFormat.SubtleGridLines"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.PencilMarkFormat.TreatValueAsGiven"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.PencilMarkFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.PencilMarkFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.PencilMarkFormat.DefaultPrinting(System.Text.StringHandler@,System.Collections.Generic.IList{System.Int16},System.Char,System.Char,System.Int32*)">
            <summary>
            Default printing method.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.PencilMarkFormat.PrintValues(System.Text.StringHandler@,System.Collections.Generic.IList{System.Int16},System.Int32,System.Int32,System.Int32*)">
            <summary>
            Print values.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.PencilMarkFormat.PrintTabLines(System.Text.StringHandler@,System.Char,System.Char,System.Char,System.Int32*)">
            <summary>
            Print tab lines.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.PencilMarkFormat.CreateTempDictionary">
            <summary>
            Creates a dictionary.
            </summary>
            <returns>The dictionary instance.</returns>
        </member>
        <member name="T:Sudoku.Text.Formatting.RxCyFormat">
            <summary>
            Defines a formatter that uses <b>RxCy</b> rule to format a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <remarks>
            <inheritdoc cref="T:Sudoku.Text.Notations.RxCyNotation" path="/remarks"/>
            </remarks>
        </member>
        <member name="F:Sudoku.Text.Formatting.RxCyFormat.Default">
            <inheritdoc cref="P:Sudoku.Text.Formatting.ICellMapFormatter.Instance"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.RxCyFormat.Sudoku#Text#Formatting#ICellMapFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Formatting.RxCyFormat.Sudoku#Text#Formatting#ICandidateMapFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.RxCyFormat.ToString(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.RxCyFormat.ToString(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.RxCyFormat.System#IFormatProvider#GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.SukakuFormat">
            <summary>
            Defines a Sukaku format.
            </summary>
            <param name="Multiline">
            <para>Indicates whether the output should be multi-line.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Text.Formatting.SukakuFormat.#ctor(System.Boolean)">
            <summary>
            Defines a Sukaku format.
            </summary>
            <param name="Multiline">
            <para>Indicates whether the output should be multi-line.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="P:Sudoku.Text.Formatting.SukakuFormat.Multiline">
            <summary>
            <para>Indicates whether the output should be multi-line.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SukakuFormat.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SukakuFormat.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SukakuFormat.Default">
            <summary>
            Indicates the default instance. The property set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.SukakuFormat.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Formatting.SukakuFormat.Multiline"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.SukakuFormat.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Text.Formatting.SukakuFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.SukakuFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Text.Formatting.SukakuFormat._placeholder">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Text.Formatting.SukakuFormat.Placeholder"/>.
            </summary>
            <seealso cref="P:Sudoku.Text.Formatting.SukakuFormat.Placeholder"/>
        </member>
        <member name="T:Sudoku.Text.Formatting.SusserFormat">
            <summary>
            Provides with a formatter that allows a <see cref="T:Sudoku.Concepts.Grid"/> instance being formatted as Susser format.
            </summary>
            <param name="WithCandidates">
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="WithModifiables">
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="ShortenSusser">
            <para>Indicates whether the formatter will shorten the final text.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Text.Formatting.SusserFormat.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Provides with a formatter that allows a <see cref="T:Sudoku.Concepts.Grid"/> instance being formatted as Susser format.
            </summary>
            <param name="WithCandidates">
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="WithModifiables">
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="ShortenSusser">
            <para>Indicates whether the formatter will shorten the final text.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="P:Sudoku.Text.Formatting.SusserFormat.WithCandidates">
            <summary>
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.SusserFormat.WithModifiables">
            <summary>
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.SusserFormat.ShortenSusser">
            <summary>
            <para>Indicates whether the formatter will shorten the final text.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.ModifiablePrefix">
            <summary>
            Indicates the modifiable prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.LineLimit">
            <summary>
            Indicates the line limitator character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.Star">
            <summary>
            Indicates the star character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.PreeliminationPrefix">
            <summary>
            Indicates the pre-elimination prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.Default">
            <summary>
            Indicates the default instance. The property set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithCandidates"/>: <see langword="false"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithModifiables"/>: <see langword="false"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.Full">
            <summary>
            Indicates the instance whose inner properties are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithCandidates"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat.FullZero">
            <summary>
            Indicates the instance whose inner properties are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.Placeholder"/>: <c>'0'</c></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithCandidates"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.SusserFormat.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Text.Formatting.SusserFormat.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.SusserFormat.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormat._placeholder">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Text.Formatting.SusserFormat.Placeholder"/>.
            </summary>
            <seealso cref="P:Sudoku.Text.Formatting.SusserFormat.Placeholder"/>
        </member>
        <member name="T:Sudoku.Text.Formatting.MatchLengthComparer">
            <summary>
            Represents a comparer instance that compares two <see cref="T:System.Text.RegularExpressions.Match"/> instances via their length.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.Match"/>
        </member>
        <member name="F:Sudoku.Text.Formatting.MatchLengthComparer.Instance">
            <summary>
            The singleton instance.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.MatchLengthComparer.#ctor">
            <summary>
            Initializes a <see cref="T:Sudoku.Text.Formatting.MatchLengthComparer"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Formatting.MatchLengthComparer.Equals(System.Text.RegularExpressions.Match,System.Text.RegularExpressions.Match)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.MatchLengthComparer.GetHashCode(System.Text.RegularExpressions.Match)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Formatting.SusserFormatEliminationsOnly">
            <summary>
            Represents with a Susser format, but only extracts for pre-eliminations.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormatEliminationsOnly.Default">
            <summary>
            Indicates the default instance. The property set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithCandidates"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.SusserFormatEliminationsOnly.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.SusserFormatEliminationsOnly.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.SusserFormatEliminationsOnly.EliminationPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Zero-width positive lookbehind.<br/>
                ○ Match ':' right-to-left.<br/>
            ○ Loop greedily any number of times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
                    ○ Match a whitespace character atomically at least once.<br/>
            ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Formatting.SusserFormatTreatingValuesAsGivens">
            <summary>
            Represents with a Susser formatter, removing all plus mark <c>'+'</c> as modifiable distinction tokens.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Formatting.SusserFormatTreatingValuesAsGivens.Default">
            <summary>
            Indicates the default instance. The property set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.WithCandidates"/>: <see langword="false"/></item>
            <item><see cref="P:Sudoku.Text.Formatting.SusserFormat.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Formatting.SusserFormatTreatingValuesAsGivens.Sudoku#Text#Formatting#IGridFormatter#Instance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Formatting.SusserFormatTreatingValuesAsGivens.ToString(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Notations.CandidateNotation">
            <summary>
            Represents a notation kind that describe a candidate list.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Notations.CandidateNotation.RxCy">
            <summary>
            Indicates the notation kind is <b>RxCy</b>.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Notations.CandidateNotation.K9">
            <summary>
            Indicates the notation kind is <b>K9</b>.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Notations.CandidateNotation.SusserElimination">
            <summary>
            Indicates the notation kind is <b>Susser Elimination Format</b>.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Notations.CellNotation">
            <summary>
            Represents a notation kind that describe a cell list.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Notations.CellNotation.RxCy">
            <summary>
            Indicates the notation kind is <b>RxCy</b>.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Notations.CellNotation.K9">
            <summary>
            Indicates the notation kind is <b>K9</b>.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Notations.EliminationNotation">
            <summary>
            Encapsulates a set of methods that handles a variety of instances, using Hodoku elimination notation
            to output the <see cref="T:System.String"/> representation, or parse a <see cref="T:System.String"/> value to convert
            it to the suitable-typed instance.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.EliminationNotation.CandidateNotation">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.EliminationNotation.TryParseCandidates(System.String,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.EliminationNotation.ToCandidatesString(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.EliminationNotation.ToCandidatesString(Sudoku.Concepts.CandidateMap@,Sudoku.Text.Notations.EliminationNotationOptions@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.EliminationNotation.ParseCandidates(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Notations.EliminationNotationOptions">
            <summary>
            Provides with a type that is used for displaying a cell list, using hodoku elimination notation.
            </summary>
            <param name="DigitFirst">
            <para>Indicates whether the output string will put the digit at first.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="Separator">
            <para>Indicates the separator that is used for the insertion between 2 adjacent candidate elements.</para>
            <para>The default value is <c>" "</c>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Text.Notations.EliminationNotationOptions.#ctor(System.Boolean,System.String)">
            <summary>
            Provides with a type that is used for displaying a cell list, using hodoku elimination notation.
            </summary>
            <param name="DigitFirst">
            <para>Indicates whether the output string will put the digit at first.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="Separator">
            <para>Indicates the separator that is used for the insertion between 2 adjacent candidate elements.</para>
            <para>The default value is <c>" "</c>.</para>
            </param>
        </member>
        <member name="P:Sudoku.Text.Notations.EliminationNotationOptions.DigitFirst">
            <summary>
            <para>Indicates whether the output string will put the digit at first.</para>
            <para>The default value is <see langword="true"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.EliminationNotationOptions.Separator">
            <summary>
            <para>Indicates the separator that is used for the insertion between 2 adjacent candidate elements.</para>
            <para>The default value is <c>" "</c>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.EliminationNotationOptions.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Notations.ICandidateNotation`2">
            <summary>
            Defines a type that can convert a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance into a result <see cref="T:System.String"/>
            representation to describe the candidate collection.
            </summary>
            <typeparam name="TSelf">The base type that applies the interface.</typeparam>
            <typeparam name="TOptions">The type that is used as the provider for extra options.</typeparam>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Text.Notations.ICandidateNotation`2.CandidateNotation">
            <summary>
            Indicates the candidate notation kind that the current type supports.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Notations.ICandidateNotation`2.TryParseCandidates(System.String,Sudoku.Concepts.CandidateMap@)">
            <summary>
            <para>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </para>
            <para>
            Different with the method <see cref="M:Sudoku.Text.Notations.ICandidateNotation`2.ParseCandidates(System.String)"/>, the method will return a
            <see cref="T:System.Boolean"/> value instead, indicating whether the operation is successful. Therefore,
            the method won't throw <see cref="T:System.FormatException"/>.
            </para>
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <param name="result">
            The <see cref="T:Sudoku.Concepts.CandidateMap"/> result. If the return value is <see langword="false"/>,
            this argument will be a discard and cannot be used.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the parsing operation is successful.</returns>
            <seealso cref="M:Sudoku.Text.Notations.ICandidateNotation`2.ParseCandidates(System.String)"/>
        </member>
        <member name="M:Sudoku.Text.Notations.ICandidateNotation`2.ToCandidatesString(Sudoku.Concepts.CandidateMap@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of candidates.
            </summary>
            <param name="candidates">The candidate list.</param>
            <returns>The <see cref="T:System.String"/> representation describe the candidate list.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.ICandidateNotation`2.ToCandidatesString(Sudoku.Concepts.CandidateMap@,`1@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of candidates.
            </summary>
            <param name="candidates">The candidates list.</param>
            <param name="options">The extra options to control the output style.</param>
            <returns>The <see cref="T:System.String"/> representation describe the candidate list.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.ICandidateNotation`2.ParseCandidates(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.CandidateMap"/>
            instance.
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <returns>The <see cref="T:Sudoku.Concepts.CandidateMap"/> result.</returns>
            <exception cref="T:System.FormatException">
            Throws when the parsing operation is failed due to invalid characters or invalid operation.
            </exception>
        </member>
        <member name="T:Sudoku.Text.Notations.ICellNotation`2">
            <summary>
            Defines a type that can convert a <see cref="T:Sudoku.Concepts.CellMap"/> instance into a result <see cref="T:System.String"/>
            representation to describe the cell collection.
            </summary>
            <typeparam name="TSelf">The base type that applies the interface.</typeparam>
            <typeparam name="TOptions">The type that is used as the provider for extra options.</typeparam>
        </member>
        <member name="P:Sudoku.Text.Notations.ICellNotation`2.CellNotation">
            <summary>
            Indicates the cell notation kind that the current type supports.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Notations.ICellNotation`2.TryParseCells(System.String,Sudoku.Concepts.CellMap@)">
            <summary>
            <para>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.CellMap"/>
            instance.
            </para>
            <para>
            Different with the method <see cref="M:Sudoku.Text.Notations.ICellNotation`2.ParseCells(System.String)"/>, the method will return a
            <see cref="T:System.Boolean"/> value instead, indicating whether the operation is successful. Therefore,
            the method won't throw <see cref="T:System.FormatException"/>.
            </para>
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <param name="result">
            The <see cref="T:Sudoku.Concepts.CellMap"/> result. If the return value is <see langword="false"/>,
            this argument will be a discard and cannot be used.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the parsing operation is successful.</returns>
            <seealso cref="M:Sudoku.Text.Notations.ICellNotation`2.ParseCells(System.String)"/>
        </member>
        <member name="M:Sudoku.Text.Notations.ICellNotation`2.ToCellsString(Sudoku.Concepts.CellMap@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of cells.
            </summary>
            <param name="cells">The cell list.</param>
            <returns>The <see cref="T:System.String"/> representation describe the cell list.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.ICellNotation`2.ToCellsString(Sudoku.Concepts.CellMap@,`1@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of cells.
            </summary>
            <param name="cells">The cell list.</param>
            <param name="options">The extra options to control the output style.</param>
            <returns>The <see cref="T:System.String"/> representation describe the cell list.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.ICellNotation`2.ParseCells(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.CellMap"/>
            instance.
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <returns>The <see cref="T:Sudoku.Concepts.CellMap"/> result.</returns>
            <exception cref="T:System.FormatException">
            Throws when the parsing operation is failed due to invalid characters or invalid operation.
            </exception>
        </member>
        <member name="T:Sudoku.Text.Notations.INotationOptions`1">
            <summary>
            Defines a type that provides the extra options that is used by
            <see cref="T:Sudoku.Text.Notations.ICellNotation`2"/> or <see cref="T:Sudoku.Text.Notations.ICandidateNotation`2"/> instances.
            </summary>
            <typeparam name="TSelf">The type of the handler.</typeparam>
            <seealso cref="T:Sudoku.Text.Notations.ICellNotation`2"/>
            <seealso cref="T:Sudoku.Text.Notations.ICandidateNotation`2"/>
        </member>
        <member name="P:Sudoku.Text.Notations.INotationOptions`1.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Notations.K9Notation">
            <summary>
            Encapsulates a set of methods that handles a variety of instances, using K9 notation
            to output the <see cref="T:System.String"/> representation, or parse a <see cref="T:System.String"/> value to convert
            it to the suitable-typed instance.
            </summary>
            <remarks>
            <para>
            The <b>K9 notation</b> is a notation to describe a set of cells that uses letters
            A, B, C, D, E, F, G, H and K to describe the row, and uses digits 1 to 9 to describe the column.
            For example, <c>C8</c> means the cell at row 3 and column 8.
            The letter I and J aren't used in this notation because they are confusing with digit 1.
            However, they can also be used in Chinese notations, for example, <c>K8</c> in traditional notation
            is same as <c>I8</c> in Chinese K9 notation rule.
            </para>
            <para>
            For more information about this concept, please visit
            <see href="http://sudopedia.enjoysudoku.com/K9.html">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="F:Sudoku.Text.Notations.K9Notation.Letters">
            <summary>
            Indicates all possible letters that used in the row notation.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.K9Notation.CellNotation">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.K9Notation.ToCellsString(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.K9Notation.ToCellsString(Sudoku.Concepts.CellMap@,Sudoku.Text.Notations.K9NotationOptions@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.K9Notation.ParseCell(System.String)">
            <summary>
            Try to parse the string and convert it into a single cell index.
            </summary>
            <param name="str">The string.</param>
            <returns>The valid cell index.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.K9Notation.ParseCells(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.K9Notation.TryParseCell(System.String,System.Int32@)">
            <inheritdoc cref="M:Sudoku.Text.Notations.RxCyNotation.TryParseCell(System.String,System.Int32@)"/>
        </member>
        <member name="M:Sudoku.Text.Notations.K9Notation.TryParseCells(System.String,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.K9Notation.CellOrCellListPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a character in the set [A-IKa-ik] atomically at least 1 and at most 9 times.<br/>
            ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Notations.K9NotationOptions">
            <summary>
            Provides with a type that is used for displaying a cell list, using K9 notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether the method should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the concept "row 3 column 3" will be displayed
            as <c>C3</c>; otherwise, <c>c3</c>.
            </param>
            <param name="AvoidConfusionOnRowLetters">
            Indicates whether the method should avoid confusion for the letter I and digit 1. For example,
            if <see langword="true"/>, row 9 column 9 will be notated as <c>K9</c>; otherwise, <c>I9</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>C1</c> and <c>D2</c> can be combined to <c>C1, D2</c> if the separator
            is <c>", "</c>.
            </param>
        </member>
        <member name="M:Sudoku.Text.Notations.K9NotationOptions.#ctor(System.Boolean,System.Boolean,System.String)">
            <summary>
            Provides with a type that is used for displaying a cell list, using K9 notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether the method should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the concept "row 3 column 3" will be displayed
            as <c>C3</c>; otherwise, <c>c3</c>.
            </param>
            <param name="AvoidConfusionOnRowLetters">
            Indicates whether the method should avoid confusion for the letter I and digit 1. For example,
            if <see langword="true"/>, row 9 column 9 will be notated as <c>K9</c>; otherwise, <c>I9</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>C1</c> and <c>D2</c> can be combined to <c>C1, D2</c> if the separator
            is <c>", "</c>.
            </param>
        </member>
        <member name="P:Sudoku.Text.Notations.K9NotationOptions.UpperCasing">
            <summary>
            Indicates whether the method should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the concept "row 3 column 3" will be displayed
            as <c>C3</c>; otherwise, <c>c3</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.K9NotationOptions.AvoidConfusionOnRowLetters">
            <summary>
            Indicates whether the method should avoid confusion for the letter I and digit 1. For example,
            if <see langword="true"/>, row 9 column 9 will be notated as <c>K9</c>; otherwise, <c>I9</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.K9NotationOptions.Separator">
            <summary>
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>C1</c> and <c>D2</c> can be combined to <c>C1, D2</c> if the separator
            is <c>", "</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.K9NotationOptions.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Notations.RxCyNotation">
            <summary>
            Encapsulates a set of methods that handles a variety of instances, using RxCy notation
            to output the <see cref="T:System.String"/> representation, or parse a <see cref="T:System.String"/> value to convert
            it to the suitable-typed instance.
            </summary>
            <remarks>
            <para>
            The <b>RxCy notation</b> is a notation to describe a set of cells that uses letter
            <c>R</c> (or its lower case <c>r</c>) to describe a row label, and uses the other letter
            <c>C</c> (or its lower case <c>c</c>) to describe a column label. For example,
            <c>R4C2</c> means the cell at row 4 and column 2.
            </para>
            <para>
            For more information about this concept, please visit
            <see href="http://sudopedia.enjoysudoku.com/Rncn.html">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Sudoku.Text.Notations.RxCyNotation.CellNotation">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Notations.RxCyNotation.CandidateNotation">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.TryParseCell(System.String,System.Int32@)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:System.Int32"/>
            instance, as the cell value.
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <param name="result">
            The <see cref="T:System.Int32"/> result. If the return value is <see langword="false"/>,
            this argument will be a discard and cannot be used.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the parsing operation is successful.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.TryParseCells(System.String,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ToCellString(System.Int32)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The <see cref="T:System.String"/> representation of a cell.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ToCellsString(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ToCellsString(Sudoku.Concepts.CellMap@,Sudoku.Text.Notations.RxCyNotationOptions@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ParseCells(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.TryParseCandidates(System.String,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ToCandidateString(System.Int32)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a candidate.
            </summary>
            <param name="candidate">The candidate.</param>
            <returns>The <see cref="T:System.String"/> representation of a candidate.</returns>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ToCandidatesString(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ToCandidatesString(Sudoku.Concepts.CandidateMap@,Sudoku.Text.Notations.RxCyNotationOptions@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ParseCandidates(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.CellOrCellListPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'R'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'C'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'r'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'c'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.ComplexCellOrCellListPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match '{'.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'R'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'C'.<br/>
                        ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'r'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'c'.<br/>
                        ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
            ○ Optional (greedy).<br/>
                ○ 2nd capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a whitespace character atomically any number of times.<br/>
                    ○ 3rd capture group.<br/>
                        ○ Match with 2 alternative expressions.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match 'R'.<br/>
                                ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                                ○ Match 'C'.<br/>
                                ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match 'r'.<br/>
                                ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                                ○ Match 'c'.<br/>
                                ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match '}'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.Candidates_PrepositionalFormPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'R'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'C'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'r'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'c'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.Candidates_PostpositionalFormPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'R'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'C'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'r'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'c'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            ○ Match '('.<br/>
            ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            ○ Match ')'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.Candidates_ComplexPrepositionalFormPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            ○ Match '{'.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'R'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'C'.<br/>
                        ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'r'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'c'.<br/>
                        ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
            ○ Optional (greedy).<br/>
                ○ 2nd capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a whitespace character atomically any number of times.<br/>
                    ○ 3rd capture group.<br/>
                        ○ Match with 2 alternative expressions.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match 'R'.<br/>
                                ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                                ○ Match 'C'.<br/>
                                ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match 'r'.<br/>
                                ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                                ○ Match 'c'.<br/>
                                ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match '}'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotation.Candidates_ComplexPostpositionalFormPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match '{'.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'R'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'C'.<br/>
                        ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match 'r'.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match 'c'.<br/>
                        ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
            ○ Optional (greedy).<br/>
                ○ 2nd capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a whitespace character atomically any number of times.<br/>
                    ○ 3rd capture group.<br/>
                        ○ Match with 2 alternative expressions.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match 'R'.<br/>
                                ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                                ○ Match 'C'.<br/>
                                ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
                            ○ Match a sequence of expressions.<br/>
                                ○ Match 'r'.<br/>
                                ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                                ○ Match 'c'.<br/>
                                ○ Match a character in the set [1-9] greedily at least 1 and at most 9 times.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "}(".<br/>
            ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
            ○ Match ')'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Notations.RxCyNotationOptions">
            <summary>
            Provides with a type that is used for displaying a cell list, using RxCy notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether we should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the cell at row 3 and column 3 will be displayed
            as <c>R3C3</c>; otherwise, <c>r3c3</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>R3C1</c> and <c>R4C2</c> can be combined to <c>R3C1, R4C2</c> if the separator
            is <c>", "</c>.
            </param>
        </member>
        <member name="M:Sudoku.Text.Notations.RxCyNotationOptions.#ctor(System.Boolean,System.String)">
            <summary>
            Provides with a type that is used for displaying a cell list, using RxCy notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether we should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the cell at row 3 and column 3 will be displayed
            as <c>R3C3</c>; otherwise, <c>r3c3</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>R3C1</c> and <c>R4C2</c> can be combined to <c>R3C1, R4C2</c> if the separator
            is <c>", "</c>.
            </param>
        </member>
        <member name="P:Sudoku.Text.Notations.RxCyNotationOptions.UpperCasing">
            <summary>
            Indicates whether we should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the cell at row 3 and column 3 will be displayed
            as <c>R3C3</c>; otherwise, <c>r3c3</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.RxCyNotationOptions.Separator">
            <summary>
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>R3C1</c> and <c>R4C2</c> can be combined to <c>R3C1, R4C2</c> if the separator
            is <c>", "</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Notations.RxCyNotationOptions.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Parsing.CellRange">
            <summary>
            Defines a range of cells.
            </summary>
            <param name="mask">Indicates the mask.</param>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.#ctor(System.Int16)">
            <summary>
            Defines a range of cells.
            </summary>
            <param name="mask">Indicates the mask.</param>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Text.Parsing.CellRange"/> instance via the specified value controlling the range.
            </summary>
            <param name="min">The minimum value.</param>
            <param name="max">The maximum value.</param>
            <exception cref="T:System.ArgumentException">
            Throws when:
            <list type="bullet">
            <item>The argument <paramref name="min"/> is greater than <paramref name="max"/>.</item>
            <item>The argument <paramref name="min"/> is below than 0 or greater than 80.</item>
            <item>The argument <paramref name="max"/> is below than 0 or greater than 81.</item>
            </list>
            </exception>
        </member>
        <member name="P:Sudoku.Text.Parsing.CellRange.MinValue">
            <summary>
            Indicates the minimum value.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsing.CellRange.MaxValue">
            <summary>
            Indicates the maximum value.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.Equals(Sudoku.Text.Parsing.CellRange)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.TryParse(System.String,Sudoku.Text.Parsing.CellRange@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.op_Explicit(System.Range)~Sudoku.Text.Parsing.CellRange">
            <summary>
            Implicitly cast from <see cref="T:System.Range"/> to <see cref="T:Sudoku.Text.Parsing.CellRange"/>.
            </summary>
            <param name="range">The range instance.</param>
        </member>
        <member name="F:Sudoku.Text.Parsing.CellRange._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.op_Equality(Sudoku.Text.Parsing.CellRange,Sudoku.Text.Parsing.CellRange)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.CellRange.op_Inequality(Sudoku.Text.Parsing.CellRange,Sudoku.Text.Parsing.CellRange)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Text.Parsing.GridParser">
            <summary>
            Encapsulates a grid parser that can parse a string value and convert it
            into a valid <see cref="T:Sudoku.Concepts.Grid"/> instance as the result.
            </summary>
            <param name="parsingValue">Indicates a string to be parsed.</param>
            <param name="compatibleFirst">
            Indicates whether the parser will change the execution order of PM grid.
            If the value is <see langword="true"/>, the parser will check compatible one
            first, and then check recommended parsing plan ('<c><![CDATA[<d>]]></c>' and '<c>*d*</c>').
            </param>
            <param name="shortenSusser">
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </param>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Encapsulates a grid parser that can parse a string value and convert it
            into a valid <see cref="T:Sudoku.Concepts.Grid"/> instance as the result.
            </summary>
            <param name="parsingValue">Indicates a string to be parsed.</param>
            <param name="compatibleFirst">
            Indicates whether the parser will change the execution order of PM grid.
            If the value is <see langword="true"/>, the parser will check compatible one
            first, and then check recommended parsing plan ('<c><![CDATA[<d>]]></c>' and '<c>*d*</c>').
            </param>
            <param name="shortenSusser">
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </param>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParser.ParseFunctions">
            <summary>
            The list of all methods to parse.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParser.MultilineParseFunctions">
            <summary>
            The list of all methods to parse multiple-line grid.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.#ctor(System.String)">
            <summary>
            Initializes an instance with parsing data.
            </summary>
            <param name="parsingValue">The string to parse.</param>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes an instance with parsing data and a bool value
            indicating whether the parsing operation should use compatible mode.
            </summary>
            <param name="parsingValue">The string to parse.</param>
            <param name="compatibleFirst">
            Indicates whether the parsing operation should use compatible mode to check PM grid. See <see cref="P:Sudoku.Text.Parsing.GridParser.CompatibleFirst"/> to learn more.
            </param>
            <seealso cref="P:Sudoku.Text.Parsing.GridParser.CompatibleFirst"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Text.Parsing.GridParser.ContainsMultilineLimits">
            <summary>
            Indicates whether the property <see cref="P:Sudoku.Text.Parsing.GridParser.ParsingValue"/> of this instance contains multiline limits.
            </summary>
            <seealso cref="P:Sudoku.Text.Parsing.GridParser.ParsingValue"/>
        </member>
        <member name="P:Sudoku.Text.Parsing.GridParser.ContainsTab">
            <summary>
            Indicates whether the property <see cref="P:Sudoku.Text.Parsing.GridParser.ParsingValue"/> of this instance contains tab character '<c>\t</c>'.
            </summary>
            <seealso cref="P:Sudoku.Text.Parsing.GridParser.ParsingValue"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.Parse">
            <summary>
            To parse the value.
            </summary>
            <returns>The grid.</returns>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.Parse(Sudoku.Text.Parsing.GridParsingOption)">
            <summary>
            To parse the value with a specified grid parsing type.
            </summary>
            <param name="gridParsingOption">A specified parsing type.</param>
            <returns>The grid.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="gridParsingOption"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.OnParsingSimpleMultilineGrid(Sudoku.Text.Parsing.GridParser@)">
            <summary>
            Parse the value using multi-line simple grid (without any candidates).
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.OnParsingExcel(Sudoku.Text.Parsing.GridParser@)">
            <summary>
            Parse the Excel format.
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.OnParsingOpenSudoku(Sudoku.Text.Parsing.GridParser@)">
            <summary>
            Parse the open sudoku format grid.
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.OnParsingPencilMarked(Sudoku.Text.Parsing.GridParser@)">
            <summary>
            Parse the PM grid.
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.OnParsingSimpleTable(Sudoku.Text.Parsing.GridParser@)">
            <summary>
            Parse the simple table format string (Sudoku explainer format).
            </summary>
            <param name="parser">The parser.</param>
            <returns>The grid.</returns>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.OnParsingSusser(Sudoku.Text.Parsing.GridParser@,System.Boolean)">
            <summary>
            Parse the susser format string.
            </summary>
            <param name="parser">The parser.</param>
            <param name="shortenSusser">Indicates whether the parser will shorten the susser format.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.OnParsingSukaku(Sudoku.Text.Parsing.GridParser@,System.Boolean)">
            <summary>
            Parse the sukaku format string.
            </summary>
            <param name="parser">The parser.</param>
            <param name="compatibleFirst">
            Indicates whether the algorithm uses compatibility mode to check and parse sudoku grid.
            </param>
            <returns>The result.</returns>
        </member>
        <member name="P:Sudoku.Text.Parsing.GridParser.ParsingValue">
            <summary>
            The generated property declaration for parameter <c>parsingValue</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsing.GridParser.CompatibleFirst">
            <summary>
            The generated property declaration for parameter <c>compatibleFirst</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsing.GridParser.ShortenSusserFormat">
            <summary>
            The generated property declaration for parameter <c>shortenSusser</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParser.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:Sudoku.Text.Parsing.GridParserPatterns">
            <summary>
            Provides with <see cref="T:System.Text.RegularExpressions.Regex"/> patterns used by <see cref="T:Sudoku.Text.Parsing.GridParser"/>.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.Regex"/>
            <seealso cref="T:Sudoku.Text.Parsing.GridParser"/>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParserPatterns.SusserDigitPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '+' atomically, optionally.<br/>
                        ○ Match a Unicode digit.<br/>
                    ○ Match '.'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParserPatterns.OpenSudokuPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a Unicode digit.<br/>
            ○ Loop exactly 242 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match '|'.<br/>
                    ○ Match a Unicode digit.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParserPatterns.PencilmarkedPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 3 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '&lt;'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '&gt;'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '*'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '*'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match a Unicode digit greedily any number of times.<br/>
                        ○ Match a character in the set [+-] atomically, optionally.<br/>
                        ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParserPatterns.SimpleMultilinePattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a character in the set [+.\d] exactly 9 times.<br/>
                    ○ 2nd capture group.<br/>
                        ○ Match with 2 alternative expressions.<br/>
                            ○ Match a character in the set [\n\r].<br/>
                            ○ Match the string "\r\n".<br/>
            ○ Match a character in the set [+.\d] exactly 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParserPatterns.SusserPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a character in the set [+.\d] greedily at least 80 times.<br/>
            ○ Optional (greedy).<br/>
                ○ 1st capture group.<br/>
                    ○ Match ':'.<br/>
                    ○ Loop greedily any number of times.<br/>
                        ○ 2nd capture group.<br/>
                            ○ Match a Unicode digit exactly 3 times.<br/>
                            ○ Match a whitespace character atomically at least once.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParserPatterns.ShortenedSusserPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsing.GridParserPatterns.SukakuSegmentPattern">
            <remarks>
            Pattern explanation:<br/>
            <code>
            ○ Match a Unicode digit greedily any number of times.<br/>
            ○ Match a character in the set [+-] atomically, optionally.<br/>
            ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsing.GridParsingOption">
            <summary>
            Represents a grid parsing type.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.Susser">
            <summary>
            <para>
            Indicates the susser format, which means all grid values will be displayed in one line with empty cell character <c>'0'</c>
            or <c>'.'</c>.
            </para>
            <para>
            For example:
            <list type="number">
            <item>
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            </item>
            <item>
            <code><![CDATA[
            4+80002+306+31000+9004000+4030109+38+24+675+1+75+1+39+8+46+2+2640708+3902090000010000002080+36+20007:713 723 533 633 537 575 176 576 577 579 583 784 586 587 496 997
            ]]></code>
            </item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.ShortenSusser">
            <summary>
            <para>
            Indicates the shorten susser format, which means all grid values will be displayed in one line
            with empty cell character <c>'0'</c> or <c>'.'</c>.
            Different with the option <see cref="F:Sudoku.Text.Parsing.GridParsingOption.Susser"/>, this option will continue shortening the code.
            The option will omit the continuous empty cells to a <c>*</c> in a single line.
            For example, the code
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            will be displayed as
            <code><![CDATA[
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            ]]></code>
            via this option.
            We use the colon <c>,</c> to separate each line of 9 numbers, and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.PencilMarked">
            <summary>
            <para>
            Indicates the pencil marked grid (PM grid), which means all grid candidates will be displayed using a table.
            </para>
            <para>
            For example:
            <code><![CDATA[
            +-------------------+-----------------+--------------------+
            | <8>   12459  249  | *6*  <7>   259  | 1245    245   *3*  |
            | 1457  1245   <6>  | 58   125   <3>  | 124578  2458  <9>  |
            | 1579  <3>    279  | <4>  1259  2589 | 12578   *6*   78   |
            +-------------------+-----------------+--------------------+
            | *2*   <7>    *3*  | <1>  <8>   45   | 456     <9>   46   |
            | <6>   458    48   | <2>  59    459  | <3>     *7*   *1*  |
            | 1459  1459   49   | *3*  *6*   <7>  | 458     458   <2>  |
            +-------------------+-----------------+--------------------+
            | <3>   2489   <1>  | 578  25    <6>  | 24789   248   478  |
            | 79    <6>    2789 | 78   <4>   *1*  | 289     *3*   <5>  |
            | 47    248    <5>  | <9>  *3*   28   | 2678    <1>   4678 |
            +-------------------+-----------------+--------------------+
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.Table">
            <summary>
            <para>
            Indicates the table format, which means all grid values will be displayed using a table with empty cell character
            <c>'0'</c> or <c>'.'</c>.
            </para>
            <para>
            For example:
            <code><![CDATA[
            .----------.----------.----------.
            |  .  4  6 |  . +1  . |  3 +7 +5 |
            | +3 +8  1 | +5  4  7 | +2 +9 +6 |
            |  .  .  5 |  .  3  . | +1 +4  8 |
            :----------+----------+----------:
            |  8  .  4 |  . +5  . | +7  6  . |
            |  .  9  . |  .  2  . | +8  5 +4 |
            |  .  5  . |  .  .  . |  9  .  3 |
            :----------+----------+----------:
            |  5  .  . |  .  8  . |  6  . +9 |
            | +4  .  8 |  1  9  . |  5  .  . |
            |  .  .  9 |  .  . +5 |  4  8  . |
            '----------'----------'----------'
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.SimpleTable">
            <summary>
            <para>
            Sudoku explainer format (9 characters in a row, and 9 rows).
            </para>
            <para>
            For example:
            <code><![CDATA[
            080630040
            200085009
            090000081
            000300800
            000020000
            006001000
            970000030
            400850007
            010094050
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.Sukaku">
            <summary>
            <para>
            Sukaku sudoku format (only contains the digits and the whitespace).
            </para>
            <para>
            For example:
            <code><![CDATA[
             23456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789  23456789
             23456789 123456789 123456789  23456789  23456789  23456789  23456789  23456789  23456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789 123456789
            123456789  23456789  23456789 123456789 123456789  23456789  23456789  23456789 123456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789  23456789
            123456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789 123456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.SukakuSingleLine">
            <summary>
            <para>Sukaku single line format, which uses '0' to be a placeholder.</para>
            <para>
            For example:
            <code><![CDATA[
            023406789123456700003050780120050789003006009123456009100056089023456080123000789003456789023006700023006700120056780100006789120400780000406789103000080020450000003406089020056709120050080100000700120056780120000709123056000123050080000450089123050709100456089003400780100450009003400009120400009123056709003000700023406000000406009123006000000056709003406700120050009103056089103456709003056009120456009123456780023400000103406709003056789020406700100050009020400000100006789020006789020456780123056080120400700000406789120400080023456789003006080020456789103450709123400009123400080023406700123406709103400080123456009120456789023406709023450080100406080103056009100400009123000789100400709100406780123050700000050080023406009
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.Excel">
            <summary>
            <para>
            Excel sudoku format (only contains the digits and the tab character).
            </para>
            <para>
            For example:
            <code><![CDATA[
            1			7	8	9	4	5	6
            4	5	6	1	2	3	7	8	9
            7	8	9	4	5	6	1	2	
            9	1	2	6		8	3	4	
            3	4	5				6	7	8
            	7	8	3		5	9	1	2
            	9	1	5	6	7	2	3	4
            2	3	4	8	9	1	5	6	7
            5	6	7	2	3	4			1
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsing.GridParsingOption.OpenSudoku">
            <summary>
            <para>
            Open sudoku format.
            </para>
            <para>
            For example:
            <code><![CDATA[
            0|0|1|1|0|0|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|0|0|1|9|0|0|8|0|0|0|0|1|0|0|1|0|0|1|0|0|1|7|0|0|2|0|0|0|0|1|0|0|1|0|0|1|0|0|1|7|0|0|0|0|1|3|0|0|0|0|1|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|9|0|0|2|0|0|6|0|0|0|0|1|0|0|1|8|0|0|0|0|1|0|0|1|7|0|0|0|0|1|0|0|1|0|0|1|3|0|0|0|0|1|0|0|1|4|0|0|5|0|0|0|0|1|6|0|0|0|0|1|0|0|1|0|0|1|3|0|0|0|0|1|1|0|0|0|0|1|0|0|1|1|0|0|7|0|0|0|0|1|8|0|0|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|0|0|1|6|0|0|0|0|1|0|0|1|3|0|0|0|0|1|9|0|0|0|0|1|0|0|1|7|0|0
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EliminationPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EliminationPattern_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the CellOrCellListPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the CellOrCellListPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.CellOrCellListPattern_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the ComplexCellOrCellListPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ComplexCellOrCellListPattern_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the Candidates_PrepositionalFormPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PrepositionalFormPattern_4.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the Candidates_PostpositionalFormPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_PostpositionalFormPattern_5.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the Candidates_ComplexPrepositionalFormPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPrepositionalFormPattern_6.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the Candidates_ComplexPostpositionalFormPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Candidates_ComplexPostpositionalFormPattern_7.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SusserDigitPattern_8">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the SusserDigitPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserDigitPattern_8.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the OpenSudokuPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.OpenSudokuPattern_9.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the PencilmarkedPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.PencilmarkedPattern_10.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the SimpleMultilinePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SimpleMultilinePattern_11.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SusserPattern_12">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the SusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.SusserPattern_12.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserPattern_12.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SusserPattern_12.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserPattern_12.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SusserPattern_12.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserPattern_12.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserPattern_12.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SusserPattern_12.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the ShortenedSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.ShortenedSusserPattern_13.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the SukakuSegmentPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.SukakuSegmentPattern_14.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfAnyDecimalDigitNumberDecimalDigitNumber(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_3BCFC31BFB1AD1127D0564F4B3C20ECED086F1C7438F92ACB58165A04BF23DD9(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*+-&lt;\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_5C1843170313CB42CA4CF4E0FCD6C277723EAACCD85464A69BFC7D367CF48212(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_65EF16F1D4CC2684453DF3C3240E17C0787C2CE3C7B9F2FA94357B7AEAC8AC3F(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_85D9C34033677881D8993C4388EDB85FC6297ECDBC9E515FF9B602A26978DF84(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+-\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPop(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Pops 2 values from the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
            <summary>Pushes 1 value onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
            <summary>Pushes 2 values onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>Pushes 3 values onto the backtracking stack.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_asciiExceptDigits">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FE0B0000FE0B0000">
            <summary>Supports searching for characters in or not in "ABCDEFGHIKabcdefghik".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFBB00FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()+,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD300ECFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'(),./:;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
    </members>
</doc>

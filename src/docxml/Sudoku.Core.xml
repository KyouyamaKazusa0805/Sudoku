<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Core</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Concepts.BitStatusMapPredicate`3">
            <summary>
            Represents a method that checks for an offset of type <typeparamref name="TElement"/>
            in the collection of type <typeparamref name="TSelf"/>, referenced from <paramref name="grid"/>,
            determining whether the offset satisfies the specified condition.
            </summary>
            <typeparam name="TSelf">
            The type of the bit status map. The value can be <see cref="T:Sudoku.Concepts.CellMap"/> or <see cref="T:Sudoku.Concepts.CandidateMap"/>.
            </typeparam>
            <typeparam name="TElement">
            The type of each element in the collection of type <typeparamref name="TSelf"/>.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <param name="offset">The <typeparamref name="TElement"/> offset value to be checked.</param>
            <param name="grid">The grid as candidate reference.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap">
            <summary>
            Encapsulates a binary series of candidate state table.
            The internal buffer size 12 is equivalent to expression <c><![CDATA[floor(729 / sizeof(long) << 6)]]></c>.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.BackingBuffer">
            <summary>
            Indicates the internal buffer type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.BackingBuffer._firstElement">
            <summary>
            Indicates the first element of the whole buffer.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.Equals(Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#IEquatable{Sudoku#Concepts#CandidateMap#BackingBuffer}#Equals(Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.op_Equality(Sudoku.Concepts.CandidateMap.BackingBuffer@,Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.op_Inequality(Sudoku.Concepts.CandidateMap.BackingBuffer@,Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#BackingBuffer,Sudoku#Concepts#CandidateMap#BackingBuffer,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap.BackingBuffer,Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#BackingBuffer,Sudoku#Concepts#CandidateMap#BackingBuffer,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap.BackingBuffer,Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.CellDigitEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellDigitEnumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.GetEnumerator">
            <summary>
            Returns itself, in order to iterate the value using <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator itself.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.CellEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each cell of the collection.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that can iterate on each cell of the collection.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellEnumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.GetEnumerator">
            <summary>
            Returns itself, in order to iterate the value using <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator itself.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Full">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Full"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap._bits">
            <summary>
            Indicates the internal field that provides the visit entry for fixed-sized buffer type <see cref="T:Sudoku.Concepts.CandidateMap.BackingBuffer"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap.BackingBuffer"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via a list of candidate offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The candidate offsets, represented as a RxCy notation.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.Int32,System.Boolean)">
            <summary>
            Indicates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance with the peer candidates of the specified candidate and a <see cref="T:System.Boolean"/>
            value indicating whether the map will process itself with <see langword="true"/> value.
            </summary>
            <param name="candidate">The candidate.</param>
            <param name="withItself">Indicates whether the map will process itself with <see langword="true"/> value.</param>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Digits">
            <summary>
            Indicates the digits used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Cells">
            <summary>
            Indicates the cells used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.DigitDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by digit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Full">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#JsonConverterInstance">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="item">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetDigitsFor(System.Int32)">
            <summary>
            Try to get digits that is in the current collection.
            </summary>
            <param name="cell">The desired cell.</param>
            <returns>The digits.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.EnumerateCells">
            <summary>
            Try to enumerate cells on each candidates.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.EnumerateCellDigit">
            <summary>
            Try to enumerate cell and digit value on each candidates.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Add(System.Int32)">
            <summary>
            Add a new <see cref="T:System.Int32"/> into the collection.
            </summary>
            <param name="item">The offset to be added.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Remove(System.Int32)">
            <summary>
            Removes the specified offset from the current collection.
            </summary>
            <param name="item">An offset to be removed.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the specified offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveCell(System.Int32)">
            <summary>
            Remove all <see cref="T:System.Int32"/> instances that is equal to the argument <paramref name="cell"/>.
            </summary>
            <param name="cell">The cell to be removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Toggle(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Clear">
            <summary>
            Remove all elements stored in the current collection, and set the property <see cref="P:Sudoku.Concepts.CandidateMap.Count"/> to zero.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CandidateMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IEquatable{Sudoku#Concepts#CandidateMap}#Equals(Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Any(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#All(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CandidateMap,System#Int32}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CandidateMap,System#Int32}#First(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IGroupByMethod{Sudoku#Concepts#CandidateMap,System#Int32}#GroupBy``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CandidateMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse``1(System.String,``0,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via the specified candidates.
            </summary>
            <param name="candidates">The candidates.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse``1(System.String,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LogicalNot(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_True(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_False(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_OnesComplement(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <summary>
            Expands the operator to <c><![CDATA[(a & b).PeerIntersection & b]]></c>.
            </summary>
            <param name="base">The base map.</param>
            <param name="template">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_ExclusiveOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_RightShift(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_UnsignedRightShift(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="offsets">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="offsets">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Equality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Inequality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CandidateMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMarshal">
            <summary>
            Represents methods that operates with <see cref="T:System.Int32"/> values.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Int32)">
            <summary>
            Converts the specified <see cref="T:System.Int32"/> into a singleton <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="this">The cell to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, containing only one element of <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})">
            <summary>
            Converts the specified list of <see cref="T:System.Int32"/> instances into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="this">The cells to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, containing all elements come from <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.ReadOnlySpan{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})"/>
        </member>
        <member name="T:Sudoku.Concepts.CellMap">
            <summary>
            Encapsulates a binary series of cell state table.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Shifting">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Shifting"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Full">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Full"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._high">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._low">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a list of offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The cell offsets, represented as a RxCy notation.</param>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.IsInIntersection">
            <summary>
            Determines whether the current list of cells are all lie in an intersection area, i.e. a locked candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CanSeeEachOther">
            <summary>
            Indicates whether every cell in the current collection cannot see each other.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.BlockMask">
            <summary>
            Indicates the mask of block that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned blocks are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.RowMask">
            <summary>
            Indicates the mask of row that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned rows are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ColumnMask">
            <summary>
            Indicates the mask of column that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned columns are 0 and 1, so the return mask is <c>0b000000011</c> (i.e. 3).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.SharedLine">
            <summary>
            Indicates the shared line. In other words, the line will contain all cells in this collection.
            </summary>
            <remarks>
            If no shared houses can be found (i.e. return value of property <see cref="P:Sudoku.Concepts.CellMap.SharedHouses"/> is 0),
            this property will return <see cref="F:Sudoku.SolutionFields.TrailingZeroCountFallback"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionFields.TrailingZeroCountFallback"/>
            <seealso cref="P:Sudoku.Concepts.CellMap.SharedHouses"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.SharedHouses">
            <summary>
            Indicates all houses shared. This property is used to check all houses that all cells of this instance shared.
            For example, if the cells are <c>[0, 1]</c>, the property <see cref="P:Sudoku.Concepts.CellMap.SharedHouses"/> will return
            house indices 0 (block 1) and 9 (row 1); however, if cells span two houses or more (e.g. cells <c>[0, 1, 27]</c>),
            this property won't contain any houses.
            </summary>
            <remarks>
            The return value will be a <see cref="T:System.Int32"/> value indicating each houses. Bits set 1 are shared houses.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Houses">
            <summary>
            All houses that the map spanned. This property is used to check all houses that all cells of
            this instance spanned. For example, if the cells are <c>[0, 1]</c>, the property
            <see cref="P:Sudoku.Concepts.CellMap.Houses"/> will return the house index 0 (block 1), 9 (row 1), 18 (column 1)
            and 19 (column 2).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Symmetry">
            <summary>
            Try to get the symmetric type of the pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ExpandedPeers">
            <summary>
            Gets the expanded peers of the current map.
            </summary>
            <remarks>
            An <b>Expanded Peers</b> is a list of cells that contains all peer cells of each cell
            appeared in the current collection. For example, if a collection contains cells <c>r1c123</c>,
            this collection will be the result of the expression <c>PeersMap[r1c1] | PeersMap[r1c2] | PeersMap[r1c3]</c>,
            where the member <c>PeersMap</c> corresponds to the array <see cref="F:Sudoku.SolutionFields.PeersMap"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionFields.PeersMap"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Full">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#JsonConverterInstance">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.InOneHouse(System.Int32@)">
            <summary>
            Indicates whether all cells in this instance are in one house.
            </summary>
            <param name="houseIndex">
            The house index whose corresponding house covered.
            If the return value is <see langword="false"/>, this value will be the constant -1.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="item">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CompareTo(Sudoku.Concepts.CellMap@)">
            <summary>
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/summary"/>
            </summary>
            <param name="other">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/param[@name='other']"/>
            </param>
            <returns>
            The result value only contains 3 possible values: 1, 0 and -1. The comparison rule is:
            <list type="number">
            <item>
            If <see langword="this"/> holds more cells than <paramref name="other"/>, then return 1
            indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <see langword="this"/> holds less cells than <paramref name="other"/>, then return -1
            indicating <paramref name="other"/> is greater.
            </item>
            <item>
            If they two hold same cells, then checks for indices held:
            <list type="bullet">
            <item>
            If <see langword="this"/> holds a cell whose index is greater than all cells appeared in <paramref name="other"/>,
            then return 1 indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <paramref name="other"/> holds a cell whose index is greater than all cells
            appeared in <paramref name="other"/>, then return -1 indicating <paramref name="other"/> is greater.
            </item>
            </list>
            </item>
            </list>
            If all rules are compared, but they are still considered equal, then return 0.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Add(System.Int32)">
            <summary>
            Add a new <see cref="T:System.Int32"/> into the collection.
            </summary>
            <param name="item">The offset to be added.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Remove(System.Int32)">
            <summary>
            Removes the specified offset from the current collection.
            </summary>
            <param name="item">An offset to be removed.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the specified offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Toggle(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Clear">
            <summary>
            Remove all elements stored in the current collection, and set the property <see cref="P:Sudoku.Concepts.CellMap.Count"/> to zero.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CellMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IEquatable{Sudoku#Concepts#CellMap}#Equals(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#Any(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#All(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IComparable{Sudoku#Concepts#CellMap}#CompareTo(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CellMap,System#Int32}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CellMap,System#Int32}#First(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#CellMap,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IGroupByMethod{Sudoku#Concepts#CellMap,System#Int32}#GroupBy``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#CellMap,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse``1(System.String,``0,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CellMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance via the specified cells.
            </summary>
            <param name="cells">The cells.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int64,System.Int64)">
            <summary>
            Initializes an instance with two binary values.
            </summary>
            <param name="high">Higher 40 bits.</param>
            <param name="low">Lower 41 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes an instance with three binary values.
            </summary>
            <param name="high">Higher 27 bits.</param>
            <param name="mid">Medium 27 bits.</param>
            <param name="low">Lower 27 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByInt128(System.Int128@)">
            <summary>
            Initializes an instance with an <see cref="T:System.Int128"/> integer.
            </summary>
            <param name="llong">The <see cref="T:System.Int128"/> integer.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse``1(System.String,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LogicalNot(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_True(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_False(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_OnesComplement(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Modulus(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <summary>
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/summary"/>
            </summary>
            <param name="base">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='base']"/>
            </param>
            <param name="template">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='template']"/>
            </param>
            <returns><inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/returns"/></returns>
            <remarks>
            <para>
            The operator is commonly used for checking eliminations, especially in type 2 of deadly patterns. 
            </para>
            <para>
            For example, if we should check the eliminations
            of digit <c>d</c>, we may use the expression
            <code><![CDATA[
            (urCells & grid.CandidatesMap[d]).PeerIntersection & grid.CandidatesMap[d]
            ]]></code>
            to express the eliminations are the peer intersection of cells of digit <c>d</c>
            appeared in <c>urCells</c>. This expression can be simplified to
            <code><![CDATA[
            urCells % grid.CandidatesMap[d]
            ]]></code>
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_ExclusiveOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_RightShift(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_UnsignedRightShift(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Implicit(Sudoku.Concepts.CellMap@)~System.Int128">
            <summary>
            Implicit cast from a <see cref="T:Sudoku.Concepts.CellMap"/> instance into a <see cref="T:System.Int128"/> result.
            </summary>
            <param name="this">A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Implicit(System.Int128)~Sudoku.Concepts.CellMap">
            <summary>
            Implicit cast from a <see cref="T:System.Int128"/> value into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="value">A <see cref="T:System.Int128"/> value.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.Int32[])~Sudoku.Concepts.CellMap">
            <summary>
            Explicit cast from a <see cref="T:System.Int32"/> array into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="cells">An array of <see cref="T:System.Int32"/> values.</param>
        </member>
        <member name="T:Sudoku.Concepts.CellMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="offset">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="offset">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Enumerator._offset">
            <summary>
            The internal field for offsets.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Equality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Inequality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Equality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_GreaterThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CellMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMarshal">
            <summary>
            Represents a list of extension methods that operates with cell instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.CopyHouseInfo(System.Int32,System.Int32@)">
            <summary>
            Gets the row, column and block value and copies to the specified array that represents by a pointer
            of 3 elements, where the first element stores the block index, second element stores the row index
            and the third element stores the column index.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="reference">
            The specified reference to the first element in a sequence. The sequence type can be an array or a <see cref="T:System.Span`1"/>,
            only if the sequence can store at least 3 values.
            </param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="reference"/> references to <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndex(System.Byte,Sudoku.Concepts.HouseType)">
            <summary>
            Get the house index (0..27 for block 1-9, row 1-9 and column 1-9)
            for the specified cell and the house type.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="houseType">The house type.</param>
            <returns>The house index. The return value must be between 0 and 26.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="houseType"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndex(System.Int32,Sudoku.Concepts.HouseType)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.ToHouseIndex(System.Byte,Sudoku.Concepts.HouseType)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Byte)">
            <summary>
            Get the house indices for the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>A <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Byte)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToBandIndex(System.Int32)">
            <summary>
            Try to get the band index (mega-row) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToTowerIndex(System.Int32)">
            <summary>
            Try to get the tower index (mega-column) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Int32)">
            <summary>
            Converts the specified <see cref="T:System.Int32"/> into a singleton <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="this">The cell to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance, containing only one element of <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})">
            <summary>
            Converts the specified list of <see cref="T:System.Int32"/> instances into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="this">The cells to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance, containing all elements come from <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.ReadOnlySpan{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})"/>
        </member>
        <member name="T:Sudoku.Concepts.CellState">
            <summary>
            Represents a cell state.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Undefined">
            <summary>
            Indicates the cell state is invalid - it holds an empty cell without any candidates here.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Empty">
            <summary>
            Indicates that the cell is empty.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Modifiable">
            <summary>
            Indicates the current cell has been filled a value that is not given from initial grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Given">
            <summary>
            Indicates the current cell has been filled a value that cannot be modified because it exists in initial grid.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Chute">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="Cells">The cells used.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="M:Sudoku.Concepts.Chute.#ctor(System.Int32,Sudoku.Concepts.CellMap@,System.Boolean,System.Int32)">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="Cells">The cells used.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Index">
            <summary>Index of the chute. The value is between 0 and 6.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Cells">
            <summary>The cells used.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.IsRow">
            <summary>Indicates whether the chute is in a mega-row.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.HousesMask">
            <summary>Indicates the houses used.</summary>
        </member>
        <member name="M:Sudoku.Concepts.Chute.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.TryParse(System.String,Sudoku.Concepts.Chute@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.TryParse``1(System.String,``0,Sudoku.Concepts.Chute@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.Parse``1(System.String,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.System#IParsable{Sudoku#Concepts#Chute}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Chute@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.System#IParsable{Sudoku#Concepts#Chute}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Conclusion">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-----------------------|---|---------------------------------------|
            |   |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-----------------------|---|---------------------------------------'
                                     \_/ \_____________________________________/
                                     (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1), but the real type
            <see cref="P:Sudoku.Concepts.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type because C# cannot set "A bit"
            to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(System.Int16)">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-----------------------|---|---------------------------------------|
            |   |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-----------------------|---|---------------------------------------'
                                     \_/ \_____________________________________/
                                     (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1), but the real type
            <see cref="P:Sudoku.Concepts.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type because C# cannot set "A bit"
            to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Conclusion.Parsers">
            <summary>
            The internal parsers.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Conclusion.DefaultOptions">
            <inheritdoc cref="P:System.Text.Json.IJsonSerializable`1.DefaultOptions"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(Sudoku.Concepts.ConclusionType,System.Int32)">
            <summary>
            Initializes an instance with a conclusion type and a candidate offset.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="candidate">The candidate offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(Sudoku.Concepts.ConclusionType,System.Int32,System.Int32)">
            <summary>
            Initializes the <see cref="T:Sudoku.Concepts.Conclusion"/> instance via the specified cell, digit and the conclusion type.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Cell">
            <summary>
            Indicates the cell the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Digit">
            <summary>
            Indicates the digit the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Candidate">
            <summary>
            Indicates the candidate the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.ConclusionType">
            <summary>
            Indicates the conclusion type of the current instance.
            If the type is <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/>, this conclusion will be set value (Set a digit into a cell);
            otherwise, a candidate will be removed.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.System#Text#Json#IJsonSerializable{Sudoku#Concepts#Conclusion}#DefaultOptions">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Deconstruct(Sudoku.Concepts.ConclusionType@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Deconstruct(Sudoku.Concepts.ConclusionType@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Equals(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.CompareTo(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.GetSymmetricConclusion(Sudoku.SymmetricType,System.Int32)">
            <summary>
            Try to get a new <see cref="T:Sudoku.Concepts.Conclusion"/> instance which is symmetric with the current instance, with the specified symmetric type.
            </summary>
            <param name="symmetricType">The symmetric type to be checked.</param>
            <param name="mappingDigit">The other mapping digit.</param>
            <returns>The other symmetric <see cref="T:Sudoku.Concepts.Conclusion"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="symmetricType"/> contains multiple (greater than 2) cells
            symmetric with the current cell and digit.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.System#Text#Json#IJsonSerializable{Sudoku#Concepts#Conclusion}#ToJsonString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.TryParse(System.String,Sudoku.Concepts.Conclusion@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.TryParse``1(System.String,``0,Sudoku.Concepts.Conclusion@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Parse``1(System.String,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.System#Text#Json#IJsonSerializable{Sudoku#Concepts#Conclusion}#FromJsonString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.System#IParsable{Sudoku#Concepts#Conclusion}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Conclusion@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.System#IParsable{Sudoku#Concepts#Conclusion}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_OnesComplement(Sudoku.Concepts.Conclusion)">
            <summary>
            Negates the current conclusion instance, changing the conclusion type from <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/> to <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/>,
            or from <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> to <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/>.
            </summary>
            <param name="self">The current conclusion instance to be negated.</param>
            <returns>The negation.</returns>
        </member>
        <member name="F:Sudoku.Concepts.Conclusion._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_Equality(Sudoku.Concepts.Conclusion,Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_Inequality(Sudoku.Concepts.Conclusion,Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Represents a JSON converter for type <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Conclusion,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionSet">
            <summary>
            Represents a list of conclusions.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.BitsCount">
            <summary>
            The total length of bits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.HalfBitsCount">
            <summary>
            The maximum number of candidates can exist in a grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.PrimeNumbers">
            <summary>
            The prime numbers below 100.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet._bitArray">
            <summary>
            The internal bit array.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet._conclusionsEntry">
            <summary>
            The entry point that can visit conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.ContainsAssignment">
            <summary>
            Indicates whether the collection contains any assignment conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.ContainsElimination">
            <summary>
            Indicates whether the collection contains any elimination conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Count">
            <summary>
            Indicates the number of bit array elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Empty">
            <summary>
            An empty instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Item(System.Int32)">
            <summary>
            Try to get n-th element stored in the collection.
            </summary>
            <param name="index">The desired index to be checked.</param>
            <returns>The found <see cref="T:Sudoku.Concepts.Conclusion"/> instance at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Add(System.Int32)">
            <summary>
            Add a new conclusion, represented as a global index (between 0 and 1458), into the collection.
            </summary>
            <param name="index">
            <para>The global index (between 0 and 1458) to be added.</para>
            <para>The global index is equivalent to the result value of this formula <c>conclusionType * 729 + candidate</c>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Add(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.AddRange(System.ReadOnlySpan{Sudoku.Concepts.Conclusion})">
            <summary>
            Add a list of conclusions into the collection.
            </summary>
            <param name="conclusions">The conclusions to be added.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Remove(System.Int32)">
            <summary>
            Remove a conclusion, represented as a global index (between 0 and 1458), from the collection.
            </summary>
            <param name="index">
            <para>The global index (between 0 and 1458) to be added.</para>
            <para>The global index is equivalent to the result value of this formula <c>conclusionType * 729 + candidate</c>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Remove(Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Replace(Sudoku.Concepts.ConclusionSet)">
            <summary>
            Removes all elements in the collection and add all elements from <paramref name="conclusions"/>.
            </summary>
            <param name="conclusions">The conclusions provider to replace with the current instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.CopyTo(System.Span{Sudoku.Concepts.Conclusion})">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Equals(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Contains(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ContainsCell(System.Int32)">
            <summary>
            Indicates whether the collection contains the specified cell.
            </summary>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Exists(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.Any(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TrueForAll(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.All(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.GetEnumerator">
            <summary>
            Try to get an enumerator type that iterates on each conclusion.
            </summary>
            <returns>An enumerator type that iterates on each conclusion.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Slice(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.ISliceMethod`2.Slice(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#CopyTo(Sudoku.Concepts.Conclusion[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#ExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IntersectWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#UnionWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Any(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#All(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#Remove(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#Add(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IEnumerable{Sudoku#Concepts#Conclusion}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#ISliceMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TryParse(System.String,Sudoku.Concepts.ConclusionSet@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TryParse``1(System.String,``0,Sudoku.Concepts.ConclusionSet@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Parse``1(System.String,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#IParsable{Sudoku#Concepts#ConclusionSet}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.ConclusionSet@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#IParsable{Sudoku#Concepts#ConclusionSet}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_LogicalNot(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_True(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_False(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_OnesComplement(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_BitwiseAnd(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_BitwiseOr(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_ExclusiveOr(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionSet.Enumerator">
            <summary>
            The internal enumerator instance.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Enumerator.#ctor(Sudoku.Concepts.ConclusionSet)">
            <summary>
            The internal enumerator instance.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.Enumerator._enumerator">
            <summary>
            The conclusions to be iterated.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Enumerator.Current">
            <summary>
            Indicates the current iterated element.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_Equality(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_Inequality(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionType">
            <summary>
            Provides a conclusion type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionType.Assignment">
            <summary>
            Indicates the conclusion is a value filling into a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionType.Elimination">
            <summary>
            Indicates the conclusion is a candidate being remove from a cell.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Conjugate">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32)">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with from and to cell offset and a digit.
            </summary>
            <param name="from">The from cell.</param>
            <param name="to">The to cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with the map and the digit.
            The map should contains two cells, the first one is the start one, and the second one is the end one.
            </summary>
            <param name="map">The map.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.From">
            <summary>
            Indicates the "from" cell, i.e. the base cell that starts the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.To">
            <summary>
            Indicates the "to" cell, i.e. the target cell that ends the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Line">
            <summary>
            Indicates the target line of the two cells lie in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Houses">
            <summary>
            Indicates the house that the current conjugate pair lies in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Map">
            <summary>
            Indicates the cells (the "from" cell and "to" cell).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.TryParse(System.String,Sudoku.Concepts.Conjugate@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.TryParse``1(System.String,``0,Sudoku.Concepts.Conjugate@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Parse``1(System.String,``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.System#IParsable{Sudoku#Concepts#Conjugate}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Conjugate@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.System#IParsable{Sudoku#Concepts#Conjugate}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.Conjugate._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Equality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Inequality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateConverter">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
            <remarks>
            You can use types <see cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>, <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>, <see cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
            <remarks>
            You can use types <see cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>, <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>, <see cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CellConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CandidateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.HouseConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of houses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ConclusionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.DigitConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.IntersectionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified information for an intersection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ChuteConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of chute.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ConjugateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified conjugate.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.TargetCurrentCulture">
            <summary>
            Indicates the target culture.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.InvariantCultureConverter">
            <summary>
            Indicates the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance for the invariant culture,
            meaning it ignores which culture your device will use.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.GetConverter(System.Globalization.CultureInfo)">
            <summary>
            Try to get a <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance from the specified culture.
            </summary>
            <param name="culture">The culture.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance from the specified culture.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateParser">
            <summary>
            Represents for a parser instance that parses a <see cref="T:System.String"/> text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateParser.DeprecatedInfo_NotSupported">
            <summary>
            The not supported information for property implemented.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.CellParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CellMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.CandidateParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.HouseParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int32"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ConclusionParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Conclusion"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.DigitParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int16"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.IntersectionParser">
            <summary>
            The parser method that can creates a list of pairs of <see cref="T:Sudoku.Concepts.IntersectionBase"/> and <see cref="T:Sudoku.Concepts.IntersectionResult"/>
            via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.IntersectionBase"/>
            <seealso cref="T:Sudoku.Concepts.IntersectionResult"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ChuteParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Chute"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Chute"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ConjuagteParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Conjugate"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conjugate"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.InvariantCultureParser">
            <summary>
            Indicates the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance for the invariant culture,
            meaning it ignores which culture your device will use.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateParser.GetParser(System.Globalization.CultureInfo)">
            <summary>
            Try to get a <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance from the specified culture.
            </summary>
            <param name="culture">The culture.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance from the specified culture.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateType">
            <summary>
            Represents a type of notation to describe a coordinate in sudoku.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.Literal">
            <summary>
            Idnicates the notation is based on literally notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.RxCy">
            <summary>
            Indicates the notation is based on <b>RxCy</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.K9">
            <summary>
            Indicates the notation is based on <b>K9</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.Excel">
            <summary>
            Indicates the notation is based on <b>Excel</b> notation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.#ctor(System.Boolean,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.GenericConceptConverter">
            <summary>
            Represents a converter that only converts from variant concept objects into corresponding equivalent <see cref="T:System.String"/> values.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.GenericConceptConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a converter that only converts from variant concept objects into corresponding equivalent <see cref="T:System.String"/> values.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.GenericConceptConverter.DefaultSeparator">
            <summary>
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.GenericConceptConverter.DigitsSeparator">
            <summary>
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.GenericConceptConverter.CurrentCulture">
            <summary>
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.GenericConceptParser">
            <summary>
            Represents a converter that parses into variant concept objects from correspoding specified <see cref="T:System.String"/> values.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.ICoordinateConvertible`1">
            <summary>
            Represents an interface type that describes for an ability on <c>ToString</c> with custom sudoku coordinate logic.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ICoordinateConvertible`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ICoordinateConvertible`1.ToString``1(``0)">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <typeparam name="T">The type of the converter.</typeparam>
            <param name="converter">The converter instance that the current concept will rely on.</param>
            <returns>A string that represents the current object.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.ICoordinateParsable`1">
            <summary>
            Represents an interface type that describes for an ability on <c>Parse</c> with custom sudoku coordinate logic.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ICoordinateParsable`1.TryParse(System.String,`0@)">
            <summary>
            Try to parse the specified string text, and get the same-meaning instance
            of type <typeparamref name="TSelf"/>.
            </summary>
            <param name="str">The string to parse. The value cannot be <see langword="null"/>.</param>
            <param name="result">
            The result parsed. If failed to parse, the value will keep the <see langword="default"/> value,
            i.e. <see langword="default"/>(<typeparamref name="TSelf"/>).
            </param>
            <returns>
            A <see cref="T:System.Boolean"/> result indicating whether the operation is successful to execute.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ICoordinateParsable`1.TryParse``1(System.String,``0,`0@)">
            <summary>
            Try to parse the specified string text, and get the same-meaning instance
            of type <typeparamref name="TSelf"/>.
            </summary>
            <typeparam name="T">The type of coordinate parser.</typeparam>
            <param name="str">The string to parse. The value cannot be <see langword="null"/>.</param>
            <param name="parser">
            A parser instance derived from <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/>,
            indicating the custom logic on parsing for coordinate items inside the concept.
            </param>
            <param name="result">
            The result parsed. If failed to parse, the value will keep the <see langword="default"/> value,
            i.e. <see langword="default"/>(<typeparamref name="TSelf"/>).
            </param>
            <returns>
            A <see cref="T:System.Boolean"/> result indicating whether the operation is successful to execute.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ICoordinateParsable`1.Parse(System.String)">
            <summary>
            Parse the specified string text, and get the same-meaning instance
            of type <typeparamref name="TSelf"/>.
            </summary>
            <param name="str">The string to parse. The value cannot be <see langword="null"/>.</param>
            <returns>The result parsed.</returns>
            <exception cref="T:System.FormatException">Throws when failed to parse.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ICoordinateParsable`1.Parse``1(System.String,``0)">
            <summary>
            Parse the specified string text, and get the same-meaning instance
            of type <typeparamref name="TSelf"/>.
            </summary>
            <typeparam name="T">The type of coordinate parser.</typeparam>
            <param name="str">The string to parse. The value cannot be <see langword="null"/>.</param>
            <param name="parser">
            A parser instance derived from <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/>,
            indicating the custom logic on parsing for coordinate items inside the concept.
            </param>
            <returns>The result parsed.</returns>
            <exception cref="T:System.FormatException">Throws when failed to parse.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.K9Converter">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distincting with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Converter.#ctor(System.Boolean,System.Char,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distincting with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.FinalRowLetter">
            <summary>
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distincting with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.K9Parser">
            <summary>
            Represents a parser type that uses <b>K9</b> notation rule to parse text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ConjuagteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Parser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[a-k]+[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Parser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+)([1-9]+)\\.([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
            ○ 2nd capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match '.'.<br/>
            ○ 3rd capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Parser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+[1-9]+(,\\s*[a-k]+[1-9]+)*)\\s*(==?|!=|&lt;&gt;)\\s*([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                ○ Match a character in the set [1-9] greedily at least once.<br/>
                ○ Loop greedily any number of times.<br/>
                    ○ 2nd capture group.<br/>
                        ○ Match ','.<br/>
                        ○ Match a whitespace character atomically any number of times.<br/>
                        ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                        ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 3rd capture group.<br/>
                ○ Match with 3 alternative expressions.<br/>
                    ○ Match '=' atomically at least 1 and at most 2 times.<br/>
                    ○ Match the string "!=".<br/>
                    ○ Match the string "&lt;&gt;".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 4th capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Parser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k][1-9])\\s*={2}\\s*([a-k][1-9])\\.([1-9])</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A].<br/>
                ○ Match a character in the set [1-9].<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "==".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 2nd capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A].<br/>
                ○ Match a character in the set [1-9].<br/>
            ○ Match '.'.<br/>
            ○ 3rd capture group.<br/>
                ○ Match a character in the set [1-9].<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.RxCyConverter">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.MakeDigitBeforeCell">
            <summary>
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.HouseNotationOnlyDisplayCapitals">
            <summary>
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.GetLabel(System.Byte)">
            <summary>
            Get the label of each house.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>The label.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.RxCyParser">
            <summary>
            Represents a parser type that uses <b>RxCy</b> notation rule to parse text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ConjuagteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+\\([1-9]+\\)|[1-9]+r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match with 2 alternative expressions, atomically.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Match an empty string.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match '('.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match ')'.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Rr].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+(,\\s*r[1-9]+c[1-9]+)*\\s*(==?|!=|&lt;&gt;)\\s*[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9] greedily at least once.<br/>
            ○ Loop greedily any number of times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a whitespace character atomically any number of times.<br/>
                    ○ Match a character in the set [Rr].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 2nd capture group.<br/>
                ○ Match with 3 alternative expressions.<br/>
                    ○ Match '=' atomically at least 1 and at most 2 times.<br/>
                    ○ Match the string "!=".<br/>
                    ○ Match the string "&lt;&gt;".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.UnitHousePattern">
            <remarks>
            Pattern:<br/>
            <code>[rcb][1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [BCRbcr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.UnitIntersectionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[rc][1-9]+b[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [CRcr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.UnitMegaLineGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>m[rc][1-3]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Mm].<br/>
            ○ Match a character in the set [CRcr].<br/>
            ○ Match a character in the set [1-3] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]c[1-9]\\s*={2}\\s*r[1-9]c[1-9]\\([1-9]\\)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "==".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match '('.<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match ')'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMapFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, or parses into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.Equals(Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.Clone">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>A new instance whose internal values are equal to the current instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.FormatMap(Sudoku.Concepts.CandidateMap@)">
            <summary>
            Try to format the current map into a valid string result.
            </summary>
            <param name="map">The map to be formatted.</param>
            <returns>The <see cref="T:System.String"/> representation of the argument <paramref name="map"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.ParseMap(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> instance into a valid <see cref="T:Sudoku.Concepts.CandidateMap"/>.
            </summary>
            <param name="str">The string value to be parsed.</param>
            <returns>The <see cref="T:Sudoku.Concepts.CandidateMap"/> as the result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.op_Equality(Sudoku.Concepts.CandidateMapFormatInfo,Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.op_Inequality(Sudoku.Concepts.CandidateMapFormatInfo,Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.CandidateMapFormatInfo"/> type that supports Hodoku elimination candidates formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.Equals(Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.FormatMap(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.ParseMap(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.CandidateNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="candidates">A list of candidates.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="candidates"/>.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.CellNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="cells">A list of cells.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="cells"/>.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.ChuteNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String" /> value via the specified <see cref="T:Sudoku.Concepts.Chute" /> instance.
            </summary>
            <param name="chutes">
            <para>A list of chutes.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>An equivalent <see cref="T:System.String" /> value to the specified argument <paramref name="chutes" />.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.ConclusionNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String" /> value via the specified <see cref="T:Sudoku.Concepts.Conclusion" /> instance.
            </summary>
            <param name="conclusions">
            <para>A list of conjugate pairs.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>An equivalent <see cref="T:System.String" /> value to the specified argument <paramref name="conclusions" />.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.ConjugateNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String" /> value via the specified <see cref="T:Sudoku.Concepts.Conjugate" /> instance.
            </summary>
            <param name="conjugatePairs">
            <para>A list of conjugate pairs.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>An equivalent <see cref="T:System.String" /> value to the specified argument <paramref name="conjugatePairs" />.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.DigitNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:System.Int16"/> instance.
            </summary>
            <param name="digitsMask">A list of digits.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="digitsMask"/>.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.HouseNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:System.Int32"/> instance.
            </summary>
            <param name="housesMask">A list of houses.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="housesMask"/>.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.IntersectionNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String" /> value
            via the specified <see cref="T:Sudoku.Concepts.IntersectionBase" /> and <see cref="T:Sudoku.Concepts.IntersectionResult" /> instance.
            </summary>
            <param name="intersections">
            <para>A list of intersections.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>An equivalent <see cref="T:System.String" /> value to the specified argument <paramref name="intersections" />.</returns>
        </member>
        <member name="T:Sudoku.Concepts.BitmapCellMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.CellMapFormatInfo"/> type that supports bitmap formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.Equals(Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.FormatMap(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.ParseMap(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMapFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.CellMap"/> instance, or parses into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.Equals(Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.Clone">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>A new instance whose internal values are equal to the current instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.FormatMap(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to format the current map into a valid string result.
            </summary>
            <param name="map">The map to be formatted.</param>
            <returns>The <see cref="T:System.String"/> representation of the argument <paramref name="map"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.ParseMap(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> instance into a valid <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <param name="str">The string value to be parsed.</param>
            <returns>The <see cref="T:Sudoku.Concepts.CellMap"/> as the result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.op_Equality(Sudoku.Concepts.CellMapFormatInfo,Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.op_Inequality(Sudoku.Concepts.CellMapFormatInfo,Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.CsvGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports Comma-separated-values formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.GridFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.Grid"/> instance, or parses into a <see cref="T:Sudoku.Concepts.Grid"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
            <seealso cref="T:System.Globalization.NumberFormatInfo"/>
        </member>
        <member name="F:Sudoku.Concepts.GridFormatInfo.ValuesRouter">
            <summary>
            Indicates the table of format and creator.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.WithCandidates">
            <summary>
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.WithModifiables">
            <summary>
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.ShortenSusser">
            <summary>
            <para>
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </para>
            <para>
            This option will omit the continuous empty cells to a <c>*</c> in a single line. For example, the code
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            will be displayed as
            <code><![CDATA[
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            ]]></code>
            via this option.
            We use the colon <c>,</c> to separate each line of 9 numbers, and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.NegateEliminationsTripletRule">
            <summary>
            <para>
            Indicates whether the parser will negate the rule, treating all digits as candidates existing in the grid
            instead of removed ones.
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.TreatValueAsGiven">
            <summary>
            Indicates whether the formatter will treat all values as givens, regardless of its value state.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.SubtleGridLines">
            <summary>
            Indicates whether the formatter will subtle grid lines to make a good-look.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.IsCompatibleMode">
            <summary>
            Indicates whether the formatter will use compatible mode to output grid values.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.Multiline">
            <summary>
            Indicates whether the formatter will handle the value with multiple-line mode.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.RemoveGridLines">
            <summary>
            Indicates whether the parsing operation will use simple way, removing all grid lines for multi-line formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.OnlyEliminations">
            <summary>
            Indicates whether the formatting operation will output for eliminations.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.Separator">
            <summary>
            Indicaets the separator used. By default it's comma <c>", "</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.InvariantInfo">
            <summary>
            Gets a read-only System.Globalization.NumberFormatInfo object that is culture-independent (invariant).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.CurrentInfo">
            <summary>
            Gets a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> that formats values based on the current culture.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.Clone">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>A new instance whose internal values are equal to the current instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Try to format the current grid into a valid string result.
            </summary>
            <param name="grid">The grid to be formatted.</param>
            <returns>The <see cref="T:System.String"/> representation of the argument <paramref name="grid"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.ParseGrid(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> instance into a valid <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="str">The string value to be parsed.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Grid"/> as the result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetInstance(System.IFormatProvider)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.GridFormatInfo"/> associated with the specified <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> used to get the <see cref="T:Sudoku.Concepts.GridFormatInfo"/>.</param>
            <returns>The <see cref="T:Sudoku.Concepts.GridFormatInfo"/> associated with the specified <see cref="T:System.IFormatProvider"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetInstance(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> instance that holds the specified format.
            </summary>
            <param name="format">The format.</param>
            <returns>A valid <see cref="T:Sudoku.Concepts.GridFormatInfo"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.op_Equality(Sudoku.Concepts.GridFormatInfo,Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.op_Inequality(Sudoku.Concepts.GridFormatInfo,Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.InlineSusserGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports inline Susser grid formatting.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.InlineSusserGridFormatInfo.PlusToken">
            <summary>
            Indicates the plus token that describes for modifiable values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.InlineSusserGridFormatInfo.EmptyString">
            <summary>
            Indicates the empty string.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?[\\d\\.]|\\[[1-9]{1,9}\\])</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '+' atomically, optionally.<br/>
                        ○ Match a character in the set [.\d].<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '['.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match ']'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.MaskGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports mask formatting.
            </summary>
            <remarks>
            <para>This type is used by diagnostic only.</para>
            <para>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.MultipleLineGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports multiple formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.GridSusserDigitPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?\\d|\\.)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '+' atomically, optionally.<br/>
                        ○ Match a Unicode digit.<br/>
                    ○ Match '.'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.GridSimpleMultilinePattern">
            <remarks>
            Pattern:<br/>
            <code>([\\d\\.\\+]{9}(\\r|\\n|\\r\\n)){8}[\\d\\.\\+]{9}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a character in the set [+.\d] exactly 9 times.<br/>
                    ○ 2nd capture group.<br/>
                        ○ Match with 2 alternative expressions.<br/>
                            ○ Match a character in the set [\n\r].<br/>
                            ○ Match the string "\r\n".<br/>
            ○ Match a character in the set [+.\d] exactly 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.OpenSudokuGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports OpenSudoku formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.GridOpenSudokuPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d(\\|\\d){242}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a Unicode digit.<br/>
            ○ Loop exactly 242 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match '|'.<br/>
                    ○ Match a Unicode digit.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.PencilmarkGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports pencilmark grid formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.GridPencilmarkingPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\&lt;\\d\\&gt;|\\*\\d\\*|\\d*[\\+\\-]?\\d+)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 3 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '&lt;'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '&gt;'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '*'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '*'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match a Unicode digit greedily any number of times.<br/>
                        ○ Match a character in the set [+-] atomically, optionally.<br/>
                        ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.SukakuGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports Sukaku formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.GridSukakuSegmentPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d*[\\-\\+]?\\d+</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a Unicode digit greedily any number of times.<br/>
            ○ Match a character in the set [+-] atomically, optionally.<br/>
            ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.SusserGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports Susser formatting.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.ModifiablePrefix">
            <summary>
            Indicates the modifiable prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.LineLimit">
            <summary>
            Indicates the line separator character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.Star">
            <summary>
            Indicates the star character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.PreeliminationPrefix">
            <summary>
            Indicates the pre-elimination prefix character.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\+]{80,}(\\:(\\d{3}\\s+)*\\d{3})?</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [+.\d] greedily at least 80 times.<br/>
            ○ Optional (greedy).<br/>
                ○ 1st capture group.<br/>
                    ○ Match ':'.<br/>
                    ○ Loop greedily any number of times.<br/>
                        ○ 2nd capture group.<br/>
                            ○ Match a Unicode digit exactly 3 times.<br/>
                            ○ Match a whitespace character atomically at least once.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.GridShortenedSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\*]{1,9}(,[\\d\\.\\*]{1,9}){8}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.EliminationPattern">
            <remarks>
            Pattern:<br/>
            <code>(?&lt;=\\:)(\\d{3}\\s+)*\\d{3}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Zero-width positive lookbehind.<br/>
                ○ Match ':' right-to-left.<br/>
            ○ Loop greedily any number of times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
                    ○ Match a whitespace character atomically at least once.<br/>
            ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.Grid">
            <summary>
            Represents a sudoku grid that uses the mask list to construct the data structure.
            </summary>
            <remarks>
            <para><large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure></para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Grid.DefaultMask">
            <summary>
            Indicates the default mask of a cell (an empty cell, with all 9 candidates left).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.MaxCandidatesMask">
            <summary>
            Indicates the maximum candidate mask that used.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyMask">
            <summary>
            Indicates the empty mask, modifiable mask and given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.ModifiableMask">
            <summary>
            Indicates the modifiable mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.GivenMask">
            <summary>
            Indicates the given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CellsCount">
            <summary>
            Indicates the number of cells of a sudoku grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CellCandidatesCount">
            <summary>
            Indicates the number of candidates appeared in a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.HeaderShift">
            <summary>
            Indicates the shifting bits count for header bits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.SukakuHeader">
            <summary>
            Indicates ths header bits describing the sudoku type is a Sukaku.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyString">
            <summary>
            Indicates the empty grid string.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Empty">
            <summary>
            The empty grid that is valid during implementation or running the program (all values are <see cref="F:Sudoku.Concepts.Grid.DefaultMask"/>, i.e. empty cells).
            </summary>
            <remarks>
            This field is initialized by the static constructor of this structure.
            </remarks>
            <seealso cref="F:Sudoku.Concepts.Grid.DefaultMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Undefined">
            <summary>
            Indicates the default grid that all values are initialized 0. This value is equivalent to <see langword="default"/>(<see cref="T:Sudoku.Concepts.Grid"/>).
            </summary>
            <remarks>
            This value can be used for non-candidate-based sudoku operations, e.g. a sudoku grid canvas.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Grid.DefaultOptions">
            <inheritdoc cref="P:System.Text.Json.IJsonSerializable`1.DefaultOptions"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid._values">
            <summary>
            Indicates the inner array that stores the masks of the sudoku grid, which stores the in-time sudoku grid inner information.
            </summary>
            <remarks>
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0 |
            |-------------------|-----------|-----------------------------------|
            |    unused bits    | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
            '-------------------|-----------|-----------------------------------'
                                 \_________/ \_________________________________/
                                     (2)                     (1)
            </code>
            Here the 9 bits in (1) indicate whether each digit is possible candidate in the current cell for each bit respectively,
            and the higher 3 bits in (2) indicate the cell state. The possible cell state are:
            <list type="table">
            <listheader>
            <term>State name</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Empty cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Empty"/>)</term>
            <description>The cell is currently empty, and wait for being filled.</description>
            </item>
            <item>
            <term>Modifiable cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Modifiable"/>)</term>
            <description>The cell is filled by a digit, but the digit isn't the given by the initial grid.</description>
            </item>
            <item>
            <term>Given cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Given"/>)</term>
            <description>The cell is filled by a digit, which is given by the initial grid and can't be modified.</description>
            </item>
            </list>
            </remarks>
            <seealso cref="T:Sudoku.Concepts.CellState"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.#ctor(System.Int32@,Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the pointer of the first element of the cell digit, and the creating option.
            </summary>
            <param name="firstElement">The reference of the first element.</param>
            <param name="creatingOption">The creating option.</param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="firstElement"/> is <see langword="null"/> reference.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsSolved">
            <summary>
            Indicates the grid has already solved. If the value is <see langword="true"/>, the grid is solved; otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsUndefined">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Grid.Undefined"/>, which means the grid holds totally same value with <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsEmpty">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Grid.Empty"/>, which means the grid holds totally same value with <see cref="F:Sudoku.Concepts.Grid.Empty"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ContainsAnyMissingCandidates">
            <summary>
            Determines whether the current grid contains any missing candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivensCount">
            <summary>
            Indicates the total number of given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiablesCount">
            <summary>
            Indicates the total number of modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptiesCount">
            <summary>
            Indicates the total number of empty cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesCount">
            <summary>
            Indicates the number of total candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyHouses">
            <summary>
            <para>Indicates which houses are empty houses.</para>
            <para>An <b>Empty House</b> is a house holding 9 empty cells, i.e. all cells in this house are empty.</para>
            <para>
            The property returns a <see cref="T:System.Int32"/> value as a mask that contains all possible house indices.
            For example, if the row 5, column 5 and block 5 (1-9) are null houses, the property will return
            the result <see cref="T:System.Int32"/> value, <c>000010000_000010000_000010000</c> as binary.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.FullHouses">
            <summary>
            <para>Indicates which houses are completed, regardless of ways of filling.</para>
            <para><inheritdoc cref="P:Sudoku.Concepts.Grid.EmptyHouses" path="//summary/para[3]"/></para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Symmetry">
            <summary>
            Try to get the symmetry of the puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.PuzzleType">
            <summary>
            Indicates the type of the puzzle.
            </summary>
            <remarks>
            Although the property type supports for other values, this property can only return a value
            either <see cref="F:Sudoku.SudokuType.Standard"/> or <see cref="F:Sudoku.SudokuType.Sukaku"/>.
            </remarks>
            <seealso cref="F:Sudoku.SudokuType.Standard"/>
            <seealso cref="F:Sudoku.SudokuType.Sukaku"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivenCells">
            <summary>
            Gets a cell list that only contains the given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiableCells">
            <summary>
            Gets a cell list that only contains the modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid is empty.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.BivalueCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid contain two candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesMap">
            <summary>
            Indicates the map of possible positions of the existence of the candidate value for each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.DigitsMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of each digit. The return value will
            be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, this property contains all givens, modifiables and
            empty cells only if it contains the digit in the mask.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ValuesMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of that value of each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, the value only contains the given or modifiable
            cells whose mask contain the set bit of that digit.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Candidates">
            <summary>
            Indicates all possible candidates in the current grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ConjugatePairs">
            <summary>
            Indicates all possible conjugate pairs appeared in this grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetGrid">
            <summary>
            Gets the grid where all modifiable cells are empty cells (i.e. the initial one).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetCandidatesGrid">
            <summary>
            Gets the grid where all empty cells are filled with all possible candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.UnfixedGrid">
            <summary>
            Indicates the unfixed grid for the current grid, meaning all given digits will be replaced with modifiable ones.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.FixedGrid">
            <summary>
            Indicates the fixed grid for the current grid, meaning all modifiable digits will be replaced with given ones.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Collections#Generic#IReadOnlyCollection{System#Int32}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Numerics#IMinMaxValue{Sudoku#Concepts#Grid}#MinValue">
            <summary>
            Indicates the minimum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Numerics#IMinMaxValue{Sudoku#Concepts#Grid}#MaxValue">
            <summary>
            Indicates the maximum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Text#Json#IJsonSerializable{Sudoku#Concepts#Grid}#DefaultOptions">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@,System.Boolean,System.Char)">
            <summary>
            <inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/summary"/>
            </summary>
            <param name="cells"><inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/param[@name='cells']"/></param>
            <param name="withValueCells">
            Indicates whether the value cells (given or modifiable ones) will be included to be gathered.
            If <see langword="true"/>, all value cells (no matter what kind of cell) will be summed up.
            </param>
            <param name="mergingMethod">
            Indicates the merging method. Values are <c>'<![CDATA[&]]>'</c>, <c>'<![CDATA[|]]>'</c> and <c>'<![CDATA[~]]>'</c>.
            <list type="bullet">
            <item><c>'<![CDATA[&]]>'</c>: Use <b>bitwise and</b> operator to merge masks.</item>
            <item><c>'<![CDATA[|]]>'</c>: Use <b>bitwise or</b> operator to merge masks.</item>
            <item><c>'<![CDATA[~]]>'</c>: Use <b>bitwise nand</b> operator to merge masks.</item>
            </list>
            By default, the value is <c>'<![CDATA[|]]>'</c>.
            </param>
            <returns><inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/returns"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when <paramref name="mergingMethod"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Grid"/> instance hold the same values as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.DuplicateWith(System.Int32,System.Int32)">
            <summary>
            Determine whether the digit in the target cell may be duplicated with a certain cell in the peers of the current cell,
            if the digit is filled into the cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)">
            <summary>
            Sets a candidate existence case with a <see cref="T:System.Boolean"/> value.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <inheritdoc cref="M:Sudoku.Concepts.Grid.SetExistence(System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)">
            <summary>
            Indicates whether the current grid contains the digit in the specified cell.
            </summary>
            <param name="cell">The cell offset.</param>
            <param name="digit">The digit.</param>
            <returns>
            The method will return a <see cref="T:System.Boolean"/>? value
            (containing three possible cases: <see langword="true"/>, <see langword="false"/> and <see langword="null"/>).
            All values corresponding to the cases are below:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Case description on this value</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>
            The cell is an empty cell <b>and</b> contains the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            The cell is an empty cell <b>but doesn't</b> contain the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The cell is <b>not</b> an empty cell.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Note that the method will return a <see cref="T:System.Boolean"/>?, so you should use the code
            '<c>grid.Exists(cell, digit) is true</c>' or '<c>grid.Exists(cell, digit) == true</c>'
            to decide whether a condition is true.
            </para>
            <para>
            In addition, because the type is <see cref="T:System.Boolean"/>? rather than <see cref="T:System.Boolean"/>,
            the result case will be more precisely than the indexer <see cref="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)"/>,
            which is the main difference between this method and that indexer.
            </para>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CompareTo(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle type is Sukaku.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToCandidateMaskArray">
            <summary>
            Serializes this instance to an array, where all digit value will be stored.
            </summary>
            <returns>
            This array. All elements are the raw masks that between 0 and <see cref="F:Sudoku.Concepts.Grid.MaxCandidatesMask"/> (i.e. 511).
            </returns>
            <seealso cref="F:Sudoku.Concepts.Grid.MaxCandidatesMask"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetCandidates(System.Int32)">
            <summary>
            Get the candidate mask part of the specified cell.
            </summary>
            <param name="cell">The cell offset you want to get.</param>
            <returns>
            <para>
            The candidate mask. The return value is a 9-bit <see cref="T:System.Int16"/> value, where each bit will be:
            <list type="table">
            <item>
            <term><c>0</c></term>
            <description>The cell <b>doesn't contain</b> the possibility of the digit.</description>
            </item>
            <item>
            <term><c>1</c></term>
            <description>The cell <b>contains</b> the possibility of the digit.</description>
            </item>
            </list>
            </para>
            <para>
            For example, if the result mask is 266 (i.e. <c>0b<b>1</b>00_00<b>1</b>_0<b>1</b>0</c> in binary),
            the value will indicate the cell contains the digit 2, 4 and 9.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetState(System.Int32)">
            <summary>
            Get the cell state at the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The cell state.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigit(System.Int32)">
            <summary>
            Try to get the digit filled in the specified cell.
            </summary>
            <param name="cell">The cell used.</param>
            <returns>The digit that the current cell filled. If the cell is empty, return -1.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified cell keeps a wrong cell state value. For example, <see cref="F:Sudoku.Concepts.CellState.Undefined"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Reset">
            <summary>
            Reset the sudoku grid, making all modifiable values to empty ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ResetCandidates">
            <summary>
            Reset the sudoku grid, but only making candidates to be reset to the initial state related to the current grid
            from given and modifiable values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Fix">
            <summary>
            To fix the current grid (all modifiable values will be changed to given ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Unfix">
            <summary>
            To unfix the current grid (all given values will be changed to modifiable ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Apply(Sudoku.Concepts.Conclusion)">
            <summary>
            Try to apply the specified conclusion.
            </summary>
            <param name="conclusion">The conclusion to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetState(System.Int32,Sudoku.Concepts.CellState)">
            <summary>
            Set the specified cell to the specified state.
            </summary>
            <param name="cell">The cell.</param>
            <param name="state">The state.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetMask(System.Int32,System.Int16)">
            <summary>
            Set the specified cell to the specified mask.
            </summary>
            <param name="cell">The cell.</param>
            <param name="mask">The mask to set.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ReplaceDigit(System.Int32,System.Int32)">
            <summary>
            Replace the specified cell with the specified digit.
            </summary>
            <param name="cell">The cell to be set.</param>
            <param name="digit">The digit to be set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="digit"/> is invalid (e.g. -1).</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetDigit(System.Int32,System.Int32)">
            <summary>
            Set the specified digit into the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">
            <para>
            The value you want to set. The value should be between 0 and 8.
            If assigning -1, the grid will execute an implicit behavior that candidates in <b>all</b> empty cells will be re-computed.
            </para>
            <para>
            The values set into the grid will be regarded as the modifiable values.
            If the cell contains a digit, it will be covered when it is a modifiable value.
            If the cell is a given cell, the setter will do nothing.
            </para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetExistence(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the target candidate state.
            </summary>
            <param name="cell">The cell offset between 0 and 80.</param>
            <param name="digit">The digit between 0 and 8.</param>
            <param name="isOn">
            The case you want to set. <see langword="false"/> means that this candidate
            doesn't exist in this current sudoku grid; otherwise, <see langword="true"/>.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#IEquatable{Sudoku#Concepts#Grid}#Equals(Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#IComparable{Sudoku#Concepts#Grid}#CompareTo(Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Text#Json#IJsonSerializable{Sudoku#Concepts#Grid}#ToJsonString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#Grid,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#Grid,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHeaderBits(System.Int32)">
            <summary>
            Gets the header 4 bits. The value can be <see cref="F:Sudoku.SudokuType.Sukaku"/> if and only if the puzzle is Sukaku,
            and the argument <paramref name="cell"/> is 0.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The header 4 bits, represented as a <see cref="T:System.Int16"/>, left-shifted.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHeaderBitsUnshifted(System.Int32)">
            <summary>
            Gets the header 4 bits. The value can be <see cref="F:Sudoku.SudokuType.Sukaku"/> if and only if the puzzle is Sukaku,
            and the argument <paramref name="cell"/> is 0.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The header 4 bits, represented as a <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetMap()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Grid.EmptyCells"/> and <see cref="P:Sudoku.Concepts.Grid.BivalueCells"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The map.</returns>
            <seealso cref="P:Sudoku.Concepts.Grid.EmptyCells"/>
            <seealso cref="P:Sudoku.Concepts.Grid.BivalueCells"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetMaps()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, <see cref="P:Sudoku.Concepts.Grid.DigitsMap"/> and <see cref="P:Sudoku.Concepts.Grid.ValuesMap"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The map indexed by each digit.</returns>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
            <seealso cref="P:Sudoku.Concepts.Grid.DigitsMap"/>
            <seealso cref="P:Sudoku.Concepts.Grid.ValuesMap"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Preserve(Sudoku.Concepts.CellMap@)">
            <summary>
            Gets a sudoku grid, removing all value digits not appearing in the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.AddSukakuHeader">
            <summary>
            Appends for Sukaku puzzle header.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.RemoveSukakuHeader">
            <summary>
            Removes for Sukaku puzzle header.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int32[],Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using grid values.
            </summary>
            <param name="gridValues">The array of grid values.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int16[])">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance with the specified mask array.
            </summary>
            <param name="masks">The masks.</param>
            <exception cref="T:System.ArgumentException">Throws when <see cref="P:System.Array.Length"/> is out of valid range.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int32},Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the array of cell digits
            of type <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Int32"/>.
            </summary>
            <param name="gridValues">The list of cell digits.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Text#Json#IJsonSerializable{Sudoku#Concepts#Grid}#FromJsonString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnValueChanged(Sudoku.Concepts.Grid@,System.Int32,System.Int16,System.Int16,System.Int32)">
            <summary>
            Event handler on value changed.
            </summary>
            <param name="this">The grid itself.</param>
            <param name="cell">Indicates the cell changed.</param>
            <param name="oldMask">Indicates the original mask representing the original digits in that cell.</param>
            <param name="newMask">Indicates the mask representing the digits updated.</param>
            <param name="setValue">
            Indicates the set value. If to clear the cell, the value will be -1.
            In fact, if the value is -1, this method will do nothing.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnRefreshingCandidates(Sudoku.Concepts.Grid@)">
            <summary>
            Event handler on refreshing candidates.
            </summary>
            <param name="this">The grid itself.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int16})">
            <summary>
            Returns a <see cref="T:Sudoku.Concepts.Grid"/> instance via the raw mask values.
            </summary>
            <param name="rawMaskValues">
            <para>The raw mask values.</para>
            <para>
            This value can contain 1 or 81 elements.
            If the array contain 1 element, all elements in the target sudoku grid will be initialized by it, the uniform value;
            if the array contain 81 elements, elements will be initialized by the array one by one using the array elements respectively.
            </para>
            </param>
            <returns>A <see cref="T:Sudoku.Concepts.Grid"/> result.</returns>
            <remarks><b><i>
            This creation ignores header bits. Please don't use this method in the puzzle creation.
            </i></b></remarks>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Explicit(System.Int16[])~Sudoku.Concepts.Grid">
            <summary>
            Converts the specified array elements into the target <see cref="T:Sudoku.Concepts.Grid"/> instance, without any value boundary checking.
            </summary>
            <param name="maskArray">An array of the target mask. The array must be of a valid length.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_CheckedExplicit(System.Int16[])~Sudoku.Concepts.Grid">
            <summary>
            Converts the specified array elements into the target <see cref="T:Sudoku.Concepts.Grid"/> instance, with value boundary checking.
            </summary>
            <param name="maskArray">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.op_Explicit(System.Int16[])~Sudoku.Concepts.Grid" path="/param[@name='maskArray']"/>
            </param>
            <exception cref="T:System.ArgumentException">
            Throws when at least one element in the mask array is greater than 0b100__111_111_111 (i.e. 2559) or less than 0.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Equality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Inequality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Equality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Inequality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_GreaterThan(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_LessThan(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_GreaterThanOrEqual(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_LessThanOrEqual(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_GreaterThan(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_LessThan(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Grid,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Predicate">
            <summary>
            Represents a list of methods to filter the cells.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Predicate.GivenCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a given cell.
            </summary>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Predicate.ModifiableCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a modifiable cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.Predicate.GivenCells(Sudoku.Concepts.Grid@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Predicate.EmptyCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is an empty cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.Predicate.GivenCells(Sudoku.Concepts.Grid@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Predicate.BivalueCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a bi-value cell, which means the cell is an empty cell,
            and contains and only contains 2 candidates.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.Predicate.GivenCells(Sudoku.Concepts.Grid@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Predicate.CandidatesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell.
            </summary>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Predicate.DigitsMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell, or whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.Predicate.CandidatesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Predicate.ValuesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Checks whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.Predicate.CandidatesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Sudoku.Concepts.GridComparison">
            <summary>
            Specifies the culture, case, and sort rules to be used by certain overloads of
            the <see cref="M:Sudoku.Concepts.Grid.CompareTo(Sudoku.Concepts.Grid@)"/> and <see cref="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)"/> methods.
            </summary>
            <seealso cref="M:Sudoku.Concepts.Grid.CompareTo(Sudoku.Concepts.Grid@)"/>
            <seealso cref="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="F:Sudoku.Concepts.GridComparison.Default">
            <summary>
            Indicates two <see cref="T:Sudoku.Concepts.Grid"/> instances only compares internal <see cref="T:System.Int16"/> values one by one.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridComparison.IncludingTransforms">
            <summary>
            Indicates two <see cref="T:Sudoku.Concepts.Grid"/> instances compares not only internal values, but its all possible transformations.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridCreatingOption">
            <summary>
            Indicates the grid creating option.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.None">
            <summary>
            Indicates the option is none.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.MinusOne">
            <summary>
            Indicates each value should minus one before creation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.HouseMarshal">
            <summary>
            Represents a list of extension methods that operates with house instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseMarshal.ToHouseType(System.Int32)">
            <summary>
            Get the house type for the specified house index.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>
            The house type. The possible return values are:
            <list type="table">
            <listheader>
            <term>House indices</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 0 and < 9]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Block"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 9 and < 18]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Row"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 18 and < 27]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Column"/></description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseType">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/House.html">house type</see>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Block">
            <summary>
            Indicates the house type is a block.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Row">
            <summary>
            Indicates the house type is a row.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Column">
            <summary>
            Indicates the house type is a column.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.IBitStatusMap`3">
            <summary>
            Extracts a base type that describes state table from elements of <typeparamref name="TSelf"/> type.
            </summary>
            <typeparam name="TSelf">The type of the instance that implements this interface type.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.StringChunks">
            <summary>
            Gets all chunks of the current collection, meaning a list of <see cref="T:System.String"/> values that can describe
            all cell and candidate indices, grouped with same row/column.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.PeerIntersection">
            <summary>
            Indicates the peer intersection of the current instance.
            </summary>
            <remarks>
            A <b>Peer Intersection</b> is a set of cells that all cells from the base collection can be seen.
            For more information please visit <see href="http://sudopedia.enjoysudoku.com/Peer.html">this link</see>.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Shifting">
            <summary>
            Indicates the size of each unit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Empty">
            <summary>
            Indicates an empty instance containing no elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Full">
            <summary>
            Indicates an instance that contains all possible elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.MaxCount">
            <summary>
            Indicates the maximum number of elements that the collection can be reached.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.JsonConverterInstance">
            <summary>
            Indicates a converter instance that supports for serialization on the current instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IAdditiveIdentity{TSelf,TSelf}#AdditiveIdentity">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IMinMaxValue{TSelf}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IMinMaxValue{TSelf}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Text#Json#IJsonSerializable{TSelf}#DefaultOptions">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.AddRange(System.ReadOnlySpan{`1})">
            <summary>
            Adds a list of offsets into the current collection.
            </summary>
            <param name="offsets">
            <para>Offsets to be added.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>The number of offsets succeeded to be added.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.RemoveRange(System.ReadOnlySpan{`1})">
            <summary>
            Removes a list of offsets from the current collection.
            </summary>
            <param name="offsets">
            <para>Offsets to be removed.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>The number of offsets succeeded to be removed.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.CopyTo(`1@,System.Int32)">
            <summary>
            Copies the current instance to the target sequence specified as a reference
            to an element of type <typeparamref name="TElement"/>.
            </summary>
            <param name="sequence">
            The reference that points to the first element in a sequence of type <typeparamref name="TElement"/>.
            </param>
            <param name="length">The length of that array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="sequence"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Throws when the capacity isn't enough to store all values.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.ForEach(System.Action{`1})">
            <summary>
            Iterates on each element in this collection.
            </summary>
            <param name="action">The visitor that handles for each element in this collection.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Toggle(`1)">
            <summary>
            Try to toggle the offset, which means the value will be added if not exist in collection, or removed if exists.
            </summary>
            <param name="offset">The offset to be added or removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.IndexOf(`1)">
            <summary>
            Try to get the specified index of the offset.
            </summary>
            <param name="offset">The desired offset.</param>
            <returns>The index of the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Equals(`0@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.ToArray">
            <summary>
            Get all offsets whose bits are set <see langword="true"/>.
            </summary>
            <returns>An array of offsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Slice(System.Int32,System.Int32)">
            <summary>
            Slices the current instance, and get the new instance with some of elements between two indices.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The number of elements.</param>
            <returns>The target instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#CopyTo(`1[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#IEquatable{TSelf}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#ExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IntersectWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#UnionWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Linq#Providers#IContainsMethod{TSelf,TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Linq#Providers#ICountMethod{TSelf,TElement}#Count">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Text#Json#IJsonSerializable{TSelf}#ToJsonString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAt(System.Index)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAtOrDefault(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAtOrDefault(System.Index)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Linq#Providers#IGetSubsetMethod{TSelf,TElement}#GetSubsets(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#IParsable{TSelf}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Text#Json#IJsonSerializable{TSelf}#FromJsonString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_LogicalNot(`0@)">
            <summary>
            Determines whether the current collection is empty.
            </summary>
            <param name="offsets">The cells to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <remarks>
            The type of the current collection supports using <see cref="T:System.Boolean"/>-like expression to determine whether the collection is not empty,
            for example:
            <code><![CDATA[
            if (collection)
                // ...
            ]]></code>
            The statement <c>collection</c> will be expanded to <c>collection.Count != 0</c>. Therefore, the negation operator <c>!</c>
            will invert the result of above expression. This is why I use <see langword="operator"/> <c>!</c> to determine on this.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_OnesComplement(`0@)">
            <summary>
            Reverse state for all offsets, which means all <see langword="true"/> bits
            will be set <see langword="false"/>, and all <see langword="false"/> bits
            will be set <see langword="true"/>.
            </summary>
            <param name="offsets">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_True(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is not empty.
            </summary>
            <param name="cells">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_False(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is empty.
            </summary>
            <param name="cells">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Addition(`0@,`1)">
            <summary>
            Adds the specified <paramref name="offset"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be added.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Subtraction(`0@,`1)">
            <summary>
            Removes the specified <paramref name="offset"/> from the <paramref name="collection"/>,
            and returns the removed result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_BitwiseAnd(`0@,`0@)">
            <summary>
            Get the elements that both <paramref name="left"/> and <paramref name="right"/> contain.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_BitwiseOr(`0@,`0@)">
            <summary>
            Combine the elements from <paramref name="left"/> and <paramref name="right"/>,
            and return the merged result.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_ExclusiveOr(`0@,`0@)">
            <summary>
            Get the elements that either <paramref name="left"/> or <paramref name="right"/> contains.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_RightShift(`0@,System.Int32)">
            <summary>
            Calculates all subsets of the current <typeparamref name="TSelf"/> instance,
            with the specified value as the result number of elements in each subset.
            </summary>
            <param name="map">The map to be checked.</param>
            <param name="subsetSize">The subset size for each result element.</param>
            <returns>
            A list of <typeparamref name="TSelf"/> instances
            whose number of elements is equal to <paramref name="subsetSize"/> as its subsets.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_UnsignedRightShift(`0@,System.Int32)">
            <summary>
            Calculates all subsets of the current <typeparamref name="TSelf"/> instance,
            with the specified value as the maximum number of elements in each subset.
            </summary>
            <param name="map">The map to be checked.</param>
            <param name="subsetSize">The subset size for each result element.</param>
            <returns>
            A list of <typeparamref name="TSelf"/> instances
            whose number of elements is equal to or less than <paramref name="subsetSize"/> as its subsets.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_True(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_False(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_LogicalNot(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Equality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Inequality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IAdditionOperators{TSelf,TElement,TSelf}#op_Addition(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#ISubtractionOperators{TSelf,TElement,TSelf}#op_Subtraction(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IModulusOperators{TSelf,TSelf,TSelf}#op_Modulus(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_OnesComplement(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_ExclusiveOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_ExclusiveOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Inference">
            <summary>
            Defines an inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Strong">
            <summary>
            Indicates the inference is strong inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Weak">
            <summary>
            Indicates the inference is weak inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.StrongGeneralized">
            <summary>
            Indicates the inference is strong inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.WeakGeneralized">
            <summary>
            Indicates the inference is weak inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.ConjugatePair">
            <summary>
            Indicates the inference is conjugate pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Default">
            <summary>
            Indicates the inference is the default case that doesn't belong to above.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Intersection">
            <summary>
            Represents a pair of intersection information.
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="M:Sudoku.Concepts.Intersection.#ctor(Sudoku.Concepts.IntersectionBase@,Sudoku.Concepts.IntersectionResult@)">
            <summary>
            Represents a pair of intersection information.
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="P:Sudoku.Concepts.Intersection.Base">
            <summary>Indicates the base that describes the block and line index.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Intersection.Result">
            <summary>Indicates the result values.</summary>
        </member>
        <member name="F:Sudoku.Concepts.Intersection.MinilinesGroupedByChuteIndex">
            <summary>
            Indicates the mini-lines to be iterated, grouped by chute index.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Intersection.Map">
            <summary>
            <para>
            Indicates all maps that forms the each intersection. The pattern will be like:
            <code><![CDATA[
            .-------.-------.-------.
            | C C C | A A A | A A A |
            | B B B | . . . | . . . |
            | B B B | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            </para>
            <para>
            In addition, in this data pattern, a <b>CoverSet</b> is a block and a <b>BaseSet</b> is a line.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Intersection.IntersectionBlockTable">
            <summary>
            Indicates the internal intersection block combinations.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Intersection.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Concepts.IntersectionBase">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionBase.#ctor(System.Byte,System.Byte)">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionBase.Line">
            <summary>The index of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionBase.Block">
            <summary>The index of the block.</summary>
        </member>
        <member name="T:Sudoku.Concepts.IntersectionResult">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used,
            especially used by <see cref="F:Sudoku.Concepts.Intersection.Map"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Intersection.Map"/>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionResult.#ctor(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,System.Byte[])">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used,
            especially used by <see cref="F:Sudoku.Concepts.Intersection.Map"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Intersection.Map"/>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.LineMap">
            <summary>The map of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.BlockMap">
            <summary>The map of the block.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.IntersectionMap">
            <summary>The map of the intersection.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.OtherBlocks">
            <summary>
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.LockedTarget">
            <summary>
            Defines the data structure that stores a set of cells and a digit, indicating the information
            about the locked candidate node.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cells">Indicates the cells used.</param>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.#ctor(System.Int32,Sudoku.Concepts.CellMap)">
            <summary>
            Defines the data structure that stores a set of cells and a digit, indicating the information
            about the locked candidate node.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cells">Indicates the cells used.</param>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.IsSole">
            <summary>
            Indicates whether the number of cells is 1.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.DigitString">
            <summary>
            The digit string value.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.System#Text#Json#IJsonSerializable{Sudoku#Concepts#LockedTarget}#DefaultOptions">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Deconstruct(Sudoku.Concepts.CellMap@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Equals(Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#IEquatable{Sudoku#Concepts#LockedTarget}#Equals(Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Text#Json#IJsonSerializable{Sudoku#Concepts#LockedTarget}#ToJsonString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Text#Json#IJsonSerializable{Sudoku#Concepts#LockedTarget}#FromJsonString(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.Digit">
            <summary>
            The generated property declaration for parameter <c>digit</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.Cells">
            <summary>
            The generated property declaration for parameter <c>cells</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.op_Equality(Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.op_Inequality(Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Numerics#IEqualityOperators{Sudoku#Concepts#LockedTarget,Sudoku#Concepts#LockedTarget,System#Boolean}#op_Equality(Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Numerics#IEqualityOperators{Sudoku#Concepts#LockedTarget,Sudoku#Concepts#LockedTarget,System#Boolean}#op_Inequality(Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.MapCombinatorial">
            <summary>
            Represents some methods operating with <see cref="T:Sudoku.Concepts.IBitStatusMap`3"/> instances
            (i.e. <see cref="T:Sudoku.Concepts.CellMap"/> and <see cref="T:Sudoku.Concepts.CandidateMap"/>) to get subsets.
            </summary>
            <seealso cref="T:Sudoku.Concepts.IBitStatusMap`3"/>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="F:Sudoku.Concepts.MapCombinatorial.MaxLimit">
            <summary>
            Indicates the size of combinatorial calculation.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.MapCombinatorial.GetSubsets(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Gets the subsets of the current collection via the specified size indicating the number of elements of the each subset.
            </summary>
            <param name="this">The instance to check for subsets.</param>
            <param name="subsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="subsetSize"/> &gt; Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term><c><paramref name="subsetSize"/> == Count</c></term>
            <description>
            Will return an array that contains only one element, same as the current instance.
            </description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.NotSupportedException">
            Throws when both the count of the current instance and <paramref name="subsetSize"/> are greater than 30.
            </exception>
            <remarks>
            For example, if the current instance is <c>r1c1</c>, <c>r1c2</c> and <c>r1c3</c>
            and the argument <paramref name="subsetSize"/> is 2,
            the method will return an array of 3 elements given below: <c>r1c12</c>, <c>r1c13</c> and <c>r1c23</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.MapCombinatorial.GetSubsets(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.MapCombinatorial.GetSubsets(Sudoku.Concepts.CellMap@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.MapCombinatorial.GetSubsetsBelow(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Gets all subsets of the current collection via the specified size
            indicating the <b>maximum</b> number of elements of the each subset.
            </summary>
            <param name="this">The instance to check subsets.</param>
            <param name="limitSubsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="limitSubsetSize"/> &gt; Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.MapCombinatorial.GetSubsetsBelow(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.MapCombinatorial.GetSubsetsBelow(Sudoku.Concepts.CellMap@,System.Int32)"/>
        </member>
        <member name="T:Sudoku.Concepts.CollectionAddingHandler`2">
            <summary>
            The file-local handler on <see cref="T:Sudoku.Concepts.CellMap"/> and <see cref="T:Sudoku.Concepts.CandidateMap"/> adding operation, with a new element.
            </summary>
            <typeparam name="T">The result collection. The collection can be an array or a list.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <param name="result">The result instance.</param>
            <param name="cells">The values to be added.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="T:Sudoku.Concepts.Subview">
            <summary>
            Represents a list of methods that operates on <see cref="T:System.Int32"/>, <see cref="T:System.Int32"/>, <see cref="T:System.Int32"/> instances,
            with interactions on <see cref="T:Sudoku.Concepts.CellMap"/>, <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.Grid"/>, to describe subview-related logic.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Subview.ReduceCellByHouse(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Reduces the <see cref="T:Sudoku.Concepts.CellMap"/> instances, only checks for cells in the specified cells, and merge into a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="cells">The cells to be checked.</param>
            <param name="house">The house to be checked.</param>
            <returns>A <see cref="T:System.Int16"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Subview.ExpandedCellFromDigit(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Expands the current <see cref="T:Sudoku.Concepts.CellMap"/> instance, inserting into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance by specified digit.
            </summary>
            <param name="cells">The cells to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Subview.ReduceCandidateByDigit(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <summary>
            Reduces the <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, only checks for candidates whose digit is equal to argument <paramref name="digit"/>,
            and merge into a <see cref="T:Sudoku.Concepts.CellMap"/> value.
            </summary>
            <param name="candidates">The candidates to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CoordinateTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetConverter(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance via the specified <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <returns>
            A valid <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetParser(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance via the specified <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <returns>
            A valid <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetField(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:System.Reflection.FieldInfo"/> instance for the specified field.
            </summary>
            <param name="this">The type of the coordinate type.</param>
            <returns>The final <see cref="T:System.Reflection.FieldInfo"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseTypeExtensions">
            <summary>
            Provides extension methods on <see cref="T:Sudoku.Concepts.HouseType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.HouseType"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetLabel(Sudoku.Concepts.HouseType)">
            <summary>
            Try to get the label of the specified house type.
            </summary>
            <param name="this">The house type.</param>
            <returns>A character that represents a house type.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetProgramOrder(Sudoku.Concepts.HouseType)">
            <summary>
            Gets the ordering of the house type. The result value will be 0, 1 and 2.
            </summary>
            <param name="this">The house type.</param>
            <returns>The program order.</returns>
        </member>
        <member name="T:Sudoku.Concepts.InferenceExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Inference"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Inference"/>
        </member>
        <member name="M:Sudoku.Concepts.InferenceExtensions.ConnectingNotation(Sudoku.Concepts.Inference)">
            <summary>
            Gets connecting notation of the inference.
            </summary>
            <param name="this">The inference instance.</param>
            <returns>The connecting notation of the inference.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in the enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.ListBitStatusMapExtensions">
            <summary>
            Represents a list of extension methods operating with <see cref="T:System.Collections.Generic.List`1"/>
            of <see cref="T:Sudoku.Concepts.IBitStatusMap`3"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
            <seealso cref="T:Sudoku.Concepts.IBitStatusMap`3"/>
        </member>
        <member name="T:Sudoku.Concepts.ListGridExtensions">
            <summary>
            Represents a list of extension methods operating with <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="T:Sudoku.Concepts.SymmetricTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.SymmetricType"/>.
            </summary>
            <seealso cref="T:Sudoku.SymmetricType"/>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetSymmetryCellsCount(Sudoku.SymmetricType)">
            <summary>
            Try to get the number of cells that the current symmetry should be formed a complete symmetric pattern.
            </summary>
            <param name="this">The symmetric type.</param>
            <returns>
            The number of cells should form a complete pattern:
            <list type="table">
            <listheader>
            <term>Argument</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><see cref="F:Sudoku.SymmetricType.None"/> (0)</term>
            <description>1 (Itself)</description>
            </item>
            <item>
            <term>
            <see cref="F:Sudoku.SymmetricType.Central"/>,
            <see cref="F:Sudoku.SymmetricType.Diagonal"/>, <see cref="F:Sudoku.SymmetricType.AntiDiagonal"/>,
            <see cref="F:Sudoku.SymmetricType.XAxis"/>, <see cref="F:Sudoku.SymmetricType.YAxis"/>
            </term>
            <description>2</description>
            </item>
            <item>
            <term>The other defined values</term>
            <description>4</description>
            </item>
            <item>
            <term>Otherwise</term>
            <description><see cref="T:System.ArgumentOutOfRangeException"/> thrown</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetAxisDimension(Sudoku.SymmetricType)">
            <summary>
            Try to get the number of axes of the specified symmetric type.
            </summary>
            <param name="this">The symmetry.</param>
            <returns>
            The number of axes the current symmetric type contains.
            If <paramref name="this"/> is <see cref="F:Sudoku.SymmetricType.None"/>, -1 will be returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="this"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetName(Sudoku.SymmetricType,System.IFormatProvider)">
            <summary>
            Gets the name of thr symmetry.
            </summary>
            <param name="this">The symmetry value.</param>
            <param name="formatProvider">The culture.</param>
            <returns>The string.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the argument holds multiple flag values.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCellsInSymmetryAxis(Sudoku.SymmetricType)">
            <summary>
            Try to get all possible cells in symmetry axis (or point).
            </summary>
            <param name="this">The symmetry.</param>
            <returns>Returns cells in the symmetry axis (or point).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined or <see cref="F:Sudoku.SymmetricType.None"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)"/>
            <param name="this"><inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)"/></param>
            <param name="cell">Indicates the target cell to be checked.</param>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)">
            <summary>
            Get the cells that is used for swapping via the specified symmetric type, and the specified row and column value.
            </summary>
            <param name="this">The symmetric type.</param>
            <param name="row">The row value.</param>
            <param name="column">The column value.</param>
            <returns>The cells.</returns>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionExtensions.AsSet(Sudoku.Concepts.Conclusion[])">
            <summary>
            Converts the <see cref="T:Sudoku.Concepts.Conclusion"/> array into a <see cref="T:Sudoku.Concepts.ConclusionSet"/> instance.
            </summary>
            <param name="this">The conclusion array.</param>
            <returns>A <see cref="T:Sudoku.Concepts.ConclusionSet"/> result.</returns>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.ConclusionType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.ConclusionType"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionTypeExtensions.GetNotation(Sudoku.Concepts.ConclusionType)">
            <summary>
            Gets the notation of the conclusion type.
            </summary>
            <param name="this">The conclusion type kind.</param>
            <returns>The string representation of the conclusion kind.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.Linq.BitStatusMapGrouping`4">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.#ctor(`3,`0@)">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Count">
            <summary>
            Indicates the number of values stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>, i.e. the shorthand of expression <c>Values.Count</c>.
            </summary>
            <seealso cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Item(System.Int32)">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Item(System.Int32)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.Deconstruct(`3@,`0@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.Equals(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An enumerator object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.CreateMapByKeys(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,System.Int32}})">
            <summary>
            Makes a <see cref="T:Sudoku.Concepts.CellMap"/> instance that is concatenated by a list of groups
            of type <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/>, adding their keys.
            </summary>
            <param name="groups">The groups.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#IEquatable{Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey}}#Equals(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Linq#Providers#IWhereMethod{TMap,TElement}#Where(System.Func{`1,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Linq#Providers#ISelectMethod{TMap,TElement}#Select``1(System.Func{`1,``0})">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Key">
            <summary>
            The generated property declaration for parameter <c>key</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Values">
            <summary>
            The generated property declaration for parameter <c>values</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.op_Equality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@,Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.op_Inequality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@,Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Numerics#IEqualityOperators{Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Equality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3},Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Numerics#IEqualityOperators{Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Inequality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3},Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Linq.BitStatusMapGroupingEnumerable">
            <summary>
            Represents a list of LINQ methods used by <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Where``4(Sudoku.Linq.BitStatusMapGrouping{``0,``1,``2,``3},System.Func{``1,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
            <typeparam name="TMap">
            The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.
            </typeparam>
            <typeparam name="TElement">
            The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>A (An) <typeparamref name="TElement"/>[] that contains elements from the input sequence that satisfy the condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Select``5(Sudoku.Linq.BitStatusMapGrouping{``0,``1,``2,``3},System.Func{``1,``4})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/summary"/>
            </summary>
            <typeparam name="TMap">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGrouping`4" path="/typeparam[@name='TMap']"/>
            </typeparam>
            <typeparam name="TElement">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGrouping`4" path="/typeparam[@name='TElement']"/>
            </typeparam>
            <typeparam name="TKey">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGrouping`4" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <typeparam name="TEnumerator">
            The type of enumerator.
            </typeparam>
            <typeparam name="TResult">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TResult']"/>
            </typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="selector">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='selector']"/>
            </param>
            <returns>
            An array of <typeparamref name="TResult"/> instances whose elements are the result of invoking the transform function
            on each element of the current instance.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0}},System.Func{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> of types <see cref="T:Sudoku.Concepts.CellMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results and merge
            into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0}},System.Func{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> of types <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results
            and merge into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:Sudoku.Linq.CandidateMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CandidateMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.FirstOrNull(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.FirstOrNull(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Select``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Where(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CandidateMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CandidateMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CandidateMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.GroupBy``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.SelectMany``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each candidate (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CandidateMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Any(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.All(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.CellMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CellMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.FirstOrNull(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.FirstOrNull(Sudoku.Concepts.CellMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element in the current instance into the target-typed <typeparamref name="TResult"/> array,
            using the specified function to convert.
            </summary>
            <typeparam name="TResult">The type of target value.</typeparam>
            <param name="this">The current instance.</param>
            <param name="selector">The selector.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Where(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CellMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CellMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CellMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function.
            </summary>
            <typeparam name="TKey">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <param name="this">The current instance.</param>
            <param name="keySelector">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='keySelector']"/>
            </param>
            <returns>
            A list of <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> instances where each value object contains a sequence of objects and a key.
            </returns>
            <seealso cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.SelectMany``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each cell (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CellMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Any(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.All(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.ConclusionsEnumerable">
            <summary>
            Provides with a list of LINQ methods used by <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="M:Sudoku.Linq.ConclusionsEnumerable.Select(System.ReadOnlySpan{Sudoku.Concepts.Conclusion},System.Func{Sudoku.Concepts.Conclusion,System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Concepts.Conclusion"/> instances, converted each instances into a <see cref="T:System.Int32"/> value,
            and merge them into a <see cref="T:Sudoku.Concepts.CellMap"/> and return it.
            </summary>
            <param name="this">A list of <see cref="T:Sudoku.Concepts.Conclusion"/> instances.</param>
            <param name="selector">The selector to project the values.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.GridEnumerable">
            <summary>
            Provides with a list of LINQ methods operating with <see cref="T:Sudoku.Concepts.Grid"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Where(Sudoku.Concepts.Grid@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters the candidates that satisfies the specified condition.
            </summary>
            <param name="this">The instance to be iterated.</param>
            <param name="predicate">The condition to filter candidates.</param>
            <returns>All candidates satisfied the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Select``1(Sudoku.Concepts.Grid@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
            <typeparam name="TResult">The type of the value returned by <paramref name="selector"/>.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>
            An array of <typeparamref name="TResult"/> elements converted.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.HouseMaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int32"/>.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Select``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.SelectMany``1(System.Int32,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int32"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int32"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Where(System.Int32,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.ListEnumerable">
            <summary>
            Represents a list of LINQ methods to be used for type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CellMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in sourece.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CandidateMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in sourece.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.MaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int16"/>.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Select``1(System.Int16,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.SelectMany``1(System.Int16,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int16"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>, flattens the resulting sequence into one sequence,
            and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int16"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Where(System.Int16,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int16"/> result.</returns>
        </member>
        <member name="T:Sudoku.ModuleInitializer">
            <target name="type">
				<summary>
					<para>
						Provides with the type that contains a module initializer method, called automatically by the CLR
						(Common Language Runtime) to initialize some values.
					</para>
					<para>
						<i>
							The type is called by the compiler and the CLR (Common Language Runtime),
							which means you cannot use any members in this type manually.
						</i>
					</para>
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.ModuleInitializer.Initialize">
            <target name="method">
				<summary>
					Called by the runtime automatically while booting on this solution to initialize the values,
					data members or any other things that can or should be initialized here.
				</summary>
				<remarks>
					The concept <b>module</b> is different with <b>assembly</b>.
					The solution can contain multiple assemblies, while each assembly can contain multiple modules.
					However, due to the design of Visual Studio project file system, each assembly will only contain
					one module by default.
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Randomization.Randomizer">
            <summary>
            Provides with extension methods for <see cref="T:System.Random"/>.
            </summary>
            <seealso cref="T:System.Random"/>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.NextDigit(System.Random)">
            <summary>
            Returns a random integer that is within valid digit range (0..9).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.NextCell(System.Random)">
            <summary>
            Returns a random integer that is within valid cell range (0..81).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.NextHouse(System.Random)">
            <summary>
            Returns a random integer that is within valid house range (0..27).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.RandomlySelect(System.Random,Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Randomly select the specified number of elements from the current collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="cells">The cells to be chosen.</param>
            <param name="count">The desired number of elements.</param>
            <returns>The specified number of elements returned, represented as a <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.RandomlySelect(System.Random,Sudoku.Concepts.CandidateMap@,System.Int32)">
            <summary>
            Randomly select the specified number of elements from the current collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="cells">The cells to be chosen.</param>
            <param name="count">The desired number of elements.</param>
            <returns>The specified number of elements returned, represented as a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.CreateCellMap(System.Random,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance, with the specified number of <see cref="T:System.Int32"/>s stored in the collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="count">The desired number of elements.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.CreateCandidateMap(System.Random,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, with the specified number of <see cref="T:System.Int32"/>s stored in the collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="count">The desired number of elements.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Resources.CoreResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.BlockLabel">
            <summary>
              Looks up a localized string similar to Block {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CandidateLabel">
            <summary>
              Looks up a localized string similar to {0}, digit {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellLabel">
            <summary>
              Looks up a localized string similar to row {0} column {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellsLabel">
            <summary>
              Looks up a localized string similar to cells: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ColumnLabel">
            <summary>
              Looks up a localized string similar to Column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ColumnName">
            <summary>
              Looks up a localized string similar to Column.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ConjugatePairWith">
            <summary>
              Looks up a localized string similar to {0} conjugates with {1}, for digit {2}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.DigitName">
            <summary>
              Looks up a localized string similar to Digit.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Error_ArgExtensionShouldBeValid">
            <summary>
              Looks up a localized string similar to The argument should contains the prefix period token..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Error_UnrecognizedGridFormat">
            <summary>
              Looks up a localized string similar to You cannot append text that cannot be recognized as a valid sudoku grid..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_CannotAssignSuccessForFailureCases">
            <summary>
              Looks up a localized string similar to Cannot assign success field to describe such failure..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_CellsShouldInSameLine">
            <summary>
              Looks up a localized string similar to Two cells must be in a same line (row or column)..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_ComparableGridMustBeStandard">
            <summary>
              Looks up a localized string similar to The puzzle can be comparable if it must be a standard sudoku..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_ContainsEmptySegmentOnParsing">
            <summary>
              Looks up a localized string similar to The string contains empty segment..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_DifferentExistenceOfConfigAndLibraryFile">
            <summary>
              Looks up a localized string similar to Different existence of config file and library file..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_DuplicatedValuesMayExistOrInvalid">
            <summary>
              Looks up a localized string similar to Duplicated or invalid values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_FileShouldBeInitializedFirst">
            <summary>
              Looks up a localized string similar to Related files should be initialized first..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridInvalid">
            <summary>
              Looks up a localized string similar to The grid is invalid - it may contain invalid internal data, or it is invalid as an argument to the method..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridInvalidCellState">
            <summary>
              Looks up a localized string similar to The grid cannot keep invalid cell state value..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridMultipleSolutions">
            <summary>
              Looks up a localized string similar to The grid contains multiple solutions..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridNoSolution">
            <summary>
              Looks up a localized string similar to The grid has no possible solution..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_InvalidStateOnParsing">
            <summary>
              Looks up a localized string similar to Invalid state on parsing values..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_LengthMustBeMatched">
            <summary>
              Looks up a localized string similar to The length of the string must be {0}..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_LibraryShouldBeInitialized">
            <summary>
              Looks up a localized string similar to The library is not initialized. It must be initialized file, ensuring the file in local exists..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MinLexShouldBeUniqueAndNotSukaku">
            <summary>
              Looks up a localized string similar to The puzzle should be standard sudoku puzzle, and contain a unique solution..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleChuteValuesFound">
            <summary>
              Looks up a localized string similar to Multiple chute values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleConjugatePairValuesFound">
            <summary>
              Looks up a localized string similar to Multiple conjuagte pair values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleFlagsExist">
            <summary>
              Looks up a localized string similar to Multiple flags exist. The method only allows the enumeration field only holds one flag value..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleSamePropertiesFound">
            <summary>
              Looks up a localized string similar to Multiple same properties are found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NoElementsInSequence">
            <summary>
              Looks up a localized string similar to No possible elements can be found in the current sequence..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NotExist">
            <summary>
              Looks up a localized string similar to The file does not exist..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NotSupportedForSukakuPuzzles">
            <summary>
              Looks up a localized string similar to This function does not support for Sukaku puzzles..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_PlaceholderMustBeZeroOrDot">
            <summary>
              Looks up a localized string similar to The placeholder character invalid; expected: &apos;0&apos; or &apos;.&apos;..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_PointerCannotMove">
            <summary>
              Looks up a localized string similar to The pointer cannot move..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_StringValueInvalidToBeParsed">
            <summary>
              Looks up a localized string similar to The string value is invalid to be parsed..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_SubsetsExceeded">
            <summary>
              Looks up a localized string similar to Both cells count and subset size is too large, which may cause potential out of memory exception. This operator will throw this exception to calculate the result, in order to prevent any possible exceptions thrown..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.HousesLabel">
            <summary>
              Looks up a localized string similar to houses: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.LockedCandidatesLabel">
            <summary>
              Looks up a localized string similar to {0} {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaColumnLabel">
            <summary>
              Looks up a localized string similar to Mega column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaLinesLabel">
            <summary>
              Looks up a localized string similar to Mega lines: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaRowLabel">
            <summary>
              Looks up a localized string similar to Mega row {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Message_LibraryInitializedException">
            <summary>
              Looks up a localized string similar to The library (local path: &apos;{0}\{1}&apos;) has already been initialized..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.RowLabel">
            <summary>
              Looks up a localized string similar to Row {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.RowName">
            <summary>
              Looks up a localized string similar to Row.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_All">
            <summary>
              Looks up a localized string similar to All symmetry.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_AntiDiagonal">
            <summary>
              Looks up a localized string similar to Anti-diagonal.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_AxisBoth">
            <summary>
              Looks up a localized string similar to Both axes.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_Central">
            <summary>
              Looks up a localized string similar to Central.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_Diagonal">
            <summary>
              Looks up a localized string similar to Diagonal.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_DiagonalBoth">
            <summary>
              Looks up a localized string similar to Both diagonals.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_None">
            <summary>
              Looks up a localized string similar to No symmetry.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_XAxis">
            <summary>
              Looks up a localized string similar to X axis.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_YAxis">
            <summary>
              Looks up a localized string similar to Y axis.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.HouseMaskOperations">
            <summary>
            Represents a list of methods handling with <see cref="T:System.Int32"/> instances.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllBlocksMask">
            <summary>
            Indicates the mask that means all blocks.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllRowsMask">
            <summary>
            Indicates the mask that means all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllColumnsMask">
            <summary>
            Indicates the mask that means all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllHousesMask">
            <summary>
            Indicates the mask that means all houses.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.HouseMaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int32"/> instance via the specified houses.
            </summary>
            <param name="houses">The houses.</param>
            <returns>A <see cref="T:System.Int32"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.HouseMaskOperations.SplitMask(System.Int32)">
            <summary>
            Try to split mask into three parts.
            </summary>
            <param name="this">The mask to be split.</param>
            <returns>The mask split.</returns>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.MaskOperations">
            <summary>
            Provides with a set of methods that operates with mask defined in basic sudoku concepts, as data structures.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int16" /> instance via the specified digits.
            </summary>
            <param name="digits">
            <para>Indicates the digits to assign.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>A <see cref="T:System.Int16" /> instance.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.Collections.Generic.HashSet{System.Int32})">
            <inheritdoc cref="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.ReadOnlySpan{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToDigits(System.Int16)">
            <summary>
            To get the digits that the current mask represents for. The mask must be between 0 and 512, and exclude 512.
            </summary>
            <param name="digitMask">The digit mask.</param>
            <returns>The digits returned.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToSudokuType(System.Int16)">
            <summary>
            To get the sudoku type for the specified cell mask inside a <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The cell mask.</param>
            <returns>The sudoku type configured.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToCellState(System.Int16)">
            <summary>
            To get the cell state for a mask value. The mask is an inner representation to describe a cell's state.
            For more information please visit the details of the design for type <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The mask.</param>
            <returns>The cell state.</returns>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.GetMaskSubsets(System.Int16)">
            <summary>
            Get all mask combinations.
            </summary>
            <param name="value">The mask.</param>
            <returns>The result list.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.GetMaskSubsets(System.Int16,System.Int32)">
            <summary>
            Get all mask combinations.
            </summary>
            <param name="value">The mask.</param>
            <param name="size">The size.</param>
            <returns>The result list.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.SplitMask(System.Int16)">
            <summary>
            Try to split a mask into 3 parts, 3-bit as a unit.
            </summary>
            <param name="this">The mask instance to be split.</param>
            <returns>A triplet of values.</returns>
        </member>
        <member name="T:Sudoku.SolutionFields">
            <summary>
            Provides with solution-wide read-only fields used.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.PeersCount">
            <summary>
            Indicates the number of each cell's peer cells. The value is a constant.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.TrailingZeroCountFallback">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L586">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>
        </member>
        <member name="F:Sudoku.SolutionFields.TrailingZeroCountFallbackLong">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L647">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>
        </member>
        <member name="F:Sudoku.SolutionFields.Digits">
            <summary>
            Indicates the digits used. The value can be also used for ordered houses by rows.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesOrderedByColumn">
            <summary>
            Indicates the houses ordered by column.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseFirst">
            <summary>
            Indicates the first cell offset for each house.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesCells">
            <summary>
            <para>
            The map of all cell offsets in its specified house.
            The indices is between 0 and 26, where:
            <list type="table">
            <item>
            <term><c>0..9</c></term>
            <description>Block 1 to 9.</description>
            </item>
            <item>
            <term><c>9..18</c></term>
            <description>Row 1 to 9.</description>
            </item>
            <item>
            <term><c>18..27</c></term>
            <description>Column 1 to 9.</description>
            </item>
            </list>
            </para>
            </summary>
            <example>
            '<c>HouseCells[0]</c>': all cell offsets in the house 0 (block 1).
            </example>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the cells belong to a house at the specified index.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.PeersMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the peer cells of a cell at the specified index.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.Chutes">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.Chute"/> instances representing chutes.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ChuteHouses">
            <summary>
            Indicates the chute house triplets.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseTypes">
            <summary>
            Indicates the possible house types to be iterated.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.BlockTable">
            <summary>
            Indicates a block list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.RowTable">
            <summary>
            Indicates a row list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ColumnTable">
            <summary>
            Indicates a column list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.CellMaps">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances that are initialized as singleton element by its corresponding index.
            For example, <c>CellMaps[0]</c> is to <c>CellMap.Empty + 0</c>, i.e. <c>r1c1</c>.
            </summary>
        </member>
        <member name="M:Sudoku.SolutionFields.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.SudokuType">
            <summary>
            Represents a type of sudoku puzzle.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.SudokuType.None">
            <summary>
            The placeholder of the enumeration field.
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.Standard">
            <summary>
            Indicates the sudoku puzzle is a standard.
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.Sukaku">
            <summary>
            Indicates the sudoku puzzle is a sukaku (pencilmark sudoku).
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.JustOneCell">
            <summary>
            Indicates the sudoku puzzle is a just-one-cell sudoku.
            </summary>
        </member>
        <member name="T:Sudoku.SymmetricType">
            <summary>
            Represents a symmetric type that can describe which one a pattern or a puzzle uses.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.SymmetricType.None">
            <summary>
            Indicates none of symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.Central">
            <summary>
            Indicates the central symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.Diagonal">
            <summary>
            Indicates the diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.AntiDiagonal">
            <summary>
            Indicates the anti-diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.XAxis">
            <summary>
            Indicates the x-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.YAxis">
            <summary>
            Indicates the y-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.AxisBoth">
            <summary>
            Indicates both X-axis and Y-axis symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.DiagonalBoth">
            <summary>
            Indicates both diagonal and anti-diagonal symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.All">
            <summary>
            Indicates all symmetry types should be satisfied.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_7">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitHousePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitHousePattern_7.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitIntersectionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitMegaLineGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_11">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_11.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserDigitPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSimpleMultilinePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridOpenSudokuPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridPencilmarkingPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_15.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSukakuSegmentPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_17">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_17.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridShortenedSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_19">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EliminationPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EliminationPattern_19.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfAnyDecimalDigitNumberDecimalDigitNumber(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_0004012A2B2E2F09(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_0004012B2C2E2F09(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_0004022B2C2D2E0909(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+-\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_0006012B2C2E2F5B5C09(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.[\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_0006022A2C2D2E3C3D0909(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*+-&lt;\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPop(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Pops 2 values from the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
            <summary>Pushes 1 value onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
            <summary>Pushes 2 values onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>Pushes 3 values onto the backtracking stack.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_asciiExceptDigits">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_800040008000400">
            <summary>Supports searching for characters in or not in "CRcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_C0004000C000400">
            <summary>Supports searching for characters in or not in "BCRbcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FE030000040000000400">
            <summary>Supports searching for characters in or not in "123456789Rr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFF7FFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFBB00FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()+,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD300ECFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'(),./:;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_nonAscii_4142434445464748494A4B6162636465666768696A6BE284AA">
            <summary>Supports searching for characters in or not in "ABCDEFGHIJKabcdefghijkK".</summary>
        </member>
    </members>
</doc>

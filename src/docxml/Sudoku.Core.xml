<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Core</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Algorithm.Generating.FilteredGeneratorProgress">
            <summary>
            Represents a progress data type that is nearly same as <see cref="T:Sudoku.Algorithm.Generating.GeneratorProgress"/>, but with filtered data.
            </summary>
            <param name="Count">The number of checked puzzles.</param>
            <param name="Succeeded">The number of succeeded puzzles.</param>
            <seealso cref="T:Sudoku.Algorithm.Generating.GeneratorProgress"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.FilteredGeneratorProgress.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents a progress data type that is nearly same as <see cref="T:Sudoku.Algorithm.Generating.GeneratorProgress"/>, but with filtered data.
            </summary>
            <param name="Count">The number of checked puzzles.</param>
            <param name="Succeeded">The number of succeeded puzzles.</param>
            <seealso cref="T:Sudoku.Algorithm.Generating.GeneratorProgress"/>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.FilteredGeneratorProgress.Count">
            <summary>The number of checked puzzles.</summary>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.FilteredGeneratorProgress.Succeeded">
            <summary>The number of succeeded puzzles.</summary>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.FilteredGeneratorProgress.Percentage">
            <summary>
            Indicates the percentage.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.FilteredGeneratorProgress.Sudoku#Algorithm#Generating#IProgressDataProvider{Sudoku#Algorithm#Generating#FilteredGeneratorProgress}#ToDisplayString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.FilteredGeneratorProgress.Sudoku#Algorithm#Generating#IProgressDataProvider{Sudoku#Algorithm#Generating#FilteredGeneratorProgress}#Create(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.GeneratorProgress">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GeneratorProgress.#ctor(System.Int32)">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.GeneratorProgress.Count">
            <summary>The number of puzzles generated currently.</summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GeneratorProgress.Sudoku#Algorithm#Generating#IProgressDataProvider{Sudoku#Algorithm#Generating#GeneratorProgress}#ToDisplayString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GeneratorProgress.Sudoku#Algorithm#Generating#IProgressDataProvider{Sudoku#Algorithm#Generating#GeneratorProgress}#Create(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator">
            <summary>
            Represents a grid-based puzzle generator.
            </summary>
            <param name="seedGrid"><inheritdoc cref="P:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.SeedGrid" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.#ctor(Sudoku.Concepts.Grid@)">
            <summary>
            Represents a grid-based puzzle generator.
            </summary>
            <param name="seedGrid"><inheritdoc cref="P:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.SeedGrid" path="/summary"/></param>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator._solver">
            <summary>
            The internal solver.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator._playground">
            <summary>
            Indicates the playground.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator._resultGrid">
            <summary>
            Indicates the result grid.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.SeedGrid">
            <summary>
            Indicates the seed grid to be used.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.Generate(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Try to generate a puzzle using the specified seed pattern.
            </summary>
            <param name="shuffleDigits">Indicates whether the method will shuffle digits, making the puzzle looking different with the seed.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>A valid <see cref="T:Sudoku.Concepts.Grid"/> to be used.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.BatchGenerate(System.Int32,System.Boolean,System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <summary>
            Batch generating puzzles.
            </summary>
            <param name="times">The times of the pattern will be tried.</param>
            <param name="shuffleDigits"><inheritdoc cref="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.Generate(System.Boolean,System.Threading.CancellationToken)" path="/param[@name='shuffleDigits']"/></param>
            <param name="progress">The <see cref="T:System.IProgress`1"/> instance that can report the progess.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>A list of valid <see cref="T:Sudoku.Concepts.Grid"/> values.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.ShuffleDigitsFor10Times(Sudoku.Concepts.Grid@)">
            <summary>
            Shuffle digits for 10 times.
            </summary>
            <param name="puzzle">The puzzle to be shuffle.</param>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator._seedGrid">
            <summary>
            The generated field declaration for parameter <c>seedGrid</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.GridBasedPuzzleGenerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator">
            <summary>
            Defines a puzzle generator that makes the given pattern as a hard one.
            A <b>hard pattern</b> doesn't mean the puzzle will be hard or fiendish.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.BlockFactor">
            <summary>
            Indicates the block factor.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.SwappingFactor">
            <summary>
            Indicates the swapping factor.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator._solver">
            <summary>
            Indicates the inner solver that can fast solve a sudoku puzzle, to check the validity
            of a puzzle being generated.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator._rng">
            <summary>
            Indicates the random number generator.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.GenerateAnswerGrid(System.Char*,System.Char*)">
            <summary>
            Generates the answer sudoku grid via the specified puzzle and the solution variable pointer.
            </summary>
            <param name="pPuzzle">The pointer that points to the puzzle.</param>
            <param name="pSolution">
            The pointer that points to the solution. The result value will be changed here.
            </param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.CreatePattern(System.Int32*)">
            <summary>
            Creates a start pattern based on a base pattern.
            </summary>
            <param name="pattern">The base pattern.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.RecreatePattern(System.Int32*)">
            <summary>
            To re-create the pattern.
            </summary>
            <param name="pattern">The pointer that points to an array of the pattern values.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HardPatternPuzzleGenerator.CheckDuplicate(System.Char*,System.Int32)">
            <summary>
            Check whether the digit in its peer cells has duplicate ones.
            </summary>
            <param name="ptrGrid">The pointer that points to a grid.</param>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator">
            <summary>
            Represents a puzzle generator, implemented by HoDoKu.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.AutoClues">
            <summary>
            Indicates the auto clues count.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._generateIndices">
            <summary>
            The order in which cells are set when generating a full grid.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._rng">
            <summary>
            A random generator for creating new puzzles.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._solver">
            <summary>
            Indicates the internal fast solver.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._stack">
            <summary>
            The recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._newFullSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._newValidSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator" />.
            </summary>
            <remarks>
            <target name="constructor">
				<i>
					The feature "Custom parameterless struct constructor" makes the parameterless struct constructor
					different with <c>default(T)</c>. If you has defined a parameterless struct constructor,
					<c>new T()</c> is no longer with the same meaning as <c>default(T)</c>.
				</i>
			</target>
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(System.Int32,Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)" path="/summary"/>
            </summary>
            <param name="cluesCount">
            <para>Indicates the number of clues the generator supports for <b>approximately</b>.</para>
            <para>
            Please note that the target puzzle may not contain the same number of givens as this value.
            If the number of givens from a puzzle is below this value but it also has a unique solution,
            this puzzle will be still treated as valid one.
            </para>
            </param>
            <param name="symmetricType">The symmetric type to be specified. The value is <see cref="F:Sudoku.Concepts.SymmetricType.Central"/> by default.</param>
            <param name="cancellationToken">
            <inheritdoc
                cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)"
                path="/param[@name='cancellationToken']"/>
            </param>
            <returns><inheritdoc cref="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)" path="/returns"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="symmetricType"/> holds multiple flags,
            or the argument <paramref name="cluesCount"/> is invalid.
            </exception>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.GenerateInitPos(System.Int32,Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            Takes a full sudoku from <see cref="F:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator._newFullSudoku"/> and generates a valid puzzle by deleting cells.
            If a deletion produces a grid with more than one solution it is of course undone.
            </summary>
            <inheritdoc cref="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Generate(System.Int32,Sudoku.Concepts.SymmetricType,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.GenerateForFullGrid">
            <summary>
            Generate a solution grid.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the generation operation is succeeded.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.HodokuPuzzleGenerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.IProgressDataProvider`1">
            <summary>
            Indicates the data provider type,
            </summary>
            <typeparam name="T">The type of the implementation data provider.</typeparam>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.IProgressDataProvider`1.Count">
            <summary>
            Indicates the number of puzzles having been generated.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.IProgressDataProvider`1.ToDisplayString">
            <summary>
            Try to fetch display string for the current instance.
            </summary>
            <returns>The display string.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.IProgressDataProvider`1.Create(System.Int32,System.Int32)">
            <summary>
            Try to create a <typeparamref name="T"/> instance.
            </summary>
            <param name="count">The number of puzzles generated.</param>
            <param name="succeeded">The number of puzzles has passed the checking.</param>
            <returns>A <typeparamref name="T"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.IPuzzleGenerator">
            <summary>
            Represents an instance that has ability to create a new sudoku puzzle game, allow cancelling.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.IPuzzleGenerator.Generate(System.IProgress{Sudoku.Algorithm.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <summary>
            Creates a sudoku grid puzzle.
            </summary>
            <param name="progress">
            <inheritdoc
                cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"
                path="/param[@name='progress']"/>
            </param>
            <param name="cancellationToken">The cancellation token to cancel the operation.</param>
            <returns>
            The result puzzle generated. If canceled, the return value will be <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </returns>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator">
            <summary>
            Represents a generator that is based on pattern.
            </summary>
            <param name="seedPattern"><inheritdoc cref="P:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.Pattern" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.#ctor(Sudoku.Concepts.CellMap@)">
            <summary>
            Represents a generator that is based on pattern.
            </summary>
            <param name="seedPattern"><inheritdoc cref="P:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.Pattern" path="/summary"/></param>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator._solver">
            <summary>
            The internal solver.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator._playground">
            <summary>
            Indicates the test grid.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator._resultGrid">
            <summary>
            Indicates the result grid.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.Pattern">
            <summary>
            Indicates the predefind pattern used.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.Generate(System.Threading.CancellationToken)">
            <summary>
            Try to generate a puzzle using the specified pattern.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>A valid <see cref="T:Sudoku.Concepts.Grid"/> pattern that has a specified pattern, with specified digits should be filled in.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.OrderPatternCellsViaConnectionDegrees">
            <summary>
            Order the pattern cells via connection complexity.
            </summary>
            <returns>The cells ordered.</returns>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator._seedPattern">
            <summary>
            The generated field declaration for parameter <c>seedPattern</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Algorithm.Generating.PatternBasedPuzzleGenerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Algorithm.Generating.RecursionStackEntry">
            <summary>
            One entry in recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Candidates">
            <summary>
            The candidates for cells <see cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Cell"/>.
            </summary>
            <seealso cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Cell"/>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Cell">
            <summary>
            The index of the cell that's being tried.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.CandidateIndex">
            <summary>
            The index of the last tried candidate in <see cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Candidates"/>.
            </summary>
            <seealso cref="F:Sudoku.Algorithm.Generating.RecursionStackEntry.Candidates"/>
        </member>
        <member name="F:Sudoku.Algorithm.Generating.RecursionStackEntry.SudokuGrid">
            <summary>
            The current state of the sudoku.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.MinLex.BestTriplet">
            <summary>
            Represents for a best triplet permutation.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.MinLex.BestTriplet.BestTripletPermutations">
            <summary>
            The best triplet permutations.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.MinLex.BestTriplet._field">
            <summary>
            The field that points to the zero-indexed position.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.MinLex.BestTriplet.BestResult">
            <summary>
            The total score of the pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.MinLex.BestTriplet.ResultMask">
            <summary>
            The result mask.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.MinLex.BestTriplet.ResultNumBits">
            <summary>
            The result number bits.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.BestTriplet.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Algorithm.MinLex.BestTriplet"/> instance via collection expression.
            </summary>
            <param name="values">The values.</param>
            <returns>A valid <see cref="T:Sudoku.Algorithm.MinLex.BestTriplet"/> result.</returns>
        </member>
        <member name="T:Sudoku.Algorithm.MinLex.GridPattern">
            <summary>
            Represents for a pattern for a grid.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.MinLex.GridPattern.Rows">
            <summary>
            Indicates the rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.MinLex.GridPattern.Digits">
            <summary>
            Indicates the digits.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.MinLex.GridPattern.BestTopRowScore">
            <summary>
            Indicates the best top-row score.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.GridPattern.FromString(System.String,Sudoku.Algorithm.MinLex.GridPattern@,Sudoku.Algorithm.MinLex.GridPattern@)">
            <inheritdoc cref="M:Sudoku.Algorithm.MinLex.GridPattern.FromStringUnsafe(System.String,Sudoku.Algorithm.MinLex.GridPattern*,Sudoku.Algorithm.MinLex.GridPattern*)"/>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="text"/> does not have 81 characters.</exception>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.GridPattern.FromStringUnsafe(System.String,Sudoku.Algorithm.MinLex.GridPattern*)">
            <summary>
            Loads a string text, parsing the data and returns two <see cref="T:Sudoku.Algorithm.MinLex.GridPattern"/> results
            indicating the data equivalent to the grid.
            </summary>
            <param name="text">The text.</param>
            <param name="pair">The pair of pointers indicating the normal and transposed cases. <i><b>The length must be 2.</b></i></param>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.GridPattern.FromStringUnsafe(System.String,Sudoku.Algorithm.MinLex.GridPattern*,Sudoku.Algorithm.MinLex.GridPattern*)">
            <summary>
            Loads a string text, parsing the data and returns two <see cref="T:Sudoku.Algorithm.MinLex.GridPattern"/> results
            indicating the data equivalent to the grid.
            </summary>
            <param name="text">The text.</param>
            <param name="normal">The normal converted data.</param>
            <param name="transposed">The transposed converted data.</param>
        </member>
        <member name="T:Sudoku.Algorithm.MinLex.MinLexCandidate">
            <summary>
            Represents for the basic data for candidates used by MinLex operations.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.MinLex.MinLexCandidate.Perm">
            <summary>
            The permutation cases.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.MinLexCandidate.#ctor">
            <summary>
            Skips for initialization for <see langword="this"/>.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.MinLexCandidate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.MinLexCandidate.ExpandStacks(Sudoku.Algorithm.MinLex.GridPattern*,System.Int32,Sudoku.Algorithm.MinLex.MinLexCandidate*,System.Int32*)">
            <summary>
            Try to expand stacks for the specified pair of <see cref="T:Sudoku.Algorithm.MinLex.GridPattern"/> instances.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.MinLexCandidate.Init(System.Boolean,System.Int32)">
            <summary>
            To initialize data manually.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.MinLexCandidate.PatCanon(System.String,System.String@,System.Boolean)">
            <summary>
            Find minimum lexicographical-ordered string for the specified grid as a string value.
            </summary>
            <param name="source">The source grid.</param>
            <param name="result">The result grid.</param>
            <param name="patternOnly">Indicates whether the method only studies with pattern.</param>
        </member>
        <member name="T:Sudoku.Algorithm.MinLex.MinLexFinder">
            <summary>
            Represents a finder object that checks for a sudoku grid, calculating for the minimal lexicographical-ordered value for that grid.
            </summary>
            <remarks>
            This object can be used for checking for duplicate for grids. If two grids are considered to be equivalent,
            two grids will contain a same minimal lexicographic value.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.MinLexFinder.Find(System.String,System.Boolean)">
            <inheritdoc cref="M:Sudoku.Algorithm.MinLex.MinLexFinder.Find(Sudoku.Concepts.Grid@,System.Boolean)"/>
        </member>
        <member name="M:Sudoku.Algorithm.MinLex.MinLexFinder.Find(Sudoku.Concepts.Grid@,System.Boolean)">
            <summary>
            Find for the minimal lexicographic result for a grid.
            </summary>
            <param name="grid">The specified grid.</param>
            <param name="findForPattern">Indicates whether the grid only searches for its minimal pattern.</param>
            <returns>The minimal result.</returns>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.BacktrackingSolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using backtracking algorithm.
            </summary>
            <remarks>
            <para>
            Please note that the current type has no optimization on solving. Therefore sometimes the puzzle will be
            extremely slowly to be solved although it is not very hard by manually solved.
            One of the examples satisfying the above condition is:
            <code>
            ..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9
            </code>
            The current solver may spend about 4.5 min on solving this puzzle.
            </para>
            <para>
            For more information, please visit
            <see href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms#cite_note-difficult_17_clue-1">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.BacktrackingSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BacktrackingSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            To solve the specified grid.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Different with other methods whose containing type is <see cref="T:Sudoku.Algorithm.Solving.ISolver"/>,
            this argument can be used no matter what the result value will be.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.BitwiseSolver">
            <summary>
            Indicates the solver that is able to solve a sudoku puzzle, and then get the solution of that sudoku.
            </summary>
            <remarks>
            <para>
            The reason why the type name contains the word <i>bitwise</i> is that the solver uses the bitwise algorithm
            to handle a sudoku grid, which is more efficient.
            </para>
            <para><b><i>
            This type is thread-unsafe. If you want to use this type in multi-threading, please use <see langword="lock"/> statement.
            </i></b></para>
            </remarks>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver.BufferLength">
            <summary>
            The buffer length of a solution puzzle.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver.BitSet27">
            <summary>
            All pencil marks set - 27 bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._stack">
            <summary>
            Stack to store current and previous states.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._singleApplied">
            <summary>
            Nasty global flag telling if <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.ApplySingleOrEmptyCells"/> found anything.
            </summary>
            <seealso cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.ApplySingleOrEmptyCells"/>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._solution">
            <summary>
            Pointer to where to store the first solution. This value can be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._numSolutions">
            <summary>
            The number of solutions found so far.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._limitSolutions">
            <summary>
            The max number of solution we're looking for.
            </summary>
            <remarks>
            For the consideration on the performance, I have refused to use auto-implemented property instead.
            </remarks>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolver._g">
            <summary>
            Pointer to the currently active slot.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.BitwiseSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The pointer to the puzzle.</param>
            <param name="solution">The solution. <see langword="null"/> if you don't want to use the value.</param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="puzzle"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(System.String,System.Char*,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The puzzle.</param>
            <param name="solution">The solution. <see langword="null"/> if you don't want to use the value.</param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(System.String,System.String@,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The puzzle.</param>
            <param name="solution">
            The solution. The value keeps <see langword="null"/> if you doesn't want to use this result.
            </param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.Char*)">
            <summary>
            Same as <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="grid"/> is <see langword="null"/>.
            </exception>
            <seealso cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String)">
            <summary>
            Same as <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <seealso cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)">
            <summary>
            Check the validity of the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="solutionIfUnique">The solution if the puzzle is unique.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Solve(Sudoku.Concepts.Grid@)">
            <summary>
            To solve the puzzle, and get the solution.
            </summary>
            <param name="puzzle">The puzzle to solve.</param>
            <returns>The solution. If failed to solve, <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.</returns>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.ClearStack">
            <summary>
            To clear the field <see cref="F:Sudoku.Algorithm.Solving.BitwiseSolver._stack"/>.
            </summary>
            <seealso cref="F:Sudoku.Algorithm.Solving.BitwiseSolver._stack"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.SetSolvedDigit(System.Int32,System.Int32)">
            <summary>
            Set a cell as solved - used in <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.EliminateDigit(System.Int32,System.Int32)">
            <summary>
            Eliminate a digit - used in <see cref="M:Sudoku.Algorithm.Solving.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.SetSolvedMask(System.Int32,System.UInt32)">
            <summary>
            Set a cell as solved - used in various guess routines.
            </summary>
            <param name="band">The band.</param>
            <param name="mask">The mask.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.InitSudoku(System.Char*)">
            <summary>
            Setup everything and load the puzzle.
            </summary>
            <param name="puzzle">The pointer that points to a puzzle buffer.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Update">
            <summary>
            Core of fast processing.
            </summary>
            <returns>The <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.ApplySingleOrEmptyCells">
            <summary>
            Find singles, bi-value cells, and impossible cells.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.InternalSolve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The internal solving method.
            </summary>
            <param name="puzzle">The pointer to the puzzle string.</param>
            <param name="solutionPtr">The pointer to the solution string.</param>
            <param name="limit">The limitation for the number of all final solutions.</param>
            <returns>The number of solutions found.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.ExtractSolution(System.Char*)">
            <summary>
            Extract solution as a string.
            </summary>
            <param name="solution">
            The solution pointer. <b>The buffer should be at least <see cref="F:Sudoku.Algorithm.Solving.BitwiseSolver.BufferLength"/>
            of value of length.</b>
            </param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.GuessBiValueInCell">
            <summary>
            Try both options for cells with exactly two pencil marks.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.GuessFirstCell">
            <summary>
            Guess all possibilities in first unsolved cell.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.Guess">
            <summary>
            Either already solved, or guess and recurse.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.FullUpdate">
            <summary>
            Get as far as possible without guessing.
            </summary>
            <returns>A <see cref="T:System.Byte"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.BitPos(System.UInt32)">
            <summary>
            Get the bit position.
            </summary>
            <param name="map">The map.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.BitwiseSolver.StringLengthOf(System.Char*)">
            <summary>
            Get the length of the specified string which is represented by a <see cref="T:System.Char"/>*.
            </summary>
            <param name="ptr">The pointer.</param>
            <returns>The total length.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="ptr"/> is <see langword="null"/>.
            </exception>
            <remarks>
            In C#, this function is unsafe because the implementation of
            <see cref="T:System.String"/> types between C and C# is totally different.
            In C, <see cref="T:System.String"/> is like a <see cref="T:System.Char"/>* or a
            <see cref="T:System.Char"/>[], they ends with the terminator symbol <c>'\0'</c>.
            However, C# not.
            </remarks>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.BitwiseSolverState">
            <summary>
            Represents a data structure, used by type <see cref="T:Sudoku.Algorithm.Solving.BitwiseSolver" />, describing state for a current grid using binary values.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.BitwiseSolver" />
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.Bands">
            <summary>
            Pencil marks in bands by digit.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.PrevBands">
            <summary>
            Value of bands last time it was calculated.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.UnsolvedCells">
            <summary>
            Bit vector of unsolved cells.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.UnsolvedRows">
            <summary>
            Bit vector of unsolved rows - three bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.BitwiseSolverState.Pairs">
            <summary>
            Bit vector of cells with exactly two pencil marks.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.ColumnNode">
            <summary>
            Represents a column node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.ColumnNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithm.Solving.ColumnNode"/> instance via the specified ID value.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.ColumnNode.Size">
            <summary>
            Indicates the size of the node.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DancingLinkNode">
            <summary>
            Represents a dancing link node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinkNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithm.Solving.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinkNode.#ctor(System.Int32,Sudoku.Algorithm.Solving.ColumnNode)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithm.Solving.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="id">The ID value.</param>
            <param name="column">The column node.</param>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Id">
            <summary>
            Indicates the ID of the node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Column">
            <summary>
            Indicates the current column node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Left">
            <summary>
            Indicates the pointer that points to the left node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Right">
            <summary>
            Indicates the pointer that points to the right node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Up">
            <summary>
            Indicates the pointer that points to the up node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinkNode.Down">
            <summary>
            Indicates the pointer that points to the down node.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DancingLinksSolver">
            <summary>
            Defines a solver that uses the dancing links algorithm.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._answerNodesStack">
            <summary>
            Indicates the stack that stores the raw data for the solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._solutionCount">
            <summary>
            indicates the number of all found solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._solution">
            <summary>
            Indicates the found solution.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DancingLinksSolver._root">
            <summary>
            Indicates the root node of the full link map.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLinksSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Search">
            <summary>
            Try to search the full dancing link map and get the possible solution.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle has multiple solutions.</exception>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Cover(Sudoku.Algorithm.Solving.DancingLinkNode)">
            <summary>
            Cover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.Uncover(Sudoku.Algorithm.Solving.DancingLinkNode)">
            <summary>
            Uncover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.RecordSolution(System.Collections.Generic.Stack{Sudoku.Algorithm.Solving.DancingLinkNode},Sudoku.Concepts.Grid@)">
            <summary>
            Try to gather all possible solutions, and determine whether the puzzle is valid.
            </summary>
            <param name="answer">The answers found.</param>
            <param name="result">The solution if the puzzle is unique.</param>
            <exception cref="T:System.InvalidOperationException">
            Throws when the puzzle has no possible solutions.
            </exception>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLinksSolver.ChooseNextColumn">
            <summary>
            Try to choose the next column node.
            </summary>
            <returns>The chosen next column node.</returns>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DancingLink">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="root">The root node.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.#ctor(Sudoku.Algorithm.Solving.ColumnNode)">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="root">The root node.</param>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DancingLink.Root">
            <summary>
            Indicates the root node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.CreateLinkedList(System.Int32[])">
            <summary>
            Creates the links.
            </summary>
            <param name="gridArray">The grid array.</param>
            <returns>The column node for the root node.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.LinkRow(Sudoku.Algorithm.Solving.MatrixRow@)">
            <summary>
            Links the row.
            </summary>
            <param name="d">The matrix row instance.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.LinkRowToColumn(Sudoku.Algorithm.Solving.DancingLinkNode)">
            <summary>
            Links the row to the column.
            </summary>
            <param name="section">The section.</param>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DancingLink.FormLinks(System.Collections.Generic.List{Sudoku.Algorithm.Solving.ColumnNode},System.Int32,System.Int32,System.Int32)">
            <summary>
            To form the links via the specified columns, the cell index and the digit used.
            </summary>
            <param name="columns">The columns having been stored.</param>
            <param name="x">The current row index.</param>
            <param name="y">The current column index.</param>
            <param name="d">The current digit.</param>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.DictionaryQuerySolver">
            <summary>
            Defines a <see cref="T:System.Collections.Generic.Dictionary`2"/>-based LINQ solver that solves a sudoku grid,
            using a different algorithm with the other one of type <see cref="T:Sudoku.Algorithm.Solving.EnumerableQuerySolver"/>.
            </summary>
            <remarks>
            <para>
            This algorithm is originally written by Python, posted from <see href="http://norvig.com/sudo.py">here</see>
            by Richard Birkby, June 2007. For more information, please visit
            <see href="http://norvig.com/sudoku.html">this link</see>.
            </para>
            <para>
            Also, <see href="https://bugzilla.mozilla.org/attachment.cgi?id=266577">this link</see> is for the same algorithm
            written by JavaScript 1.8+.
            </para>
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.EnumerableQuerySolver"/>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Rows">
            <summary>
            Indicates the characters of all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Columns">
            <summary>
            Indicates the characters of all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Digits">
            <summary>
            Indicates the characters of all digits.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Coordinates">
            <summary>
            Indicates all possible coordinates.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Peers">
            <summary>
            Indicates the peers.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Houses">
            <summary>
            Indicates the houses.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.DictionaryQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            To solve the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="result">The result.</param>
            <returns>
            <para>
            The method will return <see langword="false"/> if the puzzle has more than one solution,
            or <see langword="null"/> if the puzzle cannot be solved.
            </para>
            <para>
            Please note that the method cannot return <see langword="true"/>
            due to not being aware of the uniqueness of the puzzle.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.AllNotNull``1(System.ReadOnlySpan{``0})">
            <summary>
            Determines whether all elements in this collection are not <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the element in the sequence.</typeparam>
            <param name="sequence">The whole sequence.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.AllNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.AllNotNull``1(System.ReadOnlySpan{``0})"/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Zip(System.String[],System.String[])">
            <summary>
            To zip two lists of <see cref="T:System.String"/>s.
            </summary>
            <param name="a">The first array.</param>
            <param name="b">The second array.</param>
            <returns>The final zipped collection.</returns>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.ParseGrid(System.String)">
            <summary>
            Given a string of 81 digits (or <c>'.'</c>, <c>'0'</c> or <c>'-'</c>),
            and return a dictionary of a key-value pair of cell and the candidates.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Search(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Using depth-first search and propagation to try all possible values.
            </summary>
            <returns>A first found solution.</returns>
            <remarks>
            This algorithm is hard to determine whether the puzzle has multiple solutions, due to DFS.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Assign(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate all the other values (except d) from <c>values[s]</c> and propagate.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.DictionaryQuerySolver.Eliminate(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate d from <c>values[s]</c>; propagate when values or places <![CDATA[<=]]> 2.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.EnumerableQuerySolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using LINQ.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithm.Solving.EnumerableQuerySolver.DigitCharacters">
            <summary>
            Indicates the characters for 1 to 9.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.EnumerableQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.EnumerableQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.ISolver">
            <summary>
            Represents a solver that can provide with a basic function to solve a sudoku puzzle given with a <see cref="T:Sudoku.Concepts.Grid"/> instance,
            and returns its solution grid.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithm.Solving.ISolver.UriLink">
            <summary>
            Indicates the URI link that links to the introduction of the algorithm.
            </summary>
            <remarks>
            This property is reserved as information that is offered to the algorithm learners.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.ISolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            Solve the specified grid, and return the solution via argument <paramref name="result"/>
            with returning a <see cref="T:System.Boolean"/>? value indicating the solved state.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Please note that if the return value is not <see langword="true"/>,
            the value should be a discard and should not be used, because the argument
            keeps a memory-randomized value currently.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Algorithm.Solving.MatrixRow">
            <summary>
            The matrix row.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithm.Solving.MatrixRow.#ctor(Sudoku.Algorithm.Solving.DancingLinkNode,Sudoku.Algorithm.Solving.DancingLinkNode,Sudoku.Algorithm.Solving.DancingLinkNode,Sudoku.Algorithm.Solving.DancingLinkNode)">
            <summary>
            The matrix row.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.AnalyzerProgress">
            <summary>
            Represents a progress used by
            <see cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="StepSearcherName">Indicates the currently used step searcher.</param>
            <param name="Percent">The percent value.</param>
            <seealso cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Analytics.AnalyzerProgress.#ctor(System.String,System.Double)">
            <summary>
            Represents a progress used by
            <see cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="StepSearcherName">Indicates the currently used step searcher.</param>
            <param name="Percent">The percent value.</param>
            <seealso cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Analytics.AnalyzerProgress.StepSearcherName">
            <summary>Indicates the currently used step searcher.</summary>
        </member>
        <member name="P:Sudoku.Analytics.AnalyzerProgress.Percent">
            <summary>The percent value.</summary>
        </member>
        <member name="T:Sudoku.Analytics.Conclusion">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-----------------------|---|---------------------------------------|
            |   |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-----------------------|---|---------------------------------------'
                                     \_/ \_____________________________________/
                                     (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1), but the real type
            <see cref="P:Sudoku.Analytics.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type because C# cannot set "A bit"
            to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.#ctor(System.Int16)">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-----------------------|---|---------------------------------------|
            |   |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-----------------------|---|---------------------------------------'
                                     \_/ \_____________________________________/
                                     (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1), but the real type
            <see cref="P:Sudoku.Analytics.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type because C# cannot set "A bit"
            to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="F:Sudoku.Analytics.Conclusion.Parsers">
            <summary>
            The internal parsers.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.#ctor(Sudoku.Analytics.ConclusionType,System.Int32)">
            <summary>
            Initializes an instance with a conclusion type and a candidate offset.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="candidate">The candidate offset.</param>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.#ctor(Sudoku.Analytics.ConclusionType,System.Int32,System.Int32)">
            <summary>
            Initializes the <see cref="T:Sudoku.Analytics.Conclusion"/> instance via the specified cell, digit and the conclusion type.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.Cell">
            <summary>
            Indicates the cell the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.Digit">
            <summary>
            Indicates the digit the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.Candidate">
            <summary>
            Indicates the candidate the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.Conclusion.ConclusionType">
            <summary>
            Indicates the conclusion type of the current instance.
            If the type is <see cref="F:Sudoku.Analytics.ConclusionType.Assignment"/>, this conclusion will be set value (Set a digit into a cell);
            otherwise, a candidate will be removed.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Deconstruct(Sudoku.Analytics.ConclusionType@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Deconstruct(Sudoku.Analytics.ConclusionType@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Equals(Sudoku.Analytics.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.CompareTo(Sudoku.Analytics.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.ToString(System.Globalization.CultureInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.GetSymmetricConclusion(Sudoku.Concepts.SymmetricType,System.Int32)">
            <summary>
            Try to get a new <see cref="T:Sudoku.Analytics.Conclusion"/> instance which is symmetric with the current instance, with the specified symmetric type.
            </summary>
            <param name="symmetricType">The symmetric type to be checked.</param>
            <param name="mappingDigit">The other mapping digit.</param>
            <returns>The other symmetric <see cref="T:Sudoku.Analytics.Conclusion"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="symmetricType"/> contains multiple (greater than 2) cells
            symmetric with the current cell and digit.
            </exception>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.TryParse(System.String,Sudoku.Analytics.Conclusion@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.ParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.op_OnesComplement(Sudoku.Analytics.Conclusion)">
            <summary>
            Negates the current conclusion instance, changing the conclusion type from <see cref="F:Sudoku.Analytics.ConclusionType.Assignment"/> to <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/>,
            or from <see cref="F:Sudoku.Analytics.ConclusionType.Elimination"/> to <see cref="F:Sudoku.Analytics.ConclusionType.Assignment"/>.
            </summary>
            <param name="self">The current conclusion instance to be negated.</param>
            <returns>The negation.</returns>
        </member>
        <member name="F:Sudoku.Analytics.Conclusion._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.op_Equality(Sudoku.Analytics.Conclusion,Sudoku.Analytics.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Analytics.Conclusion.op_Inequality(Sudoku.Analytics.Conclusion,Sudoku.Analytics.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionSet">
            <summary>
            Represents a list of conclusions. The collection only allows adding conclusions.
            </summary>
            <remarks>
            This type uses <see cref="T:System.Collections.BitArray"/> to make determining on equality for two collections of <see cref="T:Sudoku.Analytics.Conclusion"/> instances.
            Because the type contains a reference-typed field, the type is also a reference type.
            </remarks>
            <seealso cref="T:System.Collections.BitArray"/>
            <seealso cref="T:Sudoku.Analytics.Conclusion"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.#ctor">
            <summary>
            Represents a list of conclusions. The collection only allows adding conclusions.
            </summary>
            <remarks>
            This type uses <see cref="T:System.Collections.BitArray"/> to make determining on equality for two collections of <see cref="T:Sudoku.Analytics.Conclusion"/> instances.
            Because the type contains a reference-typed field, the type is also a reference type.
            </remarks>
            <seealso cref="T:System.Collections.BitArray"/>
            <seealso cref="T:Sudoku.Analytics.Conclusion"/>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionSet.BitsCount">
            <summary>
            The total length of bits.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionSet.HalfBitsCount">
            <summary>
            The maximum number of candidates can exist in a grid.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionSet.PrimeNumbers">
            <summary>
            The prime numbers below 100.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionSet._bitArray">
            <summary>
            The internal bit array.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionSet._conclusionsEntry">
            <summary>
            The entry point that can visit conclusions.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.#ctor(System.ReadOnlySpan{Sudoku.Analytics.Conclusion})">
            <summary>
            Initializes a <see cref="T:Sudoku.Analytics.ConclusionSet"/> instance via the specified conclusions.
            </summary>
            <param name="conclusions">The conclusions to be added.</param>
        </member>
        <member name="P:Sudoku.Analytics.ConclusionSet.ContainsAssignment">
            <summary>
            Indicates whether the collection contains any assignment conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.ConclusionSet.ContainsElimination">
            <summary>
            Indicates whether the collection contains any elimination conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.ConclusionSet.Count">
            <summary>
            Indicates the number of bit array elements.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.ConclusionSet.Empty">
            <summary>
            An empty instance.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.ConclusionSet.Item(System.Int32)">
            <summary>
            Try to get n-th element stored in the collection.
            </summary>
            <param name="index">The desired index to be checked.</param>
            <returns>The found <see cref="T:Sudoku.Analytics.Conclusion"/> instance at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Add(System.Int32)">
            <summary>
            Add a new conclusion, represented as a global index (between 0 and 1458), into the collection.
            </summary>
            <param name="index">
            <para>The global index (between 0 and 1458) to be added.</para>
            <para>The global index is equivalent to the result value of this formula <c>conclusionType * 729 + candidate</c>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Add(Sudoku.Analytics.Conclusion)">
            <summary>
            Add a new conclusion into the collection.
            </summary>
            <param name="conclusion">The conclusion to be added.</param>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.AddRange(System.ReadOnlySpan{Sudoku.Analytics.Conclusion})">
            <summary>
            Add a list of conclusions into the collection.
            </summary>
            <param name="conclusions">The conclusions to be added.</param>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Equals(Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Contains(Sudoku.Analytics.Conclusion)">
            <summary>
            Indicates whether the collection contains the specified conclusion.
            </summary>
            <param name="conclusion">The conclusion.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.ContainsCell(System.Int32)">
            <summary>
            Indicates whether the collection contains the specified cell.
            </summary>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.ToString(System.Globalization.CultureInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.ToArray">
            <summary>
            Try to get the conclusions.
            </summary>
            <returns>The conclusions.</returns>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.GetEnumerator">
            <summary>
            Try to get an enumerator type that iterates on each conclusion.
            </summary>
            <returns>An enumerator type that iterates on each conclusion.</returns>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Slice(System.Int32,System.Int32)">
            <summary>
            Slices the collection, from the specified start index and the number of the elements.
            </summary>
            <param name="start">The start index.</param>
            <param name="length">The number of elements you want to get.</param>
            <returns>The result <see cref="T:Sudoku.Analytics.ConclusionSet"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.System#Collections#Generic#IEnumerable{Sudoku#Analytics#Conclusion}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.TryParse(System.String,Sudoku.Analytics.ConclusionSet@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.ParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_LogicalNot(Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_True(Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_False(Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_OnesComplement(Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_BitwiseAnd(Sudoku.Analytics.ConclusionSet,Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_BitwiseOr(Sudoku.Analytics.ConclusionSet,Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_ExclusiveOr(Sudoku.Analytics.ConclusionSet,Sudoku.Analytics.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_Implicit(System.ReadOnlySpan{Sudoku.Analytics.Conclusion})~Sudoku.Analytics.ConclusionSet">
            <summary>
            Implicit cast from <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:Sudoku.Analytics.Conclusion"/> instances to <see cref="T:Sudoku.Analytics.ConclusionSet"/>.
            </summary>
            <param name="conclusions">Conclusions to be added.</param>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionSet.Enumerator">
            <summary>
            The internal enumerator instance.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Enumerator.#ctor(Sudoku.Analytics.ConclusionSet)">
            <summary>
            The internal enumerator instance.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionSet.Enumerator._enumerator">
            <summary>
            The conclusions to be iterated.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.ConclusionSet.Enumerator.Current">
            <summary>
            Indicates the current iterated element.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_Equality(Sudoku.Analytics.ConclusionSet,Sudoku.Analytics.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionSet.op_Inequality(Sudoku.Analytics.ConclusionSet,Sudoku.Analytics.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionType">
            <summary>
            Provides a conclusion type.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionType.Assignment">
            <summary>
            Indicates the conclusion is a value filling into a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.ConclusionType.Elimination">
            <summary>
            Indicates the conclusion is a candidate being remove from a cell.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.IAnalyzer`2">
            <summary>
            Represents an analyzer, which can solve a puzzle and return not a solution <see cref="T:Sudoku.Concepts.Grid"/>.
            The result is a <typeparamref name="TResult"/> instance that encapsulates all possible information
            produced in the whole analysis time-cycle.
            </summary>
            <typeparam name="TSelf">The type of the solver itself.</typeparam>
            <typeparam name="TResult">The type of the target result.</typeparam>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzer`2.IsFullApplying">
            <summary>
            Indicates whether the solver will apply all found steps in a step searcher, in order to solve a puzzle faster.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)">
            <summary>
            Analyze the specified puzzle, and return a <typeparamref name="TResult"/> instance indicating the analyzed result.
            </summary>
            <param name="puzzle">The puzzle to be analyzed.</param>
            <param name="progress">A <see cref="T:System.IProgress`1"/> instance that is used for reporting the state.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current analyzing operation.</param>
            <returns>The solver result that provides the information after analyzing.</returns>
        </member>
        <member name="T:Sudoku.Analytics.IAnalyzerResult`2">
            <summary>
            Represents an instance that describes the result after executed the method
            <see cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <typeparam name="TSolver">The solver's type.</typeparam>
            <typeparam name="TSelf">The type of the target result itself.</typeparam>
            <seealso cref="M:Sudoku.Analytics.IAnalyzer`2.Analyze(Sudoku.Concepts.Grid@,System.IProgress{Sudoku.Analytics.AnalyzerProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.IsSolved">
            <summary>
            Indicates whether the solver has solved the puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.ElapsedTime">
            <summary>
            Indicates the elapsed time used during solving the puzzle. The value may not be an useful value.
            Some case if the puzzle doesn't contain a valid unique solution, the value may be
            <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
            <seealso cref="F:System.TimeSpan.Zero"/>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.Puzzle">
            <summary>
            Indicates the original puzzle to be solved.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.Solution">
            <summary>
            Indicates the result sudoku grid solved. If the solver can't solve this puzzle, the value will be
            <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Analytics.IAnalyzerResult`2.UnhandledException">
            <summary>
            Indicates the unhandled exception thrown.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.ICultureSupportedAnalyzer`2">
            <summary>
            Represents an analyzer, which can solve a puzzle and return not a solution <see cref="T:Sudoku.Concepts.Grid"/>.
            The result is a <typeparamref name="TResult"/> instance that encapsulates all possible information
            produced in the whole analysis time-cycle, using the specified culture to display running information.
            </summary>
            <typeparam name="TSelf">The type of the solver itself.</typeparam>
            <typeparam name="TResult">The type of the target result.</typeparam>
        </member>
        <member name="P:Sudoku.Analytics.ICultureSupportedAnalyzer`2.CurrentCulture">
            <summary>
            Indicates the current culture that is used for displaying running information.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.IRandomizedAnalyzer`2">
            <summary>
            Represents an analyzer, which can solve a puzzle and return not a solution <see cref="T:Sudoku.Concepts.Grid"/>,
            The result is a <typeparamref name="TSelf"/> instance that encapsulates all possible information
            produced in the whole analysis time-cycle, with randomized chosing.
            </summary>
            <typeparam name="TSelf">The type of the solver itself.</typeparam>
            <typeparam name="TResult">The type of the target result.</typeparam>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="P:Sudoku.Analytics.IRandomizedAnalyzer`2.RandomizedChoosing">
            <summary>
            Indicates whether the solver will choose a step to be applied after having searched all possible steps, in random.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.IRandomizedAnalyzer`2.RandomNumberGenerator">
            <summary>
            The internal <see cref="T:System.Random"/> instance to be used.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.RuntimeAnalyticsException">
            <summary>
            Represents an exception type that will be thrown by an <see cref="T:Sudoku.Analytics.IAnalyzer`2"/> instance.
            </summary>
            <param name="grid">Indicates the grid to be analyzed.</param>
            <seealso cref="T:Sudoku.Analytics.IAnalyzer`2"/>
        </member>
        <member name="M:Sudoku.Analytics.RuntimeAnalyticsException.#ctor(Sudoku.Concepts.Grid@)">
            <summary>
            Represents an exception type that will be thrown by an <see cref="T:Sudoku.Analytics.IAnalyzer`2"/> instance.
            </summary>
            <param name="grid">Indicates the grid to be analyzed.</param>
            <seealso cref="T:Sudoku.Analytics.IAnalyzer`2"/>
        </member>
        <member name="P:Sudoku.Analytics.RuntimeAnalyticsException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Analytics.RuntimeAnalyticsException.InvalidGrid">
            <summary>
            The generated property declaration for parameter <c>grid</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Analytics.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Analytics.Conclusion"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionExtensions.AsConclusionSet(Sudoku.Analytics.Conclusion[])">
            <summary>
            Converts the <see cref="T:Sudoku.Analytics.Conclusion"/> array into a <see cref="T:Sudoku.Analytics.ConclusionSet"/> instance.
            </summary>
            <param name="this">The conclusion array.</param>
            <returns>A <see cref="T:Sudoku.Analytics.ConclusionSet"/> result.</returns>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Analytics.ConclusionType"/>.
            </summary>
            <seealso cref="T:Sudoku.Analytics.ConclusionType"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionTypeExtensions.Notation(Sudoku.Analytics.ConclusionType)">
            <summary>
            Gets the notation of the conclusion type.
            </summary>
            <param name="this">The conclusion type kind.</param>
            <returns>The string representation of the conclusion kind.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.BitStatusMapPredicate`3">
            <summary>
            Represents a method that checks for an offset of type <typeparamref name="TElement"/>
            in the collection of type <typeparamref name="TSelf"/>, referenced from <paramref name="grid"/>,
            determining whether the offset satisfies the specified condition.
            </summary>
            <typeparam name="TSelf">
            The type of the bit status map. The value can be <see cref="T:Sudoku.Concepts.CellMap"/> or <see cref="T:Sudoku.Concepts.CandidateMap"/>.
            </typeparam>
            <typeparam name="TElement">
            The type of each element in the collection of type <typeparamref name="TSelf"/>.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <param name="offset">The <typeparamref name="TElement"/> offset value to be checked.</param>
            <param name="grid">The grid as candidate reference.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap">
            <summary>
            Encapsulates a binary series of candidate state table.
            The internal buffer size 12 is equivalent to expression <c><![CDATA[floor(729 / sizeof(long) << 6)]]></c>.
            </summary>
            <remarks>
            <para>
            This type holds a <see langword="static readonly" /> field called <see cref="F:Sudoku.Concepts.CandidateMap.Empty" />,
            it is the only field provided to be used as the entry to create or update collection.
            If you want to add elements into it, you can use <see cref="M:Sudoku.Concepts.CandidateMap.Add(System.Int32)" />
            or <see cref="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Int32)" />.
            <code><![CDATA[
            var map = CandidateMap.Empty;
            map += 0; // Adds 'r1c1(1)' into the collection.
            map.Add(1); // Adds 'r1c1(2)' into the collection.
            map |= [2, 3, 4]; // Adds 'r1c1(345)' into the collection.
            map |= anotherMap; // Adds a list of another instance of type 'CandidateMap' into the current collection.
            ]]></code>
            </para>
            <para>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </para>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.CellDigitEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellDigitEnumerator._candidates">
            <summary>
            Indictaes the internal array.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellDigitEnumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.GetEnumerator">
            <summary>
            Returns itself, in order to iterate the value using <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator itself.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.MaxValue">
            <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MaxValue"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.MinValue">
            <inheritdoc cref="P:System.Numerics.IMinMaxValue`1.MinValue"/>
            <remarks>
            This value is equivalent to <see cref="F:Sudoku.Concepts.CandidateMap.Empty"/>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via a list of candidate offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The candidate offsets, represented as a RxCy notation.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.Int32,System.Boolean)">
            <summary>
            Indicates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance with the peer candidates of the specified candidate and a <see cref="T:System.Boolean"/>
            value indicating whether the map will process itself with <see langword="true"/> value.
            </summary>
            <param name="candidate">The candidate.</param>
            <param name="withItself">Indicates whether the map will process itself with <see langword="true"/> value.</param>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Digits">
            <summary>
            Indicates the digits used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Cells">
            <summary>
            Indicates the cells used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.DigitDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by digit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CandidateMap}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CandidateMap}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CandidateIndex(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Contains(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetDigitsFor(System.Int32)">
            <summary>
            Try to get digits that is in the current collection.
            </summary>
            <param name="cell">The desired cell.</param>
            <returns>The digits.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString(System.Globalization.CultureInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.EnumerateCellDigit">
            <summary>
            Try to enumerate cell and digit value on each candidates.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetSubsets(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetSubsetsAll">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetSubsetsAllBelow(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RandomSelect(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Add(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Remove(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#ExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#IntersectWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#UnionWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via the specified candidates.
            </summary>
            <param name="candidates">The candidates.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IParsable{Sudoku#Concepts#CandidateMap}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LogicalNot(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_True(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_False(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_OnesComplement(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Division(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc cref="M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_ExclusiveOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <summary>
            Expands the operator to <c><![CDATA[(a & b).PeerIntersection & b]]></c>.
            </summary>
            <param name="base">The base map.</param>
            <param name="template">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap}#op_Addition(Sudoku.Concepts.CandidateMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap}#op_Subtraction(Sudoku.Concepts.CandidateMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Explicit(System.Int32)~Sudoku.Concepts.CandidateMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Explicit(System.Int32[])~Sudoku.Concepts.CandidateMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Explicit(System.ReadOnlySpan{System.Int32})~Sudoku.Concepts.CandidateMap">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="offsets">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="offsets">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Enumerator._offsets">
            <summary>
            The internal field for offsets.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Equality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Inequality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap._bits">
            <summary>
            Indicates the internal field that provides the visit entry for fixed-sized buffer type <see cref="T:Sudoku.Concepts.CandidateMap.__InternalBuffer"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap.__InternalBuffer"/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.__InternalBuffer">
            <summary>
            Indicates the internal buffer type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.__InternalBuffer._firstElement">
            <summary>
            Indicates the first element of the whole buffer.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.Equals(Sudoku.Concepts.CandidateMap.__InternalBuffer@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.System#IEquatable{Sudoku#Concepts#CandidateMap#__InternalBuffer}#Equals(Sudoku.Concepts.CandidateMap.__InternalBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.op_Equality(Sudoku.Concepts.CandidateMap.__InternalBuffer@,Sudoku.Concepts.CandidateMap.__InternalBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.op_Inequality(Sudoku.Concepts.CandidateMap.__InternalBuffer@,Sudoku.Concepts.CandidateMap.__InternalBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#__InternalBuffer,Sudoku#Concepts#CandidateMap#__InternalBuffer,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap.__InternalBuffer,Sudoku.Concepts.CandidateMap.__InternalBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.__InternalBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#__InternalBuffer,Sudoku#Concepts#CandidateMap#__InternalBuffer,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap.__InternalBuffer,Sudoku.Concepts.CandidateMap.__InternalBuffer)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap._count">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Concepts.CandidateMap.Count"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CandidateMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IEquatable{Sudoku#Concepts#CandidateMap}#Equals(Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IDivisionOperators{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CellMap}#op_Division(Sudoku.Concepts.CandidateMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMap">
            <summary>
            Encapsulates a binary series of cell state table.
            </summary>
            <remarks>
            <para>
            This type holds a <see langword="static readonly" /> field called <see cref="F:Sudoku.Concepts.CellMap.Empty" />,
            it is the only field provided to be used as the entry to create or update collection.
            If you want to add elements into it, you can use <see cref="M:Sudoku.Concepts.CellMap.Add(System.Int32)" /> or <see cref="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Int32)" />.
            <code><![CDATA[
            var map = CellMap.Empty;
            map += 0; // Adds 'r1c1' into the collection.
            map.Add(1); // Adds 'r1c2' into the collection.
            map |= [2, 3, 4]; // Adds 'r1c345' into the collection.
            map |= anotherMap; // Adds a list of another instance of type 'CellMap' into the current collection.
            ]]></code>
            </para>
            <para>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Shifting">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Shifting"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.CellMapParser">
            <summary>
            The internal cell map parser.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.CellMapConverter">
            <summary>
            The internal cell map converter.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._high">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._low">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a list of offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The cell offsets, represented as a RxCy notation.</param>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.IsInIntersection">
            <summary>
            Determines whether the current list of cells are all lie in an intersection area, i.e. a locked candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CanSeeEachOther">
            <summary>
            Indicates whether every cell in the current collection cannot see each other.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Token">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.BlockMask">
            <summary>
            Indicates the mask of block that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned blocks are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.RowMask">
            <summary>
            Indicates the mask of row that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned rows are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ColumnMask">
            <summary>
            Indicates the mask of column that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned columns are 0 and 1, so the return mask is <c>0b000000011</c> (i.e. 3).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CoveredLine">
            <summary>
            Indicates the covered line.
            </summary>
            <remarks>
            If the covered house can't be found, it'll return <see cref="F:Sudoku.SolutionFields.TrailingZeroCountFallback"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionFields.TrailingZeroCountFallback"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CoveredHouses">
            <summary>
            Indicates all houses covered. This property is used to check all houses that all cells
            of this instance covered. For example, if the cells are <c>[0, 1]</c>, the property
            <see cref="P:Sudoku.Concepts.CellMap.CoveredHouses"/> will return the house index 0 (block 1) and 9 (row 1);
            however, if cells spanned two houses or more (e.g. cells <c>[0, 1, 27]</c>),
            this property won't contain any houses.
            </summary>
            <remarks>
            The return value will be a <see cref="T:System.Int32"/> value indicating each houses. Bits set 1 are covered houses.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Houses">
            <summary>
            All houses that the map spanned. This property is used to check all houses that all cells of
            this instance spanned. For example, if the cells are <c>[0, 1]</c>, the property
            <see cref="P:Sudoku.Concepts.CellMap.Houses"/> will return the house index 0 (block 1), 9 (row 1), 18 (column 1)
            and 19 (column 2).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Symmetry">
            <summary>
            Try to get the symmetric type of the pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ExpandedPeers">
            <summary>
            Gets the expanded peers of the current map.
            </summary>
            <remarks>
            An <b>Expanded Peers</b> is a list of cells that contains all peer cells of each cell
            appeared in the current collection. For example, if a collection contains cells <c>r1c123</c>,
            this collection will be the result of the expression <c>PeersMap[r1c1] | PeersMap[r1c2] | PeersMap[r1c3]</c>,
            where the member <c>PeersMap</c> corresponds to the array <see cref="F:Sudoku.SolutionFields.PeersMap"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionFields.PeersMap"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CellMap}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#IMinMaxValue{Sudoku#Concepts#CellMap}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CellIndex(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.InOneHouse(System.Int32@)">
            <summary>
            Indicates whether all cells in this instance are in one house.
            </summary>
            <param name="houseIndex">
            The house index whose corresponding house covered.
            If the return value is <see langword="false"/>, this value will be the constant -1.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Contains(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CompareTo(Sudoku.Concepts.CellMap@)">
            <summary>
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/summary"/>
            </summary>
            <param name="other">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/param[@name='other']"/>
            </param>
            <returns>
            The result value only contains 3 possible values: 1, 0 and -1. The comparison rule is:
            <list type="number">
            <item>
            If <see langword="this"/> holds more cells than <paramref name="other"/>, then return 1
            indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <see langword="this"/> holds less cells than <paramref name="other"/>, then return -1
            indicating <paramref name="other"/> is greater.
            </item>
            <item>
            If they two hold same cells, then checks for indices held:
            <list type="bullet">
            <item>
            If <see langword="this"/> holds a cell whose index is greater than all cells appeared in <paramref name="other"/>,
            then return 1 indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <paramref name="other"/> holds a cell whose index is greater than all cells
            appeared in <paramref name="other"/>, then return -1 indicating <paramref name="other"/> is greater.
            </item>
            </list>
            </item>
            </list>
            If all rules are compared, but they are still considered equal, then return 0.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(System.Globalization.CultureInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.RandomSelect(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetSubsets(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetSubsetsAll">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetSubsetsAllBelow(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Add(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Remove(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#ExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#IntersectWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Sudoku#Concepts#IBitStatusMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#UnionWith(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Create(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance via the specified cells.
            </summary>
            <param name="cells">The cells.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int64,System.Int64)">
            <summary>
            Initializes an instance with two binary values.
            </summary>
            <param name="high">Higher 40 bits.</param>
            <param name="low">Lower 41 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes an instance with three binary values.
            </summary>
            <param name="high">Higher 27 bits.</param>
            <param name="mid">Medium 27 bits.</param>
            <param name="low">Lower 27 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByInt128(System.Int128@)">
            <summary>
            Initializes an instance with an <see cref="T:System.Int128"/> integer.
            </summary>
            <param name="llong">The <see cref="T:System.Int128"/> integer.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IParsable{Sudoku#Concepts#CellMap}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LogicalNot(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_True(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_False(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_OnesComplement(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_ExclusiveOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Modulus(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <summary>
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/summary"/>
            </summary>
            <param name="base">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='base']"/>
            </param>
            <param name="template">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='template']"/>
            </param>
            <returns><inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/returns"/></returns>
            <remarks>
            <para>
            The operator is commonly used for checking eliminations, especially in type 2 of deadly patterns. 
            </para>
            <para>
            For example, if we should check the eliminations
            of digit <c>d</c>, we may use the expression
            <code><![CDATA[
            (urCells & grid.CandidatesMap[d]).PeerIntersection & grid.CandidatesMap[d]
            ]]></code>
            to express the eliminations are the peer intersection of cells of digit <c>d</c>
            appeared in <c>urCells</c>. This expression can be simplified to
            <code><![CDATA[
            urCells % grid.CandidatesMap[d]
            ]]></code>
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Multiply(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Expands via the specified digit.
            </summary>
            <param name="base">The base map.</param>
            <param name="digit">The digit.</param>
            <returns>The result instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Division(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Get the sub-view mask of this map.
            </summary>
            <param name="map">The map.</param>
            <param name="houseIndex">The house index.</param>
            <returns>The mask.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap}#op_Addition(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap}#op_Subtraction(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Implicit(Sudoku.Concepts.CellMap@)~System.Int128">
            <summary>
            Implicit cast from a <see cref="T:Sudoku.Concepts.CellMap"/> instance into a <see cref="T:System.Int128"/> result.
            </summary>
            <param name="this">A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Implicit(System.Int128)~Sudoku.Concepts.CellMap">
            <summary>
            Implicit cast from a <see cref="T:System.Int128"/> value into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="value">A <see cref="T:System.Int128"/> value.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.Int32)~Sudoku.Concepts.CellMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.Int32[])~Sudoku.Concepts.CellMap">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.ReadOnlySpan{System.Int32})~Sudoku.Concepts.CellMap">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="offset">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="offset">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Enumerator._offset">
            <summary>
            The internal field for offsets.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Equality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Inequality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Equality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_GreaterThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._count">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Concepts.CellMap.Count"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CellMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IEquatable{Sudoku#Concepts#CellMap}#Equals(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IComparable{Sudoku#Concepts#CellMap}#CompareTo(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IMultiplyOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CandidateMap}#op_Multiply(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IDivisionOperators{Sudoku#Concepts#CellMap,System#Int32,System#Int16}#op_Division(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMarshal">
            <summary>
            Represents a list of extension methods that operates with cell instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.CopyHouseInfo(System.Int32,System.Int32@)">
            <summary>
            Gets the row, column and block value and copies to the specified array that represents by a pointer
            of 3 elements, where the first element stores the block index, second element stores the row index
            and the third element stores the column index.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="reference">
            The specified reference to the first element in a sequence. The sequence type can be an array or a <see cref="T:System.Span`1"/>,
            only if the sequence can store at least 3 values.
            </param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="reference"/> references to <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndex(System.Byte,Sudoku.Concepts.HouseType)">
            <summary>
            Get the house index (0..27 for block 1-9, row 1-9 and column 1-9)
            for the specified cell and the house type.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="houseType">The house type.</param>
            <returns>The house index. The return value must be between 0 and 26.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="houseType"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndex(System.Int32,Sudoku.Concepts.HouseType)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.ToHouseIndex(System.Byte,Sudoku.Concepts.HouseType)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Byte)">
            <summary>
            Get the house indices for the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>A <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Byte)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToBandIndex(System.Int32)">
            <summary>
            Try to get the band index (mega-row) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToTowerIndex(System.Int32)">
            <summary>
            Try to get the tower index (mega-column) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CellState">
            <summary>
            Represents a cell state.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Undefined">
            <summary>
            Indicates the cell state is invalid - it holds an empty cell without any candidates here.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Empty">
            <summary>
            Indicates that the cell is empty.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Modifiable">
            <summary>
            Indicates the current cell has been filled a value that is not given from initial grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Given">
            <summary>
            Indicates the current cell has been filled a value that cannot be modified because it exists in initial grid.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Chute">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="Cells">The cells used.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="M:Sudoku.Concepts.Chute.#ctor(System.Int32,Sudoku.Concepts.CellMap@,System.Boolean,System.Int32)">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="Cells">The cells used.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Index">
            <summary>Index of the chute. The value is between 0 and 6.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Cells">
            <summary>The cells used.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.IsRow">
            <summary>Indicates whether the chute is in a mega-row.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.HousesMask">
            <summary>Indicates the houses used.</summary>
        </member>
        <member name="M:Sudoku.Concepts.Chute.ToString(System.Globalization.CultureInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.ParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Conjugate">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32)">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with from and to cell offset and a digit.
            </summary>
            <param name="from">The from cell.</param>
            <param name="to">The to cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with the map and the digit.
            The map should contains two cells, the first one is the start one, and the second one is the end one.
            </summary>
            <param name="map">The map.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.From">
            <summary>
            Indicates the "from" cell, i.e. the base cell that starts the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.To">
            <summary>
            Indicates the "to" cell, i.e. the target cell that ends the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Line">
            <summary>
            Indicates the target line of the two cells lie in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Houses">
            <summary>
            Indicates the house that the current conjugate pair lies in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Map">
            <summary>
            Indicates the cells (the "from" cell and "to" cell).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString(System.Globalization.CultureInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.Conjugate._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Equality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Inequality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.CoordinateType">
            <summary>
            Represents a type of notation to describe a coordinate in sudoku.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CoordinateType.Literal">
            <summary>
            Idnicates the notation is based on literally notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CoordinateType.RxCy">
            <summary>
            Indicates the notation is based on <b>RxCy</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CoordinateType.K9">
            <summary>
            Indicates the notation is based on <b>K9</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CoordinateType.Excel">
            <summary>
            Indicates the notation is based on <b>Excel</b> notation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Grid">
            <summary>
            Represents a sudoku grid that uses the mask list to construct the data structure.
            </summary>
            <remarks>
            <para><large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure></para>
            <para>
            Begin with C# 12, we can use feature "Inline Arrays" to access internal masks as raw values via indexers.
            For example, You can use <c>grid[cellIndex]</c> to get the raw mask at the index <c>cellIndex</c>, whose value is between 0 and 81
            (include 0 but not include 81).
            </para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Grid.DefaultMask">
            <summary>
            Indicates the default mask of a cell (an empty cell, with all 9 candidates left).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.MaxCandidatesMask">
            <summary>
            Indicates the maximum candidate mask that used.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyMask">
            <summary>
            Indicates the empty mask, modifiable mask and given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.ModifiableMask">
            <summary>
            Indicates the modifiable mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.GivenMask">
            <summary>
            Indicates the given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CellsCount">
            <summary>
            Indicates the number of cells of a sudoku grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.CellCandidatesCount">
            <summary>
            Indicates the number of candidates appeared in a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyString">
            <summary>
            Indicates the empty grid string.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.ValueChanged">
            <summary>
            Indicates the event triggered when the value is changed.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.RefreshingCandidates">
            <summary>
            Indicates the event triggered when should re-compute candidates.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Empty">
            <summary>
            The empty grid that is valid during implementation or running the program (all values are <see cref="F:Sudoku.Concepts.Grid.DefaultMask"/>, i.e. empty cells).
            </summary>
            <remarks>
            This field is initialized by the static constructor of this structure.
            </remarks>
            <seealso cref="F:Sudoku.Concepts.Grid.DefaultMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Undefined">
            <summary>
            Indicates the default grid that all values are initialized 0. This value is equivalent to <see langword="default"/>(<see cref="T:Sudoku.Concepts.Grid"/>).
            </summary>
            <remarks>
            This value can be used for non-candidate-based sudoku operations, e.g. a sudoku grid canvas.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Grid.PuzzleSolvingSynchronizer">
            <summary>
            The internal field that can be used for making threads run in order while using <see cref="F:Sudoku.Concepts.Grid.Solver"/>,
            keeping the type being thread-safe.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Solver"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Solver">
            <summary>
            Indicates the backing solver.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Parsers">
            <summary>
            Indicates the internal grid parsers.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid._values">
            <summary>
            Indicates the inner array that stores the masks of the sudoku grid, which stores the in-time sudoku grid inner information.
            </summary>
            <remarks>
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0 |
            |-------------------|-----------|-----------------------------------|
            |   |   |   |   |   | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
            '-------------------|-----------|-----------------------------------'
                                 \_________/ \_________________________________/
                                     (2)                     (1)
            </code>
            Here the 9 bits in (1) indicate whether each digit is possible candidate in the current cell for each bit respectively,
            and the higher 3 bits in (2) indicate the cell state. The possible cell state are:
            <list type="table">
            <listheader>
            <term>State name</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Empty cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Empty"/>)</term>
            <description>The cell is currently empty, and wait for being filled.</description>
            </item>
            <item>
            <term>Modifiable cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Modifiable"/>)</term>
            <description>The cell is filled by a digit, but the digit isn't the given by the initial grid.</description>
            </item>
            <item>
            <term>Given cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Given"/>)</term>
            <description>The cell is filled by a digit, which is given by the initial grid and can't be modified.</description>
            </item>
            </list>
            </remarks>
            <seealso cref="T:Sudoku.Concepts.CellState"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.#ctor(System.Int32@,Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the pointer of the first element of the cell digit, and the creating option.
            </summary>
            <param name="firstElement">The reference of the first element.</param>
            <param name="creatingOption">The creating option.</param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="firstElement"/> is <see langword="null"/> reference.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsSolved">
            <summary>
            Indicates the grid has already solved. If the value is <see langword="true"/>, the grid is solved; otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsUndefined">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Grid.Undefined"/>, which means the grid holds totally same value with <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsEmpty">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Grid.Empty"/>, which means the grid holds totally same value with <see cref="F:Sudoku.Concepts.Grid.Empty"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsValid">
            <summary>
            Indicates whether the puzzle has a unique solution.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsMinimal">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ContainsAnyMissingCandidates">
            <summary>
            Determines whether the current grid contains any missing candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesCount">
            <summary>
            Indicates the number of total candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivensCount">
            <summary>
            Indicates the total number of given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiablesCount">
            <summary>
            Indicates the total number of modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptiesCount">
            <summary>
            Indicates the total number of empty cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Token">
            <summary>
            Indicates the token of the grid at the initial state.
            </summary>
            <remarks>
            A raw string example is:
            <code><![CDATA[
            35i4ra00rlr4btf9a8s573tsk1ldni00ccfg094v02pk54ff1hc6e7
            ]]></code>
            We should cut them by 6 characters as a group:
            <code><![CDATA[
            35i4ra 00rlr4 btf9a8 s573ts k1ldni 00ccfg 094v02 pk54ff 1hc6e7
            ]]></code>
            9 groups in total.
            Then we should convert it into a valid 9-digit number by treating them as 32-based integers.
            Finally, combinate all groups, then we are done.
            The final text is
            <code><![CDATA[
            106500970000907108400008520945000380672839410000406000009600002860000751051780039
            ]]></code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyHouses">
            <summary>
            <para>Indicates which houses are empty houses.</para>
            <para>An <b>Empty House</b> is a house holding 9 empty cells, i.e. all cells in this house are empty.</para>
            <para>
            The property returns a <see cref="T:System.Int32"/> value as a mask that contains all possible house indices.
            For example, if the row 5, column 5 and block 5 (1-9) are null houses, the property will return
            the result <see cref="T:System.Int32"/> value, <c>000010000_000010000_000010000</c> as binary.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.FullHouses">
            <summary>
            <para>Indicates which houses are completed, regardless of ways of filling.</para>
            <para><inheritdoc cref="P:Sudoku.Concepts.Grid.EmptyHouses" path="//summary/para[3]"/></para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Symmetry">
            <summary>
            Try to get the symmetry of the puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivenCells">
            <summary>
            Gets a cell list that only contains the given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiableCells">
            <summary>
            Gets a cell list that only contains the modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid is empty.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.BivalueCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid contain two candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesMap">
            <summary>
            Indicates the map of possible positions of the existence of the candidate value for each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.DigitsMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of each digit. The return value will
            be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, this property contains all givens, modifiables and
            empty cells only if it contains the digit in the mask.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ValuesMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of that value of each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, the value only contains the given or modifiable
            cells whose mask contain the set bit of that digit.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Candidates">
            <summary>
            Indicates all possible candidates in the current grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ConjugatePairs">
            <summary>
            Indicates all possible conjugate pairs appeared in this grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetGrid">
            <summary>
            Gets the grid where all modifiable cells are empty cells (i.e. the initial one).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetCandidatesGrid">
            <summary>
            Gets the grid where all empty cells are filled with all possible candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.UnfixedGrid">
            <summary>
            Indicates the unfixed grid for the current grid, meaning all given digits will be replaced with modifiable ones.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.FixedGrid">
            <summary>
            Indicates the fixed grid for the current grid, meaning all modifiable digits will be replaced with given ones.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.SolutionGrid">
            <summary>
            Indicates the solution of the current grid. If the puzzle has no solution or multiple solutions,
            this property will return <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Collections#Generic#IReadOnlyCollection{System#Int32}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Numerics#IMinMaxValue{Sudoku#Concepts#Grid}#MinValue">
            <summary>
            Indicates the minimum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm. For more information, please visit type <see cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>.
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.System#Numerics#IMinMaxValue{Sudoku#Concepts#Grid}#MaxValue">
            <summary>
            Indicates the maximum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm. For more information, please visit type <see cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>.
            </remarks>
            <seealso cref="T:Sudoku.Algorithm.Solving.BacktrackingSolver"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Base32CharSpan">
            <summary>
            The character span that indicates all possible characters appeared in a number with base 32.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@,System.Boolean)">
            <summary>
            <inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/summary"/>
            </summary>
            <param name="cells"><inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/param[@name='cells']"/></param>
            <param name="withValueCells">
            Indicates whether the value cells (given or modifiable ones) will be included to be gathered.
            If <see langword="true"/>, all value cells (no matter what kind of cell) will be summed up.
            </param>
            <returns><inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/returns"/></returns>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@,System.Boolean,Sudoku.Concepts.GridMaskMergingMethod)">
            <summary>
            <inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/summary"/>
            </summary>
            <param name="cells"><inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/param[@name='cells']"/></param>
            <param name="withValueCells">
            <inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@,System.Boolean)" path="/param[@name='withValueCells']"/>
            </param>
            <param name="mergingMethod">
            </param>
            <returns><inheritdoc cref="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)" path="/returns"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when <paramref name="mergingMethod"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Grid"/> instance hold the same values as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.DuplicateWith(System.Int32,System.Int32)">
            <summary>
            Determine whether the digit in the target cell may be duplicated with a certain cell in the peers of the current cell,
            if the digit is filled into the cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ExactlyValidate(Sudoku.Concepts.Grid@,System.Nullable{System.Boolean}@)">
            <summary>
            <para>
            Determines whether the current grid is valid, checking on both normal and sukaku cases
            and returning a <see cref="T:System.Boolean"/>? value indicating whether the current sudoku grid is valid
            only on sukaku case.
            </para>
            <para>
            For more information, please see the introduction about the parameter
            <paramref name="sukaku"/>.
            </para>
            </summary>
            <param name="solutionIfValid">
            The solution if the puzzle is valid; otherwise, <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </param>
            <param name="sukaku">Indicates whether the current mode is sukaku mode.<list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle is a sukaku puzzle.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle is a normal sudoku puzzle.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle is invalid.</description>
            </item>
            </list>
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CheckMinimal(System.Int32@)">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
            <param name="firstCandidateMakePuzzleNotMinimal">
            <para>
            Indicates the first found candidate that can make the puzzle not minimal, which means
            if we remove the digit in the cell, the puzzle will still keep unique.
            </para>
            <para>If the return value is <see langword="true"/>, this argument will be -1.</para>
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle is invalid (i.e. not unique).</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)">
            <summary>
            Sets a candidate existence case with a <see cref="T:System.Boolean"/> value.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <inheritdoc cref="M:Sudoku.Concepts.Grid.SetExistence(System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)">
            <summary>
            Indicates whether the current grid contains the digit in the specified cell.
            </summary>
            <param name="cell">The cell offset.</param>
            <param name="digit">The digit.</param>
            <returns>
            The method will return a <see cref="T:System.Boolean"/>? value
            (containing three possible cases: <see langword="true"/>, <see langword="false"/> and <see langword="null"/>).
            All values corresponding to the cases are below:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Case description on this value</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>
            The cell is an empty cell <b>and</b> contains the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            The cell is an empty cell <b>but doesn't</b> contain the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The cell is <b>not</b> an empty cell.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Note that the method will return a <see cref="T:System.Boolean"/>?, so you should use the code
            '<c>grid.Exists(cell, digit) is true</c>' or '<c>grid.Exists(cell, digit) == true</c>'
            to decide whether a condition is true.
            </para>
            <para>
            In addition, because the type is <see cref="T:System.Boolean"/>? rather than <see cref="T:System.Boolean"/>,
            the result case will be more precisely than the indexer <see cref="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)"/>,
            which is the main difference between this method and that indexer.
            </para>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToArray">
            <summary>
            Serializes this instance to an array, where all digit value will be stored.
            </summary>
            <returns>
            This array. All elements are between 0 and 9, where 0 means the cell is <see cref="F:Sudoku.Concepts.CellState.Empty"/> now.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToCandidateMaskArray">
            <summary>
            Serializes this instance to an array, where all digit value will be stored.
            </summary>
            <returns>
            This array. All elements are the raw masks that between 0 and 511.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetCandidates(System.Int32)">
            <summary>
            Get the candidate mask part of the specified cell.
            </summary>
            <param name="cell">The cell offset you want to get.</param>
            <returns>
            <para>
            The candidate mask. The return value is a 9-bit <see cref="T:System.Int16"/> value, where each bit will be:
            <list type="table">
            <item>
            <term><c>0</c></term>
            <description>The cell <b>doesn't contain</b> the possibility of the digit.</description>
            </item>
            <item>
            <term><c>1</c></term>
            <description>The cell <b>contains</b> the possibility of the digit.</description>
            </item>
            </list>
            </para>
            <para>
            For example, if the result mask is 266 (i.e. <c>0b<b>1</b>00_00<b>1</b>_0<b>1</b>0</c> in binary),
            the value will indicate the cell contains the digit 2, 4 and 9.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString``1(``0)">
            <summary>
            Try to convert the current instance into an equivalent <see cref="T:System.String"/> representation,
            using the specified formatting rule defined in argument <paramref name="converter"/>.
            </summary>
            <typeparam name="T">The type of the converter instance.</typeparam>
            <param name="converter">A converter instance that defines the conversion rule.</param>
            <returns>The target <see cref="T:System.String"/> representation.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetState(System.Int32)">
            <summary>
            Get the cell state at the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The cell state.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigit(System.Int32)">
            <summary>
            Try to get the digit filled in the specified cell.
            </summary>
            <param name="cell">The cell used.</param>
            <returns>The digit that the current cell filled. If the cell is empty, return -1.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified cell keeps a wrong cell state value. For example, <see cref="F:Sudoku.Concepts.CellState.Undefined"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Reset">
            <summary>
            Reset the sudoku grid, making all modifiable values to empty ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ResetCandidates">
            <summary>
            Reset the sudoku grid, but only making candidates to be reset to the initial state related to the current grid
            from given and modifiable values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Fix">
            <summary>
            To fix the current grid (all modifiable values will be changed to given ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Unfix">
            <summary>
            To unfix the current grid (all given values will be changed to modifiable ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Apply(Sudoku.Analytics.Conclusion)">
            <summary>
            Try to apply the specified conclusion.
            </summary>
            <param name="conclusion">The conclusion to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Apply(Sudoku.Rendering.IRenderable)">
            <summary>
            <inheritdoc cref="M:Sudoku.Concepts.Grid.ApplyAll(System.ReadOnlySpan{Sudoku.Analytics.Conclusion})" path="/summary"/>
            </summary>
            <param name="renderable">The renderable instance providing with conclusions to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ApplyAll(System.ReadOnlySpan{Sudoku.Analytics.Conclusion})">
            <summary>
            Try to apply the specified array of conclusions.
            </summary>
            <param name="conclusions">The conclusions to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetState(System.Int32,Sudoku.Concepts.CellState)">
            <summary>
            Set the specified cell to the specified state.
            </summary>
            <param name="cell">The cell.</param>
            <param name="state">The state.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetMask(System.Int32,System.Int16)">
            <summary>
            Set the specified cell to the specified mask.
            </summary>
            <param name="cell">The cell.</param>
            <param name="mask">The mask to set.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ReplaceDigit(System.Int32,System.Int32)">
            <summary>
            Replace the specified cell with the specified digit.
            </summary>
            <param name="cell">The cell to be set.</param>
            <param name="digit">The digit to be set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="digit"/> is invalid (e.g. -1).</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetDigit(System.Int32,System.Int32)">
            <summary>
            Set the specified digit into the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">
            <para>
            The value you want to set. The value should be between 0 and 8.
            If assigning -1, the grid will execute an implicit behavior that candidates in <b>all</b> empty cells will be re-computed.
            </para>
            <para>
            The values set into the grid will be regarded as the modifiable values.
            If the cell contains a digit, it will be covered when it is a modifiable value.
            If the cell is a given cell, the setter will do nothing.
            </para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetExistence(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the target candidate state.
            </summary>
            <param name="cell">The cell offset between 0 and 80.</param>
            <param name="digit">The digit between 0 and 8.</param>
            <param name="isOn">
            The case you want to set. <see langword="false"/> means that this candidate
            doesn't exist in this current sudoku grid; otherwise, <see langword="true"/>.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetMap()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Grid.EmptyCells"/> and <see cref="P:Sudoku.Concepts.Grid.BivalueCells"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The map.</returns>
            <seealso cref="P:Sudoku.Concepts.Grid.EmptyCells"/>
            <seealso cref="P:Sudoku.Concepts.Grid.BivalueCells"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetMaps()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>, <see cref="P:Sudoku.Concepts.Grid.DigitsMap"/> and <see cref="P:Sudoku.Concepts.Grid.ValuesMap"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The map indexed by each digit.</returns>
            <seealso cref="P:Sudoku.Concepts.Grid.CandidatesMap"/>
            <seealso cref="P:Sudoku.Concepts.Grid.DigitsMap"/>
            <seealso cref="P:Sudoku.Concepts.Grid.ValuesMap"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Preserve(Sudoku.Concepts.CellMap@)">
            <summary>
            Gets a sudoku grid, removing all value digits not appearing in the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using the specified token of length 54.
            </summary>
            <param name="token">Indicates the token.</param>
            <returns>A <see cref="T:Sudoku.Concepts.Grid"/> result.</returns>
            <exception cref="T:System.FormatException">Throws when the length of the argument mismatched.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int32[],Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using grid values.
            </summary>
            <param name="gridValues">The array of grid values.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int16[])">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance with the specified mask array.
            </summary>
            <param name="masks">The masks.</param>
            <exception cref="T:System.ArgumentException">Throws when <see cref="P:System.Array.Length"/> is out of valid range.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int16})">
            <summary>
            Returns a <see cref="T:Sudoku.Concepts.Grid"/> instance via the raw mask values.
            </summary>
            <param name="rawMaskValues">
            <para>The raw mask values.</para>
            <para>
            This value can contain 1 or 81 elements.
            If the array contain 1 element, all elements in the target sudoku grid will be initialized by it, the uniform value;
            if the array contain 81 elements, elements will be initialized by the array one by one using the array elements respectively.
            </para>
            </param>
            <returns>A <see cref="T:Sudoku.Concepts.Grid"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int32},Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the array of cell digits
            of type <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Int32"/>.
            </summary>
            <param name="gridValues">The list of cell digits.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String)">
            <summary>
            <inheritdoc cref="M:System.ISimpleParsable`1.Parse(System.String)" path="/summary"/>
            </summary>
            <param name="str"><inheritdoc cref="M:System.ISimpleParsable`1.Parse(System.String)" path="/param[@name='str']"/></param>
            <returns>The <see cref="T:Sudoku.Concepts.Grid"/> instance.</returns>
            <remarks>
            We suggest you use <see cref="M:Sudoku.Concepts.Grid.op_Explicit(System.String)~Sudoku.Concepts.Grid"/> to achieve same goal if the passing argument is a constant.
            For example:
            <code><![CDATA[
            var grid1 = (Grid)"123456789456789123789123456214365897365897214897214365531642978642978531978531642";
            var grid2 = (Grid)"987654321654321987321987654896745213745213896213896745579468132468132579132579468";
            var grid3 = Grid.Parse(stringCode); // 'stringCode' is a string, not null.
            ]]></code>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Grid.op_Explicit(System.String)~Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
            <para>Parses a string value and converts to this type.</para>
            <para>
            If you want to parse a PM grid, we recommend you
            use the method <see cref="M:Sudoku.Concepts.Grid.ParseExact``1(System.String,``0)"/> instead of this method.
            </para>
            </summary>
            <param name="str">The string.</param>
            <returns>The result instance had converted.</returns>
            <seealso cref="M:Sudoku.Concepts.Grid.ParseExact``1(System.String,``0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ParseExact``1(System.String,``0)">
            <summary>
            Parses the specified <see cref="T:System.String"/> text and convert into a grid parser instance,
            using the specified parsing rule.
            </summary>
            <typeparam name="T">The type of the parser.</typeparam>
            <param name="str">The string text to be parsed.</param>
            <param name="parser">The parser instance to be used.</param>
            <returns>A valid grid parsed.</returns>
            <exception cref="T:System.FormatException">Throws when the target grid parser instance cannot parse it.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.Utf8String,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParseExact``1(System.String,``0,Sudoku.Concepts.Grid@)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> text and convert into a <see cref="T:Sudoku.Concepts.Grid"/> instance,
            using the specified parsing rule. If the parsing operation is failed, return <see langword="false"/> to report the failure case.
            No exceptions will be thrown.
            </summary>
            <typeparam name="T">The type of the parser.</typeparam>
            <param name="str">The string text to be parsed.</param>
            <param name="parser">The parser instance to be used.</param>
            <param name="result">A parsed value of type <see cref="T:Sudoku.Concepts.Grid"/>.</param>
            <returns>Indicates whether the parsing operation is successful.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigitViaToken(System.String)">
            <summary>
            Get digit via token.
            </summary>
            <param name="s">The string.</param>
            <returns>The result digit.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.InternalEqualsByRef(System.Byte@,System.Byte@,System.UIntPtr)">
            <summary>
            Determines whether two sequences are considered equal on respective bits.
            </summary>
            <param name="first">The first sequence.</param>
            <param name="second">The second sequence.</param>
            <param name="length">
            The total bits of the sequence to be compared. Please note that two sequences
            <paramref name="first"/> and <paramref name="second"/> must hold a same length.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether they are considered equal.</returns>
            <remarks>
            Optimized byte-based <c>SequenceEquals</c>.
            The <paramref name="length"/> parameter for this one is declared a <see langword="nuint"/> rather than <see cref="T:System.Int32"/>
            as we also use it for types other than <see cref="T:System.Byte"/> where the length can exceed 2Gb once scaled by <see langword="sizeof"/>(T).
            </remarks>
            <!--
            Licensed to the .NET Foundation under one or more agreements.
            The .NET Foundation licenses this file to you under the MIT license.
            https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/SpanHelpers.Byte.cs,998a36a55f580ab1
            -->
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnValueChanged(Sudoku.Concepts.Grid@,System.Int32,System.Int16,System.Int16,System.Int32)">
            <summary>
            The light-weight event handler for <see cref="F:Sudoku.Concepts.Grid.ValueChanged"/>.
            </summary>
            <param name="this">The grid itself.</param>
            <param name="cell">Indicates the cell changed.</param>
            <param name="oldMask">Indicates the original mask representing the original digits in that cell.</param>
            <param name="newMask">Indicates the mask representing the digits updated.</param>
            <param name="setValue">
            Indicates the set value. If to clear the cell, the value will be -1.
            In fact, if the value is -1, this method will do nothing.
            </param>
            <seealso cref="F:Sudoku.Concepts.Grid.ValueChanged"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnRefreshingCandidates(Sudoku.Concepts.Grid@)">
            <summary>
            The light-weight event handler for <see cref="F:Sudoku.Concepts.Grid.RefreshingCandidates"/>.
            </summary>
            <param name="this">The grid itself.</param>
            <seealso cref="F:Sudoku.Concepts.Grid.RefreshingCandidates"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Explicit(System.Int16[])~Sudoku.Concepts.Grid">
            <summary>
            Converts the specified array elements into the target <see cref="T:Sudoku.Concepts.Grid"/> instance, without any value boundary checking.
            </summary>
            <param name="maskArray">An array of the target mask. The array must be of a valid length.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_CheckedExplicit(System.Int16[])~Sudoku.Concepts.Grid">
            <summary>
            Converts the specified array elements into the target <see cref="T:Sudoku.Concepts.Grid"/> instance, with value boundary checking.
            </summary>
            <param name="maskArray">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.op_Explicit(System.Int16[])~Sudoku.Concepts.Grid" path="/param[@name='maskArray']"/>
            </param>
            <exception cref="T:System.ArgumentException">
            Throws when at least one element in the mask array is greater than 0b100__111_111_111 (i.e. 2559) or less than 0.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Explicit(System.String)~Sudoku.Concepts.Grid">
            <summary>
            Implicit cast from <see cref="T:System.String"/> code to its equivalent <see cref="T:Sudoku.Concepts.Grid"/> instance representation.
            </summary>
            <param name="gridCode">The grid code.</param>
            <remarks>
            <para>
            This explicit operator has same meaning for method <see cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/>. You can also use
            <see cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/> to get the same result as this operator.
            </para>
            <para>
            If the argument being passed is <see langword="null"/>, this operator will return <see cref="F:Sudoku.Concepts.Grid.Undefined"/>
            as the final result, whose behavior is the only one that is different with method <see cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/>.
            That method will throw a <see cref="T:System.FormatException"/> instance to report the invalid argument being passed.
            </para>
            </remarks>
            <exception cref="T:System.FormatException">
            See exception thrown cases for method <see cref="M:System.ISimpleParsable`1.Parse(System.String)"/>.
            </exception>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
            <seealso cref="M:Sudoku.Concepts.Grid.Parse(System.String)"/>
            <seealso cref="M:System.ISimpleParsable`1.Parse(System.String)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Equality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Inequality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Equality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Inequality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#IEquatable{Sudoku#Concepts#Grid}#Equals(Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.GridCellPredicates">
            <summary>
            Represents a list of methods to filter the cells.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridCellPredicates.GivenCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a given cell.
            </summary>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridCellPredicates.ModifiableCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a modifiable cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridCellPredicates.GivenCells(Sudoku.Concepts.Grid@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridCellPredicates.EmptyCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is an empty cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridCellPredicates.GivenCells(Sudoku.Concepts.Grid@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridCellPredicates.BivalueCells(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a bi-value cell, which means the cell is an empty cell,
            and contains and only contains 2 candidates.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridCellPredicates.GivenCells(Sudoku.Concepts.Grid@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridCellPredicates.CandidatesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell.
            </summary>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridCellPredicates.DigitsMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell, or whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridCellPredicates.CandidatesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridCellPredicates.ValuesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Checks whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridCellPredicates.CandidatesMap(Sudoku.Concepts.Grid@,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Sudoku.Concepts.GridCreatingOption">
            <summary>
            Indicates the grid creating option.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.None">
            <summary>
            Indicates the option is none.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.MinusOne">
            <summary>
            Indicates each value should minus one before creation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridMaskMergingMethod">
            <summary>
            Represents a method that totals the masks in a list of cells up.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridMaskMergingMethod.AndNot">
            <summary>
            Indicates the merging operation is <see langword="operator"/> <c><![CDATA[&]]></c> and <see langword="operator"/> <c><![CDATA[~]]></c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridMaskMergingMethod.And">
            <summary>
            Indicates the merging operation is <see langword="operator"/> <c><![CDATA[&]]></c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridMaskMergingMethod.Or">
            <summary>
            Indicates the merging operation is <see langword="operator"/> <c><![CDATA[|]]></c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridTransformations">
            <summary>
            Provides methods for <see cref="T:Sudoku.Concepts.Grid"/> instances on transformations.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.ClockwiseTable">
            <summary>
            The table of clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.CounterclockwiseTable">
            <summary>
            The table of counter-clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.PiRotateTable">
            <summary>
            The table of pi-rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridTransformations.SwappableHouses">
            <summary>
            Indicates the swappable pairs, which means the swappable houses.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorLeftRight(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror left-right the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorTopBottom(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror top-bottom the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorDiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.Transpose(Sudoku.Concepts.Grid@)">
            <summary>
            Transpose the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.MirrorAntidiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror anti-diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.RotateClockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid clockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.RotateCounterclockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid counterclockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.RotatePi(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid <c><see cref="F:System.Math.PI"/></c> degrees.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
            <seealso cref="F:System.Math.PI"/>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.SwapTwoDigits(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap two digits.
            </summary>
            <param name="this">The grid.</param>
            <param name="digit1">The digit 1 to be swapped.</param>
            <param name="digit2">The digit 2 to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">Throws when the puzzle is not solved.</exception>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.SwapTwoHouses(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap to houses.
            </summary>
            <param name="this">The grid.</param>
            <param name="houseIndex1">The house 1 to be swapped.</param>
            <param name="houseIndex2">The house 2 to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when two specified house argument is not in valid range (0..27),
            two houses are not in same house type, or are not swappable.
            </exception>
            <remarks>
            This method will return the reference that is same as the argument <paramref name="this"/>,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformations.SwapChute(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap chutes (i.e. mega-rows or mega-columns).
            </summary>
            <param name="this">The grid.</param>
            <param name="chuteIndex1">The first chute to be swapped.</param>
            <param name="chuteIndex2">The second chute to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">Throws when two specified chute index is not in valid range (0..6).</exception>
        </member>
        <member name="T:Sudoku.Concepts.HouseMarshal">
            <summary>
            Represents a list of extension methods that operates with house instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseMarshal.ToHouseType(System.Int32)">
            <summary>
            Get the house type for the specified house index.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>
            The house type. The possible return values are:
            <list type="table">
            <listheader>
            <term>House indices</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 0 and < 9]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Block"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 9 and < 18]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Row"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 18 and < 27]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Column"/></description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseType">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/House.html">house type</see>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Block">
            <summary>
            Indicates the house type is a block.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Row">
            <summary>
            Indicates the house type is a row.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Column">
            <summary>
            Indicates the house type is a column.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.IBitStatusMap`3">
            <summary>
            Extracts a base type that describes state table from elements of <typeparamref name="TSelf"/> type.
            </summary>
            <typeparam name="TSelf">The type of the instance that implements this interface type.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
        </member>
        <member name="F:Sudoku.Concepts.IBitStatusMap`3.ErrorInfo_SubsetsExceeded">
            <summary>
            Indicates the error information describing the case that the number of subsets calculated by methods
            <see cref="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsets(System.Int32)"/> and <see cref="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsetsAllBelow(System.Int32)"/> is too large.
            </summary>
            <seealso cref="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsets(System.Int32)"/>
            <seealso cref="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsetsAllBelow(System.Int32)"/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Count">
            <summary>
            Indicates the number of the values stored in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.StringChunks">
            <summary>
            Gets all chunks of the current collection, meaning a list of <see cref="T:System.String"/> values that can describe
            all cell and candidate indices, grouped with same row/column.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.PeerIntersection">
            <summary>
            Indicates the peer intersection of the current instance.
            </summary>
            <remarks>
            A <b>Peer Intersection</b> is a set of cells that all cells from the base collection can be seen.
            For more information please visit <see href="http://sudopedia.enjoysudoku.com/Peer.html">this link</see>.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Shifting">
            <summary>
            Indicates the size of each unit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Empty">
            <summary>
            Indicates the empty instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.MaxCount">
            <summary>
            Indicates the maximum number of elements that the collection can be reached.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="P:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IAdditiveIdentity{TSelf,TSelf}#AdditiveIdentity">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Add(`1)">
            <summary>
            Adds a new offset into the current collection.
            </summary>
            <param name="offset">An offset to be added.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.AddRange(System.ReadOnlySpan{`1})">
            <summary>
            Adds a list of offsets into the current collection.
            </summary>
            <param name="offsets">Offsets to be added.</param>
            <returns>The number of offsets succeeded to be added.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Remove(`1)">
            <summary>
            Removes the specified offset from the current collection.
            </summary>
            <param name="offset">An offset to be removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.RemoveRange(System.ReadOnlySpan{`1})">
            <summary>
            Removes a list of offsets from the current collection.
            </summary>
            <param name="offsets">Offsets to be removed.</param>
            <returns>The number of offsets succeeded to be removed.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Clear">
            <summary>
            Clear all bits.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.CopyTo(`1@,System.Int32)">
            <summary>
            Copies the current instance to the target sequence specified as a reference
            to an element of type <typeparamref name="TElement"/>.
            </summary>
            <param name="sequence">
            The reference that points to the first element in a sequence of type <typeparamref name="TElement"/>.
            </param>
            <param name="length">The length of that array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="sequence"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Throws when the capacity isn't enough to store all values.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.CopyTo(`1[],System.Int32)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.ForEach(System.Action{`1})">
            <summary>
            Iterates on each element in this collection.
            </summary>
            <param name="action">The visitor that handles for each element in this collection.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.ExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.IntersectWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.UnionWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Contains(`1)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="offset">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.IndexOf(`1)">
            <summary>
            Try to get the specified index of the offset.
            </summary>
            <param name="offset">The desired offset.</param>
            <returns>The index of the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Equals(`0@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.ToArray">
            <summary>
            Get all offsets whose bits are set <see langword="true"/>.
            </summary>
            <returns>An array of offsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Slice(System.Int32,System.Int32)">
            <summary>
            Slices the current instance, and get the new instance with some of elements between two indices.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The number of elements.</param>
            <returns>The target instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsets(System.Int32)">
            <summary>
            Gets the subsets of the current collection via the specified size indicating the number of elements of the each subset.
            </summary>
            <param name="subsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="subsetSize"/> &gt; Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term><c><paramref name="subsetSize"/> == Count</c></term>
            <description>
            Will return an array that contains only one element, same as the current instance.
            </description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.NotSupportedException">
            Throws when both the count of the current instance and <paramref name="subsetSize"/> are greater than 30.
            </exception>
            <remarks>
            For example, if the current instance is <c>r1c1</c>, <c>r1c2</c> and <c>r1c3</c>
            and the argument <paramref name="subsetSize"/> is 2,
            the method will return an array of 3 elements given below: <c>r1c12</c>, <c>r1c13</c> and <c>r1c23</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsetsAll">
            <summary>
            Equivalent to calling <see cref="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsets(System.Int32)"/> with argument <see cref="P:Sudoku.Concepts.IBitStatusMap`3.Count"/>.
            </summary>
            <returns>All subsets of the current instance.</returns>
            <seealso cref="P:Sudoku.Concepts.IBitStatusMap`3.Count"/>
            <seealso cref="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsetsAllBelow(System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.GetSubsetsAllBelow(System.Int32)">
            <summary>
            Gets all subsets of the current collection via the specified size
            indicating the <b>maximum</b> number of elements of the each subset.
            </summary>
            <param name="limitSubsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="limitSubsetSize"/> &gt; Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.RandomSelect(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.IBitStatusMap`3.RandomSelect(System.Int32,System.Random)"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.RandomSelect(System.Int32,System.Random)">
            <summary>
            Randomly select the specified number of elements in the current collection.
            </summary>
            <param name="count">The desired number of elements.</param>
            <param name="random">The random number generator instance.</param>
            <returns>The desired number of elements, as a <typeparamref name="TSelf"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#IParsable{TSelf}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_LogicalNot(`0@)">
            <summary>
            Determines whether the current collection is empty.
            </summary>
            <param name="offsets">The cells to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <remarks>
            The type of the current collection supports using <see cref="T:System.Boolean"/>-like expression to determine whether the collection is not empty,
            for example:
            <code><![CDATA[
            if (collection)
                // ...
            ]]></code>
            The statement <c>collection</c> will be expanded to <c>collection.Count != 0</c>. Therefore, the negation operator <c>!</c>
            will invert the result of above expression. This is why I use <see langword="operator"/> <c>!</c> to determine on this.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_OnesComplement(`0@)">
            <summary>
            Reverse state for all offsets, which means all <see langword="true"/> bits
            will be set <see langword="false"/>, and all <see langword="false"/> bits
            will be set <see langword="true"/>.
            </summary>
            <param name="offsets">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_True(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is not empty.
            </summary>
            <param name="cells">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_False(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is empty.
            </summary>
            <param name="cells">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Addition(`0@,`1)">
            <summary>
            Adds the specified <paramref name="offset"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be added.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Subtraction(`0@,`1)">
            <summary>
            Removes the specified <paramref name="offset"/> from the <paramref name="collection"/>,
            and returns the removed result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Subtraction(`0@,`0@)">
            <summary>
            Get a <typeparamref name="TSelf"/> that contains all <paramref name="left"/> instance
            but not in <paramref name="right"/> instance.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_BitwiseAnd(`0@,`0@)">
            <summary>
            Get the elements that both <paramref name="left"/> and <paramref name="right"/> contain.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_BitwiseOr(`0@,`0@)">
            <summary>
            Combine the elements from <paramref name="left"/> and <paramref name="right"/>,
            and return the merged result.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_ExclusiveOr(`0@,`0@)">
            <summary>
            Get the elements that either <paramref name="left"/> or <paramref name="right"/> contains.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Equality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Inequality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#ISubtractionOperators{TSelf,TSelf,TSelf}#op_Subtraction(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IModulusOperators{TSelf,TSelf,TSelf}#op_Modulus(`0,`0)">
            <summary>
            Expands the operator to <c><![CDATA[(a & b).PeerIntersection & b]]></c>.
            </summary>
            <param name="left">The base map.</param>
            <param name="right">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Explicit(`1)~`0">
            <summary>
            Converts an element of type <typeparamref name="TElement"/> into a <typeparamref name="TSelf"/> instance,
            with only one element - itself.
            </summary>
            <param name="offset">The offset to be used.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Explicit(`1[])~`0">
            <summary>
            Converts an array of element type <typeparamref name="TElement"/> to a <typeparamref name="TSelf"/> instance.
            </summary>
            <param name="offsets">An array of element type <typeparamref name="TElement"/>.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.op_Explicit(System.ReadOnlySpan{`1})~`0">
            <summary>
            Converts an <see cref="T:System.ReadOnlySpan`1"/> of element type <typeparamref name="TElement"/> to a <typeparamref name="TSelf"/> instance.
            </summary>
            <param name="offsets">An array of element type <typeparamref name="TElement"/>.</param>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ICollection{TElement}#CopyTo(`1[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#ExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IntersectWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#UnionWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#IEquatable{TSelf}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#ISet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Collections#Generic#IReadOnlySet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_LogicalNot(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_OnesComplement(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_True(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_False(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#ILogicalOperators{TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IBitStatusMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_ExclusiveOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Inference">
            <summary>
            Defines an inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Strong">
            <summary>
            Indicates the inference is strong inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Weak">
            <summary>
            Indicates the inference is weak inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.StrongGeneralized">
            <summary>
            Indicates the inference is strong inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.WeakGeneralized">
            <summary>
            Indicates the inference is weak inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.ConjugatePair">
            <summary>
            Indicates the inference is conjugate pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Default">
            <summary>
            Indicates the inference is the default case that doesn't belong to above.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Intersection">
            <summary>
            Represents a pair of intersection information.
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="M:Sudoku.Concepts.Intersection.#ctor(Sudoku.Concepts.IntersectionBase@,Sudoku.Concepts.IntersectionResult@)">
            <summary>
            Represents a pair of intersection information.
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="P:Sudoku.Concepts.Intersection.Base">
            <summary>Indicates the base that describes the block and line index.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Intersection.Result">
            <summary>Indicates the result values.</summary>
        </member>
        <member name="F:Sudoku.Concepts.Intersection.MinilinesGroupedByChuteIndex">
            <summary>
            Indicates the mini-lines to be iterated, grouped by chute index.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Intersection.IntersectionMaps">
            <summary>
            <para>
            Indicates all maps that forms the each intersection. The pattern will be like:
            <code><![CDATA[
            .-------.-------.-------.
            | C C C | A A A | A A A |
            | B B B | . . . | . . . |
            | B B B | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            </para>
            <para>
            In addition, in this data pattern, a <b>CoverSet</b> is a block and a <b>BaseSet</b> is a line.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Intersection.IntersectionBlockTable">
            <summary>
            Indicates the internal intersection block combinations.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Intersection.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Concepts.EqualityComparer">
            <summary>
            Represents a comparer instance that compares two tuples.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.EqualityComparer.Equals(Sudoku.Concepts.IntersectionBase,Sudoku.Concepts.IntersectionBase)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.EqualityComparer.GetHashCode(Sudoku.Concepts.IntersectionBase)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.IntersectionBase">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionBase.#ctor(System.Byte,System.Byte)">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionBase.Line">
            <summary>The index of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionBase.Block">
            <summary>The index of the block.</summary>
        </member>
        <member name="T:Sudoku.Concepts.IntersectionResult">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used, especially used by <see cref="F:Sudoku.Concepts.Intersection.IntersectionMaps"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Intersection.IntersectionMaps"/>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionResult.#ctor(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,System.Byte[])">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used, especially used by <see cref="F:Sudoku.Concepts.Intersection.IntersectionMaps"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Intersection.IntersectionMaps"/>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.LineMap">
            <summary>The map of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.BlockMap">
            <summary>The map of the block.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.IntersectionMap">
            <summary>The map of the intersection.</summary>
        </member>
        <member name="P:Sudoku.Concepts.IntersectionResult.OtherBlocks">
            <summary>
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.ITokenizable`1">
            <summary>
            Represents an object that can create a token of type <see cref="T:System.String"/> to describe the encrpyted representation.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.ITokenizable`1.Token">
            <summary>
            Indicates the token of the object.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ITokenizable`1.TokenHashCode">
            <summary>
            Indicates the hash code that is calculated with token.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.ITokenizable`1.System#Collections#Generic#IEqualityComparer{TSelf}#Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ITokenizable`1.System#Collections#Generic#IEqualityComparer{TSelf}#GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ITokenizable`1.Equals(`0,`0)">
            <inheritdoc cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ITokenizable`1.GetHashCode(`0)">
            <inheritdoc cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ITokenizable`1.Create(System.String)">
            <summary>
            Create an instance of type <typeparamref name="TSelf"/> that is used a token.
            </summary>
            <param name="token">The token to be used.</param>
            <returns>A <typeparamref name="TSelf"/> instance created.</returns>
            <exception cref="T:System.FormatException">Throws when the token is invalid.</exception>
        </member>
        <member name="T:Sudoku.Concepts.LockedTarget">
            <summary>
            Defines the data structure that stores a set of cells and a digit, indicating the information
            about the locked candidate node.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cells">Indicates the cells used.</param>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.#ctor(System.Int32,Sudoku.Concepts.CellMap)">
            <summary>
            Defines the data structure that stores a set of cells and a digit, indicating the information
            about the locked candidate node.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cells">Indicates the cells used.</param>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="scoped ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.IsSole">
            <summary>
            Indicates whether the number of cells is 1.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.DigitString">
            <summary>
            The digit string value.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Deconstruct(Sudoku.Concepts.CellMap@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Equals(Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.ToString(System.Globalization.CultureInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <inheritdoc cref="M:Sudoku.Text.ICoordinateObject`1.ToString(Sudoku.Text.Converters.CoordinateConverter)"/>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.Digit">
            <summary>
            The generated property declaration for parameter <c>digit</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.LockedTarget.Cells">
            <summary>
            The generated property declaration for parameter <c>cells</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.op_Equality(Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.op_Inequality(Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Numerics#IEqualityOperators{Sudoku#Concepts#LockedTarget,Sudoku#Concepts#LockedTarget,System#Boolean}#op_Equality(Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#Numerics#IEqualityOperators{Sudoku#Concepts#LockedTarget,Sudoku#Concepts#LockedTarget,System#Boolean}#op_Inequality(Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.LockedTarget.System#IEquatable{Sudoku#Concepts#LockedTarget}#Equals(Sudoku.Concepts.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.SymmetricType">
            <summary>
            Represents a symmetric type that can describe which one a pattern or a puzzle uses.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.None">
            <summary>
            Indicates none of symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.Central">
            <summary>
            Indicates the central symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.Diagonal">
            <summary>
            Indicates the diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.AntiDiagonal">
            <summary>
            Indicates the anti-diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.XAxis">
            <summary>
            Indicates the x-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.YAxis">
            <summary>
            Indicates the y-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.AxisBoth">
            <summary>
            Indicates both X-axis and Y-axis symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.DiagonalBoth">
            <summary>
            Indicates both diagonal and anti-diagonal symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetricType.All">
            <summary>
            Indicates all symmetry types should be satisfied.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.TransformType">
            <summary>
            Represents a type of transformation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.None">
            <summary>
            The placeholder of this type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.DigitSwap">
            <summary>
            Indicates the transform type is to swap digits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.RowSwap">
            <summary>
            Indicates the transform type is to swap rows.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.ColumnSwap">
            <summary>
            Indicates the transform type is to swap columns.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.BandSwap">
            <summary>
            Indicates the transform type is to swap bands.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.TowerSwap">
            <summary>
            Indicates the transform type is to swap towers.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.MirrorLeftRight">
            <summary>
            Indicates the transform type is to mirror left and right.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.MirrorTopBottom">
            <summary>
            Indicates the transform type is to mirror top and bottom.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.MirrorDiagonal">
            <summary>
            Indicates the transform type is to mirror diagonal.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.MirrorAntidiagonal">
            <summary>
            Indicates the transform type is to mirror anti-diagonal.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.RotateClockwise">
            <summary>
            Indicates the transform type is to rotate clockwise.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.TransformType.RotateCounterclockwise">
            <summary>
            Indicates the transform type is to ratate counter-clockwise.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.CoordinateTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.CoordinateType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CoordinateType"/>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetConverter(Sudoku.Concepts.CoordinateType,System.Object[])">
            <summary>
            Gets the <see cref="T:Sudoku.Text.Converters.CoordinateConverter"/> instance via the specified <see cref="T:Sudoku.Concepts.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <param name="arguments">The arguments to be initialized when calling the constructor.</param>
            <returns>
            A valid <see cref="T:Sudoku.Text.Converters.CoordinateConverter"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetParser(Sudoku.Concepts.CoordinateType,System.Object[])">
            <summary>
            Gets the <see cref="T:Sudoku.Text.Parsers.CoordinateParser"/> instance via the specified <see cref="T:Sudoku.Concepts.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <param name="arguments">The arguments to be initialized when calling the constructor.</param>
            <returns>
            A valid <see cref="T:Sudoku.Text.Parsers.CoordinateParser"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetField(Sudoku.Concepts.CoordinateType)">
            <summary>
            Gets the <see cref="T:System.Reflection.FieldInfo"/> instance for the specified field.
            </summary>
            <param name="this">The type of the coordinate type.</param>
            <returns>The final <see cref="T:System.Reflection.FieldInfo"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseTypeExtensions">
            <summary>
            Provides extension methods on <see cref="T:Sudoku.Concepts.HouseType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.HouseType"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetLabel(Sudoku.Concepts.HouseType)">
            <summary>
            Try to get the label of the specified house type.
            </summary>
            <param name="this">The house type.</param>
            <returns>A character that represents a house type.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetProgramOrder(Sudoku.Concepts.HouseType)">
            <summary>
            Gets the ordering of the house type. The result value will be 0, 1 and 2.
            </summary>
            <param name="this">The house type.</param>
            <returns>The program order.</returns>
        </member>
        <member name="T:Sudoku.Concepts.InferenceExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Inference"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Inference"/>
        </member>
        <member name="M:Sudoku.Concepts.InferenceExtensions.ConnectingNotation(Sudoku.Concepts.Inference)">
            <summary>
            Gets connecting notation of the inference.
            </summary>
            <param name="this">The inference instance.</param>
            <returns>The connecting notation of the inference.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in the enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.IntersectionCollection">
            <summary>
            Represents a collection that stores for a list of <see cref="T:Sudoku.Concepts.IntersectionBase"/> and <see cref="T:Sudoku.Concepts.IntersectionResult"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.IntersectionBase"/>
            <seealso cref="T:Sudoku.Concepts.IntersectionResult"/>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionCollection.#ctor(Sudoku.Concepts.Intersection[])">
            <summary>
            Represents a collection that stores for a list of <see cref="T:Sudoku.Concepts.IntersectionBase"/> and <see cref="T:Sudoku.Concepts.IntersectionResult"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.IntersectionBase"/>
            <seealso cref="T:Sudoku.Concepts.IntersectionResult"/>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionCollection.GetEnumerator">
            <summary>
            Try to get the enumerator that iterates on the elements of the current collection.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionCollection.ToArray">
            <summary>
            Copies the internal array into a new instance, and return it.
            </summary>
            <returns>An array of <see cref="T:Sudoku.Concepts.Intersection"/> instances.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionCollection.System#Collections#Generic#IEnumerable{Sudoku#Concepts#Intersection}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IntersectionCollection.Create(System.ReadOnlySpan{Sudoku.Concepts.Intersection})">
            <summary>
            Creates an <see cref="T:Sudoku.Concepts.IntersectionCollection"/> instance via the specified values using collection expression.
            </summary>
            <param name="values">The values.</param>
            <returns>An <see cref="T:Sudoku.Concepts.IntersectionCollection"/> result.</returns>
        </member>
        <member name="F:Sudoku.Concepts.IntersectionCollection._values">
            <summary>
            The generated field declaration for parameter <c>values</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.SymmetricTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.SymmetricType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.SymmetricType"/>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetSymmetryCellsCount(Sudoku.Concepts.SymmetricType)">
            <summary>
            Try to get the number of cells that the current symmetry should be formed a complete symmetric pattern.
            </summary>
            <param name="this">The symmetric type.</param>
            <returns>
            The number of cells should form a complete pattern:
            <list type="table">
            <listheader>
            <term>Argument</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><see cref="F:Sudoku.Concepts.SymmetricType.None"/> (0)</term>
            <description>1 (Itself)</description>
            </item>
            <item>
            <term>
            <see cref="F:Sudoku.Concepts.SymmetricType.Central"/>,
            <see cref="F:Sudoku.Concepts.SymmetricType.Diagonal"/>, <see cref="F:Sudoku.Concepts.SymmetricType.AntiDiagonal"/>,
            <see cref="F:Sudoku.Concepts.SymmetricType.XAxis"/>, <see cref="F:Sudoku.Concepts.SymmetricType.YAxis"/>
            </term>
            <description>2</description>
            </item>
            <item>
            <term>Other defined values</term>
            <description>4</description>
            </item>
            <item>
            <term>Otherwise</term>
            <description><see cref="T:System.ArgumentOutOfRangeException"/> thrown</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetAxisDimension(Sudoku.Concepts.SymmetricType)">
            <summary>
            Try to get the number of axes of the specified symmetric type.
            </summary>
            <param name="this">The symmetry.</param>
            <returns>
            The number of axes the current symmetric type contains.
            If <paramref name="this"/> is <see cref="F:Sudoku.Concepts.SymmetricType.None"/>, -1 will be returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="this"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCellsInSymmetryAxis(Sudoku.Concepts.SymmetricType)">
            <summary>
            Try to get all possible cells in symmetry axis (or point).
            </summary>
            <param name="this">The symmetry.</param>
            <returns>Returns cells in the symmetry axis (or point).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined or <see cref="F:Sudoku.Concepts.SymmetricType.None"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.Concepts.SymmetricType,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.Concepts.SymmetricType,System.Int32,System.Int32)"/>
            <param name="this"><inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.Concepts.SymmetricType,System.Int32,System.Int32)"/></param>
            <param name="cell">Indicates the target cell to be checked.</param>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.Concepts.SymmetricType,System.Int32,System.Int32)">
            <summary>
            Get the cells that is used for swapping via the specified symmetric type, and the specified row and column value.
            </summary>
            <param name="this">The symmetric type.</param>
            <param name="row">The row value.</param>
            <param name="column">The column value.</param>
            <returns>The cells.</returns>
        </member>
        <member name="T:Sudoku.Linq.BitStatusMapGroup`4">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.#ctor(`3,`0@)">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGroup`4.Count">
            <summary>
            Indicates the number of values stored in <see cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>, i.e. the shorthand of expression <c>Values.Count</c>.
            </summary>
            <seealso cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGroup`4.Item(System.Int32)">
            <inheritdoc cref="P:Sudoku.Concepts.IBitStatusMap`3.Item(System.Int32)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.Deconstruct(`3@,`0@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.Equals(Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An enumerator object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.CreateMapByKeys(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,System.Int32}})">
            <summary>
            Makes a <see cref="T:Sudoku.Concepts.CellMap"/> instance that is concatenated by a list of groups
            of type <see cref="T:Sudoku.Linq.BitStatusMapGroup`4"/>, adding their keys.
            </summary>
            <param name="groups">The groups.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGroup`4.Key">
            <summary>
            The generated property declaration for parameter <c>key</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGroup`4.Values">
            <summary>
            The generated property declaration for parameter <c>values</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.op_Equality(Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3}@,Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.op_Inequality(Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3}@,Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.System#Numerics#IEqualityOperators{Sudoku#Linq#BitStatusMapGroup{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#BitStatusMapGroup{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Equality(Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3},Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.System#Numerics#IEqualityOperators{Sudoku#Linq#BitStatusMapGroup{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#BitStatusMapGroup{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Inequality(Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3},Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroup`4.System#IEquatable{Sudoku#Linq#BitStatusMapGroup{TMap,TElement,TEnumerator,TKey}}#Equals(Sudoku.Linq.BitStatusMapGroup{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Linq.BitStatusMapGroupEnumerable">
            <summary>
            Represents a list of LINQ methods used by <see cref="T:Sudoku.Linq.BitStatusMapGroup`4"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Linq.BitStatusMapGroup`4"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupEnumerable.Where``4(Sudoku.Linq.BitStatusMapGroup{``0,``1,``2,``3},System.Func{``1,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
            <typeparam name="TMap">
            The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>.
            </typeparam>
            <typeparam name="TElement">
            The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGroup`4.Values"/>.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>A (An) <typeparamref name="TElement"/>[] that contains elements from the input sequence that satisfy the condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupEnumerable.Select``5(Sudoku.Linq.BitStatusMapGroup{``0,``1,``2,``3},System.Func{``1,``4})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/summary"/>
            </summary>
            <typeparam name="TMap">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGroup`4" path="/typeparam[@name='TMap']"/>
            </typeparam>
            <typeparam name="TElement">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGroup`4" path="/typeparam[@name='TElement']"/>
            </typeparam>
            <typeparam name="TKey">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGroup`4" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <typeparam name="TEnumerator">
            The type of enumerator.
            </typeparam>
            <typeparam name="TResult">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TResult']"/>
            </typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="selector">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='selector']"/>
            </param>
            <returns>
            An array of <typeparamref name="TResult"/> instances whose elements are the result of invoking the transform function
            on each element of the current instance.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGroup{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0}},System.Func{Sudoku.Linq.BitStatusMapGroup{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.BitStatusMapGroup`4"/> of types <see cref="T:Sudoku.Concepts.CellMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results and merge
            into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGroup{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0}},System.Func{Sudoku.Linq.BitStatusMapGroup{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.BitStatusMapGroup`4"/> of types <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results
            and merge into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:Sudoku.Linq.CandidateMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CandidateMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.FirstOrNull(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.FirstOrNull(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Select``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Where(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CandidateMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CandidateMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CandidateMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.GroupBy``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.SelectMany``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each candidate (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CandidateMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Any(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.All(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.CellMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CellMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.FirstOrNull(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.FirstOrNull(Sudoku.Concepts.CellMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.BitStatusMapPredicate{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element in the current instance into the target-typed <typeparamref name="TResult"/> array,
            using the specified function to convert.
            </summary>
            <typeparam name="TResult">The type of target value.</typeparam>
            <param name="this">The current instance.</param>
            <param name="selector">The selector.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Where(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CellMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CellMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CellMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function.
            </summary>
            <typeparam name="TKey">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <param name="this">The current instance.</param>
            <param name="keySelector">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='keySelector']"/>
            </param>
            <returns>
            A list of <see cref="T:Sudoku.Linq.BitStatusMapGroup`4"/> instances where each value object contains a sequence of objects and a key.
            </returns>
            <seealso cref="T:Sudoku.Linq.BitStatusMapGroup`4"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.SelectMany``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each cell (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CellMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Any(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.All(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.ConclusionsEnumerable">
            <summary>
            Provides with a list of LINQ methods used by <see cref="T:Sudoku.Analytics.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Analytics.Conclusion"/>
        </member>
        <member name="M:Sudoku.Linq.ConclusionsEnumerable.Select(System.ReadOnlySpan{Sudoku.Analytics.Conclusion},System.Func{Sudoku.Analytics.Conclusion,System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Analytics.Conclusion"/> instances, converted each instances into a <see cref="T:System.Int32"/> value,
            and merge them into a <see cref="T:Sudoku.Concepts.CellMap"/> and return it.
            </summary>
            <param name="this">A list of <see cref="T:Sudoku.Analytics.Conclusion"/> instances.</param>
            <param name="selector">The selector to project the values.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.GridEnumerable">
            <summary>
            Provides with a list of LINQ methods operating with <see cref="T:Sudoku.Concepts.Grid"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Where(Sudoku.Concepts.Grid@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters the candidates that satisfies the specified condition.
            </summary>
            <param name="this">The instance to be iterated.</param>
            <param name="predicate">The condition to filter candidates.</param>
            <returns>All candidates satisfied the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Select``1(Sudoku.Concepts.Grid@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
            <typeparam name="TResult">The type of the value returned by <paramref name="selector"/>.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>
            An array of <typeparamref name="TResult"/> elements converted.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.HouseMaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int32"/>.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Select``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.SelectMany``1(System.Int32,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int32"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int32"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Where(System.Int32,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.IntersectionCollectionEnumerable">
            <summary>
            Represents a list of methods that is used as LINQ methods on type <see cref="T:Sudoku.Concepts.IntersectionCollection"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.IntersectionCollection"/>
        </member>
        <member name="M:Sudoku.Linq.IntersectionCollectionEnumerable.Select``1(Sudoku.Concepts.IntersectionCollection,System.Func{Sudoku.Concepts.Intersection,``0})">
            <summary>
            Projects each element into a new transform using the specified method to transform.
            </summary>
            <typeparam name="TResult">The type of result elements.</typeparam>
            <param name="this">The instance to be checked..</param>
            <param name="selector">The transform method.</param>
            <returns>An array of <typeparamref name="TResult"/> results.</returns>
        </member>
        <member name="T:Sudoku.Linq.ListEnumerable">
            <summary>
            Represents a list of LINQ methods to be used for type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CellMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in sourece.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CandidateMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in sourece.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.MaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int16"/>.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Select``1(System.Int16,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.SelectMany``1(System.Int16,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int16"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>, flattens the resulting sequence into one sequence,
            and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int16"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Where(System.Int16,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int16"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.ViewEnumerable">
            <summary>
            Represents with LINQ methods for <see cref="T:Sudoku.Rendering.View"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Rendering.View"/>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.Select``1(Sudoku.Rendering.View,System.Func{Sudoku.Rendering.ViewNode,``0})">
            <summary>
            Projects with a new transform of elements.
            </summary>
            <typeparam name="T">The type of target element.</typeparam>
            <param name="this">The view.</param>
            <param name="selector">The method to transform each element.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="T"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.Where(Sudoku.Rendering.View,System.Func{Sudoku.Rendering.ViewNode,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Rendering.View"/>, only reserves the <see cref="T:Sudoku.Rendering.ViewNode"/> instances satisfying the specified condition.
            </summary>
            <param name="this">The view.</param>
            <param name="predicate">The filter.</param>
            <returns>A list of <see cref="T:Sudoku.Rendering.ViewNode"/> filtered.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.OfType``1(Sudoku.Rendering.View)">
            <summary>
            Filters the view nodes, only returns nodes of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the node.</typeparam>
            <returns>The target collection of element type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.First(Sudoku.Rendering.View,System.Func{Sudoku.Rendering.ViewNode,System.Boolean})">
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found;
            otherwise, throw an <see cref="T:System.InvalidOperationException"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the sequence has no elements satisfying the specified rule.
            </exception>
            <inheritdoc cref="M:Sudoku.Linq.ViewEnumerable.FirstOrDefault(Sudoku.Rendering.View,System.Func{Sudoku.Rendering.ViewNode,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.FirstOrDefault(Sudoku.Rendering.View,System.Func{Sudoku.Rendering.ViewNode,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the first occurrence within the entire <see cref="T:Sudoku.Rendering.View"/>.
            </summary>
            <param name="this">The view to be checked.</param>
            <param name="match">The <see cref="T:System.Func`2"/> delegate that defines the conditions of the element to search for.</param>
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found; otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="T:Sudoku.ModuleInitializer">
            <target name="type">
				<summary>
					<para>
						Provides with the type that contains a module initializer method, called automatically by the CLR
						(Common Language Runtime) to initialize some values.
					</para>
					<para>
						<i>
							The type is called by the compiler and the CLR (Common Language Runtime),
							which means you cannot use any members in this type manually.
						</i>
					</para>
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.ModuleInitializer.Initialize">
            <target name="method">
				<summary>
					Called by the runtime automatically while booting on this solution to initialize the values,
					data members or any other things that can or should be initialized here.
				</summary>
				<remarks>
					The concept <b>module</b> is different with <b>assembly</b>.
					The solution can contain multiple assemblies, while each assembly can contain multiple modules.
					However, due to the design of Visual Studio project file system, each assembly will only contain
					one module by default.
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Rendering.ColorColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="a">Indicates the color alpha raw values to be assigned.</param>
            <param name="r">Indicates the color red raw values to be assigned.</param>
            <param name="g">Indicates the color green raw values to be assigned.</param>
            <param name="b">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="a">Indicates the color alpha raw values to be assigned.</param>
            <param name="r">Indicates the color red raw values to be assigned.</param>
            <param name="g">Indicates the color green raw values to be assigned.</param>
            <param name="b">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.RawValue">
            <summary>
            Indicates the raw value.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.A">
            <summary>
            The generated property declaration for parameter <c>a</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.R">
            <summary>
            The generated property declaration for parameter <c>r</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.G">
            <summary>
            The generated property declaration for parameter <c>g</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.B">
            <summary>
            The generated property declaration for parameter <c>b</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.ColorIdentifier">
            <summary>
            Represents an identifier that is used for describing target rendering item.
            </summary>
            <completionlist cref="T:Sudoku.Rendering.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Normal">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Normal"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Auxiliary1">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary1"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Auxiliary2">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary2"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Auxiliary3">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary3"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Assignment">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Assignment"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.OverlappedAssignment">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.OverlappedAssignment"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Elimination">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Elimination"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Cannibalism">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Cannibalism"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Exofin">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Exofin"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Endofin">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Endofin"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.Link">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Link"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.AlmostLockedSet1">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet1"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.AlmostLockedSet2">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet2"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.AlmostLockedSet3">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet3"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.AlmostLockedSet4">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet4"/>
        </member>
        <member name="F:Sudoku.Rendering.ColorIdentifier.AlmostLockedSet5">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet5"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Implicit(System.Int32)~Sudoku.Rendering.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/> to <see cref="T:Sudoku.Rendering.ColorIdentifier"/>.
            </summary>
            <param name="paletteId">The <see cref="T:System.Int32"/> instance indicating the palette ID.</param>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Implicit(Sudoku.Rendering.WellKnownColorIdentifierKind)~Sudoku.Rendering.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:Sudoku.Rendering.WellKnownColorIdentifierKind"/> to <see cref="T:Sudoku.Rendering.ColorIdentifier"/>.
            </summary>
            <param name="kind">The <see cref="T:Sudoku.Rendering.WellKnownColorIdentifierKind"/> instance.</param>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Equality(Sudoku.Rendering.ColorIdentifier,Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Inequality(Sudoku.Rendering.ColorIdentifier,Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Rendering.IRenderable">
            <summary>
            Represents a renderable instance that can be used for rendering, providing with base data structure to be used by drawing APIs.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.IRenderable.Conclusions">
            <summary>
            Indicates the conclusions that the step can be eliminated or assigned to.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.IRenderable.Views">
            <summary>
            Indicates the views of the step that may be displayed onto the screen using pictures.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.BabaGroupViewNode">
            <summary>
            Defines a view node that highlights for a Baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Utf8Char,System.Int16)">
            <summary>
            Defines a view node that highlights for a Baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.#ctor(System.Int32,System.Utf8Char,System.Int16)">
            <summary>
            Initializes a <see cref="T:Sudoku.Rendering.Nodes.BabaGroupViewNode"/> instance via the specified values.
            </summary>
            <inheritdoc cref="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Utf8Char,System.Int16)"/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.DigitsMaskString">
            <summary>
            Indicates the digits mask string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@,System.Utf8Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@,System.Int16@,System.Utf8Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.UnknownValueChar">
            <summary>
            The generated property declaration for parameter <c>unknownValueChar</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.DigitsMask">
            <summary>
            The generated property declaration for parameter <c>digitsMask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.BasicViewNode">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BasicViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CandidateViewNode">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CandidateViewNode.Cell">
            <summary>
            Indicates the target cell.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CandidateViewNode.CandidateString">
            <summary>
            Indicates the candidate string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CandidateViewNode.Candidate">
            <summary>
            The generated property declaration for parameter <c>candidate</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CellViewNode">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.RenderingMode">
            <summary>
            Indicates the mode that the bound view node will be displayed.
            The default value is <see cref="F:Sudoku.Rendering.RenderingMode.PencilmarkModeOnly"/>, which means only pencilmark mode the node will be displayed.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.ChuteViewNode">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.IsRow">
            <summary>
            Indicates whether the chute is in a row.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.HousesMask">
            <summary>
            <para>
            Indicates a <see cref="T:System.Int32"/> that represents for the houses used.
            The result mask is a 27-bit digit that represents every possible houses using cases.
            </para>
            <para>
            Please note that the first 9-bit always keep the zero value because they is reserved bits
            for block houses, but all chutes don't use them.
            </para>
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.ChuteIndex">
            <summary>
            The generated property declaration for parameter <c>chuteIndex</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CircleViewNode">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CircleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CircleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CrossViewNode">
            <summary>
            Defines a cross view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CrossViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a cross view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CrossViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.DiamondViewNode">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.DiamondViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.DiamondViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.HeartViewNode">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HeartViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HeartViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.HouseViewNode">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.HouseViewNode.House">
            <summary>
            The generated property declaration for parameter <c>house</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.IconViewNode">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.IconViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.LinkViewNode">
            <summary>
            Defines a view node that highlights for a link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="inference">Indicates the inference type.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget,Sudoku.Concepts.Inference)">
            <summary>
            Defines a view node that highlights for a link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="inference">Indicates the inference type.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.Inference@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.Start">
            <summary>
            The generated property declaration for parameter <c>start</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.End">
            <summary>
            The generated property declaration for parameter <c>end</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.Inference">
            <summary>
            The generated property declaration for parameter <c>inference</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.SquareViewNode">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.SquareViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.SquareViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.StarViewNode">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.StarViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.StarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.TriangleViewNode">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.TriangleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.TriangleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.PaletteIdColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.#ctor(System.Int32)">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.PaletteIdColorIdentifier.Value">
            <summary>
            The generated property declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.RenderingMode">
            <summary>
            Represents a kind of the rendering mode.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.None">
            <summary>
            Indicates never displays the current node.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.DirectModeOnly">
            <summary>
            Indicates the view node is only displayed in direct mode. In the direct mode, candidates will be never displayed.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.PencilmarkModeOnly">
            <summary>
            Indicates the view node is only displayed in pencilmark mode. In the pencilmark mode, candidates will be displayed.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.BothDirectAndPencilmark">
            <summary>
            Indicates the view node will be displayed in both direct and pencilmark mode.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.View">
            <summary>
            Provides with a data structure that displays a view for basic information.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.View.AddRange``1(System.ReadOnlySpan{``0})">
            <summary>
            Adds a list of <see cref="T:Sudoku.Rendering.ViewNode"/>s into the collection.
            </summary>
            <param name="nodes">A list of <see cref="T:Sudoku.Rendering.ViewNode"/> instance.</param>
        </member>
        <member name="M:Sudoku.Rendering.View.UnknownOverlaps(System.Int32)">
            <summary>
            Determines whether the specified <see cref="T:Sudoku.Rendering.View"/> stores several <see cref="T:Sudoku.Rendering.Nodes.BabaGroupViewNode"/>s,
            and at least one of it overlaps the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether being overlapped.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.Equals(Sudoku.Rendering.View)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.View.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.View.Clone">
            <summary>
            Creates a new <see cref="T:Sudoku.Rendering.View"/> instance with same values as the current instance, with independency.
            </summary>
            <returns>A new <see cref="T:Sudoku.Rendering.View"/> instance with same values as the current instance.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.AsSpan">
            <summary>
            Try to convert this collection as a <see cref="T:System.ReadOnlySpan`1"/> instance.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.op_BitwiseAnd(Sudoku.Rendering.View,Sudoku.Rendering.View)">
            <summary>
            Creates a <see cref="T:Sudoku.Rendering.View"/> whose elements contains both <paramref name="left"/> and <paramref name="right"/>.
            </summary>
            <param name="left">The left-side <see cref="T:Sudoku.Rendering.View"/> instance.</param>
            <param name="right">The right-side <see cref="T:Sudoku.Rendering.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Rendering.View"/> result created.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.op_BitwiseOr(Sudoku.Rendering.View,Sudoku.Rendering.View)">
            <summary>
            Merges two <see cref="T:Sudoku.Rendering.View"/> instances into one <see cref="T:Sudoku.Rendering.View"/>.
            </summary>
            <param name="left">Indicates the left-side <see cref="T:Sudoku.Rendering.View"/> instance.</param>
            <param name="right">Indicates the right-side <see cref="T:Sudoku.Rendering.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Rendering.View"/> result merged.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.op_ExclusiveOr(Sudoku.Rendering.View,Sudoku.Rendering.View)">
            <summary>
            Creates a <see cref="T:Sudoku.Rendering.View"/> instance, whose elements is from two <see cref="T:Sudoku.Rendering.View"/> collections
            <paramref name="left"/> and <paramref name="right"/>, with only one-side containing this element.
            </summary>
            <param name="left">The left-side <see cref="T:Sudoku.Rendering.View"/> instance.</param>
            <param name="right">The right-side <see cref="T:Sudoku.Rendering.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Rendering.View"/> result created.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Rendering.View.op_Equality(Sudoku.Rendering.View,Sudoku.Rendering.View)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Rendering.View.op_Inequality(Sudoku.Rendering.View,Sudoku.Rendering.View)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Rendering.ViewNode">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Rendering.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Rendering.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="P:Sudoku.Rendering.ViewNode.Identifier">
            <summary>
            Indicates an instance providing with data for describing coloring.
            </summary>
            <remarks><b>
            We cannot change this property into a primary constructor parameter because here attribute <c>[StringMember]</c>
            is not supported by derived types, meaning derived types cannot detect this attribute
            because it's in primary constructor declaration by a base type.
            </b></remarks>
        </member>
        <member name="P:Sudoku.Rendering.ViewNode.TypeIdentifier">
            <summary>
            Indicates the inner identifier to distinct the different types that is derived from <see cref="T:Sudoku.Rendering.ViewNode"/>.
            </summary>
            <seealso cref="T:Sudoku.Rendering.ViewNode"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Clone">
            <summary>
            Creates a new <see cref="T:Sudoku.Rendering.View"/> instance with same values as the current instance, with independency.
            </summary>
            <returns>A new <see cref="T:Sudoku.Rendering.View"/> instance with same values as the current instance.</returns>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.op_Equality(Sudoku.Rendering.ViewNode,Sudoku.Rendering.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.op_Inequality(Sudoku.Rendering.ViewNode,Sudoku.Rendering.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Rendering.WellKnownColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.#ctor(Sudoku.Rendering.WellKnownColorIdentifierKind)">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.Deconstruct(Sudoku.Rendering.WellKnownColorIdentifierKind@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.WellKnownColorIdentifier.Kind">
            <summary>
            The generated property declaration for parameter <c>kind</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.WellKnownColorIdentifierKind">
            <summary>
            Represents a kind of well-known <see cref="T:Sudoku.Rendering.ColorIdentifier"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Rendering.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Normal">
            <summary>
            Indicates the normal color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary1">
            <summary>
            Indicates the first auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary2">
            <summary>
            Indicates the second auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary3">
            <summary>
            Indicates the third auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Assignment">
            <summary>
            Indicates the assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.OverlappedAssignment">
            <summary>
            Indicates the overlapped assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Elimination">
            <summary>
            Indicates the elimination color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Exofin">
            <summary>
            Indicates the exo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Endofin">
            <summary>
            Indicates the endo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Cannibalism">
            <summary>
            Indicates the cannibalism color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Link">
            <summary>
            Indicates the link color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet1">
            <summary>
            Indicates the first ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet2">
            <summary>
            Indicates the second ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet3">
            <summary>
            Indicates the third ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet4">
            <summary>
            Indicates the fourth ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet5">
            <summary>
            Indicates the fifth ALS recorded.
            </summary>
        </member>
        <member name="T:Sudoku.Resources.CoreResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.BlockLabel">
            <summary>
              Looks up a localized string similar to Block {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CandidateLabel">
            <summary>
              Looks up a localized string similar to {0}, digit {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellLabel">
            <summary>
              Looks up a localized string similar to row {0} column {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellsLabel">
            <summary>
              Looks up a localized string similar to cells: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ColumnLabel">
            <summary>
              Looks up a localized string similar to Column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ConjugatePairWith">
            <summary>
              Looks up a localized string similar to {0} conjugates with {1}, for digit {2}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.HousesLabel">
            <summary>
              Looks up a localized string similar to houses: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.LockedCandidatesLabel">
            <summary>
              Looks up a localized string similar to {0} {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaColumnLabel">
            <summary>
              Looks up a localized string similar to Mega column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaLinesLabel">
            <summary>
              Looks up a localized string similar to Mega lines: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaRowLabel">
            <summary>
              Looks up a localized string similar to Mega row {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.RowLabel">
            <summary>
              Looks up a localized string similar to Row {0}.
            </summary>
        </member>
        <member name="T:Sudoku.Resources.MissingResourceManagerException">
            <summary>
            Represents an exception that will be thrown if resource manager is missing.
            </summary>
            <param name="assembly"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Resources.MissingResourceManagerException.#ctor(System.Reflection.Assembly)">
            <summary>
            Represents an exception that will be thrown if resource manager is missing.
            </summary>
            <param name="assembly"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Resources.MissingResourceManagerException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Resources.MissingResourceManagerException.Data">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Resources.ResourceDictionary">
            <summary>
            Represents a easy way to fetch resource values using the specified key and culture information.
            </summary>
        </member>
        <member name="F:Sudoku.Resources.ResourceDictionary.DefaultBindingFlags">
            <summary>
            Indicates the resource manager reflection binding flags.
            </summary>
        </member>
        <member name="F:Sudoku.Resources.ResourceDictionary.DefaultCulture">
            <summary>
            Indicates the default culture.
            </summary>
        </member>
        <member name="F:Sudoku.Resources.ResourceDictionary.ResourceManagers">
            <summary>
            The internal resource managers.
            </summary>
        </member>
        <member name="M:Sudoku.Resources.ResourceDictionary.RegisterResourceManager``1">
            <summary>
            Register a new resource manager for the current assembly calling this method.
            </summary>
            <typeparam name="TResourceManagerProvider">
            <para>The type of the resource manager provider.</para>
            <para>
            This type should point to a generated type, bound with your resource dictionary manifest file (*.resx), named like the file name of it.
            For example, if you create a resource dictionary manifest file called <c>Resource.resx</c>, a generated type will be named <c>Resource</c>.
            You should pass in this type (<c>Resource</c> here) as type argument to this method.
            </para>
            </typeparam>
            <exception cref="T:Sudoku.Resources.MissingResourceManagerException">Throws when the current calling assembly doesn't contain any resource manager.</exception>
        </member>
        <member name="M:Sudoku.Resources.ResourceDictionary.Get(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get resource via the key, or throw a <see cref="T:Sudoku.Resources.ResourceNotFoundException"/> if resource is not found.
            </summary>
            <inheritdoc cref="M:Sudoku.Resources.ResourceDictionary.GetOrNull(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)"/>
            <exception cref="T:Sudoku.Resources.ResourceNotFoundException">Throws when the specified resource is not found.</exception>
        </member>
        <member name="M:Sudoku.Resources.ResourceDictionary.GetOrNull(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get resource via the key, or return <see langword="null"/> if failed.
            </summary>
            <param name="resourceKey">The resource key.</param>
            <param name="culture">The culture.</param>
            <param name="assembly">The assembly storing the resource dictionaries.</param>
            <returns>The result string result.</returns>
            <exception cref="T:Sudoku.Resources.MissingResourceManagerException">Throws when the resource manager object is missing.</exception>
        </member>
        <member name="T:Sudoku.Resources.ResourceException">
            <summary>
            Represents an exception type that relates to resource dictionary.
            </summary>
            <param name="assembly">Indicates the target assembly.</param>
        </member>
        <member name="M:Sudoku.Resources.ResourceException.#ctor(System.Reflection.Assembly)">
            <summary>
            Represents an exception type that relates to resource dictionary.
            </summary>
            <param name="assembly">Indicates the target assembly.</param>
        </member>
        <member name="P:Sudoku.Resources.ResourceException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Resources.ResourceException.Data">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Resources.ResourceException._assembly">
            <summary>
            The generated field declaration for parameter <c>assembly</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Resources.ResourceNotFoundException">
            <summary>
            Indicates an exception that will be thrown if target resource is not found.
            </summary>
            <param name="assembly"><inheritdoc/></param>
            <param name="resourceKey">The resource key.</param>
            <param name="culture">The culture information.</param>
        </member>
        <member name="M:Sudoku.Resources.ResourceNotFoundException.#ctor(System.Reflection.Assembly,System.String,System.Globalization.CultureInfo)">
            <summary>
            Indicates an exception that will be thrown if target resource is not found.
            </summary>
            <param name="assembly"><inheritdoc/></param>
            <param name="resourceKey">The resource key.</param>
            <param name="culture">The culture information.</param>
        </member>
        <member name="F:Sudoku.Resources.ResourceNotFoundException.CultureNotSpecifiedDefaultText">
            <summary>
            The "unspecified" text.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.ResourceNotFoundException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Resources.ResourceNotFoundException.Data">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Resources.ResourceNotFoundException._resourceKey">
            <summary>
            The generated field declaration for parameter <c>resourceKey</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Resources.ResourceNotFoundException._culture">
            <summary>
            The generated field declaration for parameter <c>culture</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions">
            <summary>
            Represents a list of extension methods operating with <see cref="T:System.Collections.Generic.List`1"/>
            of <see cref="T:Sudoku.Concepts.IBitStatusMap`3"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
            <seealso cref="T:Sudoku.Concepts.IBitStatusMap`3"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.AddRef(System.Collections.Generic.List{Sudoku.Concepts.CellMap},Sudoku.Concepts.CellMap@)">
            <summary>
            Adds the given object to the end of this list.
            </summary>
            <param name="this">The list.</param>
            <param name="cells">The <see cref="T:Sudoku.Concepts.CellMap"/> to be added.</param>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.AddRef(System.Collections.Generic.List{Sudoku.Concepts.CandidateMap},Sudoku.Concepts.CandidateMap@)">
            <summary>
            Adds the given object to the end of this list.
            </summary>
            <param name="this">The list.</param>
            <param name="candidates">The <see cref="T:Sudoku.Concepts.CandidateMap"/> to be added.</param>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.AddRangeRef(System.Collections.Generic.List{Sudoku.Concepts.CellMap},System.ReadOnlySpan{Sudoku.Concepts.CellMap})">
            <inheritdoc cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.AddRangeRef(System.Collections.Generic.List{Sudoku.Concepts.CandidateMap},System.ReadOnlySpan{Sudoku.Concepts.CandidateMap})">
            <inheritdoc cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.AddWithResize(System.Collections.Generic.List{Sudoku.Concepts.CellMap},Sudoku.Concepts.CellMap@)">
            <summary>
            Add an item and resize the <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <param name="this">The list.</param>
            <param name="cells">The <see cref="T:Sudoku.Concepts.CellMap"/> to be added.</param>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.AddWithResize(System.Collections.Generic.List{Sudoku.Concepts.CandidateMap},Sudoku.Concepts.CandidateMap@)">
            <summary>
            Add an item and resize the <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:Sudoku.Concepts.CandidateMap"/>.
            </summary>
            <param name="this">The list.</param>
            <param name="candidates">The <see cref="T:Sudoku.Concepts.CandidateMap"/> to be added.</param>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetNewCapacity(System.Collections.Generic.List{Sudoku.Concepts.CellMap},System.Int32)">
            <summary>
            Try to get a new capacity value by the desired capacity to be set.
            </summary>
            <param name="this">The collection.</param>
            <param name="capacity">The desired capacity to be set.</param>
            <returns>The result value to be set.</returns>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetNewCapacity(System.Collections.Generic.List{Sudoku.Concepts.CandidateMap},System.Int32)">
            <inheritdoc cref="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetNewCapacity(System.Collections.Generic.List{Sudoku.Concepts.CellMap},System.Int32)"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetSize(System.Collections.Generic.List{Sudoku.Concepts.CellMap})">
            <summary>
            Try to fetch the internal field <c>_size</c> in type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="this">The list.</param>
            <returns>The reference to the internal field.</returns>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetSize(System.Collections.Generic.List{Sudoku.Concepts.CandidateMap})">
            <inheritdoc cref="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetSize(System.Collections.Generic.List{Sudoku.Concepts.CellMap})"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetVersion(System.Collections.Generic.List{Sudoku.Concepts.CellMap})">
            <summary>
            Try to fetch the internal field <c>_version</c> in type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="this">The list.</param>
            <returns>The reference to the internal field.</returns>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetVersion(System.Collections.Generic.List{Sudoku.Concepts.CandidateMap})">
            <inheritdoc cref="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetVersion(System.Collections.Generic.List{Sudoku.Concepts.CellMap})"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetItems(System.Collections.Generic.List{Sudoku.Concepts.CellMap})">
            <summary>
            Try to fetch the internal reference to the first element of type <see cref="T:Sudoku.Concepts.CellMap"/> in a <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="this">The list of <see cref="T:Sudoku.Concepts.CellMap"/> instances.</param>
            <returns>The reference to the first element of type <see cref="T:Sudoku.Concepts.CellMap"/>.</returns>
            <remarks><b><i>
            Please note that this method will return the reference to the internal field,
            but this doesn't mean you can use its reference and re-assign it.
            </i></b></remarks>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListBitStatusMapExtensions.GetItems(System.Collections.Generic.List{Sudoku.Concepts.CandidateMap})">
            <summary>
            Try to fetch the internal reference to the first element of type <see cref="T:Sudoku.Concepts.CandidateMap"/> in a <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="this">The list of <see cref="T:Sudoku.Concepts.CandidateMap"/> instances.</param>
            <returns>The reference to the first element of type <see cref="T:Sudoku.Concepts.CandidateMap"/>.</returns>
            <remarks><b><i>
            Please note that this method will return the reference to the internal field,
            but this doesn't mean you can use its reference and re-assign it.
            </i></b></remarks>
        </member>
        <member name="T:Sudoku.Runtime.CompilerServices.ListGridExtensions">
            <summary>
            Represents a list of extension methods operating with <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListGridExtensions.AddRef(System.Collections.Generic.List{Sudoku.Concepts.Grid},Sudoku.Concepts.Grid@)">
            <summary>
            Adds the given object to the end of this list.
            </summary>
            <param name="this">The list.</param>
            <param name="grid">The item to be added.</param>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListGridExtensions.AddRangeRef(System.Collections.Generic.List{Sudoku.Concepts.Grid},System.ReadOnlySpan{Sudoku.Concepts.Grid})">
            <inheritdoc cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListGridExtensions.AddWithResize(System.Collections.Generic.List{Sudoku.Concepts.Grid},Sudoku.Concepts.Grid@)">
            <summary>
            Add an item and resize the <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="this">The list.</param>
            <param name="grid">The grid to be added.</param>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListGridExtensions.GetNewCapacity(System.Collections.Generic.List{Sudoku.Concepts.Grid},System.Int32)">
            <summary>
            Try to get a new capacity value by the desired capacity to be set.
            </summary>
            <param name="this">The collection.</param>
            <param name="capacity">The desired capacity to be set.</param>
            <returns>The result value to be set.</returns>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListGridExtensions.GetSize(System.Collections.Generic.List{Sudoku.Concepts.Grid})">
            <summary>
            Try to fetch the internal field <c>_size</c> in type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="this">The list.</param>
            <returns>The reference to the internal field.</returns>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListGridExtensions.GetVersion(System.Collections.Generic.List{Sudoku.Concepts.Grid})">
            <summary>
            Try to fetch the internal field <c>_version</c> in type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="this">The list.</param>
            <returns>The reference to the internal field.</returns>
        </member>
        <member name="M:Sudoku.Runtime.CompilerServices.ListGridExtensions.GetItems(System.Collections.Generic.List{Sudoku.Concepts.Grid})">
            <summary>
            Try to fetch the internal reference to the first element of type <see cref="T:Sudoku.Concepts.Grid"/> in a <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="this">The list of grids.</param>
            <returns>The reference to the first element of type <see cref="T:Sudoku.Concepts.Grid"/>.</returns>
            <remarks><b><i>
            Please note that this method will return the reference to the internal field,
            but this doesn't mean you can use its reference and re-assign it.
            </i></b></remarks>
        </member>
        <member name="T:Sudoku.Runtime.LibraryServices.Library">
            <summary>
            Represents an entry that plays with a puzzle library file.
            </summary>
            <param name="directory">Indicates the parent directory that stores the library.</param>
            <param name="fileId">Indicates the file name used. The value should be valid as a file name, without file extension.</param>
            <remarks><i>
            This type only supports for Windows now. For other OS platforms,
            I will allow them in the future because I'm not familiar with file systems on other OS platforms.
            </i></remarks>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.#ctor(System.String,System.String)">
            <summary>
            Represents an entry that plays with a puzzle library file.
            </summary>
            <param name="directory">Indicates the parent directory that stores the library.</param>
            <param name="fileId">Indicates the file name used. The value should be valid as a file name, without file extension.</param>
            <remarks><i>
            This type only supports for Windows now. For other OS platforms,
            I will allow them in the future because I'm not familiar with file systems on other OS platforms.
            </i></remarks>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.Error_NotExist">
            <summary>
            Indicates the "Not Exist" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.Error_MultipleSamePropertiesFound">
            <summary>
            Indicates the "Multiple Same Properties Found" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.Error_DifferentExistenceOfConfigAndLibraryFile">
            <summary>
            Indicates the "Difference Existence of Library File and Config File" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.Error_FileShouldBeInitializedFirst">
            <summary>
            Indicates the "Related Files Should Be Initialized First" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.Error_UnrecognizedGridFormat">
            <summary>
            Indicates the "Unrecognized Grid Format" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.Error_ArgExtensionShouldBeValid">
            <summary>
            Indicates the "Argument 'extension' Should Be Valid" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.SeparatorChar">
            <summary>
            Indicates the separator character.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library.ConfigFileHeader">
            <summary>
            Indicates the file header of config files after created or initialized.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.IsInitialized">
            <summary>
            Indicates whether the library-related files are initialized.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.Count">
            <summary>
            Indicates the number of puzzles stored in this file.
            </summary>
            <remarks>
            This property is run synchronously, calling <see cref="M:Sudoku.Runtime.LibraryServices.Library.GetCountAsync(System.Threading.CancellationToken)"/>.
            <b>Always measure performance if you want to use this property.</b>
            </remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.Library.GetCountAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.LibraryFilePath">
            <summary>
            Indicates the path of the library file. The file only contains the puzzles.
            If you want to check for details of the configuration, use <see cref="P:Sudoku.Runtime.LibraryServices.Library.ConfigFilePath"/> instead.
            </summary>
            <seealso cref="P:Sudoku.Runtime.LibraryServices.Library.ConfigFilePath"/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.ConfigFilePath">
            <summary>
            Indicates the path of configuration file. The file contains the information of the library.
            </summary>
            <remarks>
            <para>
            Due to the design of the library APIs, a puzzle library contains two parts, separated with 2 files.
            One is the configuration file, and the other is the library details, only containing puzzles.
            </para>
            <para><i>
            Call this property will implicitly create config file if file is not found. No exception will be thrown here.
            </i></para>
            </remarks>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.Author">
            <summary>
            Indicates the author of the library. Return <see langword="null"/> if no author configured.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.Name">
            <summary>
            Indicates the name of the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.Description">
            <summary>
            Indicates the description to the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.Tags">
            <summary>
            Indicates the tags of the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.LastModifiedTime">
            <summary>
            Indicates the last modified time of the library file.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.ConfigFileExtension">
            <summary>
            Indicates the supported extension of config file. The extension will be used by API in runtime, recognizing config files.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.Item(System.Int32)">
            <summary>
            Try to get the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The target <see cref="T:Sudoku.Concepts.Grid"/> instance at the specified index.</returns>
            <remarks>
            This property is run synchronously, calling <see cref="M:Sudoku.Runtime.LibraryServices.Library.GetAtAsync(System.Int32,System.Threading.CancellationToken)"/>.
            <b>Always measure performance if you want to use this indexer.</b>
            </remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.Library.GetAtAsync(System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.Deconstruct(System.String@,System.String@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
    => (name, age) = (Name, Age);
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
(string name, int age) = student; // Explicitly-typed variables
var (name, age) = student; // Implicitly-typed variables
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.Initialize">
            <summary>
            Initializes the library-related files if not found. If initialized, throw <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInitializedException"/>.
            </summary>
            <exception cref="T:Sudoku.Runtime.LibraryServices.LibraryInitializedException">Throws when the library has already been initialized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.Delete">
            <summary>
            Delete the current library, removing files from local path.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.ClearPuzzles">
            <summary>
            Clears the current library, removing all puzzles stored in this library, making the file empty,
            but reserving the files not deleted.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library isn't initialized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.Equals(Sudoku.Runtime.LibraryServices.Library)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.Any">
            <summary>
            Determines whether the library contains at least one puzzle.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            <para>
            Append a puzzle, represented as a <see cref="T:System.String"/> value,
            into the specified file path represented as a puzzle library.
            </para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grid">The grid text code to be appended.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the grid cannot be recognized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzleAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzleAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            <para>
            Append a list of puzzles, represented as a list of <see cref="T:System.String"/> values,
            into the specified file path represented as a puzzle library.
            </para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grids">A list of grid text code to be appended.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> of an <see cref="T:System.Int32"/> instance indicating how many text code are appended into the file.
            </returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzlesAsync(System.Collections.Generic.IAsyncEnumerable{System.String},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Grid},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.RemovePuzzleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Removes all puzzles that exactly same as the specified one from the file.
            </summary>
            <param name="grid">The grid.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throw when the library file is not initialized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.RemovePuzzleAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.RemovePuzzleAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.RemoveDuplicatePuzzlesAsync(System.Threading.CancellationToken)">
            <summary>
            Removes a list of duplicate puzzles stored in the current library.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle should be initialized first.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.WriteAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            <para>Write a puzzle into a file just created.</para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grid">The grid to be written.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the grid cannot be recognized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.WriteAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.WriteAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.GetCountAsync(System.Threading.CancellationToken)">
            <summary>
            Calculates how many puzzles in this file.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> of an <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            <b><i>If you want to check whether the puzzle has at least one puzzle, please use method <see cref="M:Sudoku.Runtime.LibraryServices.Library.Any"/> instead.</i></b>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Throws when the library file is not initialized.</exception>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.Library.Any"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.GetAtAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Grid"/> at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Sudoku.Concepts.Grid"/> instance as the result.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the library file is not initialized.</exception>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.RandomReadOneAsync(Sudoku.Concepts.TransformType,System.Threading.CancellationToken)">
            <summary>
            Randomly read one puzzle in the specified file, and return it.
            </summary>
            <param name="transformTypes">
            Indicates the available transform type that the chosen grid can be transformed.
            Use <see cref="T:Sudoku.Concepts.TransformType"/>.<see langword="operator"/> |(<see cref="T:Sudoku.Concepts.TransformType"/>, <see cref="T:Sudoku.Concepts.TransformType"/>)
            to combine multiple flags.
            </param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Sudoku.Concepts.Grid"/> instance as the result.</returns>
            <exception cref="T:System.InvalidOperationException">Throw when the library file is not initialized.</exception>
            <seealso href="http://tinyurl.com/choose-a-random-element">Choose a random element from a sequence of unknown length</seealso>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.CreateTextPointer">
            <summary>
            Creates a <see cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/> instance that uses <see cref="T:System.IO.FileStream"/> to read puzzles line by line.
            </summary>
            <returns>A <see cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/> instance that reads for the current library.</returns>
            <remarks><b>
            This method returns an instance that implements <see cref="T:System.IAsyncDisposable"/> and <see cref="T:System.IDisposable"/>,
            meaning you must call <see cref="M:System.IAsyncDisposable.DisposeAsync"/> or <see cref="M:System.IDisposable.Dispose"/>
            after you finishing using the return value:
            <code><![CDATA[await using var pointer = library.CreateTextPointer();]]></code>
            </b></remarks>
            <seealso cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/>
            <seealso cref="T:System.IDisposable"/>
            <seealso cref="T:System.IAsyncDisposable"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.GetAsyncEnumerator(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.EnumerateTextAsync(System.Threading.CancellationToken)">
            <summary>
            Enumerates raw text codes stored in the library.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>An async-iterable collection of <see cref="T:System.String"/> values as raw text codes.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.ConfigFileReplaceOrAppend(System.Func{System.String,System.Boolean},System.String,System.String)">
            <summary>
            Replace or append the value into the file, using the specified match method.
            </summary>
            <param name="match">The matcher method.</param>
            <param name="replaceOrAppendValue">The value to replace with original value, or appened.</param>
            <param name="callerPropertyName">
            Indicates the property name as caller. This parameter shouldn't be assigned. It will be assigned by compiler.
            </param>
            <exception cref="T:System.InvalidOperationException">Throws when multiple same properties found.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.RegisterConfigFileExtension(System.String)">
            <summary>
            Registers the config file extension. Argument should contain prefix period token '<c>.</c>'.
            </summary>
            <param name="extension">The extension of the config file. Period '<c>.</c>' required.</param>
            <remarks>
            <b>Please note that only one extension can work. If you call this method multiple times, only the last one will work.</b>
            </remarks>
            <exception cref="T:System.ArgumentException">Throws when the argument <paramref name="extension"/> is not valid.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.GetSingleLineGridString(Sudoku.Concepts.Grid@)">
            <summary>
            Returns <c>grid.ToString("#")</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.AuthorPattern">
            <remarks>
            Pattern:<br/>
            <code>author:\\s*([\\s\\S]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Uu].<br/>
            ○ Match a character in the set [Tt].<br/>
            ○ Match a character in the set [Hh].<br/>
            ○ Match a character in the set [Oo].<br/>
            ○ Match a character in the set [Rr].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.NamePattern">
            <remarks>
            Pattern:<br/>
            <code>name:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Nn].<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Mm].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.DescriptionPattern">
            <remarks>
            Pattern:<br/>
            <code>description:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Dd].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Ss].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [Ii].<br/>
            ○ Match a character in the set [Pp].<br/>
            ○ Match a character in the set [Tt].<br/>
            ○ Match a character in the set [Ii].<br/>
            ○ Match a character in the set [Oo].<br/>
            ○ Match a character in the set [Nn].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.TagsPattern">
            <remarks>
            Pattern:<br/>
            <code>tags:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Tt].<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Gg].<br/>
            ○ Match a character in the set [Ss].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.Library._directory">
            <summary>
            The generated field declaration for parameter <c>directory</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.Library.FileId">
            <summary>
            The generated property declaration for parameter <c>fileId</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.op_Equality(Sudoku.Runtime.LibraryServices.Library,Sudoku.Runtime.LibraryServices.Library)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.Library.op_Inequality(Sudoku.Runtime.LibraryServices.Library,Sudoku.Runtime.LibraryServices.Library)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Runtime.LibraryServices.LibraryInitializedException">
            <summary>
            Represents an exception type that will be thrown if a library instance has already been initialized, but a user still calls
            method <see cref="M:Sudoku.Runtime.LibraryServices.Library.Initialize"/>.
            </summary>
            <param name="directory"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.#ctor(System.String,System.String)" path="/param[@name='directory']"/></param>
            <param name="fileId"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.#ctor(System.String,System.String)" path="/param[@name='fileId']"/></param>
            <remarks><i>
            This type is only used by Windows platform because the relied type <see cref="T:Sudoku.Runtime.LibraryServices.Library"/>
            is marked <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute"/>, limited in Windows.
            </i></remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.Library.Initialize"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInitializedException.#ctor(System.String,System.String)">
            <summary>
            Represents an exception type that will be thrown if a library instance has already been initialized, but a user still calls
            method <see cref="M:Sudoku.Runtime.LibraryServices.Library.Initialize"/>.
            </summary>
            <param name="directory"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.#ctor(System.String,System.String)" path="/param[@name='directory']"/></param>
            <param name="fileId"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.Library.#ctor(System.String,System.String)" path="/param[@name='fileId']"/></param>
            <remarks><i>
            This type is only used by Windows platform because the relied type <see cref="T:Sudoku.Runtime.LibraryServices.Library"/>
            is marked <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute"/>, limited in Windows.
            </i></remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.Library.Initialize"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInitializedException.#ctor(Sudoku.Runtime.LibraryServices.Library)">
            <summary>
            Initializes a <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInitializedException"/> instance via the specified directory and file ID.
            </summary>
            <param name="library">The library instance.</param>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInitializedException.Message">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInitializedException.Directory">
            <summary>
            The generated property declaration for parameter <c>directory</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInitializedException.FileId">
            <summary>
            The generated property declaration for parameter <c>fileId</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.LibraryServices.TextPointer">
            <summary>
            Represents a text pointer object that reads the detail of a <see cref="T:Sudoku.Runtime.LibraryServices.Library"/>.
            </summary>
            <remarks><i>
            This type only supports for Windows now because the relied type <see cref="T:Sudoku.Runtime.LibraryServices.Library"/> is limited in Windows.
            </i></remarks>
            <seealso cref="T:Sudoku.Runtime.LibraryServices.Library"/>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.TextPointer.MaxLimitOfPuzzleLength">
            <summary>
            Indicates the max limit of a puzzle length.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.TextPointer.Error_LibraryShouldBeInitialized">
            <summary>
            Indicates the "Library should be initialized" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.TextPointer.Error_PointerCannotMove">
            <summary>
            Indicates the "Pointer cannot move" message.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.TextPointer._stream">
            <summary>
            Indicates the internal stream.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.#ctor(Sudoku.Runtime.LibraryServices.Library)">
            <summary>
            Initializes a <see cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/> instance via the specified library.
            </summary>
            <param name="library">Indicates the libary object.</param>
            <exception cref="T:System.ArgumentException">Throws when the library is not initialized.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.ForwardPuzzlesCount">
            <summary>
            Indicates the number of puzzles left to be iterated from the current position. The current puzzle will be included.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.BackPuzzlesCount">
            <summary>
            Indicates the number of puzzles left to be iterated back from the current position. The current puzzle will be included.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.Current">
            <summary>
            Indicates the currently-pointed puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.Length">
            <summary>
            Indicates the number of puzzles stored in the file, regardless of the position of the pointer.
            </summary>
            <remarks><inheritdoc cref="P:Sudoku.Runtime.LibraryServices.Library.Count" path="/remarks"/></remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.Library.GetCountAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.Library">
            <summary>
            Indicates the library object.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#Generic#IReadOnlyCollection{System#String}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.PositionOfPointer">
            <summary>
            Indicates the position of the pointer.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.SetStart">
            <summary>
            Sets the pointer to the start position, 0.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.SetEnd">
            <summary>
            Sets the pointer to the end position, the length of the stream.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.Equals(Sudoku.Runtime.LibraryServices.TextPointer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryReadNextPuzzle(System.String@)">
            <summary>
            Try to read the next puzzle beginning with the current text pointer position.
            </summary>
            <param name="result">The result of the grid, represented as a <see cref="T:System.String"/> result.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the file exists the next grid.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryReadPreviousPuzzle(System.String@)">
            <summary>
            Try to read the previous puzzle beginning with the current text pointer position.
            </summary>
            <param name="result">The result of the grid, represented as a <see cref="T:System.String"/> result.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the file exists the previous grid.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TrySkipNext(System.Int32)">
            <summary>
            Try to skip the number of puzzles forward, making the pointer point to the next grid after the skipped grids.
            </summary>
            <param name="count">The desired number of puzzles to be skipped. The default value is 1.</param>
            <returns>The number of puzzles skipped in fact.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TrySkipPrevious(System.Int32)">
            <summary>
            Try to skip the number of puzzles back, making the pointer point to the next grid before the skipped grids.
            </summary>
            <param name="count">The desired number of puzzles to be skipped. The default value is 1.</param>
            <returns>The number of puzzles skipped in fact.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryFetchNext(System.Int32,System.ReadOnlySpan{System.String}@)">
            <summary>
            Fetch the number of puzzles beginning with the current pointer position.
            </summary>
            <param name="count">The desired number of puzzles.</param>
            <param name="result">Indicates the puzzles fetched.</param>
            <returns>The number of puzzles fetched.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryFetchPrevious(System.Int32,System.ReadOnlySpan{System.String}@)">
            <summary>
            Fetch the number of puzzles in previous beginning with the current pointer position.
            </summary>
            <param name="count">The desired number of puzzles.</param>
            <param name="result">Indicates the puzzles fetched.</param>
            <returns>The number of puzzles fetched.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.GetEnumerator">
            <summary>
            Returns itself. The method is consumed by <see langword="foreach"/> loops.
            </summary>
            <returns>A <see cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/> instance that can iterate on each puzzle stored in library file.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerator#MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#Generic#IEnumerable{System#String}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Increment(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the next puzzle. If the pointer is at the end of the sequence, moves to the first element.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedIncrement(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the next puzzle. If the pointer is at the end of the sequence,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the pointer cannot be moved.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Decrement(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the previous puzzle. If the pointer is at the start of the sequence, moves to the last element.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedDecrement(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the previous puzzle. If the pointer is at the start of the sequence, throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the pointer cannot be moved.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Addition(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles forward.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedAddition(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles forward. If the pointer has already moved to the last element,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements can be skipped.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Subtraction(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles back.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedSubtraction(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles back. If the pointer has already moved to the first element,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements can be skipped.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Equality(Sudoku.Runtime.LibraryServices.TextPointer,Sudoku.Runtime.LibraryServices.TextPointer)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Inequality(Sudoku.Runtime.LibraryServices.TextPointer,Sudoku.Runtime.LibraryServices.TextPointer)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.HouseMaskOperations">
            <summary>
            Represents a list of methods handling with <see cref="T:System.Int32"/> instances.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllBlocksMask">
            <summary>
            Indicates the mask that means all blocks.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllRowsMask">
            <summary>
            Indicates the mask that means all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllColumnsMask">
            <summary>
            Indicates the mask that means all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllHousesMask">
            <summary>
            Indicates the mask that means all houses.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.HouseMaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int32"/> instance via the specified houses.
            </summary>
            <param name="houses">The houses.</param>
            <returns>A <see cref="T:System.Int32"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.MaskOperations">
            <summary>
            Provides with a set of methods that operates with mask defined in basic sudoku concepts, as data structures.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int16"/> instance via the specified digits.
            </summary>
            <param name="digits">The digits.</param>
            <returns>A <see cref="T:System.Int16"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.Collections.Generic.HashSet{System.Int32})">
            <inheritdoc cref="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.ReadOnlySpan{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToDigits(System.Int16)">
            <summary>
            To get the digits that the current mask represents for. The mask must be between 0 and 512, and exclude 512.
            </summary>
            <param name="digitMask">The digit mask.</param>
            <returns>The digits returned.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToCellState(System.Int16)">
            <summary>
            To get the cell state for a mask value. The mask is an inner representation to describe a cell's state.
            For more information please visit the details of the design for type <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The mask.</param>
            <returns>The cell state.</returns>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.GetMaskSubsets(System.Int16)">
            <summary>
            Get all mask combinations.
            </summary>
            <param name="value">The mask.</param>
            <returns>The result list.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.GetMaskSubsets(System.Int16,System.Int32)">
            <summary>
            Get all mask combinations.
            </summary>
            <param name="value">The mask.</param>
            <param name="size">The size.</param>
            <returns>The result list.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.SplitMask(System.Int16)">
            <summary>
            Try to split a mask into 3 parts, 3-bit as a unit.
            </summary>
            <param name="this">The mask instance to be split.</param>
            <returns>A triplet of values.</returns>
        </member>
        <member name="T:Sudoku.SolutionFields">
            <summary>
            Provides with solution-wide read-only fields used.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.NumberOfPeersForEachCell">
            <summary>
            Indicates the number of each cell's peer cells. The value is a constant.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.TrailingZeroCountFallback">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L586">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>
        </member>
        <member name="F:Sudoku.SolutionFields.TrailingZeroCountFallbackLong">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L647">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>
        </member>
        <member name="F:Sudoku.SolutionFields.Digits">
            <summary>
            Indicates the digits used. The value can be also used for ordered houses by rows.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesOrderedByColumn">
            <summary>
            Indicates the houses ordered by column.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseFirst">
            <summary>
            Indicates the first cell offset for each house.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseCells">
            <summary>
            <para>
            The map of all cell offsets in its specified house.
            The indices is between 0 and 26, where:
            <list type="table">
            <item>
            <term><c>0..9</c></term>
            <description>Block 1 to 9.</description>
            </item>
            <item>
            <term><c>9..18</c></term>
            <description>Row 1 to 9.</description>
            </item>
            <item>
            <term><c>18..27</c></term>
            <description>Column 1 to 9.</description>
            </item>
            </list>
            </para>
            </summary>
            <example>
            '<c>HouseCells[0]</c>': all cell offsets in the house 0 (block 1).
            </example>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the cells belong to a house at the specified index.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.PeersMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the peer cells of a cell at the specified index.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.Chutes">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.Chute"/> instances representing chutes.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseTypes">
            <summary>
            Indicates the possible house types to be iterated.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.BlockTable">
            <summary>
            Indicates a block list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.RowTable">
            <summary>
            Indicates a row list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ColumnTable">
            <summary>
            Indicates a column list that each cell belongs to.
            </summary>
        </member>
        <member name="M:Sudoku.SolutionFields.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Text.Converters.BitStatusCellMapConverter">
            <summary>
            Represents a converter that uses bit operation to format <see cref="T:Sudoku.Concepts.CellMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Text.Converters.BitStatusCellMapConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.CandidateNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="candidates">A list of candidates.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="candidates"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.CellNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="cells">A list of cells.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="cells"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.ChuteNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:Sudoku.Concepts.Chute"/> instance.
            </summary>
            <param name="chutes">A list of chutes.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="chutes"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.ConclusionNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:Sudoku.Analytics.Conclusion"/> instance.
            </summary>
            <param name="conclusions">A list of conjugate pairs.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="conclusions"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.ConjugateNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:Sudoku.Concepts.Conjugate"/> instance.
            </summary>
            <param name="conjugatePairs">A list of conjugate pairs.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="conjugatePairs"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.CoordinateConverter">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
            <remarks>
            You can use types <see cref="T:Sudoku.Text.Converters.RxCyConverter"/>, <seealso cref="T:Sudoku.Text.Converters.K9Converter"/>, <see cref="T:Sudoku.Text.Converters.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Text.Converters.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Text.Converters.RxCyConverter"/>
            <seealso cref="T:Sudoku.Text.Converters.K9Converter"/>
            <seealso cref="T:Sudoku.Text.Converters.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Text.Converters.ExcelCoordinateConverter"/>
        </member>
        <member name="M:Sudoku.Text.Converters.CoordinateConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
            <remarks>
            You can use types <see cref="T:Sudoku.Text.Converters.RxCyConverter"/>, <seealso cref="T:Sudoku.Text.Converters.K9Converter"/>, <see cref="T:Sudoku.Text.Converters.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Text.Converters.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Text.Converters.RxCyConverter"/>
            <seealso cref="T:Sudoku.Text.Converters.K9Converter"/>
            <seealso cref="T:Sudoku.Text.Converters.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Text.Converters.ExcelCoordinateConverter"/>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.CellConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of cells.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.CandidateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.HouseConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of houses.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.ConclusionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.DigitConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of digits.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.IntersectionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified information for an intersection.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.ChuteConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of chute.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.ConjugateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified conjugate.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.CoordinateConverter.TargetCurrentCulture">
            <summary>
            Indicates the target culture.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Converters.DigitNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:System.Int16"/> instance.
            </summary>
            <param name="digitsMask">A list of digits.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="digitsMask"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.ExcelCoordinateConverter">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Text.Converters.ExcelCoordinateConverter.#ctor(System.Boolean,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.ExcelGridConverter">
            <summary>
            Represents with a converter that uses <c>Excel</c>-compatible <c>csv</c>-format to convert <see cref="T:Sudoku.Concepts.Grid"/> instances.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.ExcelGridConverter.Tab">
            <summary>
            Indicates the tab character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.ExcelGridConverter.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.ExcelGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.GenericConceptConverter">
            <summary>
            Represents a converter that only converts from variant concept objects into corresponding equivalent <see cref="T:System.String"/> values.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
        </member>
        <member name="M:Sudoku.Text.Converters.GenericConceptConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a converter that only converts from variant concept objects into corresponding equivalent <see cref="T:System.String"/> values.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
        </member>
        <member name="P:Sudoku.Text.Converters.GenericConceptConverter.DefaultSeparator">
            <summary>
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.GenericConceptConverter.DigitsSeparator">
            <summary>
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.GenericConceptConverter.CurrentCulture">
            <summary>
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </summary>
        </member>
        <member name="T:Sudoku.Text.Converters.GlobalizedConverter">
            <summary>
            Represents a type that defines some easy-in-use members, making user work with types derived from <see cref="T:Sudoku.Text.Converters.CoordinateConverter"/> easier
            for variant culture.
            </summary>
            <seealso cref="T:Sudoku.Text.Converters.CoordinateConverter"/>
            <seealso cref="T:System.Globalization.CultureInfo"/>
        </member>
        <member name="P:Sudoku.Text.Converters.GlobalizedConverter.InvariantCultureConverter">
            <summary>
            Indicates the <see cref="T:Sudoku.Text.Converters.CoordinateConverter"/> instance for the invariant culture.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Converters.GlobalizedConverter.GetConverter(System.Globalization.CultureInfo)">
            <summary>
            Try to get a <see cref="T:Sudoku.Text.Converters.CoordinateConverter"/> instance from the specified culture.
            </summary>
            <param name="culture">The culture.</param>
            <returns>The <see cref="T:Sudoku.Text.Converters.CoordinateConverter"/> instance from the specified culture.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.GridNotationConverter">
            <summary>
            Defines a method that converts a <see cref="T:Sudoku.Concepts.Grid"/> instance, converting it into an equivalent <see cref="T:System.String"/> value.
            </summary>
            <param name="Grid">The grid.</param>
            <returns>The equivalent <see cref="T:System.String"/> result.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.HodokuLibraryGridConverter">
            <summary>
            Represents a type that converts from a <see cref="T:Sudoku.Concepts.Grid"/> into an equivalent <see cref="T:System.String"/> representation
            using Hodoku library text rule.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.HodokuLibraryGridConverter.FormatPrefix">
            <summary>
            Indicates the format prefix.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.HodokuLibraryGridConverter.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.HodokuLibraryGridConverter.FormatSuffix">
            <summary>
            Indicates the format suffix.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.HodokuLibraryGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.HodokuTripletConverter">
            <summary>
            Represents a coordinate converter using <b>Hodoku Triplet</b> notation.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.HodokuTripletConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.HouseNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value via the specified <see cref="T:System.Int32"/> instance.
            </summary>
            <param name="housesMask">A list of houses.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="housesMask"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.InlineSusserGridConverter">
            <summary>
            Represents a grid converter that uses inline Susser format, by using square brackets to describe candidates,
            removing triplet set.
            </summary>
            <param name="NegateEliminationsTripletRule">
            <inheritdoc cref="T:Sudoku.Text.Converters.SusserGridConverter" path="/param[@name='NegateEliminationsTripletRule']"/>
            </param>
        </member>
        <member name="M:Sudoku.Text.Converters.InlineSusserGridConverter.#ctor(System.Boolean)">
            <summary>
            Represents a grid converter that uses inline Susser format, by using square brackets to describe candidates,
            removing triplet set.
            </summary>
            <param name="NegateEliminationsTripletRule">
            <inheritdoc cref="T:Sudoku.Text.Converters.SusserGridConverter" path="/param[@name='NegateEliminationsTripletRule']"/>
            </param>
        </member>
        <member name="P:Sudoku.Text.Converters.InlineSusserGridConverter.NegateEliminationsTripletRule">
            <summary>
            <inheritdoc cref="T:Sudoku.Text.Converters.SusserGridConverter" path="/param[@name='NegateEliminationsTripletRule']"/>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.InlineSusserGridConverter.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.InlineSusserGridConverter.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.InlineSusserGridConverter.ModifiablePrefix">
            <summary>
            Indicates the modifiable prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.InlineSusserGridConverter.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.InlineSusserGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.InlineSusserGridConverter.NegateEliminationsTripletRule"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.InlineSusserGridConverter.DefaultZero">
            <summary>
            Indicates the instance whose inner properties are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.InlineSusserGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.InlineSusserGridConverter.NegateEliminationsTripletRule"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.InlineSusserGridConverter.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Text.Converters.InlineSusserGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Text.Converters.InlineSusserGridConverter._placeholder">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Text.Converters.InlineSusserGridConverter.Placeholder"/>.
            </summary>
            <seealso cref="P:Sudoku.Text.Converters.InlineSusserGridConverter.Placeholder"/>
        </member>
        <member name="T:Sudoku.Text.Converters.IntersectionNotationConverter">
            <summary>
            Represents a delegate type that creates a <see cref="T:System.String"/> value
            via the specified <see cref="T:Sudoku.Concepts.IntersectionBase"/> and <see cref="T:Sudoku.Concepts.IntersectionResult"/> instance.
            </summary>
            <param name="intersections">A list of intersections.</param>
            <returns>An equivalent <see cref="T:System.String"/> value to the specified argument <paramref name="intersections"/>.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.K9Converter">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distincting with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Text.Converters.K9Converter.#ctor(System.Boolean,System.Char,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distincting with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.FinalRowLetter">
            <summary>
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distincting with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.K9Converter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.LiteralCoordinateConverter">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Text.Converters.LiteralCoordinateConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.LiteralCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.MaskGridConverter">
            <summary>
            Represents a type that converts the grid into an equivalent <see cref="T:System.String"/> representation using mask displaying rule.
            </summary>
            <param name="Separator">
            <para>Indicates the mask separator.</para>
            <para>The default value is a comma followed by a space: <c>", "</c>.</para>
            </param>
            <remarks>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Converters.MaskGridConverter.#ctor(System.String)">
            <summary>
            Represents a type that converts the grid into an equivalent <see cref="T:System.String"/> representation using mask displaying rule.
            </summary>
            <param name="Separator">
            <para>Indicates the mask separator.</para>
            <para>The default value is a comma followed by a space: <c>", "</c>.</para>
            </param>
            <remarks>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </remarks>
        </member>
        <member name="P:Sudoku.Text.Converters.MaskGridConverter.Separator">
            <summary>
            <para>Indicates the mask separator.</para>
            <para>The default value is a comma followed by a space: <c>", "</c>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.MaskGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.MultipleLineGridConverter">
            <summary>
            Represents a converter that converts a <see cref="T:Sudoku.Concepts.Grid"/> instance into an equivalent <see cref="T:System.String"/> representation
            using multiple-line formatting rule.
            </summary>
            <param name="SubtleGridLines"><inheritdoc cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.SubtleGridLines" path="/summary"/></param>
            <param name="TreatValueAsGiven"><inheritdoc cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.TreatValueAsGiven" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Text.Converters.MultipleLineGridConverter.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Represents a converter that converts a <see cref="T:Sudoku.Concepts.Grid"/> instance into an equivalent <see cref="T:System.String"/> representation
            using multiple-line formatting rule.
            </summary>
            <param name="SubtleGridLines"><inheritdoc cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.SubtleGridLines" path="/summary"/></param>
            <param name="TreatValueAsGiven"><inheritdoc cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.TreatValueAsGiven" path="/summary"/></param>
        </member>
        <member name="P:Sudoku.Text.Converters.MultipleLineGridConverter.SubtleGridLines">
            <summary><inheritdoc cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.SubtleGridLines" path="/summary"/></summary>
        </member>
        <member name="P:Sudoku.Text.Converters.MultipleLineGridConverter.TreatValueAsGiven">
            <summary><inheritdoc cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.TreatValueAsGiven" path="/summary"/></summary>
        </member>
        <member name="F:Sudoku.Text.Converters.MultipleLineGridConverter.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.MultipleLineGridConverter.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.MultipleLineGridConverter.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.MultipleLineGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.MultipleLineGridConverter.SubtleGridLines"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.MultipleLineGridConverter.TreatValueAsGiven"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.MultipleLineGridConverter.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Text.Converters.MultipleLineGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Text.Converters.MultipleLineGridConverter._placeholder">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Text.Converters.MultipleLineGridConverter.Placeholder"/>.
            </summary>
            <seealso cref="P:Sudoku.Text.Converters.MultipleLineGridConverter.Placeholder"/>
        </member>
        <member name="T:Sudoku.Text.Converters.OpenSudokuGridConverter">
            <summary>
            Represents a converter type for Open-Sudoku app format.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.OpenSudokuGridConverter.Terminator">
            <summary>
            Indicates the string terminator character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.OpenSudokuGridConverter.Separator">
            <summary>
            Indicates the separator character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.OpenSudokuGridConverter.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.OpenSudokuGridConverter.One">
            <summary>
            Indicates the one character.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.OpenSudokuGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.PencilmarkingGridConverter">
            <summary>
            Represents a converter type that converts a <see cref="T:Sudoku.Concepts.Grid"/> into an equivalent <see cref="T:System.String"/> representation
            using pencil-marking grid formatting rule.
            </summary>
            <param name="SubtleGridLines">
            <para>Indicates whether need to handle all grid outlines while outputting.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="TreatValueAsGiven">
            <para>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>' instead
            of '<c>*digit*</c>'.
            </para>
            <para>
            The value has 3 possible cases:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The formatter will treat all value cells as given one, no matter what kind of value cell it is, given or modifiable.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The formatter will tell with givens and modifiables.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            The formatter will <b>not</b> check its value states. It will be displayed and handled as candidate cells,
            using a single digit to display the cell.
            </description>
            </item>
            </list>
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Text.Converters.PencilmarkingGridConverter.#ctor(System.Boolean,System.Nullable{System.Boolean})">
            <summary>
            Represents a converter type that converts a <see cref="T:Sudoku.Concepts.Grid"/> into an equivalent <see cref="T:System.String"/> representation
            using pencil-marking grid formatting rule.
            </summary>
            <param name="SubtleGridLines">
            <para>Indicates whether need to handle all grid outlines while outputting.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="TreatValueAsGiven">
            <para>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>' instead
            of '<c>*digit*</c>'.
            </para>
            <para>
            The value has 3 possible cases:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The formatter will treat all value cells as given one, no matter what kind of value cell it is, given or modifiable.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The formatter will tell with givens and modifiables.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            The formatter will <b>not</b> check its value states. It will be displayed and handled as candidate cells,
            using a single digit to display the cell.
            </description>
            </item>
            </list>
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="P:Sudoku.Text.Converters.PencilmarkingGridConverter.SubtleGridLines">
            <summary>
            <para>Indicates whether need to handle all grid outlines while outputting.</para>
            <para>The default value is <see langword="true"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.PencilmarkingGridConverter.TreatValueAsGiven">
            <summary>
            <para>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>' instead
            of '<c>*digit*</c>'.
            </para>
            <para>
            The value has 3 possible cases:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The formatter will treat all value cells as given one, no matter what kind of value cell it is, given or modifiable.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The formatter will tell with givens and modifiables.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            The formatter will <b>not</b> check its value states. It will be displayed and handled as candidate cells,
            using a single digit to display the cell.
            </description>
            </item>
            </list>
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.PencilmarkingGridConverter.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.SubtleGridLines"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.PencilmarkingGridConverter.TreatValueAsGiven"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.PencilmarkingGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.RxCyConverter">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Text.Converters.RxCyConverter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.MakeDigitBeforeCell">
            <summary>
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.HouseNotationOnlyDisplayCapitals">
            <summary>
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Converters.RxCyConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Converters.RxCyConverter.GetLabel(System.Byte)">
            <summary>
            Get the label of each house.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>The label.</returns>
        </member>
        <member name="T:Sudoku.Text.Converters.SukakuGridConverter">
            <summary>
            Represents a converter type that converts a <see cref="T:Sudoku.Concepts.Grid"/> instance into an equivalent <see cref="T:System.String"/> value
            using Sukaku formatting rule.
            </summary>
            <param name="Multiline">
            <para>Indicates whether the output should be multi-line.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Text.Converters.SukakuGridConverter.#ctor(System.Boolean)">
            <summary>
            Represents a converter type that converts a <see cref="T:Sudoku.Concepts.Grid"/> instance into an equivalent <see cref="T:System.String"/> value
            using Sukaku formatting rule.
            </summary>
            <param name="Multiline">
            <para>Indicates whether the output should be multi-line.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
        </member>
        <member name="P:Sudoku.Text.Converters.SukakuGridConverter.Multiline">
            <summary>
            <para>Indicates whether the output should be multi-line.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SukakuGridConverter.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SukakuGridConverter.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SukakuGridConverter.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.SukakuGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.SukakuGridConverter.Multiline"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.SukakuGridConverter.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Text.Converters.SukakuGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Text.Converters.SukakuGridConverter._placeholder">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Text.Converters.SukakuGridConverter.Placeholder"/>.
            </summary>
            <seealso cref="P:Sudoku.Text.Converters.SukakuGridConverter.Placeholder"/>
        </member>
        <member name="T:Sudoku.Text.Converters.SusserEliminationsGridConverter">
            <summary>
            Represents with a Susser format, but only extracts for pre-eliminations.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserEliminationsGridConverter.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithCandidates"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.ShortenSusser"/>: <see langword="false"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.NegateEliminationsTripletRule"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserEliminationsGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Converters.SusserEliminationsGridConverter.EliminationPattern">
            <remarks>
            Pattern:<br/>
            <code>(?&lt;=\\:)(\\d{3}\\s+)*\\d{3}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Zero-width positive lookbehind.<br/>
                ○ Match ':' right-to-left.<br/>
            ○ Loop greedily any number of times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
                    ○ Match a whitespace character atomically at least once.<br/>
            ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Converters.SusserGridConverter">
            <summary>
            Represents a converter that converts a <see cref="T:Sudoku.Concepts.Grid"/> into an equivalent <see cref="T:System.String"/> representation
            using Susser formatting rule.
            </summary>
            <param name="WithCandidates">
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="WithModifiables">
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="ShortenSusser">
            <para>Indicates whether the formatter will shorten the final text.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="NegateEliminationsTripletRule">
            <inheritdoc cref="M:Sudoku.Text.Parsers.SusserGridParser.#ctor(System.Boolean,System.Boolean)" path="/param[@name='NegateEliminationsTripletRule']"/>
            </param>
        </member>
        <member name="M:Sudoku.Text.Converters.SusserGridConverter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Represents a converter that converts a <see cref="T:Sudoku.Concepts.Grid"/> into an equivalent <see cref="T:System.String"/> representation
            using Susser formatting rule.
            </summary>
            <param name="WithCandidates">
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="WithModifiables">
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="ShortenSusser">
            <para>Indicates whether the formatter will shorten the final text.</para>
            <para>The default value is <see langword="false"/>.</para>
            </param>
            <param name="NegateEliminationsTripletRule">
            <inheritdoc cref="M:Sudoku.Text.Parsers.SusserGridParser.#ctor(System.Boolean,System.Boolean)" path="/param[@name='NegateEliminationsTripletRule']"/>
            </param>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserGridConverter.WithCandidates">
            <summary>
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserGridConverter.WithModifiables">
            <summary>
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserGridConverter.ShortenSusser">
            <summary>
            <para>Indicates whether the formatter will shorten the final text.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserGridConverter.NegateEliminationsTripletRule">
            <summary>
            <inheritdoc cref="M:Sudoku.Text.Parsers.SusserGridParser.#ctor(System.Boolean,System.Boolean)" path="/param[@name='NegateEliminationsTripletRule']"/>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.ModifiablePrefix">
            <summary>
            Indicates the modifiable prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.LineLimit">
            <summary>
            Indicates the line separator character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.Star">
            <summary>
            Indicates the star character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.PreeliminationPrefix">
            <summary>
            Indicates the pre-elimination prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithCandidates"/>: <see langword="false"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithModifiables"/>: <see langword="false"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.Full">
            <summary>
            Indicates the instance whose inner properties are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithCandidates"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter.FullZero">
            <summary>
            Indicates the instance whose inner properties are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder"/>: <c>'0'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithCandidates"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserGridConverter.Converter">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverter._placeholder">
            <summary>
            Indicates the backing field of property <see cref="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder"/>.
            </summary>
            <seealso cref="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder"/>
        </member>
        <member name="T:Sudoku.Text.Converters.EqualityComparer">
            <summary>
            Represents a comparer instance that compares two <see cref="T:System.Text.RegularExpressions.Match"/> instances via their length.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.Match"/>
        </member>
        <member name="F:Sudoku.Text.Converters.EqualityComparer.Instance">
            <summary>
            The singleton instance.
            </summary>
        </member>
        <member name="M:Sudoku.Text.Converters.EqualityComparer.Equals(System.Text.RegularExpressions.Match,System.Text.RegularExpressions.Match)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Converters.EqualityComparer.GetHashCode(System.Text.RegularExpressions.Match)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Converters.SusserGridConverterTreatingValuesAsGivens">
            <summary>
            Represents with a Susser formatter, removing all plus mark <c>'+'</c> as modifiable distinction tokens.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Converters.SusserGridConverterTreatingValuesAsGivens.Default">
            <summary>
            Indicates the default instance. The properties set are:
            <list type="bullet">
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.Placeholder"/>: <c>'.'</c></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithModifiables"/>: <see langword="true"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.WithCandidates"/>: <see langword="false"/></item>
            <item><see cref="P:Sudoku.Text.Converters.SusserGridConverter.ShortenSusser"/>: <see langword="false"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Converters.SusserGridConverterTreatingValuesAsGivens.Converter">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.CoordinateConverterAttribute`1">
            <summary>
            Represents an attribute type that specifies the bound concept for converter.
            </summary>
            <typeparam name="T">The type of the converter.</typeparam>
        </member>
        <member name="T:Sudoku.Text.CoordinateParserAttribute`1">
            <summary>
            Represents an attribute type that specifies the bound concept for parser.
            </summary>
            <typeparam name="T">The type of the parser.</typeparam>
        </member>
        <member name="T:Sudoku.Text.GridFormatterFactory">
            <summary>
            Indicates the factory that creates the grid formatter.
            </summary>
        </member>
        <member name="M:Sudoku.Text.GridFormatterFactory.GetBuiltInConverter(System.String)">
            <summary>
            Get a built-in converter instance according to the specified format.
            </summary>
            <param name="format">The format.</param>
            <returns>The grid formatter.</returns>
            <exception cref="T:System.FormatException">Throws when the format string is invalid.</exception>
        </member>
        <member name="T:Sudoku.Text.IConceptConverter`1">
            <summary>
            Represents a converter that only converts from a specified concept object into an equivalent <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T">The type of the instance to be converted.</typeparam>
        </member>
        <member name="P:Sudoku.Text.IConceptConverter`1.Converter">
            <summary>
            Indicates the converter that can convert a <typeparamref name="T"/> instance into an equivalent <see cref="T:System.String"/> representation.
            </summary>
        </member>
        <member name="T:Sudoku.Text.IConceptParser`1">
            <summary>
            Represents a parser that only parses into a specified concept object from a specified <see cref="T:System.String"/> text.
            </summary>
            <typeparam name="T">The type of return value.</typeparam>
        </member>
        <member name="P:Sudoku.Text.IConceptParser`1.Parser">
            <summary>
            A parser instance that parses the specified <see cref="T:System.String"/> text, converting it into a valid <typeparamref name="T"/> instance.
            </summary>
        </member>
        <member name="T:Sudoku.Text.ICoordinateObject`1">
            <summary>
            Defines a type that supports for coordinate output rule.
            </summary>
            <typeparam name="TSelf">The type of implementation.</typeparam>
        </member>
        <member name="M:Sudoku.Text.ICoordinateObject`1.ToString(Sudoku.Text.Converters.CoordinateConverter)">
            <summary>
            Formats the current instance, converting it into a <see cref="T:System.String"/> result that can describe for this object.
            The conversion rule is specified as parameter <paramref name="converter"/>.
            </summary>
            <param name="converter">The coordinate converter object.</param>
            <returns>A <see cref="T:System.String"/> representation of the current object.</returns>
        </member>
        <member name="M:Sudoku.Text.ICoordinateObject`1.ParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser)">
            <summary>
            Parses the specified <see cref="T:System.String"/> text and convert into a <typeparamref name="TSelf"/> instance,
            using the specified parsing rule.
            </summary>
            <param name="str">The string text to be parsed.</param>
            <param name="parser">The parser instance to be used.</param>
            <returns>A valid <typeparamref name="TSelf"/> instance parsed.</returns>
            <exception cref="T:System.FormatException">Throws when the <see cref="T:Sudoku.Text.Parsers.CoordinateParser"/> instance cannot parse it.</exception>
        </member>
        <member name="M:Sudoku.Text.ICoordinateObject`1.TryParseExact(System.String,Sudoku.Text.Parsers.CoordinateParser,`0@)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> text and convert into a <typeparamref name="TSelf"/> instance,
            using the specified parsing rule. If the parsing operation is failed, return <see langword="false"/> to report the failure case.
            No exceptions will be thrown.
            </summary>
            <param name="str">The string text to be parsed.</param>
            <param name="parser">The parser instance to be used.</param>
            <param name="result">A parsed value of type <typeparamref name="TSelf"/>.</param>
            <returns>Indicates whether the parsing operation is successful.</returns>
        </member>
        <member name="T:Sudoku.Text.ICultureFormattable">
            <summary>
            Represents an object that describes for an object that is defined in sudoku puzzle, with globalization (I18N) output supported.
            </summary>
            <seealso cref="T:System.Globalization.CultureInfo"/>
        </member>
        <member name="M:Sudoku.Text.ICultureFormattable.ToString(System.Globalization.CultureInfo)">
            <summary>
            Converts the current object into an <see cref="T:System.String"/> result, using the specified <see cref="T:System.Globalization.CultureInfo"/>
            to describe the data.
            </summary>
            <param name="culture">The current culture to be used.</param>
            <returns>The final <see cref="T:System.String"/> representation of the object.</returns>
        </member>
        <member name="T:Sudoku.Text.Languages">
            <summary>
            Indicates the supported languages in resource.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Languages.EnglishLanguage">
            <summary>
            Indicates English language identifier.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Languages.ChineseLanguage">
            <summary>
            Indicates Chinese language identifier.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Parsers.BitStatusCellMapParser">
            <summary>
            Represents a parser that uses bit operation rule to parse <see cref="T:Sudoku.Concepts.CellMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.BitStatusCellMapParser.Parser">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Parsers.CoordinateParser">
            <summary>
            Represents for a parser instance that parses a <see cref="T:System.String"/> text,
            converting it into a valid <see cref="T:Sudoku.Text.ICoordinateObject`1"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Text.ICoordinateObject`1"/>
        </member>
        <member name="F:Sudoku.Text.Parsers.CoordinateParser.DeprecatedInfo_NotSupported">
            <summary>
            The not supported information for property implemented.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.CellParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CellMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.CandidateParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.HouseParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int32"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.ConclusionParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Analytics.Conclusion"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Analytics.Conclusion"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.DigitParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int16"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.IntersectionParser">
            <summary>
            The parser method that can creates a list of pairs of <see cref="T:Sudoku.Concepts.IntersectionBase"/> and <see cref="T:Sudoku.Concepts.IntersectionResult"/>
            via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.IntersectionBase"/>
            <seealso cref="T:Sudoku.Concepts.IntersectionResult"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.ChuteParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Chute"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Chute"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.CoordinateParser.ConjuagteParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Conjugate"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conjugate"/>
        </member>
        <member name="T:Sudoku.Text.Parsers.ExcelGridParser">
            <summary>
            Represents an Excel grid parser.
            </summary>
            <example>
            For example:
            <code><![CDATA[
            1			7	8	9	4	5	6
            4	5	6	1	2	3	7	8	9
            7	8	9	4	5	6	1	2	
            9	1	2	6		8	3	4	
            3	4	5				6	7	8
            	7	8	3		5	9	1	2
            	9	1	5	6	7	2	3	4
            2	3	4	8	9	1	5	6	7
            5	6	7	2	3	4			1
            ]]></code>
            </example>
        </member>
        <member name="P:Sudoku.Text.Parsers.ExcelGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Parsers.GenericConceptParser">
            <summary>
            Represents a converter that parses into variant concept objects from correspoding specified <see cref="T:System.String"/> values.
            </summary>
        </member>
        <member name="T:Sudoku.Text.Parsers.HodokuTripletParser">
            <summary>
            Represents a parser type that uses <b>Hodoku Triplet</b> notation rule to parse text,
            converting into a valid <see cref="T:Sudoku.Text.ICoordinateObject`1"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Text.ICoordinateObject`1"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.HodokuTripletParser.Parser">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Parsers.InlineSusserGridParser">
            <summary>
            Represents a grid parser for linline Susser format.
            </summary>
            <param name="NegateEliminationsTripletRule">
            <inheritdoc cref="T:Sudoku.Text.Parsers.SusserGridParser" path="/param[@name='NegateEliminationsTripletRule']"/>
            </param>
        </member>
        <member name="M:Sudoku.Text.Parsers.InlineSusserGridParser.#ctor(System.Boolean)">
            <summary>
            Represents a grid parser for linline Susser format.
            </summary>
            <param name="NegateEliminationsTripletRule">
            <inheritdoc cref="T:Sudoku.Text.Parsers.SusserGridParser" path="/param[@name='NegateEliminationsTripletRule']"/>
            </param>
        </member>
        <member name="P:Sudoku.Text.Parsers.InlineSusserGridParser.NegateEliminationsTripletRule">
            <summary>
            <inheritdoc cref="T:Sudoku.Text.Parsers.SusserGridParser" path="/param[@name='NegateEliminationsTripletRule']"/>
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsers.InlineSusserGridParser.PlusToken">
            <summary>
            Indicates the plus token that describes for modifiable values.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsers.InlineSusserGridParser.EmptyString">
            <summary>
            Indicates the empty string.
            </summary>
        </member>
        <member name="F:Sudoku.Text.Parsers.InlineSusserGridParser.DigitParser">
            <summary>
            Indicates the internal digits parser.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsers.InlineSusserGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.InlineSusserGridParser.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?[\\d\\.]|\\[[1-9]{1,9}\\])</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '+' atomically, optionally.<br/>
                        ○ Match a character in the set [.\d].<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '['.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match ']'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.K9Parser">
            <summary>
            Represents a parser type that uses <b>K9</b> notation rule to parse text,
            converting into a valid <see cref="T:Sudoku.Text.ICoordinateObject`1"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Text.ICoordinateObject`1"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.ConjuagteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.K9Parser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.K9Parser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[a-k]+[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.K9Parser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+)([1-9]+)\\.([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
            ○ 2nd capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match '.'.<br/>
            ○ 3rd capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.K9Parser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+[1-9]+(,\\s*[a-k]+[1-9]+)*)\\s*(==?|!=|&lt;&gt;)\\s*([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                ○ Match a character in the set [1-9] greedily at least once.<br/>
                ○ Loop greedily any number of times.<br/>
                    ○ 2nd capture group.<br/>
                        ○ Match ','.<br/>
                        ○ Match a whitespace character atomically any number of times.<br/>
                        ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                        ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 3rd capture group.<br/>
                ○ Match with 3 alternative expressions.<br/>
                    ○ Match '=' atomically at least 1 and at most 2 times.<br/>
                    ○ Match the string "!=".<br/>
                    ○ Match the string "&lt;&gt;".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 4th capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.K9Parser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k][1-9])\\s*={2}\\s*([a-k][1-9])\\.([1-9])</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A].<br/>
                ○ Match a character in the set [1-9].<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "==".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 2nd capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A].<br/>
                ○ Match a character in the set [1-9].<br/>
            ○ Match '.'.<br/>
            ○ 3rd capture group.<br/>
                ○ Match a character in the set [1-9].<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.MultipleLineGridParser">
            <summary>
            Represents a table parser.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsers.MultipleLineGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.MultipleLineGridParser.GridSusserDigitPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?\\d|\\.)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '+' atomically, optionally.<br/>
                        ○ Match a Unicode digit.<br/>
                    ○ Match '.'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.OpenSudokuGridParser">
            <summary>
            Represents an Open-Sudoku format parser.
            </summary>
            <example>
            For example:
            <code><![CDATA[
            0|0|1|1|0|0|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|0|0|1|9|0|0|
            8|0|0|0|0|1|0|0|1|0|0|1|0|0|1|7|0|0|2|0|0|0|0|1|0|0|1|
            0|0|1|0|0|1|7|0|0|0|0|1|3|0|0|0|0|1|0|0|1|4|0|0|0|0|1|
            0|0|1|0|0|1|9|0|0|2|0|0|6|0|0|0|0|1|0|0|1|8|0|0|0|0|1|
            0|0|1|7|0|0|0|0|1|0|0|1|0|0|1|3|0|0|0|0|1|0|0|1|4|0|0|
            5|0|0|0|0|1|6|0|0|0|0|1|0|0|1|0|0|1|3|0|0|0|0|1|1|0|0|
            0|0|1|0|0|1|1|0|0|7|0|0|0|0|1|8|0|0|0|0|1|0|0|1|0|0|1|
            0|0|1|0|0|1|0|0|1|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|0|0|1|
            6|0|0|0|0|1|0|0|1|3|0|0|0|0|1|9|0|0|0|0|1|0|0|1|7|0|0
            ]]></code>
            </example>
        </member>
        <member name="P:Sudoku.Text.Parsers.OpenSudokuGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.OpenSudokuGridParser.GridOpenSudokuPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d(\\|\\d){242}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a Unicode digit.<br/>
            ○ Loop exactly 242 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match '|'.<br/>
                    ○ Match a Unicode digit.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.PencilmarkingGridParser">
            <summary>
            Represents for a pencilmarking grid parser.
            </summary>
            <example>
            For example:
            <code><![CDATA[
            +-------------------+-----------------+--------------------+
            | <8>   12459  249  | *6*  <7>   259  | 1245    245   *3*  |
            | 1457  1245   <6>  | 58   125   <3>  | 124578  2458  <9>  |
            | 1579  <3>    279  | <4>  1259  2589 | 12578   *6*   78   |
            +-------------------+-----------------+--------------------+
            | *2*   <7>    *3*  | <1>  <8>   45   | 456     <9>   46   |
            | <6>   458    48   | <2>  59    459  | <3>     *7*   *1*  |
            | 1459  1459   49   | *3*  *6*   <7>  | 458     458   <2>  |
            +-------------------+-----------------+--------------------+
            | <3>   2489   <1>  | 578  25    <6>  | 24789   248   478  |
            | 79    <6>    2789 | 78   <4>   *1*  | 289     *3*   <5>  |
            | 47    248    <5>  | <9>  *3*   28   | 2678    <1>   4678 |
            +-------------------+-----------------+--------------------+
            ]]></code>
            </example>
        </member>
        <member name="P:Sudoku.Text.Parsers.PencilmarkingGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.PencilmarkingGridParser.GridPencilmarkingPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\&lt;\\d\\&gt;|\\*\\d\\*|\\d*[\\+\\-]?\\d+)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 3 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '&lt;'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '&gt;'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '*'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '*'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match a Unicode digit greedily any number of times.<br/>
                        ○ Match a character in the set [+-] atomically, optionally.<br/>
                        ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.RxCyParser">
            <summary>
            Represents a parser type that uses <b>RxCy</b> notation rule to parse text,
            converting into a valid <see cref="T:Sudoku.Text.ICoordinateObject`1"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Text.ICoordinateObject`1"/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.ConjuagteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Text.Parsers.RxCyParser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.RxCyParser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.RxCyParser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+\\([1-9]+\\)|[1-9]+r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match with 2 alternative expressions, atomically.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Match a character in the set [Rr].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match '('.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match ')'.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Rr].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.RxCyParser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+(,\\s*r[1-9]+c[1-9]+)*\\s*(==?|!=|&lt;&gt;)\\s*[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9] greedily at least once.<br/>
            ○ Loop greedily any number of times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a whitespace character atomically any number of times.<br/>
                    ○ Match a character in the set [Rr].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 2nd capture group.<br/>
                ○ Match with 3 alternative expressions.<br/>
                    ○ Match '=' atomically at least 1 and at most 2 times.<br/>
                    ○ Match the string "!=".<br/>
                    ○ Match the string "&lt;&gt;".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.RxCyParser.UnitHousePattern">
            <remarks>
            Pattern:<br/>
            <code>[rcb][1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [BCRbcr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.RxCyParser.UnitIntersectionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[rc][1-9]+b[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [CRcr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.RxCyParser.UnitMegaLineGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>m[rc][1-3]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Mm].<br/>
            ○ Match a character in the set [CRcr].<br/>
            ○ Match a character in the set [1-3] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.RxCyParser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]c[1-9]\\s*={2}\\s*r[1-9]c[1-9]\\([1-9]\\)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "==".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match '('.<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match ')'.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.SimpleMultipleLineGridParser">
            <summary>
            Represents a simple multiple-line grid parser.
            </summary>
            <example>
            For example:
            <list type="bullet">
            <item>
            <code><![CDATA[
            .----------.----------.----------.
            |  .  4  6 |  . +1  . |  3 +7 +5 |
            | +3 +8  1 | +5  4  7 | +2 +9 +6 |
            |  .  .  5 |  .  3  . | +1 +4  8 |
            :----------+----------+----------:
            |  8  .  4 |  . +5  . | +7  6  . |
            |  .  9  . |  .  2  . | +8  5 +4 |
            |  .  5  . |  .  .  . |  9  .  3 |
            :----------+----------+----------:
            |  5  .  . |  .  8  . |  6  . +9 |
            | +4  .  8 |  1  9  . |  5  .  . |
            |  .  .  9 |  .  . +5 |  4  8  . |
            '----------'----------'----------'
            ]]></code>
            </item>
            <item>
            <code><![CDATA[
            080630040
            200085009
            090000081
            000300800
            000020000
            006001000
            970000030
            400850007
            010094050
            ]]></code>
            </item>
            </list>
            </example>
        </member>
        <member name="P:Sudoku.Text.Parsers.SimpleMultipleLineGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.SimpleMultipleLineGridParser.GridSimpleMultilinePattern">
            <remarks>
            Pattern:<br/>
            <code>([\\d\\.\\+]{9}(\\r|\\n|\\r\\n)){8}[\\d\\.\\+]{9}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a character in the set [+.\d] exactly 9 times.<br/>
                    ○ 2nd capture group.<br/>
                        ○ Match with 2 alternative expressions.<br/>
                            ○ Match a character in the set [\n\r].<br/>
                            ○ Match the string "\r\n".<br/>
            ○ Match a character in the set [+.\d] exactly 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.SukakuGridParser">
            <summary>
            Represents a Sukaku grid parser.
            </summary>
            <param name="SingleLine">
            Indicates whether the parser use single-line logic to parse the string text.
            The single-line text uses 729 characters to describe all possible existences for all 9 digits in all 81 cells.
            </param>
            <example>
            For example:
            <list type="number">
            <item>
            <code><![CDATA[
            023406789123456700003050780120050789003006009123456009100056089023456080123000789
            003456789023006700023006700120056780100006789120400780000406789103000080020450000
            003406089020056709120050080100000700120056780120000709123056000123050080000450089
            123050709100456089003400780100450009003400009120400009123056709003000700023406000
            000406009123006000000056709003406700120050009103056089103456709003056009120456009
            123456780023400000103406709003056789020406700100050009020400000100006789020006789
            020456780123056080120400700000406789120400080023456789003006080020456789103450709
            123400009123400080023406700123406709103400080123456009120456789023406709023450080
            100406080103056009100400009123000789100400709100406780123050700000050080023406009
            ]]></code>
            </item>
            <item>
            <code><![CDATA[
             23456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789  23456789
             23456789 123456789 123456789  23456789  23456789  23456789  23456789  23456789  23456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789 123456789
            123456789  23456789  23456789 123456789 123456789  23456789  23456789  23456789 123456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789  23456789
            123456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789 123456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
            ]]></code>
            </item>
            </list>
            </example>
        </member>
        <member name="M:Sudoku.Text.Parsers.SukakuGridParser.#ctor(System.Boolean)">
            <summary>
            Represents a Sukaku grid parser.
            </summary>
            <param name="SingleLine">
            Indicates whether the parser use single-line logic to parse the string text.
            The single-line text uses 729 characters to describe all possible existences for all 9 digits in all 81 cells.
            </param>
            <example>
            For example:
            <list type="number">
            <item>
            <code><![CDATA[
            023406789123456700003050780120050789003006009123456009100056089023456080123000789
            003456789023006700023006700120056780100006789120400780000406789103000080020450000
            003406089020056709120050080100000700120056780120000709123056000123050080000450089
            123050709100456089003400780100450009003400009120400009123056709003000700023406000
            000406009123006000000056709003406700120050009103056089103456709003056009120456009
            123456780023400000103406709003056789020406700100050009020400000100006789020006789
            020456780123056080120400700000406789120400080023456789003006080020456789103450709
            123400009123400080023406700123406709103400080123456009120456789023406709023450080
            100406080103056009100400009123000789100400709100406780123050700000050080023406009
            ]]></code>
            </item>
            <item>
            <code><![CDATA[
             23456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789  23456789
             23456789 123456789 123456789  23456789  23456789  23456789  23456789  23456789  23456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789 123456789
            123456789  23456789  23456789 123456789 123456789  23456789  23456789  23456789 123456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789  23456789
            123456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789 123456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
            ]]></code>
            </item>
            </list>
            </example>
        </member>
        <member name="P:Sudoku.Text.Parsers.SukakuGridParser.SingleLine">
            <summary>
            Indicates whether the parser use single-line logic to parse the string text.
            The single-line text uses 729 characters to describe all possible existences for all 9 digits in all 81 cells.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsers.SukakuGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.SukakuGridParser.GridSukakuSegmentPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d*[\\-\\+]?\\d+</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a Unicode digit greedily any number of times.<br/>
            ○ Match a character in the set [+-] atomically, optionally.<br/>
            ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Parsers.SusserGridParser">
            <summary>
            Represents a Susser format parser.
            </summary>
            <param name="ShortenSusserFormat">
            <para>
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </para>
            <para>
            This option will omit the continuous empty cells to a <c>*</c> in a single line. For example, the code
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            will be displayed as
            <code><![CDATA[
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            ]]></code>
            via this option.
            We use the colon <c>,</c> to separate each line of 9 numbers, and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            </param>
            <param name="NegateEliminationsTripletRule">
            Indicates whether the parser will negate the rule, treating all digits as candidates existing in the grid instead of removed ones.
            The default value is <see langword="false"/>.
            </param>
            <example>
            For example:
            <list type="number">
            <item>
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            </item>
            <item>
            <code><![CDATA[
            4+80002+306+31000+9004000+4030109+38+24+675+1+75+1+39+8+46+2+2640708+3902090000010000002080+36+20007:713 723 533 633 537 575 176 576 577 579 583 784 586 587 496 997
            ]]></code>
            </item>
            </list>
            </example>
        </member>
        <member name="M:Sudoku.Text.Parsers.SusserGridParser.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Represents a Susser format parser.
            </summary>
            <param name="ShortenSusserFormat">
            <para>
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </para>
            <para>
            This option will omit the continuous empty cells to a <c>*</c> in a single line. For example, the code
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            will be displayed as
            <code><![CDATA[
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            ]]></code>
            via this option.
            We use the colon <c>,</c> to separate each line of 9 numbers, and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            </param>
            <param name="NegateEliminationsTripletRule">
            Indicates whether the parser will negate the rule, treating all digits as candidates existing in the grid instead of removed ones.
            The default value is <see langword="false"/>.
            </param>
            <example>
            For example:
            <list type="number">
            <item>
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            </item>
            <item>
            <code><![CDATA[
            4+80002+306+31000+9004000+4030109+38+24+675+1+75+1+39+8+46+2+2640708+3902090000010000002080+36+20007:713 723 533 633 537 575 176 576 577 579 583 784 586 587 496 997
            ]]></code>
            </item>
            </list>
            </example>
        </member>
        <member name="P:Sudoku.Text.Parsers.SusserGridParser.ShortenSusserFormat">
            <summary>
            <para>
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </para>
            <para>
            This option will omit the continuous empty cells to a <c>*</c> in a single line. For example, the code
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            will be displayed as
            <code><![CDATA[
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            ]]></code>
            via this option.
            We use the colon <c>,</c> to separate each line of 9 numbers, and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsers.SusserGridParser.NegateEliminationsTripletRule">
            <summary>
            Indicates whether the parser will negate the rule, treating all digits as candidates existing in the grid instead of removed ones.
            The default value is <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Parsers.SusserGridParser.Parser">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Parsers.SusserGridParser.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\+]{80,}(\\:(\\d{3}\\s+)*\\d{3})?</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [+.\d] greedily at least 80 times.<br/>
            ○ Optional (greedy).<br/>
                ○ 1st capture group.<br/>
                    ○ Match ':'.<br/>
                    ○ Loop greedily any number of times.<br/>
                        ○ 2nd capture group.<br/>
                            ○ Match a Unicode digit exactly 3 times.<br/>
                            ○ Match a whitespace character atomically at least once.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Text.Parsers.SusserGridParser.GridShortenedSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\*]{1,9}(,[\\d\\.\\*]{1,9}){8}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:Sudoku.Text.Serialization.Specialized.CandidateMapConverter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Text.Serialization.Specialized.CandidateMapConverter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.CandidateMapConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.CandidateMapConverter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CandidateMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Serialization.Specialized.CellMapConverter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Text.Serialization.Specialized.CellMapConverter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.CellMapConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.CellMapConverter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CellMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Serialization.Specialized.ConclusionConverter">
            <summary>
            Represents a JSON converter for type <see cref="T:Sudoku.Analytics.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Analytics.Conclusion"/>
        </member>
        <member name="P:Sudoku.Text.Serialization.Specialized.ConclusionConverter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.ConclusionConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.ConclusionConverter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Analytics.Conclusion,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Text.Serialization.Specialized.GridConverter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Text.Serialization.Specialized.GridConverter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.GridConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Text.Serialization.Specialized.GridConverter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Grid,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the AuthorPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.AuthorPattern_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the NamePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.NamePattern_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the DescriptionPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.DescriptionPattern_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_3">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the TagsPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.TagsPattern_3.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_3.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_3.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_3.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_3.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_4">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EliminationPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EliminationPattern_4.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_4.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_4.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_4.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_4.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_4.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_4.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_4.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_5">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_5.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_5.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_5.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_5.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_5.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_5.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_5.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_5.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_6.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_7.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_8.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_9.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserDigitPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_10.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridOpenSudokuPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_11.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridPencilmarkingPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkingPattern_12.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_16">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitHousePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitHousePattern_16.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitIntersectionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitMegaLineGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSimpleMultilinePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_20.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSukakuSegmentPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_21.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_22">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_22.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_22.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_22.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_22.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_22.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_22.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_22.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_22.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridShortenedSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_23.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfAnyDecimalDigitNumberDecimalDigitNumber(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_3BCFC31BFB1AD1127D0564F4B3C20ECED086F1C7438F92ACB58165A04BF23DD9(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*+-&lt;\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_5C1843170313CB42CA4CF4E0FCD6C277723EAACCD85464A69BFC7D367CF48212(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_65EF16F1D4CC2684453DF3C3240E17C0787C2CE3C7B9F2FA94357B7AEAC8AC3F(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_85D9C34033677881D8993C4388EDB85FC6297ECDBC9E515FF9B602A26978DF84(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+-\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_CD2F1FA646F2680322897C0F819061CC86FEA149AFB0FCC253B807E2A597D6F4(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.[\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPop(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Pops 2 values from the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
            <summary>Pushes 1 value onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
            <summary>Pushes 2 values onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>Pushes 3 values onto the backtracking stack.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_asciiExceptDigits">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_800040008000400">
            <summary>Supports searching for characters in or not in "CRcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_C0004000C000400">
            <summary>Supports searching for characters in or not in "BCRbcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FE030000040000000400">
            <summary>Supports searching for characters in or not in "123456789Rr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFF7FFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFBB00FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()+,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD300ECFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'(),./:;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_nonAscii_F399137324019CEE8DA2E2200E10D0083E7A4C31A2E981061D50385C16616C8A">
            <summary>Supports searching for characters in or not in "ABCDEFGHIJKabcdefghijkK".</summary>
        </member>
    </members>
</doc>

<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Core</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Generating.FilteredGeneratorProgress">
            <summary>
            Represents a progress data type that is nearly same as <see cref="T:Sudoku.Generating.GeneratorProgress"/>, but with filtered data.
            </summary>
            <param name="Count">The number of checked puzzles.</param>
            <param name="Succeeded">The number of succeeded puzzles.</param>
            <seealso cref="T:Sudoku.Generating.GeneratorProgress"/>
        </member>
        <member name="M:Sudoku.Generating.FilteredGeneratorProgress.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents a progress data type that is nearly same as <see cref="T:Sudoku.Generating.GeneratorProgress"/>, but with filtered data.
            </summary>
            <param name="Count">The number of checked puzzles.</param>
            <param name="Succeeded">The number of succeeded puzzles.</param>
            <seealso cref="T:Sudoku.Generating.GeneratorProgress"/>
        </member>
        <member name="P:Sudoku.Generating.FilteredGeneratorProgress.Count">
            <summary>The number of checked puzzles.</summary>
        </member>
        <member name="P:Sudoku.Generating.FilteredGeneratorProgress.Succeeded">
            <summary>The number of succeeded puzzles.</summary>
        </member>
        <member name="P:Sudoku.Generating.FilteredGeneratorProgress.Percentage">
            <summary>
            Indicates the percentage.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.FilteredGeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#FilteredGeneratorProgress}#ToDisplayString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Generating.FilteredGeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#FilteredGeneratorProgress}#Create(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Generating.Generator">
            <summary>
            Represents a puzzle generator, implemented by HoDoKu.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator.AutoClues">
            <summary>
            Indicates the auto clues count.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._generateIndices">
            <summary>
            The order in which cells are set when generating a full grid.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._rng">
            <summary>
            A random generator for creating new puzzles.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._solver">
            <summary>
            Indicates the internal fast solver.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._stack">
            <summary>
            The recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._newFullSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._newValidSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.Generator.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Sudoku.Generating.Generator" />.
            </summary>
            <remarks>
            <target name="constructor">
				<i>
					The feature "Custom parameterless struct constructor" makes the parameterless struct constructor
					different with <c>default(T)</c>. If you has defined a parameterless struct constructor,
					<c>new T()</c> is no longer with the same meaning as <c>default(T)</c>.
				</i>
			</target>
            </remarks>
        </member>
        <member name="M:Sudoku.Generating.Generator.Generate(System.Int32,Sudoku.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            Try to generate a puzzle.
            </summary>
            <param name="cluesCount">
            <para>Indicates the number of clues the generator supports for <b>approximately</b>.</para>
            <para>
            Please note that the target puzzle may not contain the same number of givens as this value.
            If the number of givens from a puzzle is below this value but it also has a unique solution,
            this puzzle will be still treated as valid one.
            </para>
            </param>
            <param name="symmetricType">The symmetric type to be specified. The value is <see cref="F:Sudoku.SymmetricType.Central"/> by default.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>The result grid.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="symmetricType"/> holds multiple flags,
            or the argument <paramref name="cluesCount"/> is invalid.
            </exception>
        </member>
        <member name="M:Sudoku.Generating.Generator.GenerateInitPos(System.Int32,Sudoku.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            Takes a full sudoku from <see cref="F:Sudoku.Generating.Generator._newFullSudoku"/> and generates a valid puzzle by deleting cells.
            If a deletion produces a grid with more than one solution it is of course undone.
            </summary>
            <inheritdoc cref="M:Sudoku.Generating.Generator.Generate(System.Int32,Sudoku.SymmetricType,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Generating.Generator.GenerateForFullGrid">
            <summary>
            Generate a solution grid.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the generation operation is succeeded.</returns>
        </member>
        <member name="M:Sudoku.Generating.Generator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Generating.Generator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Generating.Generator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Generating.GeneratorProgress">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Generating.GeneratorProgress.#ctor(System.Int32)">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Generating.GeneratorProgress.Count">
            <summary>The number of puzzles generated currently.</summary>
        </member>
        <member name="M:Sudoku.Generating.GeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#GeneratorProgress}#ToDisplayString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Generating.GeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#GeneratorProgress}#Create(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Generating.GeneratorRecursionStackEntry">
            <summary>
            One entry in recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.Candidates">
            <summary>
            The candidates for cells <see cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Cell"/>.
            </summary>
            <seealso cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Cell"/>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.Cell">
            <summary>
            The index of the cell that's being tried.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.CandidateIndex">
            <summary>
            The index of the last tried candidate in <see cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Candidates"/>.
            </summary>
            <seealso cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Candidates"/>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.SudokuGrid">
            <summary>
            The current state of the sudoku.
            </summary>
        </member>
        <member name="T:Sudoku.Generating.HardPatternPuzzleGenerator">
            <summary>
            Defines a puzzle generator that makes the given pattern as a hard one.
            A <b>hard pattern</b> doesn't mean the puzzle will be hard or fiendish.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.HardPatternPuzzleGenerator.BlockFactor">
            <summary>
            Indicates the block factor.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.HardPatternPuzzleGenerator.SwappingFactor">
            <summary>
            Indicates the swapping factor.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.HardPatternPuzzleGenerator._randomShared">
            <summary>
            Indicates the shared <see cref="T:System.Random"/> instance.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.HardPatternPuzzleGenerator._solver">
            <summary>
            Indicates the inner solver that can fast solve a sudoku puzzle, to check the validity
            of a puzzle being generated.
            </summary>
        </member>
        <member name="P:Sudoku.Generating.HardPatternPuzzleGenerator.Rng">
            <summary>
            Indicates the backing random.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.GenerateAnswerGrid(System.Span{System.Char},System.Span{System.Char})">
            <summary>
            Generates the answer sudoku grid via the specified puzzle and the solution variable pointer.
            </summary>
            <param name="puzzleString">The pointer that points to the puzzle.</param>
            <param name="solutionString">
            The pointer that points to the solution. The result value will be changed here.
            </param>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.CreatePattern(System.Span{System.Int32})">
            <summary>
            Creates a start pattern based on a base pattern.
            </summary>
            <param name="pattern">The base pattern.</param>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.RecreatePattern(System.Span{System.Int32})">
            <summary>
            To re-create the pattern.
            </summary>
            <param name="pattern">The pointer that points to an array of the pattern values.</param>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.CheckDuplicate(System.Span{System.Char},System.Int32)">
            <summary>
            Check whether the digit in its peer cells has duplicate ones.
            </summary>
            <param name="gridString">The pointer that points to a grid.</param>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="T:Sudoku.Generating.IGenerator`1">
            <summary>
            Represents a generator type that produces a complex data type <typeparamref name="TResult"/>,
            encapsulating the details of the result.
            </summary>
            <typeparam name="TResult">The type of the result. This type is generally <see cref="T:Sudoku.Concepts.Grid"/>.</typeparam>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <summary>
            Generates a puzzle and return an instance of type <typeparamref name="TResult"/> indicating the result.
            </summary>
            <param name="progress">An <see cref="T:System.IProgress`1"/> instance that is used for reporting the state.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>The result returned.</returns>
        </member>
        <member name="T:Sudoku.Generating.IProgressDataProvider`1">
            <summary>
            Indicates the data provider type,
            </summary>
            <typeparam name="TSelf">The type of the implementation data provider.</typeparam>
        </member>
        <member name="P:Sudoku.Generating.IProgressDataProvider`1.Count">
            <summary>
            Indicates the number of puzzles having been generated.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.IProgressDataProvider`1.ToDisplayString">
            <summary>
            Try to fetch display string for the current instance.
            </summary>
            <returns>The display string.</returns>
        </member>
        <member name="M:Sudoku.Generating.IProgressDataProvider`1.Create(System.Int32,System.Int32)">
            <summary>
            Try to create a <typeparamref name="TSelf"/> instance.
            </summary>
            <param name="count">The number of puzzles generated.</param>
            <param name="succeeded">The number of puzzles has passed the checking.</param>
            <returns>A <typeparamref name="TSelf"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Generating.PatternBasedPuzzleGenerator">
            <summary>
            Represents a generator that is based on pattern.
            </summary>
            <param name="missingDigit">Indicates the missing digit that can be used.</param>
            <param name="seedPattern">Indicates the predefind pattern used.</param>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.#ctor(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Represents a generator that is based on pattern.
            </summary>
            <param name="missingDigit">Indicates the missing digit that can be used.</param>
            <param name="seedPattern">Indicates the predefind pattern used.</param>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.GenerateCore(System.Int32[],Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@,System.Int32,System.Int32@,System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <summary>
            The back method to generate a valid sudoku grid puzzle.
            </summary>
            <param name="patternCellsSorted">The cells ordered by the number of related cells.</param>
            <param name="playground">The playground to be operated with.</param>
            <param name="resultGrid">The result grid to be returned.</param>
            <param name="i">The index that the current searching is on.</param>
            <param name="count">The number of puzzles generated.</param>
            <param name="progress">The progress instance.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.OrderCellsViaConnectionComplexity">
            <summary>
            Order the pattern cells via connection complexity.
            </summary>
            <returns>The cells ordered.</returns>
        </member>
        <member name="F:Sudoku.Generating.PatternBasedPuzzleGenerator._seedPattern">
            <summary>
            The generated field declaration for parameter <c>seedPattern</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithms.MinLex.BestTripletPermutation">
            <summary>
            Represents the permutation information for best triplet.
            </summary>
            <param name="bestResult">Indicates the best result.</param>
            <param name="resultMask">Indicates the result mask.</param>
            <param name="resultNumberOfBits">Indicates the result number of bits.</param>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.BestTripletPermutation.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Represents the permutation information for best triplet.
            </summary>
            <param name="bestResult">Indicates the best result.</param>
            <param name="resultMask">Indicates the result mask.</param>
            <param name="resultNumberOfBits">Indicates the result number of bits.</param>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.BestTripletPermutation.Perm">
            <summary>
            Indicates the permutation cases.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.BestTripletPermutation.BestTripletPermutations">
            <summary>
            Indicates all best triplet permutations.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.BestTripletPermutation.BestResult">
            <summary>
            The generated field declaration for parameter <c>bestResult</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.BestTripletPermutation.ResultMask">
            <summary>
            The generated field declaration for parameter <c>resultMask</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.BestTripletPermutation.ResultNumberOfBits">
            <summary>
            The generated field declaration for parameter <c>resultNumberOfBits</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithms.MinLex.GridMinLexExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/>, by checking min-lex-related properties.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.GridMinLexExtensions.IsMinLexGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Checks whether the current grid is the minimal lexicographical form, which means the corresponding string text code
            is the minimum value in all equivalent transforming cases in lexicographical order.
            </summary>
            <param name="this">The grid to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.GridMinLexExtensions.GetMinLexGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Checks the minimal lexicographical grid form.
            </summary>
            <param name="this">The grid to be checked.</param>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.GridMinLexExtensions.MakeMinLex(Sudoku.Concepts.Grid@)">
            <summary>
            Adjust the grid to minimal lexicographical form.
            </summary>
            <param name="this">The grid to be changed.</param>
        </member>
        <member name="T:Sudoku.Algorithms.MinLex.GridPattern">
            <summary>
            Represents a pattern for a sudoku grid.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.GridPattern.MinCanNineBits">
            <summary>
            A precomputed min-lex'ed recomposition of the bit triplets for a 9-bits input.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.GridPattern.Rows">
            <summary>
            Indicates the rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.GridPattern.Digits">
            <summary>
            Indicates the digit.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.GridPattern.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.GridPattern.BestTopRowScore(Sudoku.Algorithms.MinLex.GridPattern@)">
            <summary>
            Try to calculate the best top row score from the specified <see cref="T:Sudoku.Algorithms.MinLex.GridPattern"/> instance.
            </summary>
            <param name="p">The grid pattern instance.</param>
            <returns>The score value calculated.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.GridPattern.FromString(System.String,System.ReadOnlySpan{Sudoku.Algorithms.MinLex.GridPattern}@)">
            <summary>
            Initializes for normal and transposed <see cref="T:Sudoku.Algorithms.MinLex.GridPattern"/> instances from a string grid code.
            </summary>
            <param name="grid">Indicates the grid code to be used.</param>
            <param name="resultPair">Indicates the 2 <see cref="T:Sudoku.Algorithms.MinLex.GridPattern"/> instances for normal and transposed cases.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the number of given cells.</returns>
        </member>
        <member name="T:Sudoku.Algorithms.MinLex.Mapper">
            <summary>
            Indicates a data structure that describes the cell and label handled.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.Mapper.Cell">
            <summary>
            Indicates the cell <see cref="T:System.Byte"/> values.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.Mapper.Label">
            <summary>
            Indicates the label <see cref="T:System.Byte"/> values.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithms.MinLex.MinLexCandidate">
            <summary>
            Indicates a node representing the min-lexicographical candidate.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.MinLexCandidate.IsTransposed">
            <summary>
            A flag field indicating whether the candidate is handled as transposed.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.MinLexCandidate.MapRowsForward">
            <summary>
            Indicates the map bits on forward rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.MinLexCandidate.MapRowsBackward">
            <summary>
            Indicates the map bits on backward rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.MinLexCandidate.StacksPermutation">
            <summary>
            Indicates the stack permutation.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.MinLexCandidate.ColumnsPermutationMask">
            <summary>
            Indicates mask bit values for column permutation.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.MinLexCandidate.#ctor">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithms.MinLex.MinLexCandidate"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.MinLexCandidate.#ctor(System.SByte,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithms.MinLex.MinLexCandidate"/> instance via the specified flag for tranpose case and top row.
            </summary>
            <param name="transpose">The value for transpose flag. The value can only be 0 or 1.</param>
            <param name="topRow">The top row used.</param>
        </member>
        <member name="P:Sudoku.Algorithms.MinLex.MinLexCandidate.Empty">
            <summary>
            Represents an empty <see cref="T:Sudoku.Algorithms.MinLex.MinLexCandidate"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.MinLexCandidate.ExpandStacks(System.ReadOnlySpan{Sudoku.Algorithms.MinLex.GridPattern},System.Int32,System.Span{Sudoku.Algorithms.MinLex.MinLexCandidate},System.Int32@)">
            <summary>
            To expand stacks.
            </summary>
            <param name="pair">A pair of <see cref="T:Sudoku.Algorithms.MinLex.GridPattern"/> instance.</param>
            <param name="topKey">Indicates the top key.</param>
            <param name="results">Indicates the results.</param>
            <param name="resultCount">The result count.</param>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.MinLexCandidate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Algorithms.MinLex.MinLexFinder">
            <summary>
            Represents a finder type.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.MinLexFinder.CandidateListTotal">
            <summary>
            Indicates the total number of candidate list, which means the worst case.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.MinLex.MinLexFinder._mappers">
            <summary>
            Indicates the internal mappers.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.MinLexFinder.Find(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Algorithms.MinLex.MinLexFinder.Find(System.String)"/>
        </member>
        <member name="M:Sudoku.Algorithms.MinLex.MinLexFinder.Find(System.String)">
            <summary>
            Finds the minimal lexicographical form of the source grid code.
            </summary>
            <param name="grid">Indicates the source grid.</param>
            <returns>The corresponding minimal lexicographical form of the grid.</returns>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Backtracking.BacktrackingSolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using backtracking algorithm.
            </summary>
            <remarks>
            <para>
            Please note that the current type has no optimization on solving. Therefore sometimes the puzzle will be
            extremely slowly to be solved although it is not very hard by manually solved.
            One of the examples satisfying the above condition is:
            <code>
            ..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9
            </code>
            The current solver may spend about 4.5 min on solving this puzzle on my machine.
            </para>
            <para>
            For more information, please visit
            <see href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms#cite_note-difficult_17_clue-1">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Backtracking.BacktrackingSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Backtracking.BacktrackingSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            To solve the specified grid.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Different with other methods whose containing type is <see cref="T:Sudoku.Algorithms.Solving.ISolver"/>,
            this argument can be used no matter what the result value will be.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver">
            <summary>
            Indicates the solver that is able to solve a sudoku puzzle, and then get the solution of that sudoku.
            </summary>
            <remarks>
            <para>
            The reason why the type name contains the word <i>bitwise</i> is that the solver uses the bitwise algorithm
            to handle a sudoku grid, which is more efficient.
            </para>
            <para><b>
            This type is thread-unsafe. If you want to use this type in multi-threading, please use <see langword="lock"/> statement.
            </b></para>
            </remarks>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.BufferLength">
            <summary>
            The buffer length of a solution puzzle.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.BitSet27">
            <summary>
            All pencil marks set - 27 bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._stack">
            <summary>
            Stack to store current and previous states.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._singleApplied">
            <summary>
            Nasty global flag telling if <see cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.ApplySingleOrEmptyCells"/> found anything.
            </summary>
            <seealso cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.ApplySingleOrEmptyCells"/>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._solution">
            <summary>
            Pointer to where to store the first solution. This value can be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._numSolutions">
            <summary>
            The number of solutions found so far.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._limitSolutions">
            <summary>
            The max number of solution we're looking for.
            </summary>
            <remarks>
            For the consideration on the performance, I have refused to use auto-implemented property instead.
            </remarks>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._g">
            <summary>
            Pointer to the currently active slot.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.SolveString(System.Char*,System.Char*,System.Int32)">
            <summary>
            Solves the puzzle represented as a string value.
            </summary>
            <param name="puzzle">The puzzle represented as a string.</param>
            <param name="solution">The solution.</param>
            <param name="limit">The limit of solutions to be checked.</param>
            <returns>A <see cref="T:System.Int64"/> value indicating the number of solutions.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.SolveString(System.String,System.Char*,System.Int32)">
            <inheritdoc cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.SolveString(System.Char*,System.Char*,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.SolveString(System.String,System.String@,System.Int32)">
            <inheritdoc cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.SolveString(System.Char*,System.Char*,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char*)">
            <summary>
            Same as <see cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="grid"/> is <see langword="null"/>.
            </exception>
            <seealso cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char@)">
            <inheritdoc cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char*)"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String)">
            <inheritdoc cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char*)"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String,System.String@)">
            <summary>
            Check the validity of the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="solutionIfUnique">The solution if the puzzle is unique.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.Solve(Sudoku.Concepts.Grid@)">
            <summary>
            To solve the puzzle, and get the solution.
            </summary>
            <param name="puzzle">The puzzle to solve.</param>
            <returns>The solution. If failed to solve, <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.</returns>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.ClearStack">
            <summary>
            To clear the field <see cref="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._stack"/>.
            </summary>
            <seealso cref="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver._stack"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.SetSolvedDigit(System.Int32,System.Int32)">
            <summary>
            Set a cell as solved - used in <see cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.EliminateDigit(System.Int32,System.Int32)">
            <summary>
            Eliminate a digit - used in <see cref="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.SetSolvedMask(System.Int32,System.UInt32)">
            <summary>
            Set a cell as solved - used in various guess routines.
            </summary>
            <param name="band">The band.</param>
            <param name="mask">The mask.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.InitSudoku(System.Char*)">
            <summary>
            Setup everything and load the puzzle.
            </summary>
            <param name="puzzle">The pointer that points to a puzzle buffer.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.Update">
            <summary>
            Core of fast processing.
            </summary>
            <returns>The <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.ApplySingleOrEmptyCells">
            <summary>
            Find singles, bi-value cells, and impossible cells.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.InternalSolve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The internal solving method.
            </summary>
            <param name="puzzle">The pointer to the puzzle string.</param>
            <param name="solutionPtr">The pointer to the solution string.</param>
            <param name="limit">The limitation for the number of all final solutions.</param>
            <returns>The number of solutions found.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.ExtractSolution(System.Char*)">
            <summary>
            Extract solution as a string.
            </summary>
            <param name="solution">
            The solution pointer. <b>The buffer should be at least <see cref="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.BufferLength"/>
            of value of length.</b>
            </param>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.GuessBiValueInCell">
            <summary>
            Try both options for cells with exactly two pencil marks.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.GuessFirstCell">
            <summary>
            Guess all possibilities in first unsolved cell.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.Guess">
            <summary>
            Either already solved, or guess and recurse.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.FullUpdate">
            <summary>
            Get as far as possible without guessing.
            </summary>
            <returns>A <see cref="T:System.Byte"/> result.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.BitPos(System.UInt32)">
            <summary>
            Get the bit position.
            </summary>
            <param name="map">The map.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver.StringLengthOf(System.Char*)">
            <summary>
            Get the length of the specified string which is represented by a <see cref="T:System.Char"/>*.
            </summary>
            <param name="ptr">The pointer.</param>
            <returns>The total length.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="ptr"/> is <see langword="null"/>.
            </exception>
            <remarks>
            In C#, this function is unsafe because the implementation of
            <see cref="T:System.String"/> types between C and C# is totally different.
            In C, <see cref="T:System.String"/> is like a <see cref="T:System.Char"/>* or a
            <see cref="T:System.Char"/>[], they ends with the terminator symbol <c>'\0'</c>.
            However, C# not.
            </remarks>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolverState">
            <summary>
            Represents a data structure, used by type <see cref="T:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver" />, describing state for a current grid using binary values.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
            <seealso cref="T:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolver" />
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolverState.Bands">
            <summary>
            Pencil marks in bands by digit.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolverState.PrevBands">
            <summary>
            Value of bands last time it was calculated.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolverState.UnsolvedCells">
            <summary>
            Bit vector of unsolved cells.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolverState.UnsolvedRows">
            <summary>
            Bit vector of unsolved rows - three bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Bitwise.BitwiseSolverState.Pairs">
            <summary>
            Bit vector of cells with exactly two pencil marks.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver">
            <summary>
            Defines a <see cref="T:System.Collections.Generic.Dictionary`2"/>-based LINQ solver that solves a sudoku grid,
            using a different algorithm with the other one of type <see cref="T:Sudoku.Algorithms.Solving.EnumerableQuery.EnumerableQuerySolver"/>.
            </summary>
            <remarks>
            <para>
            This algorithm is originally written by Python, posted from <see href="http://norvig.com/sudo.py">here</see>
            by Richard Birkby, June 2007. For more information, please visit
            <see href="http://norvig.com/sudoku.html">this link</see>.
            </para>
            <para>
            Also, <see href="https://bugzilla.mozilla.org/attachment.cgi?id=266577">this link</see> is for the same algorithm
            written by JavaScript 1.8+.
            </para>
            </remarks>
            <seealso cref="T:Sudoku.Algorithms.Solving.EnumerableQuery.EnumerableQuerySolver"/>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Rows">
            <summary>
            Indicates the characters of all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Columns">
            <summary>
            Indicates the characters of all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Digits">
            <summary>
            Indicates the characters of all digits.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Coordinates">
            <summary>
            Indicates all possible coordinates.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Peers">
            <summary>
            Indicates the peers.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Houses">
            <summary>
            Indicates the houses.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            To solve the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="result">The result.</param>
            <returns>
            <para>
            The method will return <see langword="false"/> if the puzzle has more than one solution,
            or <see langword="null"/> if the puzzle cannot be solved.
            </para>
            <para>
            Please note that the method cannot return <see langword="true"/>
            due to not being aware of the uniqueness of the puzzle.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.AllNotNull``1(System.ReadOnlySpan{``0})">
            <summary>
            Determines whether all elements in this collection are not <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the element in the sequence.</typeparam>
            <param name="sequence">The whole sequence.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.AllNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.AllNotNull``1(System.ReadOnlySpan{``0})"/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Zip(System.String[],System.String[])">
            <summary>
            To zip two lists of <see cref="T:System.String"/>s.
            </summary>
            <param name="a">The first array.</param>
            <param name="b">The second array.</param>
            <returns>The final zipped collection.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.ParseGrid(System.String)">
            <summary>
            Given a string of 81 digits (or <c>'.'</c>, <c>'0'</c> or <c>'-'</c>),
            and return a dictionary of a key-value pair of cell and the candidates.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Search(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Using depth-first search and propagation to try all possible values.
            </summary>
            <returns>A first found solution.</returns>
            <remarks>
            This algorithm is hard to determine whether the puzzle has multiple solutions, due to DFS.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Assign(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate all the other values (except d) from <c>values[s]</c> and propagate.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.DictionaryQuery.DictionaryQuerySolver.Eliminate(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate d from <c>values[s]</c>; propagate when values or places <![CDATA[<=]]> 2.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Dlx.ColumnNode">
            <summary>
            Represents a column node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.ColumnNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithms.Solving.Dlx.ColumnNode"/> instance via the specified ID value.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.ColumnNode.Size">
            <summary>
            Indicates the size of the node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.ColumnNode.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode">
            <summary>
            Represents a dancing link node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.#ctor(System.Int32,Sudoku.Algorithms.Solving.Dlx.ColumnNode)">
            <summary>
            Initializes a <see cref="T:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="id">The ID value.</param>
            <param name="column">The column node.</param>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.Id">
            <summary>
            Indicates the ID of the node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.Column">
            <summary>
            Indicates the current column node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.Left">
            <summary>
            Indicates the pointer that points to the left node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.Right">
            <summary>
            Indicates the pointer that points to the right node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.Up">
            <summary>
            Indicates the pointer that points to the up node.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.Down">
            <summary>
            Indicates the pointer that points to the down node.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinkNode.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver">
            <summary>
            Defines a solver that uses the dancing links algorithm.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver._answerNodesStack">
            <summary>
            Indicates the stack that stores the raw data for the solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver._solutionCount">
            <summary>
            indicates the number of all found solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver._solution">
            <summary>
            Indicates the found solution.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver._root">
            <summary>
            Indicates the root node of the full link map.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver.Search">
            <summary>
            Try to search the full dancing link map and get the possible solution.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle has multiple solutions.</exception>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver.Cover(Sudoku.Algorithms.Solving.Dlx.DancingLinkNode)">
            <summary>
            Cover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver.Uncover(Sudoku.Algorithms.Solving.Dlx.DancingLinkNode)">
            <summary>
            Uncover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver.RecordSolution(System.Collections.Generic.Stack{Sudoku.Algorithms.Solving.Dlx.DancingLinkNode},Sudoku.Concepts.Grid@)">
            <summary>
            Try to gather all possible solutions, and determine whether the puzzle is valid.
            </summary>
            <param name="answer">The answers found.</param>
            <param name="result">The solution if the puzzle is unique.</param>
            <exception cref="T:System.InvalidOperationException">
            Throws when the puzzle has no possible solutions.
            </exception>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLinksSolver.ChooseNextColumn">
            <summary>
            Try to choose the next column node.
            </summary>
            <returns>The chosen next column node.</returns>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Dlx.DancingLink">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="root">The root node.</param>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLink.#ctor(Sudoku.Algorithms.Solving.Dlx.ColumnNode)">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="root">The root node.</param>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.Dlx.DancingLink.Entry">
            <summary>
            Indicates the entry instance.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLink.CreateLinkedList(System.Int32[])">
            <summary>
            Creates the links.
            </summary>
            <param name="gridArray">The grid array.</param>
            <returns>The column node for the root node.</returns>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.DancingLink.FormLinks(Sudoku.Algorithms.Solving.Dlx.ColumnNode[],System.Int32,System.Int32,System.Int32)">
            <summary>
            To form the links via the specified columns, the cell index and the digit used.
            </summary>
            <param name="columns">The columns having been stored.</param>
            <param name="x">The current row index.</param>
            <param name="y">The current column index.</param>
            <param name="d">The current digit.</param>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Dlx.MatrixRow">
            <summary>
            Represents a type describing for a matrix row.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.Dlx.MatrixRow.#ctor(Sudoku.Algorithms.Solving.Dlx.DancingLinkNode,Sudoku.Algorithms.Solving.Dlx.DancingLinkNode,Sudoku.Algorithms.Solving.Dlx.DancingLinkNode,Sudoku.Algorithms.Solving.Dlx.DancingLinkNode)">
            <summary>
            Represents a type describing for a matrix row.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.EnumerableQuery.EnumerableQuerySolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using LINQ.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.EnumerableQuery.EnumerableQuerySolver.DigitCharacters">
            <summary>
            Indicates the characters for 1 to 9.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.EnumerableQuery.EnumerableQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.EnumerableQuery.EnumerableQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.ISolver">
            <summary>
            Represents a solver that can provide with a basic function to solve a sudoku puzzle given with a <see cref="T:Sudoku.Concepts.Grid"/> instance,
            and returns its solution grid.
            </summary>
        </member>
        <member name="P:Sudoku.Algorithms.Solving.ISolver.UriLink">
            <summary>
            Indicates the URI link that links to the introduction of the algorithm.
            </summary>
            <remarks>
            This property is reserved as information that is offered to the algorithm learners.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Solving.ISolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            Solve the specified grid, and return the solution via argument <paramref name="result"/>
            with returning a <see cref="T:System.Boolean"/>? value indicating the solved state.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Please note that if the return value is not <see langword="true"/>,
            the value should be a discard and should not be used, because the argument
            keeps a memory-randomized value currently.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Algorithms.Solving.Uniqueness">
            <summary>
            Represents a flag describing the number of solutions to a puzzle.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Uniqueness.None">
            <summary>
            The placeholder of this type.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Uniqueness.Bad">
            <summary>
            Indicates the puzzle has no valid solution.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Uniqueness.Unique">
            <summary>
            Indicates the puzzle has a unique solution.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Solving.Uniqueness.Multiple">
            <summary>
            Indicates the puzzle has multiple solutions.
            </summary>
        </member>
        <member name="T:Sudoku.Algorithms.Transformation.GridTransformations">
            <summary>
            Provides methods for <see cref="T:Sudoku.Concepts.Grid"/> instances on transformations.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.GridTransformations.ClockwiseTable">
            <summary>
            The table of clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.GridTransformations.CounterclockwiseTable">
            <summary>
            The table of counter-clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.GridTransformations.PiRotateTable">
            <summary>
            The table of pi-rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.GridTransformations.SwappableHouses">
            <summary>
            Indicates the swappable pairs, which means the swappable houses.
            </summary>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.MirrorLeftRight(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror left-right the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.MirrorTopBottom(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror top-bottom the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.MirrorDiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.Transpose(Sudoku.Concepts.Grid@)">
            <summary>
            Transpose the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.MirrorAntidiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror anti-diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.RotateClockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid clockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.RotateCounterclockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid counterclockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.RotatePi(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid <c><see cref="F:System.Math.PI"/></c> degrees.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
            <seealso cref="F:System.Math.PI"/>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.SwapDigit(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap two digits.
            </summary>
            <param name="this">The grid.</param>
            <param name="digit1">The digit 1 to be swapped.</param>
            <param name="digit2">The digit 2 to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">Throws when the puzzle is not solved.</exception>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.SwapHouse(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap to houses.
            </summary>
            <param name="this">The grid.</param>
            <param name="houseIndex1">The house 1 to be swapped.</param>
            <param name="houseIndex2">The house 2 to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when two specified house argument is not in valid range (0..27),
            two houses are not in same house type, or are not swappable.
            </exception>
            <remarks>
            This method will return the reference that is same as the argument <paramref name="this"/>,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Algorithms.Transformation.GridTransformations.SwapChute(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap chutes (i.e. mega-rows or mega-columns).
            </summary>
            <param name="this">The grid.</param>
            <param name="chuteIndex1">The first chute to be swapped.</param>
            <param name="chuteIndex2">The second chute to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">Throws when two specified chute index is not in valid range (0..6).</exception>
        </member>
        <member name="T:Sudoku.Algorithms.Transformation.TransformType">
            <summary>
            Represents a type of transformation.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.None">
            <summary>
            The placeholder of this type.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.DigitSwap">
            <summary>
            Indicates the transform type is to swap digits.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.RowSwap">
            <summary>
            Indicates the transform type is to swap rows.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.ColumnSwap">
            <summary>
            Indicates the transform type is to swap columns.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.BandSwap">
            <summary>
            Indicates the transform type is to swap bands.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.TowerSwap">
            <summary>
            Indicates the transform type is to swap towers.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.MirrorLeftRight">
            <summary>
            Indicates the transform type is to mirror left and right.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.MirrorTopBottom">
            <summary>
            Indicates the transform type is to mirror top and bottom.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.MirrorDiagonal">
            <summary>
            Indicates the transform type is to mirror diagonal.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.MirrorAntidiagonal">
            <summary>
            Indicates the transform type is to mirror anti-diagonal.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.RotateClockwise">
            <summary>
            Indicates the transform type is to rotate clockwise.
            </summary>
        </member>
        <member name="F:Sudoku.Algorithms.Transformation.TransformType.RotateCounterclockwise">
            <summary>
            Indicates the transform type is to ratate counter-clockwise.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap">
            <summary>
            Encapsulates a binary series of candidate state table.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.BackingBuffer">
            <summary>
            Indicates the internal buffer type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.BackingBuffer._firstElement">
            <summary>
            Indicates the first element of the whole buffer.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.Equals(Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#IEquatable{Sudoku#Concepts#CandidateMap#BackingBuffer}#Equals(Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.op_Equality(Sudoku.Concepts.CandidateMap.BackingBuffer@,Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.op_Inequality(Sudoku.Concepts.CandidateMap.BackingBuffer@,Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#BackingBuffer,Sudoku#Concepts#CandidateMap#BackingBuffer,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap.BackingBuffer,Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#BackingBuffer,Sudoku#Concepts#CandidateMap#BackingBuffer,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap.BackingBuffer,Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.CellDigitEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellDigitEnumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.GetEnumerator">
            <summary>
            Returns itself, in order to iterate the value using <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator itself.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.CellEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each cell of the collection.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that can iterate on each cell of the collection.
            </summary>
            <param name="candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellEnumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.GetEnumerator">
            <summary>
            Returns itself, in order to iterate the value using <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator itself.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Length">
            <summary>
            Indicates the length of the backing buffer.
            The size of the buffer is 12 <c><![CDATA[floor(729 / sizeof(long) << 6)]]></c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Full">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Full"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap._bits">
            <summary>
            Indicates the internal field that provides the visit entry for fixed-sized buffer type <see cref="T:Sudoku.Concepts.CandidateMap.BackingBuffer"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap.BackingBuffer"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via a list of candidate offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The candidate offsets, represented as a RxCy notation.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.Int32,System.Boolean)">
            <summary>
            Indicates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance with the peer candidates of the specified candidate and a <see cref="T:System.Boolean"/>
            value indicating whether the map will process itself with <see langword="true"/> value.
            </summary>
            <param name="candidate">The candidate.</param>
            <param name="withItself">Indicates whether the map will process itself with <see langword="true"/> value.</param>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Digits">
            <summary>
            Indicates the digits used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Cells">
            <summary>
            Indicates the cells used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.DigitDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by digit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Full">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="item">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CompareTo(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetDigitsFor(System.Int32)">
            <summary>
            Try to get digits that is in the current collection.
            </summary>
            <param name="cell">The desired cell.</param>
            <returns>The digits.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.EnumerateCells">
            <summary>
            Try to enumerate cells on each candidates.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.EnumerateCellDigit">
            <summary>
            Try to enumerate cell and digit value on each candidates.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Add(System.Int32)">
            <summary>
            Add a new <see cref="T:System.Int32"/> into the collection.
            </summary>
            <param name="item">The offset to be added.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Remove(System.Int32)">
            <summary>
            Removes the specified offset from the current collection.
            </summary>
            <param name="item">An offset to be removed.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the specified offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveCell(System.Int32)">
            <summary>
            Remove all <see cref="T:System.Int32"/> instances that is equal to the argument <paramref name="cell"/>.
            </summary>
            <param name="cell">The cell to be removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Toggle(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Clear">
            <summary>
            Remove all elements stored in the current collection, and set the property <see cref="P:Sudoku.Concepts.CandidateMap.Count"/> to zero.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CandidateMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IEquatable{Sudoku#Concepts#CandidateMap}#Equals(Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Any(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#All(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CandidateMap,System#Int32}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CandidateMap,System#Int32}#First(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IGroupByMethod{Sudoku#Concepts#CandidateMap,System#Int32}#GroupBy``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CandidateMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via the specified candidates.
            </summary>
            <param name="candidates">The candidates.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LogicalNot(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_True(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_False(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_OnesComplement(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <summary>
            Expands the operator to <c><![CDATA[(a & b).PeerIntersection & b]]></c>.
            </summary>
            <param name="base">The base map.</param>
            <param name="template">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_ExclusiveOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,System.Range)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Division(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <summary>
            Reduces the <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, only checks for candidates
            whose digit is equal to argument <paramref name="digit"/>,
            and merge into a <see cref="T:Sudoku.Concepts.CellMap"/> value.
            </summary>
            <param name="candidates">The candidates to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="offsets">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="offsets">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Equality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Inequality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_GreaterThan(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LessThan(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_GreaterThanOrEqual(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LessThanOrEqual(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_GreaterThan(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_LessThan(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CandidateMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMarshal">
            <summary>
            Represents methods that operates with <see cref="T:System.Int32"/> values.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Int32)">
            <summary>
            Converts the specified <see cref="T:System.Int32"/> into a singleton <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="this">The cell to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, containing only one element of <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})">
            <summary>
            Converts the specified list of <see cref="T:System.Int32"/> instances into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="this">The cells to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, containing all elements come from <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.ReadOnlySpan{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})"/>
        </member>
        <member name="T:Sudoku.Concepts.CellMap">
            <summary>
            Encapsulates a binary series of cell state table.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Shifting">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Shifting"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Full">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Full"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.SharedHouseConstants">
            <summary>
            Indicates the <see cref="T:System.Runtime.Intrinsics.Vector128`1"/> instances to be used for checking shared houses.
            </summary>
            <seealso cref="T:System.Runtime.Intrinsics.Vector128`1"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.SharedHouseFactorValues">
            <summary>
            Indicates the factor values for property <see cref="P:Sudoku.Concepts.CellMap.SharedHouses"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CellMap.SharedHouses"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._high">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._low">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.CellMap._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.CellMap._low"/> represents the lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a list of offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The cell offsets, represented as a RxCy notation.</param>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.IsInIntersection">
            <summary>
            Determines whether the current list of cells are all lie in an intersection area, i.e. a locked candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CanSeeEachOther">
            <summary>
            Indicates whether every cell in the current collection cannot see each other.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.BlockMask">
            <summary>
            Indicates the mask of block that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned blocks are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.RowMask">
            <summary>
            Indicates the mask of row that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned rows are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ColumnMask">
            <summary>
            Indicates the mask of column that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned columns are 0 and 1, so the return mask is <c>0b000000011</c> (i.e. 3).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.SharedLine">
            <summary>
            Indicates the shared line. In other words, the line will contain all cells in this collection.
            </summary>
            <remarks>
            If no shared houses can be found (i.e. return value of property <see cref="P:Sudoku.Concepts.CellMap.SharedHouses"/> is 0),
            this property will return <see cref="F:Sudoku.SolutionFields.TrailingZeroCountFallback"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionFields.TrailingZeroCountFallback"/>
            <seealso cref="P:Sudoku.Concepts.CellMap.SharedHouses"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.SharedHouses">
            <summary>
            Indicates all houses shared. This property is used to check all houses that all cells of this instance shared.
            For example, if the cells are <c>[0, 1]</c>, the property <see cref="P:Sudoku.Concepts.CellMap.SharedHouses"/> will return
            house indices 0 (block 1) and 9 (row 1); however, if cells span two houses or more (e.g. cells <c>[0, 1, 27]</c>),
            this property won't contain any houses.
            </summary>
            <remarks>
            The return value will be a <see cref="T:System.Int32"/> value indicating each houses. Bits set 1 are shared houses.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Houses">
            <summary>
            All houses that the map spanned. This property is used to check all houses that all cells of
            this instance spanned. For example, if the cells are <c>[0, 1]</c>, the property
            <see cref="P:Sudoku.Concepts.CellMap.Houses"/> will return the house index 0 (block 1), 9 (row 1), 18 (column 1)
            and 19 (column 2).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Symmetry">
            <summary>
            Try to get the symmetric type of the pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ExpandedPeers">
            <summary>
            Gets the expanded peers of the current map.
            </summary>
            <remarks>
            An <b>Expanded Peers</b> is a list of cells that contains all peer cells of each cell
            appeared in the current collection. For example, if a collection contains cells <c>r1c123</c>,
            this collection will be the result of the expression <c>PeersMap[r1c1] | PeersMap[r1c2] | PeersMap[r1c3]</c>,
            where the member <c>PeersMap</c> corresponds to the array <see cref="F:Sudoku.SolutionFields.PeersMap"/>.
            </remarks>
            <seealso cref="F:Sudoku.SolutionFields.PeersMap"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#Primitives#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Full">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.InOneHouse(System.Int32@)">
            <summary>
            Indicates whether all cells in this instance are in one house.
            </summary>
            <param name="houseIndex">
            The house index whose corresponding house covered.
            If the return value is <see langword="false"/>, this value will be the constant -1.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="item">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc cref="M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc cref="M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CompareTo(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Add(System.Int32)">
            <summary>
            Add a new <see cref="T:System.Int32"/> into the collection.
            </summary>
            <param name="item">The offset to be added.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Remove(System.Int32)">
            <summary>
            Removes the specified offset from the current collection.
            </summary>
            <param name="item">An offset to be removed.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the specified offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Toggle(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Clear">
            <summary>
            Remove all elements stored in the current collection, and set the property <see cref="P:Sudoku.Concepts.CellMap.Count"/> to zero.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CellMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IEquatable{Sudoku#Concepts#CellMap}#Equals(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#Any(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#All(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CellMap,System#Int32}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CellMap,System#Int32}#First(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#CellMap,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IGroupByMethod{Sudoku#Concepts#CellMap,System#Int32}#GroupBy``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#CellMap,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CellMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance via the specified cells.
            </summary>
            <param name="cells">The cells.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int64,System.Int64)">
            <summary>
            Initializes an instance with two binary values.
            </summary>
            <param name="high">Higher 40 bits.</param>
            <param name="low">Lower 41 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes an instance with three binary values.
            </summary>
            <param name="high">Higher 27 bits.</param>
            <param name="mid">Medium 27 bits.</param>
            <param name="low">Lower 27 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LogicalNot(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_True(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_False(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_OnesComplement(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Modulus(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <summary>
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/summary"/>
            </summary>
            <param name="base">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='base']"/>
            </param>
            <param name="template">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/param[@name='template']"/>
            </param>
            <returns><inheritdoc cref="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)" path="/returns"/></returns>
            <remarks>
            <para>
            The operator is commonly used for checking eliminations, especially in type 2 of deadly patterns. 
            </para>
            <para>
            For example, if we should check the eliminations
            of digit <c>d</c>, we may use the expression
            <code><![CDATA[
            (urCells & grid.CandidatesMap[d]).PeerIntersection & grid.CandidatesMap[d]
            ]]></code>
            to express the eliminations are the peer intersection of cells of digit <c>d</c>
            appeared in <c>urCells</c>. This expression can be simplified to
            <code><![CDATA[
            urCells % grid.CandidatesMap[d]
            ]]></code>
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_ExclusiveOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,System.Range)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Multiply(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Expands the current <see cref="T:Sudoku.Concepts.CellMap"/> instance, inserting into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance by specified digit.
            </summary>
            <param name="cells">The cells to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Division(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Reduces the <see cref="T:Sudoku.Concepts.CellMap"/> instances, only checks for cells in the specified cells, and merge into a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="cells">The cells to be checked.</param>
            <param name="house">The house to be checked.</param>
            <returns>A <see cref="T:System.Int16"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.Int32[])~Sudoku.Concepts.CellMap">
            <summary>
            Explicit cast from a <see cref="T:System.Int32"/> array into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="cells">An array of <see cref="T:System.Int32"/> values.</param>
        </member>
        <member name="T:Sudoku.Concepts.CellMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="offset">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="offset">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.MaxValueDouble">
            <summary>
            Indicates the possible maximal value in <see cref="T:System.Double"/> representation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Size">
            <summary>
            Indicates the size.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.MaxValueUInt128">
            <summary>
            Indicates the max bits on numeric representation.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.NumericValue">
            <summary>
            Indicates the back numeric value to be used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#Radix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#One">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#Zero">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#IMultiplicativeIdentity{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#MultiplicativeIdentity">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#ISignedNumber{Sudoku#Concepts#CellMap}#NegativeOne">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.System#Numerics#IBinaryNumber{Sudoku#Concepts#CellMap}#AllBitsSet">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#ISpanFormattable#TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#TryWriteBigEndian(System.Span{System.Byte},System.Int32@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IComparable#CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#GetByteCount">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#GetShortestBitLength">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByNumericValue(System.Int128)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a <see cref="T:System.Int128"/> as numeric value.
            </summary>
            <param name="numericValue">The numeric value.</param>
            <returns>A valid <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByNumericValueChecked(System.Int128)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a <see cref="T:System.Int128"/> as numeric value.
            </summary>
            <param name="numericValue">The numeric value.</param>
            <returns>A valid <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
            <exception cref="T:System.OverflowException">Throws when the numeric value has exceeded bits of position greater than 81.</exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsCanonical(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsComplexNumber(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsEvenInteger(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsFinite(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsImaginaryNumber(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsInfinity(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsInteger(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsNaN(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsNegative(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsNegativeInfinity(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsNormal(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsOddInteger(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsPositive(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsPositiveInfinity(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryNumber{Sudoku#Concepts#CellMap}#IsPow2(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsRealNumber(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsSubnormal(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#IsZero(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryConvertFromChecked``1(``0,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryConvertFromSaturating``1(``0,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryConvertFromTruncating``1(``0,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryConvertToChecked``1(Sudoku.Concepts.CellMap,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryConvertToSaturating``1(Sudoku.Concepts.CellMap,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryConvertToTruncating``1(Sudoku.Concepts.CellMap,``0@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#ISpanParsable{Sudoku#Concepts#CellMap}#TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IParsable{Sudoku#Concepts#CellMap}#TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#TryReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#TryReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#Abs(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryNumber{Sudoku#Concepts#CellMap}#Log2(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#MaxMagnitude(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#MaxMagnitudeNumber(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#MinMagnitude(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#MinMagnitudeNumber(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#INumberBase{Sudoku#Concepts#CellMap}#Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#ISpanParsable{Sudoku#Concepts#CellMap}#Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IParsable{Sudoku#Concepts#CellMap}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#PopCount(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IBinaryInteger{Sudoku#Concepts#CellMap}#TrailingZeroCount(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.LeadingZeroCountAsInt32(System.Int128)">
            <summary>
            Calculates leading zeros count, try casting the value as two parts of bits.
            </summary>
            <param name="value">The values.</param>
            <returns>The final value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IUnaryPlusOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_UnaryPlus(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_Addition(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IAdditionOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_CheckedAddition(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IUnaryNegationOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_UnaryNegation(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IUnaryNegationOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_CheckedUnaryNegation(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_Subtraction(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#ISubtractionOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_CheckedSubtraction(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IIncrementOperators{Sudoku#Concepts#CellMap}#op_Increment(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IIncrementOperators{Sudoku#Concepts#CellMap}#op_CheckedIncrement(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IDecrementOperators{Sudoku#Concepts#CellMap}#op_Decrement(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IDecrementOperators{Sudoku#Concepts#CellMap}#op_CheckedDecrement(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IMultiplyOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_Multiply(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IMultiplyOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_CheckedMultiply(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IDivisionOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_Division(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IDivisionOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap}#op_CheckedDivision(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IShiftOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap}#op_LeftShift(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IShiftOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap}#op_RightShift(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IShiftOperators{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap}#op_UnsignedRightShift(Sudoku.Concepts.CellMap,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(Sudoku.Concepts.CellMap@)~System.Int128">
            <summary>
            Creates a <see cref="T:System.Int128"/> instance as its numeric representation via the specified <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="this">A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Explicit(System.Int128)~Sudoku.Concepts.CellMap">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance as its bit representation via the specified <see cref="T:System.Int128"/> instance.
            </summary>
            <param name="value">An <see cref="T:System.Int128"/> instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_CheckedExplicit(System.Int128)~Sudoku.Concepts.CellMap">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance as its bit representation via the specified <see cref="T:System.Int128"/> instance;
            with overflow checking - throws <see cref="T:System.OverflowException"/> if the argument uses exceeded bits
            whose position is greater than 81.
            </summary>
            <param name="value">An <see cref="T:System.Int128"/> instance.</param>
            <exception cref="T:System.OverflowException">Throws when the value uses exceeded bits whose position is greater than 81.</exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Equality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Inequality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Equality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_GreaterThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CellMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMapOrCandidateMapPredicate`3">
            <summary>
            Represents a method that checks for an offset of type <typeparamref name="TElement"/>
            in the collection of type <typeparamref name="TSelf"/>, referenced from <paramref name="grid"/>,
            determining whether the offset satisfies the specified condition.
            </summary>
            <typeparam name="TSelf">
            The type of the bit status map. The value can be <see cref="T:Sudoku.Concepts.CellMap"/> or <see cref="T:Sudoku.Concepts.CandidateMap"/>.
            </typeparam>
            <typeparam name="TElement">
            The type of each element in the collection of type <typeparamref name="TSelf"/>.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <param name="offset">The <typeparamref name="TElement"/> offset value to be checked.</param>
            <param name="grid">The grid as candidate reference.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CellMapToken">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapToken.GetToken(Sudoku.Concepts.CellMap@)">
            <summary>
            Indicates the token to the current instance.
            </summary>
            <param name="this">The instance.</param>
            <returns>The string token.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMapToken.CreateFromToken(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.CellMapToken.CreateFromToken(System.String)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapToken.CreateFromToken(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance using the specified token of length 18.
            </summary>
            <param name="token">Indicates the token.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> result.</returns>
            <exception cref="T:System.FormatException">Throws when the length of the argument mismatched.</exception>
        </member>
        <member name="T:Sudoku.Concepts.CellMarshal">
            <summary>
            Represents a list of extension methods that operates with cell instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.CopyHouseInfo(System.Int32,System.Int32@)">
            <summary>
            Gets the row, column and block value and copies to the specified array that represents by a pointer
            of 3 elements, where the first element stores the block index, second element stores the row index
            and the third element stores the column index.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="reference">
            The specified reference to the first element in a sequence. The sequence type can be an array or a <see cref="T:System.Span`1"/>,
            only if the sequence can store at least 3 values.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="reference"/> references to <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouse(System.Byte,Sudoku.Concepts.HouseType)">
            <summary>
            Get the house index (0..27 for block 1-9, row 1-9 and column 1-9)
            for the specified cell and the house type.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="houseType">The house type.</param>
            <returns>The house index. The return value must be between 0 and 26.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="houseType"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouse(System.Int32,Sudoku.Concepts.HouseType)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.ToHouse(System.Byte,Sudoku.Concepts.HouseType)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Int32)">
            <summary>
            Get the house indices for the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>A <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToBand(System.Int32)">
            <summary>
            Try to get the band index (mega-row) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToTower(System.Int32)">
            <summary>
            Try to get the tower index (mega-column) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Int32)">
            <summary>
            Converts the specified <see cref="T:System.Int32"/> into a singleton <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="this">The cell to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance, containing only one element of <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})">
            <summary>
            Converts the specified list of <see cref="T:System.Int32"/> instances into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="this">The cells to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance, containing all elements come from <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.ReadOnlySpan{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})"/>
        </member>
        <member name="T:Sudoku.Concepts.CellState">
            <summary>
            Represents a cell state.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Undefined">
            <summary>
            Indicates the cell state is invalid - it holds an empty cell without any candidates here.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Empty">
            <summary>
            Indicates that the cell is empty.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Modifiable">
            <summary>
            Indicates the current cell has been filled a value that is not given from initial grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Given">
            <summary>
            Indicates the current cell has been filled a value that cannot be modified because it exists in initial grid.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Chute">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="Cells">The cells used.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="M:Sudoku.Concepts.Chute.#ctor(System.Int32,Sudoku.Concepts.CellMap@,System.Boolean,System.Int32)">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="Cells">The cells used.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Index">
            <summary>Index of the chute. The value is between 0 and 6.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Cells">
            <summary>The cells used.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.IsRow">
            <summary>Indicates whether the chute is in a mega-row.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.HousesMask">
            <summary>Indicates the houses used.</summary>
        </member>
        <member name="M:Sudoku.Concepts.Chute.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.TryParse(System.String,Sudoku.Concepts.Chute@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Chute@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Conclusion">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-----------------------|---|---------------------------------------|
            |   |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-----------------------|---|---------------------------------------'
                                     \_/ \_____________________________________/
                                     (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1), but the real type
            <see cref="P:Sudoku.Concepts.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type because C# cannot set "A bit"
            to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(System.Int16)">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-----------------------|---|---------------------------------------|
            |   |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-----------------------|---|---------------------------------------'
                                     \_/ \_____________________________________/
                                     (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1), but the real type
            <see cref="P:Sudoku.Concepts.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type because C# cannot set "A bit"
            to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type, but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Conclusion.Parsers">
            <summary>
            The internal parsers.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(Sudoku.Concepts.ConclusionType,System.Int32)">
            <summary>
            Initializes an instance with a conclusion type and a candidate offset.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="candidate">The candidate offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(Sudoku.Concepts.ConclusionType,System.Int32,System.Int32)">
            <summary>
            Initializes the <see cref="T:Sudoku.Concepts.Conclusion"/> instance via the specified cell, digit and the conclusion type.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Cell">
            <summary>
            Indicates the cell the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Digit">
            <summary>
            Indicates the digit the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Candidate">
            <summary>
            Indicates the candidate the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.ConclusionType">
            <summary>
            Indicates the conclusion type of the current instance.
            If the type is <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/>, this conclusion will be set value (Set a digit into a cell);
            otherwise, a candidate will be removed.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Deconstruct(Sudoku.Concepts.ConclusionType@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Deconstruct(Sudoku.Concepts.ConclusionType@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Equals(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.CompareTo(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.GetSymmetricConclusion(Sudoku.SymmetricType,System.Int32)">
            <summary>
            Try to get a new <see cref="T:Sudoku.Concepts.Conclusion"/> instance which is symmetric with the current instance, with the specified symmetric type.
            </summary>
            <param name="symmetricType">The symmetric type to be checked.</param>
            <param name="mappingDigit">The other mapping digit.</param>
            <returns>The other symmetric <see cref="T:Sudoku.Concepts.Conclusion"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="symmetricType"/> contains multiple (greater than 2) cells
            symmetric with the current cell and digit.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.TryParse(System.String,Sudoku.Concepts.Conclusion@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Conclusion@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_OnesComplement(Sudoku.Concepts.Conclusion)">
            <summary>
            Negates the current conclusion instance, changing the conclusion type from <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/> to <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/>,
            or from <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> to <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/>.
            </summary>
            <param name="self">The current conclusion instance to be negated.</param>
            <returns>The negation.</returns>
        </member>
        <member name="F:Sudoku.Concepts.Conclusion._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_Equality(Sudoku.Concepts.Conclusion,Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_Inequality(Sudoku.Concepts.Conclusion,Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Represents a JSON converter for type <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Conclusion,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionSet">
            <summary>
            Represents a list of conclusions.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.BitsCount">
            <summary>
            The total length of bits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.HalfBitsCount">
            <summary>
            The maximum number of candidates can exist in a grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.PrimeNumbers">
            <summary>
            The prime numbers below 100.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet._bitArray">
            <summary>
            The internal bit array.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet._conclusionsEntry">
            <summary>
            The entry point that can visit conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.ContainsAssignment">
            <summary>
            Indicates whether the collection contains any assignment conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.ContainsElimination">
            <summary>
            Indicates whether the collection contains any elimination conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Count">
            <summary>
            Indicates the number of bit array elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Empty">
            <summary>
            An empty instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Item(System.Int32)">
            <summary>
            Try to get n-th element stored in the collection.
            </summary>
            <param name="index">The desired index to be checked.</param>
            <returns>The found <see cref="T:Sudoku.Concepts.Conclusion"/> instance at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Add(System.Int32)">
            <summary>
            Add a new conclusion, represented as a global index (between 0 and 1458), into the collection.
            </summary>
            <param name="index">
            <para>The global index (between 0 and 1458) to be added.</para>
            <para>The global index is equivalent to the result value of this formula <c>conclusionType * 729 + candidate</c>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Add(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.AddRange(System.ReadOnlySpan{Sudoku.Concepts.Conclusion})">
            <summary>
            Add a list of conclusions into the collection.
            </summary>
            <param name="conclusions">The conclusions to be added.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Remove(System.Int32)">
            <summary>
            Remove a conclusion, represented as a global index (between 0 and 1458), from the collection.
            </summary>
            <param name="index">
            <para>The global index (between 0 and 1458) to be added.</para>
            <para>The global index is equivalent to the result value of this formula <c>conclusionType * 729 + candidate</c>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Remove(Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Replace(Sudoku.Concepts.ConclusionSet)">
            <summary>
            Removes all elements in the collection and add all elements from <paramref name="conclusions"/>.
            </summary>
            <param name="conclusions">The conclusions provider to replace with the current instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.CopyTo(System.Span{Sudoku.Concepts.Conclusion})">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Equals(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Contains(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ContainsCell(System.Int32)">
            <summary>
            Indicates whether the collection contains the specified cell.
            </summary>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Exists(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.Any(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TrueForAll(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.All(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.IsWorthFor(Sudoku.Concepts.Grid@)">
            <summary>
            Determine whether the conclusion set contains valid conclusions that can be applied to grid.
            </summary>
            <param name="grid">The grid to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.GetEnumerator">
            <summary>
            Try to get an enumerator type that iterates on each conclusion.
            </summary>
            <returns>An enumerator type that iterates on each conclusion.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Slice(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.ISliceMethod`2.Slice(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#CopyTo(Sudoku.Concepts.Conclusion[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#ExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IntersectWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#UnionWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Any(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#All(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#Remove(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#Add(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IEnumerable{Sudoku#Concepts#Conclusion}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#ISliceMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TryParse(System.String,Sudoku.Concepts.ConclusionSet@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.ConclusionSet@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_LogicalNot(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_True(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_False(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_OnesComplement(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_BitwiseAnd(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_BitwiseOr(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_ExclusiveOr(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionSet.Enumerator">
            <summary>
            The internal enumerator instance.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Enumerator.#ctor(Sudoku.Concepts.ConclusionSet)">
            <summary>
            The internal enumerator instance.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.Enumerator._enumerator">
            <summary>
            The conclusions to be iterated.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Enumerator.Current">
            <summary>
            Indicates the current iterated element.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_Equality(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_Inequality(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionType">
            <summary>
            Provides a conclusion type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionType.Assignment">
            <summary>
            Indicates the conclusion is a value filling into a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionType.Elimination">
            <summary>
            Indicates the conclusion is a candidate being remove from a cell.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Conjugate">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32)">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with from and to cell offset and a digit.
            </summary>
            <param name="from">The from cell.</param>
            <param name="to">The to cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with the map and the digit.
            The map should contains two cells, the first one is the start one, and the second one is the end one.
            </summary>
            <param name="map">The map.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.From">
            <summary>
            Indicates the "from" cell, i.e. the base cell that starts the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.To">
            <summary>
            Indicates the "to" cell, i.e. the target cell that ends the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Line">
            <summary>
            Indicates the target line of the two cells lie in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Houses">
            <summary>
            Indicates the house that the current conjugate pair lies in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Map">
            <summary>
            Indicates the cells (the "from" cell and "to" cell).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.TryParse(System.String,Sudoku.Concepts.Conjugate@)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Conjugate@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.Conjugate._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Equality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Inequality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateConverter">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
            <remarks>
            You can use types <see cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>, <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>, <see cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
            <remarks>
            You can use types <see cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>, <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>, <see cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.DefaultSeparator">
            <summary>
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.DigitsSeparator">
            <summary>
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CurrentCulture">
            <summary>
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CellConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CandidateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.HouseConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of houses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ConclusionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.DigitConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.IntersectionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified information for an intersection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ChuteConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of chute.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ConjugateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified conjugate.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.TargetCurrentCulture">
            <summary>
            Indicates the target culture.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.InvariantCultureConverter">
            <summary>
            Indicates the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance for the invariant culture,
            meaning it ignores which culture your device will use.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.GetConverter(System.IFormatProvider)">
            <summary>
            Try to get a <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance from the specified format provider.
            </summary>
            <param name="formatProvider">The format provider instance.</param>
            <returns>A <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance as the final result.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateParser">
            <summary>
            Represents for a parser instance that parses a <see cref="T:System.String"/> text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateParser.DeprecatedInfo_NotSupported">
            <summary>
            The not supported information for property implemented.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.CellParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CellMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.CandidateParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.HouseParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int32"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ConclusionParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Conclusion"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.DigitParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int16"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.IntersectionParser">
            <summary>
            The parser method that can creates a list of pairs of <see cref="T:Sudoku.Concepts.MinilineBase"/> and <see cref="T:Sudoku.Concepts.MinilineResult"/>
            via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.MinilineBase"/>
            <seealso cref="T:Sudoku.Concepts.MinilineResult"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ChuteParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Chute"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Chute"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ConjugateParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Conjugate"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conjugate"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.InvariantCultureParser">
            <summary>
            Indicates the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance for the invariant culture,
            meaning it ignores which culture your device will use.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateParser.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateParser.GetParser(System.IFormatProvider)">
            <summary>
            Try to get a <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance from the specified culture.
            </summary>
            <param name="formatProvider">The format provider instance.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance from the specified culture.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateType">
            <summary>
            Represents a type of notation to describe a coordinate in sudoku.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.Literal">
            <summary>
            Idnicates the notation is based on literally notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.RxCy">
            <summary>
            Indicates the notation is based on <b>RxCy</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.K9">
            <summary>
            Indicates the notation is based on <b>K9</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.Excel">
            <summary>
            Indicates the notation is based on <b>Excel</b> notation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.#ctor(System.Boolean,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.K9Converter">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distinct with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Converter.#ctor(System.Boolean,System.Char,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distinct with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.FinalRowLetter">
            <summary>
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distinct with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Converter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.K9Parser">
            <summary>
            Represents a parser type that uses <b>K9</b> notation rule to parse text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ConjugateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[a-k]+[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+)([1-9]+)\\.([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
            ○ 2nd capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match '.'.<br/>
            ○ 3rd capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+[1-9]+(,\\s*[a-k]+[1-9]+)*)\\s*(==?|!=|&lt;&gt;)\\s*([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                ○ Match a character in the set [1-9] greedily at least once.<br/>
                ○ Loop greedily any number of times.<br/>
                    ○ 2nd capture group.<br/>
                        ○ Match ','.<br/>
                        ○ Match a whitespace character atomically any number of times.<br/>
                        ○ Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                        ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 3rd capture group.<br/>
                ○ Match with 3 alternative expressions.<br/>
                    ○ Match '=' atomically at least 1 and at most 2 times.<br/>
                    ○ Match the string "!=".<br/>
                    ○ Match the string "&lt;&gt;".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 4th capture group.<br/>
                ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k][1-9])\\s*={2}\\s*([a-k][1-9])\\.([1-9])</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A].<br/>
                ○ Match a character in the set [1-9].<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "==".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 2nd capture group.<br/>
                ○ Match a character in the set [A-Ka-k\u212A].<br/>
                ○ Match a character in the set [1-9].<br/>
            ○ Match '.'.<br/>
            ○ 3rd capture group.<br/>
                ○ Match a character in the set [1-9].<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Parser.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.#ctor(System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.RxCyConverter">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.MakeDigitBeforeCell">
            <summary>
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.HouseNotationOnlyDisplayCapitals">
            <summary>
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.GetLabel(System.Byte)">
            <summary>
            Get the label of each house.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>The label.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.RxCyParser">
            <summary>
            Represents a parser type that uses <b>RxCy</b> notation rule to parse text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ConjugateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+\\([1-9]+\\)|[1-9]+r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match with 2 alternative expressions, atomically.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Match an empty string.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match '('.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match ')'.<br/>
                ○ Match a sequence of expressions.<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Rr].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+(,\\s*r[1-9]+c[1-9]+)*\\s*(==?|!=|&lt;&gt;)\\s*[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9] greedily at least once.<br/>
            ○ Loop greedily any number of times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a whitespace character atomically any number of times.<br/>
                    ○ Match a character in the set [Rr].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
                    ○ Match a character in the set [Cc].<br/>
                    ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ 2nd capture group.<br/>
                ○ Match with 3 alternative expressions.<br/>
                    ○ Match '=' atomically at least 1 and at most 2 times.<br/>
                    ○ Match the string "!=".<br/>
                    ○ Match the string "&lt;&gt;".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitHousePattern">
            <remarks>
            Pattern:<br/>
            <code>[rcb][1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [BCRbcr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitIntersectionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[rc][1-9]+b[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [CRcr].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            ○ Match a character in the set [Bb].<br/>
            ○ Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitMegaLineGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>m[rc][1-3]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Mm].<br/>
            ○ Match a character in the set [CRcr].<br/>
            ○ Match a character in the set [1-3] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]c[1-9]\\s*={2}\\s*r[1-9]c[1-9]\\([1-9]\\)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match the string "==".<br/>
            ○ Match a whitespace character atomically any number of times.<br/>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match '('.<br/>
            ○ Match a character in the set [1-9].<br/>
            ○ Match ')'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.BitmapCandidateMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.CandidateMapFormatInfo"/> type that supports bitmap formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.BitmapCandidateMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.BitmapCandidateMapFormatInfo.Equals(Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.BitmapCandidateMapFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.BitmapCandidateMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.BitmapCandidateMapFormatInfo.FormatMap(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.BitmapCandidateMapFormatInfo.ParseMap(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMapFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, or parses into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.Equals(Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.Clone">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>A new instance whose internal values are equal to the current instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.FormatMap(Sudoku.Concepts.CandidateMap@)">
            <summary>
            Try to format the current map into a valid string result.
            </summary>
            <param name="map">The map to be formatted.</param>
            <returns>The <see cref="T:System.String"/> representation of the argument <paramref name="map"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.ParseMap(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> instance into a valid <see cref="T:Sudoku.Concepts.CandidateMap"/>.
            </summary>
            <param name="str">The string value to be parsed.</param>
            <returns>The <see cref="T:Sudoku.Concepts.CandidateMap"/> as the result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.op_Equality(Sudoku.Concepts.CandidateMapFormatInfo,Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMapFormatInfo.op_Inequality(Sudoku.Concepts.CandidateMapFormatInfo,Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.CandidateMapFormatInfo"/> type that supports Hodoku elimination candidates formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.Equals(Sudoku.Concepts.CandidateMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.FormatMap(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.HodokuTripletCandidateMapFormatInfo.ParseMap(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.BitmapCellMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.CellMapFormatInfo"/> type that supports bitmap formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.Equals(Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.FormatMap(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.BitmapCellMapFormatInfo.ParseMap(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMapFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.CellMap"/> instance, or parses into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.Equals(Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.Clone">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>A new instance whose internal values are equal to the current instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.FormatMap(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to format the current map into a valid string result.
            </summary>
            <param name="map">The map to be formatted.</param>
            <returns>The <see cref="T:System.String"/> representation of the argument <paramref name="map"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.ParseMap(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> instance into a valid <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <param name="str">The string value to be parsed.</param>
            <returns>The <see cref="T:Sudoku.Concepts.CellMap"/> as the result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.op_Equality(Sudoku.Concepts.CellMapFormatInfo,Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMapFormatInfo.op_Inequality(Sudoku.Concepts.CellMapFormatInfo,Sudoku.Concepts.CellMapFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.CsvGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports Comma-separated-values formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CsvGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.GridFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.Grid"/> instance, or parses into a <see cref="T:Sudoku.Concepts.Grid"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
            <seealso cref="T:System.Globalization.NumberFormatInfo"/>
        </member>
        <member name="F:Sudoku.Concepts.GridFormatInfo.ValuesRouter">
            <summary>
            Indicates the table of format and creator.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.WithCandidates">
            <summary>
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.WithModifiables">
            <summary>
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.ShortenSusser">
            <summary>
            <para>
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </para>
            <para>
            This option will omit the continuous empty cells to a <c>*</c> in a single line. For example, the code
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            will be displayed as
            <code><![CDATA[
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            ]]></code>
            via this option.
            We use the colon <c>,</c> to separate each line of 9 numbers, and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.NegateEliminationsTripletRule">
            <summary>
            <para>
            Indicates whether the parser will negate the rule, treating all digits as candidates existing in the grid
            instead of removed ones.
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.TreatValueAsGiven">
            <summary>
            Indicates whether the formatter will treat all values as givens, regardless of its value state.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.SubtleGridLines">
            <summary>
            Indicates whether the formatter will subtle grid lines to make a good-look.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.IsCompatibleMode">
            <summary>
            Indicates whether the formatter will use compatible mode to output grid values.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.Multiline">
            <summary>
            Indicates whether the formatter will handle the value with multiple-line mode.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.RemoveGridLines">
            <summary>
            Indicates whether the parsing operation will use simple way, removing all grid lines for multi-line formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.OnlyEliminations">
            <summary>
            Indicates whether the formatting operation will output for eliminations.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.Separator">
            <summary>
            Indicaets the separator used. By default it's comma <c>", "</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.InvariantInfo">
            <summary>
            Gets a read-only System.Globalization.NumberFormatInfo object that is culture-independent (invariant).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.GridFormatInfo.CurrentInfo">
            <summary>
            Gets a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> that formats values based on the current culture.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.Clone">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>A new instance whose internal values are equal to the current instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Try to format the current grid into a valid string result.
            </summary>
            <param name="grid">The grid to be formatted.</param>
            <returns>The <see cref="T:System.String"/> representation of the argument <paramref name="grid"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.ParseGrid(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> instance into a valid <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="str">The string value to be parsed.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Grid"/> as the result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetInstance(System.IFormatProvider)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.GridFormatInfo"/> associated with the specified <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> used to get the <see cref="T:Sudoku.Concepts.GridFormatInfo"/>.</param>
            <returns>The <see cref="T:Sudoku.Concepts.GridFormatInfo"/> associated with the specified <see cref="T:System.IFormatProvider"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetInstance(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> instance that holds the specified format.
            </summary>
            <param name="format">The format.</param>
            <returns>A valid <see cref="T:Sudoku.Concepts.GridFormatInfo"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.op_Equality(Sudoku.Concepts.GridFormatInfo,Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridFormatInfo.op_Inequality(Sudoku.Concepts.GridFormatInfo,Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.InlineSusserGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports inline Susser grid formatting.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.InlineSusserGridFormatInfo.PlusToken">
            <summary>
            Indicates the plus token that describes for modifiable values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.InlineSusserGridFormatInfo.EmptyString">
            <summary>
            Indicates the empty string.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.InlineSusserGridFormatInfo.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?[\\d\\.]|\\[[1-9]{1,9}\\])</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '+' atomically, optionally.<br/>
                        ○ Match a character in the set [.\d].<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '['.<br/>
                        ○ Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                        ○ Match ']'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.InlineSusserGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.MaskGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports mask formatting.
            </summary>
            <remarks>
            <para>This type is used by diagnostic only.</para>
            <para>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MaskGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.MultipleLineGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports multiple formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.MultipleLineGridFormatInfo.GridSusserDigitPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?\\d|\\.)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 2 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '+' atomically, optionally.<br/>
                        ○ Match a Unicode digit.<br/>
                    ○ Match '.'.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.MultipleLineGridFormatInfo.GridSimpleMultilinePattern">
            <remarks>
            Pattern:<br/>
            <code>([\\d\\.\\+]{9}(\\r|\\n|\\r\\n)){8}[\\d\\.\\+]{9}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a character in the set [+.\d] exactly 9 times.<br/>
                    ○ 2nd capture group.<br/>
                        ○ Match with 2 alternative expressions.<br/>
                            ○ Match a character in the set [\n\r].<br/>
                            ○ Match the string "\r\n".<br/>
            ○ Match a character in the set [+.\d] exactly 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.MultipleLineGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.OpenSudokuGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports OpenSudoku formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.OpenSudokuGridFormatInfo.GridOpenSudokuPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d(\\|\\d){242}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a Unicode digit.<br/>
            ○ Loop exactly 242 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match '|'.<br/>
                    ○ Match a Unicode digit.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.OpenSudokuGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.PencilmarkGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports pencilmark grid formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.PencilmarkGridFormatInfo.GridPencilmarkPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\&lt;\\d\\&gt;|\\*\\d\\*|\\d*[\\+\\-]?\\d+)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ 1st capture group.<br/>
                ○ Match with 3 alternative expressions, atomically.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '&lt;'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '&gt;'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match '*'.<br/>
                        ○ Match a Unicode digit.<br/>
                        ○ Match '*'.<br/>
                    ○ Match a sequence of expressions.<br/>
                        ○ Match a Unicode digit greedily any number of times.<br/>
                        ○ Match a character in the set [+-] atomically, optionally.<br/>
                        ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.PencilmarkGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.SukakuGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports Sukaku formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.SukakuGridFormatInfo.GridSukakuSegmentPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d*[\\-\\+]?\\d+</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a Unicode digit greedily any number of times.<br/>
            ○ Match a character in the set [+-] atomically, optionally.<br/>
            ○ Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SukakuGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.SusserGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.GridFormatInfo"/> type that supports Susser formatting.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.ModifiablePrefix">
            <summary>
            Indicates the modifiable prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.LineLimit">
            <summary>
            Indicates the line separator character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.Star">
            <summary>
            Indicates the star character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SusserGridFormatInfo.PreeliminationPrefix">
            <summary>
            Indicates the pre-elimination prefix character.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.SusserGridFormatInfo.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\+]{80,}(\\:(\\d{3}\\s+)*\\d{3})?</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [+.\d] greedily at least 80 times.<br/>
            ○ Optional (greedy).<br/>
                ○ 1st capture group.<br/>
                    ○ Match ':'.<br/>
                    ○ Loop greedily any number of times.<br/>
                        ○ 2nd capture group.<br/>
                            ○ Match a Unicode digit exactly 3 times.<br/>
                            ○ Match a whitespace character atomically at least once.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.SusserGridFormatInfo.GridShortenedSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\*]{1,9}(,[\\d\\.\\*]{1,9}){8}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            ○ Loop exactly 8 times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match ','.<br/>
                    ○ Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.SusserGridFormatInfo.EliminationPattern">
            <remarks>
            Pattern:<br/>
            <code>(?&lt;=\\:)(\\d{3}\\s+)*\\d{3}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Zero-width positive lookbehind.<br/>
                ○ Match ':' right-to-left.<br/>
            ○ Loop greedily any number of times.<br/>
                ○ 1st capture group.<br/>
                    ○ Match a Unicode digit exactly 3 times.<br/>
                    ○ Match a whitespace character atomically at least once.<br/>
            ○ Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.Equals(Sudoku.Concepts.GridFormatInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.FormatGrid(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.SusserGridFormatInfo.ParseGrid(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Grid">
            <summary>
            Represents a sudoku grid that uses the mask list to construct the data structure.
            </summary>
            <remarks>
            <para><large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure></para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Grid.DefaultMask">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.DefaultMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.MaxCandidatesMask">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.MaxCandidatesMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyMask">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.EmptyMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.ModifiableMask">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.ModifiableMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.GivenMask">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.GivenMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.HeaderShift">
            <summary>
            Indicates the shifting bits count for header bits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.SukakuHeader">
            <summary>
            Indicates ths header bits describing the sudoku type is a Sukaku.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyString">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.EmptyString"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Undefined">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Undefined"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid._values">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGrid`1.FirstMaskRef"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.#ctor(System.Int32@,Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the pointer of the first element of the cell digit, and the creating option.
            </summary>
            <param name="firstElement">The reference of the first element.</param>
            <param name="creatingOption">The creating option.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="firstElement"/> is <see langword="null"/> reference.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsUndefined">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsSolved">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsMissingCandidates">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivensCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiablesCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptiesCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyHouses">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CompletedHouses">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Symmetry">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.PuzzleType">
            <summary>
            Indicates the type of the puzzle.
            </summary>
            <remarks>
            Although the property type supports for other values, this property can only return a value
            either <see cref="F:Sudoku.SudokuType.Standard"/> or <see cref="F:Sudoku.SudokuType.Sukaku"/>.
            </remarks>
            <seealso cref="F:Sudoku.SudokuType.Standard"/>
            <seealso cref="F:Sudoku.SudokuType.Sukaku"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivenCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiableCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.BivalueCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.DigitsMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ValuesMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Candidates">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ConjugatePairs">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetCandidatesGrid">
            <summary>
            Gets the grid where all empty cells are filled with all possible candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.UnfixedGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.FixedGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGrid{Sudoku#Concepts#Grid}#FirstMaskRef">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#DefaultMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#MaxCandidatesMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#EmptyMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#ModifiableMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#GivenMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#EmptyString">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Concepts#Grid}#Undefined">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@,System.Boolean,System.Char)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridOperations{Sudoku#Concepts#Grid}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ConflictWith(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CompareTo(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle type is Sukaku.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToCandidateMaskArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetCandidates(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigit(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ResetCandidates">
            <summary>
            Reset the sudoku grid, but only making candidates to be reset to the initial state related to the current grid
            from given and modifiable values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Fix">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Unfix">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Apply(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetState(System.Int32,Sudoku.Concepts.CellState)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetMask(System.Int32,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ReplaceDigit(System.Int32,System.Int32)">
            <summary>
            Replace the specified cell with the specified digit.
            </summary>
            <param name="cell">The cell to be set.</param>
            <param name="digit">The digit to be set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="digit"/> is invalid (e.g. -1).</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetDigit(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetExistence(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#Grid,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#Grid,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Preserve(Sudoku.Concepts.CellMap@)">
            <summary>
            Gets a sudoku grid, removing all value digits not appearing in the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHeaderBits(System.Int32)">
            <summary>
            Gets the header 4 bits. The value can be <see cref="F:Sudoku.SudokuType.Sukaku"/> if and only if the puzzle is Sukaku,
            and the argument <paramref name="cell"/> is 0.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The header 4 bits, represented as a <see cref="T:System.Int16"/>, left-shifted.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHeaderBitsUnshifted(System.Int32)">
            <summary>
            Gets the header 4 bits. The value can be <see cref="F:Sudoku.SudokuType.Sukaku"/> if and only if the puzzle is Sukaku,
            and the argument <paramref name="cell"/> is 0.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The header 4 bits, represented as a <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.AddSukakuHeader">
            <summary>
            Appends for Sukaku puzzle header.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.RemoveSukakuHeader">
            <summary>
            Removes for Sukaku puzzle header.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int32[],Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using grid values.
            </summary>
            <param name="gridValues">The array of grid values.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int16[])">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance with the specified mask array.
            </summary>
            <param name="masks">The masks.</param>
            <exception cref="T:System.ArgumentException">Throws when <see cref="P:System.Array.Length"/> is out of valid range.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int32},Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the array of cell digits
            of type <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Int32"/>.
            </summary>
            <param name="gridValues">The list of cell digits.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridProperties{Sudoku#Concepts#Grid}#OnValueChanged(Sudoku.Concepts.Grid@,System.Int32,System.Int16,System.Int16,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGridProperties{Sudoku#Concepts#Grid}#OnRefreshingCandidates(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Sudoku#Concepts#Primitives#IGrid{Sudoku#Concepts#Grid}#Create(System.ReadOnlySpan{System.Int16})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int16})">
            <summary>
            Returns a <see cref="T:Sudoku.Concepts.Grid"/> instance via the raw mask values.
            </summary>
            <param name="values">
            <para>The raw mask values.</para>
            <para>
            This value can contain 1 or 81 elements.
            If the array contain 1 element, all elements in the target sudoku grid will be initialized by it, the uniform value;
            if the array contain 81 elements, elements will be initialized by the array one by one using the array elements respectively.
            </para>
            </param>
            <returns>A <see cref="T:Sudoku.Concepts.Grid"/> result.</returns>
            <remarks><b><i>
            This creation ignores header bits. Please don't use this method in the puzzle creation.
            </i></b></remarks>
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnValueChanged(Sudoku.Concepts.Grid@,System.Int32,System.Int16,System.Int16,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.Primitives.IGridProperties`1.OnValueChanged(`0@,System.Int32,System.Int16,System.Int16,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnRefreshingCandidates(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Primitives.IGridProperties`1.OnRefreshingCandidates(`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Explicit(System.Int16[])~Sudoku.Concepts.Grid">
            <summary>
            Converts the specified array elements into the target <see cref="T:Sudoku.Concepts.Grid"/> instance, without any value boundary checking.
            </summary>
            <param name="maskArray">An array of the target mask. The array must be of a valid length.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_CheckedExplicit(System.Int16[])~Sudoku.Concepts.Grid">
            <summary>
            Converts the specified array elements into the target <see cref="T:Sudoku.Concepts.Grid"/> instance, with value boundary checking.
            </summary>
            <param name="maskArray">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.op_Explicit(System.Int16[])~Sudoku.Concepts.Grid" path="/param[@name='maskArray']"/>
            </param>
            <exception cref="T:System.ArgumentException">
            Throws when at least one element in the mask array is greater than 0b100__111_111_111 (i.e. 2559) or less than 0.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Equality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Inequality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Equality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Inequality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_GreaterThan(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_LessThan(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_GreaterThanOrEqual(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_LessThanOrEqual(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_GreaterThan(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_LessThan(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Converter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Grid,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.GridComparison">
            <summary>
            Specifies the culture, case, and sort rules to be used by certain overloads of
            the <see cref="M:Sudoku.Concepts.Grid.CompareTo(Sudoku.Concepts.Grid@)"/> and <see cref="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)"/> methods.
            </summary>
            <seealso cref="M:Sudoku.Concepts.Grid.CompareTo(Sudoku.Concepts.Grid@)"/>
            <seealso cref="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="F:Sudoku.Concepts.GridComparison.Default">
            <summary>
            Indicates two <see cref="T:Sudoku.Concepts.Grid"/> instances only compares internal <see cref="T:System.Int16"/> values one by one.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridComparison.IncludingTransforms">
            <summary>
            Indicates two <see cref="T:Sudoku.Concepts.Grid"/> instances compares not only internal values, but its all possible transformations.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridCreatingOption">
            <summary>
            Indicates the grid creating option.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.None">
            <summary>
            Indicates the option is none.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.MinusOne">
            <summary>
            Indicates each value should minus one before creation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridPredicates">
            <summary>
            Represents a list of methods to filter the cells.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a given cell.
            </summary>
            <typeparam name="TGrid">The type of the grid.</typeparam>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.ModifiableCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a modifiable cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.EmptyCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is an empty cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.BivalueCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a bi-value cell, which means the cell is an empty cell,
            and contains and only contains 2 candidates.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.CandidatesMap``1(``0@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell.
            </summary>
            <typeparam name="TGrid">The type of the grid.</typeparam>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.DigitsMap``1(``0@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell, or whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.ValuesMap``1(``0@,System.Int32,System.Int32)">
            <summary>
            Checks whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.CandidatesMap``1(``0@,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Sudoku.Concepts.GridToken">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="P:Sudoku.Concepts.GridToken.Base32CharSpan">
            <inheritdoc/>
            <summary>
            The character span that indicates all possible characters appeared in a number with base 32.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridToken.GetToken(Sudoku.Concepts.Grid@)">
            <summary>
            Indicates the token of the grid at the initial state.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <returns>The token.</returns>
            <remarks>
            A raw string example is:
            <code><![CDATA[
            35i4ra00rlr4btf9a8s573tsk1ldni00ccfg094v02pk54ff1hc6e7
            ]]></code>
            We should cut them by 6 characters as a group:
            <code><![CDATA[
            35i4ra 00rlr4 btf9a8 s573ts k1ldni 00ccfg 094v02 pk54ff 1hc6e7
            ]]></code>
            9 groups in total.
            Then we should convert it into a valid 9-digit number by treating them as 32-based integers.
            Finally, combinate all groups, then we are done.
            The final text is
            <code><![CDATA[
            106500970000907108400008520945000380672839410000406000009600002860000751051780039
            ]]></code>
            </remarks>
            <exception cref="T:System.NotSupportedException">Throws when the puzzle type is Sukaku.</exception>
        </member>
        <member name="M:Sudoku.Concepts.GridToken.CreateFromToken(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.GridToken.CreateFromToken(System.String)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridToken.CreateFromToken(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using the specified token of length 54.
            </summary>
            <param name="token">Indicates the token.</param>
            <returns>A <see cref="T:Sudoku.Concepts.Grid"/> result.</returns>
            <exception cref="T:System.FormatException">Throws when the length of the argument mismatched.</exception>
        </member>
        <member name="M:Sudoku.Concepts.GridToken.GetDigitViaToken(System.String)">
            <summary>
            Get digit via token.
            </summary>
            <param name="s">The string.</param>
            <returns>The result digit.</returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseMarshal">
            <summary>
            Represents a list of extension methods that operates with house instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseMarshal.ToHouseType(System.Int32)">
            <summary>
            Get the house type for the specified house index.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>
            The house type. The possible return values are:
            <list type="table">
            <listheader>
            <term>House indices</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 0 and < 9]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Block"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 9 and < 18]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Row"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 18 and < 27]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Column"/></description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseType">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/House.html">house type</see>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Block">
            <summary>
            Indicates the house type is a block.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Row">
            <summary>
            Indicates the house type is a row.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Column">
            <summary>
            Indicates the house type is a column.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Inference">
            <summary>
            Defines an inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Strong">
            <summary>
            Indicates the inference is strong inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Weak">
            <summary>
            Indicates the inference is weak inference.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Miniline">
            <summary>
            Represents a miniline (mini-row or mini-column).
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="M:Sudoku.Concepts.Miniline.#ctor(Sudoku.Concepts.MinilineBase@,Sudoku.Concepts.MinilineResult@)">
            <summary>
            Represents a miniline (mini-row or mini-column).
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="P:Sudoku.Concepts.Miniline.Base">
            <summary>Indicates the base that describes the block and line index.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Miniline.Result">
            <summary>Indicates the result values.</summary>
        </member>
        <member name="F:Sudoku.Concepts.Miniline.MinilinesGroupedByChuteIndex">
            <summary>
            Indicates the mini-lines to be iterated, grouped by chute index.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Miniline.Map">
            <summary>
            <para>
            Indicates all maps that forms the each intersection. The pattern will be like:
            <code><![CDATA[
            .-------.-------.-------.
            | C C C | A A A | A A A |
            | B B B | . . . | . . . |
            | B B B | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            </para>
            <para>
            In addition, in this data pattern, a <b>CoverSet</b> is a block and a <b>BaseSet</b> is a line.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Miniline.IntersectionBlockTable">
            <summary>
            Indicates the internal intersection block combinations.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Miniline.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Concepts.MinilineBase">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="M:Sudoku.Concepts.MinilineBase.#ctor(System.Byte,System.Byte)">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="P:Sudoku.Concepts.MinilineBase.Line">
            <summary>The index of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineBase.Block">
            <summary>The index of the block.</summary>
        </member>
        <member name="T:Sudoku.Concepts.MinilineResult">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used,
            especially used by <see cref="F:Sudoku.Concepts.Miniline.Map"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Miniline.Map"/>
        </member>
        <member name="M:Sudoku.Concepts.MinilineResult.#ctor(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,System.Byte[])">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used,
            especially used by <see cref="F:Sudoku.Concepts.Miniline.Map"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Miniline.Map"/>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.LineMap">
            <summary>The map of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.BlockMap">
            <summary>The map of the block.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.IntersectionMap">
            <summary>The map of the intersection.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.OtherBlocks">
            <summary>
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3">
            <summary>
            Extracts a base type that describes state table from elements of <typeparamref name="TSelf"/> type.
            </summary>
            <typeparam name="TSelf">The type of the instance that implements this interface type.</typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
        </member>
        <member name="F:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.MaxLimit">
            <summary>
            Indicates the size of combinatorial calculation.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.StringChunks">
            <summary>
            Gets all chunks of the current collection, meaning a list of <see cref="T:System.String"/> values that can describe
            all offset values (cell indices and candidate indices), grouped with same row/column.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.PeerIntersection">
            <summary>
            Indicates the peer intersection of the current instance.
            </summary>
            <remarks>
            A <b>Peer Intersection</b> is a set of offsets that all offsets from the base collection can be seen.
            For more information please visit <see href="http://sudopedia.enjoysudoku.com/Peer.html">this link</see>.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Offsets">
            <summary>
            Indicates the offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Shifting">
            <summary>
            Indicates the size of each unit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Empty">
            <summary>
            Indicates an empty instance containing no elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Full">
            <summary>
            Indicates an instance that contains all possible elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.MaxCount">
            <summary>
            Indicates the maximum number of elements that the collection can be reached.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IAdditiveIdentity{TSelf,TSelf}#AdditiveIdentity">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IMinMaxValue{TSelf}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IMinMaxValue{TSelf}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.AddRange(System.ReadOnlySpan{`1})">
            <summary>
            Adds a list of offsets into the current collection.
            </summary>
            <param name="offsets">
            <para>Offsets to be added.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>The number of offsets succeeded to be added.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.RemoveRange(System.ReadOnlySpan{`1})">
            <summary>
            Removes a list of offsets from the current collection.
            </summary>
            <param name="offsets">
            <para>Offsets to be removed.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>The number of offsets succeeded to be removed.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.CopyTo(`1@,System.Int32)">
            <summary>
            Copies the current instance to the target sequence specified as a reference
            to an element of type <typeparamref name="TElement"/>.
            </summary>
            <param name="sequence">
            The reference that points to the first element in a sequence of type <typeparamref name="TElement"/>.
            </param>
            <param name="length">The length of that array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="sequence"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Throws when the capacity isn't enough to store all values.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.ForEach(System.Action{`1})">
            <summary>
            Iterates on each element in this collection.
            </summary>
            <param name="action">The visitor that handles for each element in this collection.</param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Toggle(`1)">
            <summary>
            Try to toggle the offset, which means the value will be added if not exist in collection, or removed if exists.
            </summary>
            <param name="offset">The offset to be added or removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.IndexOf(`1)">
            <summary>
            Try to get the specified index of the offset.
            </summary>
            <param name="offset">The desired offset.</param>
            <returns>The index of the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.CompareTo(`0@)">
            <summary>
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/summary"/>
            </summary>
            <param name="other"><inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/param[@name='other']"/></param>
            <returns>
            <para>The result value only contains 3 possible values: 1, 0 and -1.</para>
            <para>
            The comparison rule is:
            <list type="number">
            <item>
            If <see langword="this"/> holds more offsets than <paramref name="other"/>, then return 1
            indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <see langword="this"/> holds less offsets than <paramref name="other"/>, then return -1
            indicating <paramref name="other"/> is greater.
            </item>
            <item>
            If they two hold same offsets, then checks for indices held:
            <list type="bullet">
            <item>
            If <see langword="this"/> holds a cell whose index is greater than all offsets appeared in <paramref name="other"/>,
            then return 1 indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <paramref name="other"/> holds a cell whose index is greater than all offsets
            appeared in <paramref name="other"/>, then return -1 indicating <paramref name="other"/> is greater.
            </item>
            </list>
            </item>
            </list>
            If all rules are compared, but they are still considered equal, then return 0.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Equals(`0@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.ToArray">
            <summary>
            Get all offsets whose bits are set <see langword="true"/>.
            </summary>
            <returns>An array of offsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Slice(System.Int32,System.Int32)">
            <summary>
            Slices the current instance, and get the new instance with some of elements between two indices.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The number of elements.</param>
            <returns>The target instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#CopyTo(`1[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#IEquatable{TSelf}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#ExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IntersectWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#UnionWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Linq#Providers#IContainsMethod{TSelf,TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Linq#Providers#ICountMethod{TSelf,TElement}#Count">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#IComparable{TSelf}#CompareTo(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAt(System.Index)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAtOrDefault(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAtOrDefault(System.Index)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Linq#Providers#IGetSubsetMethod{TSelf,TElement}#GetSubsets(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_LogicalNot(`0@)">
            <summary>
            Determines whether the current collection is empty.
            </summary>
            <param name="offsets">The offsets to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <remarks>
            The type of the current collection supports using <see cref="T:System.Boolean"/>-like expression to determine whether the collection is not empty,
            for example:
            <code><![CDATA[
            if (collection)
                // ...
            ]]></code>
            The statement <c>collection</c> will be expanded to <c>collection.Count != 0</c>. Therefore, the negation operator <c>!</c>
            will invert the result of above expression. This is why I use <see langword="operator"/> <c>!</c> to determine on this.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_OnesComplement(`0@)">
            <summary>
            Reverse state for all offsets, which means all <see langword="true"/> bits
            will be set <see langword="false"/>, and all <see langword="false"/> bits
            will be set <see langword="true"/>.
            </summary>
            <param name="offsets">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_True(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is not empty.
            </summary>
            <param name="map">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_False(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is empty.
            </summary>
            <param name="map">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_Equality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_Inequality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_Addition(`0@,`1)">
            <summary>
            Adds the specified <paramref name="offset"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be added.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_Subtraction(`0@,`1)">
            <summary>
            Removes the specified <paramref name="offset"/> from the <paramref name="collection"/>,
            and returns the removed result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_BitwiseAnd(`0@,`0@)">
            <summary>
            Get the elements that both <paramref name="left"/> and <paramref name="right"/> contain.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_BitwiseOr(`0@,`0@)">
            <summary>
            Combine the elements from <paramref name="left"/> and <paramref name="right"/>,
            and return the merged result.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_ExclusiveOr(`0@,`0@)">
            <summary>
            Get the elements that either <paramref name="left"/> or <paramref name="right"/> contains.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_BitwiseAnd(`0@,System.Int32)">
            <summary>
            Gets the subsets of the current collection via the specified size indicating the number of elements of the each subset.
            </summary>
            <param name="map">The instance to check for subsets.</param>
            <param name="subsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="subsetSize"/> &gt; Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term><c><paramref name="subsetSize"/> == Count</c></term>
            <description>
            Will return an array that contains only one element, same as the current instance.
            </description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.NotSupportedException">
            Throws when both the count of the current instance and <paramref name="subsetSize"/> are greater than 30.
            </exception>
            <remarks>
            For example, if the current instance is <c>r1c1</c>, <c>r1c2</c> and <c>r1c3</c>
            and the argument <paramref name="subsetSize"/> is 2,
            the method will return an array of 3 elements given below: <c>r1c12</c>, <c>r1c13</c> and <c>r1c23</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_BitwiseOr(`0@,System.Int32)">
            <summary>
            Gets all subsets of the current collection via the specified size
            indicating the <b>maximum</b> number of elements of the each subset.
            </summary>
            <param name="map">The instance to check subsets.</param>
            <param name="subsetSize">The desired size.</param>
            <returns>
            All possible subsets. If <paramref name="subsetSize"/> is greater than <see cref="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Count"/>,
            this method will return all possible subsets without throwing exceptions.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.op_BitwiseOr(`0@,System.Range)">
            <summary>
            Gets all subsets of the current collection via the specified range of the subset size.
            </summary>
            <param name="map">The instance to check subsets.</param>
            <param name="subsetSizeRange">The desired size.</param>
            <returns>All possible subsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#ILogicalOperators{TSelf}#op_True(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#ILogicalOperators{TSelf}#op_False(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#ILogicalOperators{TSelf}#op_LogicalNot(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Equality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Inequality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IAdditionOperators{TSelf,TElement,TSelf}#op_Addition(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#ISubtractionOperators{TSelf,TElement,TSelf}#op_Subtraction(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IModulusOperators{TSelf,TSelf,TSelf}#op_Modulus(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_OnesComplement(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_ExclusiveOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#ILogicalOperators{TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#ILogicalOperators{TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.System#ILogicalOperators{TSelf}#op_ExclusiveOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Primitives.IGrid`1">
            <summary>
            Represents a sudoku grid.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGrid`1.IsMissingCandidates">
            <summary>
            Determines whether the current grid contains any missing candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGrid`1.FirstMaskRef">
            <summary>
            Indicates the inner array that stores the masks of the sudoku grid, which stores the in-time sudoku grid inner information.
            </summary>
            <remarks>
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 16  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0 |
            |-------------------|-----------|-----------------------------------|
            |    unused bits    | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
            '-------------------|-----------|-----------------------------------'
                                 \_________/ \_________________________________/
                                     (2)                     (1)
            </code>
            Here the 9 bits in (1) indicate whether each digit is possible candidate in the current cell for each bit respectively,
            and the higher 3 bits in (2) indicate the cell state. The possible cell state are:
            <list type="table">
            <listheader>
            <term>State name</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Empty cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Empty"/>)</term>
            <description>The cell is currently empty, and wait for being filled.</description>
            </item>
            <item>
            <term>Modifiable cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Modifiable"/>)</term>
            <description>The cell is filled by a digit, but the digit isn't the given by the initial grid.</description>
            </item>
            <item>
            <term>Given cell (i.e. <see cref="F:Sudoku.Concepts.CellState.Given"/>)</term>
            <description>The cell is filled by a digit, which is given by the initial grid and can't be modified.</description>
            </item>
            </list>
            </remarks>
            <seealso cref="T:Sudoku.Concepts.CellState"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IMinMaxValue{TSelf}#MinValue">
            <summary>
            Indicates the minimum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IMinMaxValue{TSelf}#MaxValue">
            <summary>
            Indicates the maximum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.Equals(`0@)">
            <summary>
            Determines whether the current instance has same mask values with the other object.
            </summary>
            <param name="other">The other instance.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.ConflictWith(System.Int32,System.Int32)">
            <summary>
            Determine whether the digit in the target cell is conflict with a certain cell in the peers of the current cell,
            if the digit is filled into the cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.CompareTo(`0@)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.ToString(System.String)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.ToCandidateMaskArray">
            <summary>
            Serializes this instance to an array, where all digit value will be stored.
            </summary>
            <returns>
            This array. All elements are the raw masks
            that are between 0 and <see cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.MaxCandidatesMask"/> (i.e. 511).
            </returns>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.MaxCandidatesMask"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.ToArray">
            <inheritdoc cref="M:System.Linq.Providers.IToArrayMethod`2.ToArray"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#IEquatable{TSelf}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#IComparable{TSelf}#CompareTo(`0)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGrid`1.System#Collections#Generic#IReadOnlyCollection{System#Int32}#Count">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Linq#Providers#IToArrayMethod{TSelf,System#Int32}#ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.TryParse(System.String,System.IFormatProvider,`0@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)">
            <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.TryParse(System.String,`0@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.TryParse(System.ReadOnlySpan{System.Char},`0@)">
            <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.Create(System.ReadOnlySpan{System.Int16})">
            <summary>
            Creates a <typeparamref name="TSelf"/> instance via the specified list of <see cref="T:System.Int16"/> values.
            </summary>
            <param name="values">The values to be created.</param>
            <returns>A <typeparamref name="TSelf"/> instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_Equality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_Inequality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_GreaterThan(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_GreaterThanOrEqual(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_LessThan(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_LessThanOrEqual(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Equality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Inequality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_GreaterThan(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_LessThan(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_GreaterThanOrEqual(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_LessThanOrEqual(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_Explicit(System.Int16[])~`0">
            <summary>
            Converts the specified array elements into the target <typeparamref name="TSelf"/> instance,
            without any value boundary checking.
            </summary>
            <param name="maskArray">An array of the target mask. The array must be of a valid length.</param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGrid`1.op_CheckedExplicit(System.Int16[])~`0">
            <summary>
            Converts the specified array elements into the target <typeparamref name="TSelf"/> instance, with value boundary checking.
            </summary>
            <param name="maskArray">
            <inheritdoc cref="M:Sudoku.Concepts.Primitives.IGrid`1.op_Explicit(System.Int16[])~`0" path="/param[@name='maskArray']"/>
            </param>
            <exception cref="T:System.ArgumentException">
            Throws when at least one element in the mask array is greater than 0b100__111_111_111 (i.e. 2559) or less than 0.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Primitives.IGridConstants`1">
            <summary>
            Represents constant values for type.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="F:Sudoku.Concepts.Primitives.IGridConstants`1.CellsCount">
            <summary>
            Indicates the number of cells of a sudoku grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Primitives.IGridConstants`1.CellCandidatesCount">
            <summary>
            Indicates the number of digits can be appeared inside a cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.IsEmpty">
            <summary>
            Indicates whether the grid is <see cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Empty"/>, which means the grid holds totally same value with <see cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Empty"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.IsUndefined">
            <summary>
            Indicates whether the grid is <see cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Undefined"/>, which means the grid holds totally same value with <see cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Undefined"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.EmptyString">
            <summary>
            Represents a string value that describes a <typeparamref name="TSelf"/> instance can be parsed into <see cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Empty"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.DefaultMask">
            <summary>
            Indicates the default mask of a cell (an empty cell, with all 9 candidates left).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.EmptyMask">
            <summary>
            Indicates the empty mask, modifiable mask and given mask.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.ModifiableMask">
            <summary>
            Indicates the modifiable mask.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.GivenMask">
            <summary>
            Indicates the given mask.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.MaxCandidatesMask">
            <summary>
            Indicates the maximum candidate mask that used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.Empty">
            <summary>
            The empty grid that is valid during implementation or running the program
            (all values are <see cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.DefaultMask"/>, i.e. empty cells).
            </summary>
            <remarks>
            This field is initialized by the static constructor of this structure.
            </remarks>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.DefaultMask"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridConstants`1.Undefined">
            <summary>
            Indicates the default grid that all values are initialized 0.
            This value is equivalent to <see langword="default"/>(<typeparamref name="TSelf"/>).
            </summary>
            <remarks>
            This value can be used for non-candidate-based sudoku operations, e.g. a sudoku grid canvas.
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.Primitives.IGridOperations`1">
            <summary>
            Represents a type that supports operations used by a sudoku grid.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridOperations`1.Item(System.Int32)">
            <summary>
            Gets the mask at the specified position.
            </summary>
            <param name="cell">The desired cell index.</param>
            <returns>The reference to the mask.</returns>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridOperations`1.Item(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridOperations`1.Item(Sudoku.Concepts.CellMap@,System.Boolean,System.Char)">
            <summary>
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridOperations`1.Item(Sudoku.Concepts.CellMap@)" path="/summary"/>
            </summary>
            <param name="cells"><inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridOperations`1.Item(Sudoku.Concepts.CellMap@)" path="/param[@name='cells']"/></param>
            <param name="withValueCells">
            Indicates whether the value cells (given or modifiable ones) will be included to be gathered.
            If <see langword="true"/>, all value cells (no matter what kind of cell) will be summed up.
            </param>
            <param name="mergingMethod">
            Indicates the merging method. Values are <c>'<![CDATA[&]]>'</c>, <c>'<![CDATA[|]]>'</c> and <c>'<![CDATA[~]]>'</c>.
            <list type="bullet">
            <item><c>'<![CDATA[&]]>'</c>: Use <b>bitwise and</b> operator to merge masks.</item>
            <item><c>'<![CDATA[|]]>'</c>: Use <b>bitwise or</b> operator to merge masks.</item>
            <item><c>'<![CDATA[~]]>'</c>: Use <b>bitwise nand</b> operator to merge masks.</item>
            </list>
            By default, the value is <c>'<![CDATA[|]]>'</c>.
            </param>
            <returns><inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridOperations`1.Item(Sudoku.Concepts.CellMap@)" path="/returns"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when <paramref name="mergingMethod"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.Reset">
            <summary>
            Reset the sudoku grid, making all modifiable values to empty ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.Fix">
            <summary>
            To fix the current grid (all modifiable values will be changed to given ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.Unfix">
            <summary>
            To unfix the current grid (all given values will be changed to modifiable ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.Apply(Sudoku.Concepts.Conclusion)">
            <summary>
            Try to apply the specified conclusion.
            </summary>
            <param name="conclusion">The conclusion to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.SetState(System.Int32,Sudoku.Concepts.CellState)">
            <summary>
            Set the specified cell to the specified state.
            </summary>
            <param name="cell">The cell.</param>
            <param name="state">The state.</param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.SetMask(System.Int32,System.Int16)">
            <summary>
            Set the specified cell to the specified mask.
            </summary>
            <param name="cell">The cell.</param>
            <param name="mask">The mask to set.</param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.SetDigit(System.Int32,System.Int32)">
            <summary>
            Set the specified digit into the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">
            <para>
            The value you want to set. The value should be between 0 and 8.
            If assigning -1, the grid will execute an implicit behavior that candidates in <b>all</b> empty cells will be re-computed.
            </para>
            <para>
            The values set into the grid will be regarded as the modifiable values.
            If the cell contains a digit, it will be covered when it is a modifiable value.
            If the cell is a given cell, the setter will do nothing.
            </para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.SetExistence(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the target candidate state.
            </summary>
            <param name="cell">The cell offset between 0 and 80.</param>
            <param name="digit">The digit between 0 and 8.</param>
            <param name="isOn">
            The case you want to set. <see langword="false"/> means that this candidate
            doesn't exist in this current sudoku grid; otherwise, <see langword="true"/>.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.GetExistence(System.Int32,System.Int32)">
            <summary>
            Sets a candidate existence case with a <see cref="T:System.Boolean"/> value.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <inheritdoc cref="M:Sudoku.Concepts.Primitives.IGridOperations`1.SetExistence(System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.Exists(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.Primitives.IGridOperations`1.Exists(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.Exists(System.Int32,System.Int32)">
            <summary>
            Indicates whether the current grid contains the digit in the specified cell.
            </summary>
            <param name="cell">The cell to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>
            The method will return a <see cref="T:System.Boolean"/>? value
            (containing three possible cases: <see langword="true"/>, <see langword="false"/> and <see langword="null"/>).
            All values corresponding to the cases are below:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Case description on this value</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>
            The cell is an empty cell <b>and</b> contains the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            The cell is an empty cell <b>but doesn't</b> contain the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The cell is <b>not</b> an empty cell.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Note that the method will return a <see cref="T:System.Boolean"/>?, so you should use the code
            '<c>grid.Exists(cell, digit) is true</c>' or '<c>grid.Exists(cell, digit) == true</c>'
            to decide whether a condition is true.
            </para>
            <para>
            In addition, because the type is <see cref="T:System.Boolean"/>? rather than <see cref="T:System.Boolean"/>,
            the result case will be more precisely than the indexer <see cref="M:Sudoku.Concepts.Primitives.IGridOperations`1.GetExistence(System.Int32,System.Int32)"/>,
            which is the main difference between this method and that indexer.
            </para>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Primitives.IGridOperations`1.GetExistence(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.GetState(System.Int32)">
            <summary>
            Get the cell state at the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The cell state.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.GetCandidates(System.Int32)">
            <summary>
            Get the candidate mask part of the specified cell.
            </summary>
            <param name="cell">The cell offset you want to get.</param>
            <returns>
            <para>
            The candidate mask. The return value is a 9-bit <see cref="T:System.Int16"/> value, where each bit will be:
            <list type="table">
            <item>
            <term><c>0</c></term>
            <description>The cell <b>doesn't contain</b> the possibility of the digit.</description>
            </item>
            <item>
            <term><c>1</c></term>
            <description>The cell <b>contains</b> the possibility of the digit.</description>
            </item>
            </list>
            </para>
            <para>
            For example, if the result mask is 266 (i.e. <c>0b<b>1</b>00_00<b>1</b>_0<b>1</b>0</c> in binary),
            the value will indicate the cell contains the digit 2, 4 and 9.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridOperations`1.GetDigit(System.Int32)">
            <summary>
            Try to get the digit filled in the specified cell.
            </summary>
            <param name="cell">The cell used.</param>
            <returns>The digit that the current cell filled. If the cell is empty, return -1.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified cell keeps a wrong cell state value. For example, <see cref="F:Sudoku.Concepts.CellState.Undefined"/>.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Primitives.IGridProperties`1">
            <summary>
            Represents a type that contains properties inside a grid.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.Symmetry">
            <summary>
            Try to get the symmetry of the puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.GivensCount">
            <summary>
            Indicates the total number of given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.ModifiablesCount">
            <summary>
            Indicates the total number of modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.EmptiesCount">
            <summary>
            Indicates the total number of empty cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.GivenCells">
            <summary>
            Gets a cell list that only contains the given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.ModifiableCells">
            <summary>
            Gets a cell list that only contains the modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.EmptyCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid is empty.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesCount">
            <summary>
            Indicates the number of total candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.BivalueCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid contain two candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesMap">
            <summary>
            Indicates the map of possible positions of the existence of the candidate value for each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.DigitsMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of each digit. The return value will
            be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesMap"/>, this property contains all givens, modifiables and
            empty cells only if it contains the digit in the mask.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.ValuesMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of that value of each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesMap"/>, the value only contains the given or modifiable
            cells whose mask contain the set bit of that digit.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.Candidates">
            <summary>
            Indicates all possible candidates in the current grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.ConjugatePairs">
            <summary>
            Indicates all possible conjugate pairs appeared in this grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.EmptyHouses">
            <summary>
            <para>Indicates which houses are empty houses.</para>
            <para>An <b>Empty House</b> is a house holding 9 empty cells, i.e. all cells in this house are empty.</para>
            <para>
            The property returns a <see cref="T:System.Int32"/> value as a mask that contains all possible house indices.
            For example, if the row 5, column 5 and block 5 (1-9) are null houses, the property will return
            the result <see cref="T:System.Int32"/> value, <c>000010000_000010000_000010000</c> as binary.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.CompletedHouses">
            <summary>
            <para>Indicates which houses are completed, regardless of ways of filling.</para>
            <para><inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.EmptyHouses" path="//summary/para[3]"/></para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.ResetGrid">
            <summary>
            Gets the grid where all modifiable cells are empty cells (i.e. the initial one).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.UnfixedGrid">
            <summary>
            Indicates the unfixed grid for the current grid, meaning all given digits will be replaced with modifiable ones.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridProperties`1.FixedGrid">
            <summary>
            Indicates the fixed grid for the current grid, meaning all modifiable digits will be replaced with given ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridProperties`1.OnValueChanged(`0@,System.Int32,System.Int16,System.Int16,System.Int32)">
            <summary>
            Event handler on value changed.
            </summary>
            <param name="this">The grid itself.</param>
            <param name="cell">Indicates the cell changed.</param>
            <param name="oldMask">Indicates the original mask representing the original digits in that cell.</param>
            <param name="newMask">Indicates the mask representing the digits updated.</param>
            <param name="setValue">
            Indicates the set value. If to clear the cell, the value will be -1.
            In fact, if the value is -1, this method will do nothing.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridProperties`1.OnRefreshingCandidates(`0@)">
            <summary>
            Event handler on refreshing candidates.
            </summary>
            <param name="this">The grid itself.</param>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridProperties`1.GetMap(`0@,)">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.EmptyCells"/> and <see cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.BivalueCells"/>.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">The predicate.</param>
            <returns>The map.</returns>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.EmptyCells"/>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.BivalueCells"/>
        </member>
        <member name="M:Sudoku.Concepts.Primitives.IGridProperties`1.GetMaps(`0@,)">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesMap"/>, <see cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.DigitsMap"/> and <see cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.ValuesMap"/>.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">The predicate.</param>
            <returns>The map indexed by each digit.</returns>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.CandidatesMap"/>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.DigitsMap"/>
            <seealso cref="P:Sudoku.Concepts.Primitives.IGridProperties`1.ValuesMap"/>
        </member>
        <member name="T:Sudoku.Concepts.Primitives.IGridSolvingMembers`1">
            <summary>
            Represents a grid that contains solving members.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.Primitives.IGridSolvingMembers`1.IsSolved">
            <summary>
            Indicates the grid has already solved. If the value is <see langword="true"/>, the grid is solved;
            otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.CoordinateTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetConverter(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance via the specified <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <returns>
            A valid <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetParser(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance via the specified <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <returns>
            A valid <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CoordinateTypeExtensions.GetField(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:System.Reflection.FieldInfo"/> instance for the specified field.
            </summary>
            <param name="this">The type of the coordinate type.</param>
            <returns>The final <see cref="T:System.Reflection.FieldInfo"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.GridMinimalExtensions">
            <summary>
            Represents extension methods on <see cref="T:Sudoku.Concepts.Grid"/> for minimal.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.GridMinimalExtensions.GetIsMinimal(Sudoku.Concepts.Grid@)">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridMinimalExtensions.CheckMinimal(Sudoku.Concepts.Grid@,System.Int32@)">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="firstCandidateMakePuzzleNotMinimal">
            <para>
            Indicates the first found candidate that can make the puzzle not minimal, which means
            if we remove the digit in the cell, the puzzle will still keep unique.
            </para>
            <para>If the return value is <see langword="true"/>, this argument will be -1.</para>
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle is invalid (i.e. not unique).</exception>
        </member>
        <member name="T:Sudoku.Concepts.GridMinLexExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/> for minlex.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.GridMinLexExtensions.Equals(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@,Sudoku.Concepts.GridComparison)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Grid"/> instance hold the same values as the current instance,
            by using the specified comparison type.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="other">The instance to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="comparisonType"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.GridMinLexExtensions.GetHashCode(Sudoku.Concepts.Grid@,Sudoku.Concepts.GridComparison)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.GetHashCode"/>
            <param name="this">Indicates the current instance.</param>
            <param name="comparisonType">
            Indicates the comparison type that specifies the target grid to be calculated its hash code.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="comparisonType"/> isn't defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.GridMinLexExtensions.CompareTo(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@,Sudoku.Concepts.GridComparison)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer
            that indicates whether the current instance precedes, follows or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="other">The other object to be compared.</param>
            <param name="comparisonType">The comparison type to be used.</param>
            <returns>A value that indicates the relative order of the objects being compared.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when one of the grids to be compared is a Sukaku puzzle.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="comparisonType"/> is not defined.</exception>
        </member>
        <member name="T:Sudoku.Concepts.GridSolvingExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/> for solving.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Concepts.GridSolvingExtensions.PuzzleSolvingSynchronizer">
            <summary>
            The internal field that can be used for making threads run in order while using <see cref="F:Sudoku.Concepts.GridSolvingExtensions.Solver"/>,
            keeping the type being thread-safe.
            </summary>
            <seealso cref="F:Sudoku.Concepts.GridSolvingExtensions.Solver"/>
        </member>
        <member name="F:Sudoku.Concepts.GridSolvingExtensions.Solver">
            <summary>
            Indicates the backing solver.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridSolvingExtensions.GetIsValid(Sudoku.Concepts.Grid@)">
            <summary>
            Indicates whether the puzzle is valid (solved or a normal puzzle with a unique solution).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridSolvingExtensions.GetUniqueness(Sudoku.Concepts.Grid@)">
            <summary>
            Checks the uniqueness of the current sudoku puzzle.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle has already been solved.</exception>
        </member>
        <member name="M:Sudoku.Concepts.GridSolvingExtensions.GetSolutionGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Indicates the solution of the current grid. If the puzzle has no solution or multiple solutions,
            this property will return <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="T:Sudoku.Concepts.GridTransformingExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.GridTransformingExtensions.Transform(Sudoku.Concepts.Grid@,Sudoku.Algorithms.Transformation.TransformType)">
            <summary>
            Transforms the grid by the specified type.
            </summary>
            <param name="grid">The grid to be transformed.</param>
            <param name="transformTypes">
            The transform types can be applied. You can use <c><see cref="T:Sudoku.Algorithms.Transformation.TransformType"/>.<see langword="operator"/> |</c> to combine flags.
            </param>
        </member>
        <member name="T:Sudoku.Concepts.HouseTypeExtensions">
            <summary>
            Provides extension methods on <see cref="T:Sudoku.Concepts.HouseType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.HouseType"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetLabel(Sudoku.Concepts.HouseType)">
            <summary>
            Try to get the label of the specified house type.
            </summary>
            <param name="this">The house type.</param>
            <returns>A character that represents a house type.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetProgramOrder(Sudoku.Concepts.HouseType)">
            <summary>
            Gets the ordering of the house type. The result value will be 0, 1 and 2.
            </summary>
            <param name="this">The house type.</param>
            <returns>The program order.</returns>
        </member>
        <member name="T:Sudoku.Concepts.InferenceExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Inference"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Inference"/>
        </member>
        <member name="M:Sudoku.Concepts.InferenceExtensions.ConnectingNotation(Sudoku.Concepts.Inference)">
            <summary>
            Gets connecting notation of the inference, with two spaces sandwiching the characters.
            </summary>
            <param name="this">The inference instance.</param>
            <returns>The connecting notation of the inference.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in the enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.SymmetricTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.SymmetricType"/>.
            </summary>
            <seealso cref="T:Sudoku.SymmetricType"/>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetSymmetryCellsCount(Sudoku.SymmetricType)">
            <summary>
            Try to get the number of cells that the current symmetry should be formed a complete symmetric pattern.
            </summary>
            <param name="this">The symmetric type.</param>
            <returns>
            The number of cells should form a complete pattern:
            <list type="table">
            <listheader>
            <term>Argument</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><see cref="F:Sudoku.SymmetricType.None"/> (0)</term>
            <description>1 (Itself)</description>
            </item>
            <item>
            <term>
            <see cref="F:Sudoku.SymmetricType.Central"/>,
            <see cref="F:Sudoku.SymmetricType.Diagonal"/>, <see cref="F:Sudoku.SymmetricType.AntiDiagonal"/>,
            <see cref="F:Sudoku.SymmetricType.XAxis"/>, <see cref="F:Sudoku.SymmetricType.YAxis"/>
            </term>
            <description>2</description>
            </item>
            <item>
            <term>The other defined values</term>
            <description>4</description>
            </item>
            <item>
            <term>Otherwise</term>
            <description><see cref="T:System.ArgumentOutOfRangeException"/> thrown</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetAxisDimension(Sudoku.SymmetricType)">
            <summary>
            Try to get the number of axes of the specified symmetric type.
            </summary>
            <param name="this">The symmetry.</param>
            <returns>
            The number of axes the current symmetric type contains.
            If <paramref name="this"/> is <see cref="F:Sudoku.SymmetricType.None"/>, -1 will be returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="this"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetName(Sudoku.SymmetricType,System.IFormatProvider)">
            <summary>
            Gets the name of thr symmetry.
            </summary>
            <param name="this">The symmetry value.</param>
            <param name="formatProvider">The culture.</param>
            <returns>The string.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the argument holds multiple flag values.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCellsInSymmetryAxis(Sudoku.SymmetricType)">
            <summary>
            Try to get all possible cells in symmetry axis (or point).
            </summary>
            <param name="this">The symmetry.</param>
            <returns>Returns cells in the symmetry axis (or point).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined or <see cref="F:Sudoku.SymmetricType.None"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)"/>
            <param name="this"><inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)"/></param>
            <param name="cell">Indicates the target cell to be checked.</param>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)">
            <summary>
            Get the cells that is used for swapping via the specified symmetric type, and the specified row and column value.
            </summary>
            <param name="this">The symmetric type.</param>
            <param name="row">The row value.</param>
            <param name="column">The column value.</param>
            <returns>The cells.</returns>
        </member>
        <member name="T:Sudoku.Drawing.ColorColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="alpha">Indicates the color alpha raw values to be assigned.</param>
            <param name="red">Indicates the color red raw values to be assigned.</param>
            <param name="green">Indicates the color green raw values to be assigned.</param>
            <param name="blue">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="alpha">Indicates the color alpha raw values to be assigned.</param>
            <param name="red">Indicates the color red raw values to be assigned.</param>
            <param name="green">Indicates the color green raw values to be assigned.</param>
            <param name="blue">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.ColorIdentifier">
            <summary>
            Represents an identifier that is used for describing target rendering item.
            </summary>
            <completionlist cref="T:Sudoku.Drawing.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Normal">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Normal"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Auxiliary1">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary1"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Auxiliary2">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary2"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Auxiliary3">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary3"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Assignment">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Assignment"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.OverlappedAssignment">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.OverlappedAssignment"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Elimination">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Elimination"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Cannibalism">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Cannibalism"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Exofin">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Exofin"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Endofin">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Endofin"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Link">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Link"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet1">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet1"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet2">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet2"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet3">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet3"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet4">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet4"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet5">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet5"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Implicit(System.Int32)~Sudoku.Drawing.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/> to <see cref="T:Sudoku.Drawing.ColorIdentifier"/>.
            </summary>
            <param name="paletteId">The <see cref="T:System.Int32"/> instance indicating the palette ID.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Implicit(Sudoku.Drawing.WellKnownColorIdentifierKind)~Sudoku.Drawing.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:Sudoku.Drawing.WellKnownColorIdentifierKind"/> to <see cref="T:Sudoku.Drawing.ColorIdentifier"/>.
            </summary>
            <param name="kind">The <see cref="T:Sudoku.Drawing.WellKnownColorIdentifierKind"/> instance.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Equality(Sudoku.Drawing.ColorIdentifier,Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Inequality(Sudoku.Drawing.ColorIdentifier,Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Drawing.IDrawable">
            <summary>
            Represents a drawable instance that can be used for drawing, providing with base data structure to be used by drawing APIs.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.IDrawable.Conclusions">
            <summary>
            Indicates the conclusions that the step can be eliminated or assigned to.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.IDrawable.Views">
            <summary>
            Indicates the views of the step that may be displayed onto the screen using pictures.
            </summary>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.BabaGroupViewNode">
            <summary>
            Defines a view node that highlights for a Baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32,System.Char,System.Int16)">
            <summary>
            Defines a view node that highlights for a Baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.#ctor(System.Int32,System.Char,System.Int16)">
            <summary>
            Initializes a <see cref="T:Sudoku.Drawing.Nodes.BabaGroupViewNode"/> instance via the specified values.
            </summary>
            <inheritdoc cref="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32,System.Char,System.Int16)"/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.DigitsMaskString">
            <summary>
            Indicates the digits mask string.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@,System.Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@,System.Int16@,System.Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.UnknownValueChar">
            <summary>
            The generated property declaration for parameter <c>unknownValueChar</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.DigitsMask">
            <summary>
            The generated property declaration for parameter <c>digitsMask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.BasicViewNode">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BasicViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CandidateViewNode">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CandidateViewNode.Cell">
            <summary>
            Indicates the target cell.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CandidateViewNode.CandidateString">
            <summary>
            Indicates the candidate string.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CandidateViewNode.Candidate">
            <summary>
            The generated property declaration for parameter <c>candidate</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CellViewNode">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.ChainLinkViewNode">
            <summary>
            Defines a view node that highlights for a chain link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="isStrongLink">Indicates whether the link is a strong link.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap,System.Boolean)">
            <summary>
            Defines a view node that highlights for a chain link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="isStrongLink">Indicates whether the link is a strong link.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.Start">
            <summary>
            The generated property declaration for parameter <c>start</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.End">
            <summary>
            The generated property declaration for parameter <c>end</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.IsStrongLink">
            <summary>
            The generated property declaration for parameter <c>isStrongLink</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.ChuteViewNode">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChuteViewNode.IsRow">
            <summary>
            Indicates whether the chute is in a row.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChuteViewNode.HousesMask">
            <summary>
            <para>
            Indicates a <see cref="T:System.Int32"/> that represents for the houses used.
            The result mask is a 27-bit digit that represents every possible houses using cases.
            </para>
            <para>
            Please note that the first 9-bit always keep the zero value because they is reserved bits
            for block houses, but all chutes don't use them.
            </para>
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChuteViewNode.ChuteIndex">
            <summary>
            The generated property declaration for parameter <c>chuteIndex</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CircleViewNode">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CircleViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CircleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CrossViewNode">
            <summary>
            Defines a cross view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CrossViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a cross view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CrossViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.DiamondViewNode">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.DiamondViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.DiamondViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.HeartViewNode">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HeartViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HeartViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.HouseViewNode">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.HouseViewNode.House">
            <summary>
            The generated property declaration for parameter <c>house</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.IconViewNode">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.ViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.ViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.IconViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.SquareViewNode">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.SquareViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.SquareViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.StarViewNode">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.StarViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.StarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.TriangleViewNode">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.TriangleViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.TriangleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.PaletteIdColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.#ctor(System.Int32)">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.PaletteIdColorIdentifier.Value">
            <summary>
            The generated property declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.View">
            <summary>
            Provides with a data structure that displays a view for basic information.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.View.Empty">
            <summary>
            Indicates an empty <see cref="T:Sudoku.Drawing.View"/> instance. You can use this property to create a new instance.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.View.AddRange``1(System.ReadOnlySpan{``0})">
            <summary>
            Adds a list of <see cref="T:Sudoku.Drawing.ViewNode"/>s into the collection.
            </summary>
            <param name="nodes">A list of <see cref="T:Sudoku.Drawing.ViewNode"/> instance.</param>
        </member>
        <member name="M:Sudoku.Drawing.View.FindCell(System.Int32)">
            <summary>
            Try to find the candidate whose cell is specified one.
            </summary>
            <param name="cell">The cell to be found.</param>
            <returns>The found node; or <see langword="null"/> if none found.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.FindCandidate(System.Int32)">
            <summary>
            Try to find the candidate whose candidate is specified one.
            </summary>
            <param name="candidate">The candidate to be found.</param>
            <returns>The found node; or <see langword="null"/> if none found.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.UnknownOverlaps(System.Int32)">
            <summary>
            Determines whether the specified <see cref="T:Sudoku.Drawing.View"/> stores several <see cref="T:Sudoku.Drawing.Nodes.BabaGroupViewNode"/>s,
            and at least one of it overlaps the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether being overlapped.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.Equals(Sudoku.Drawing.View)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.Clone">
            <summary>
            Creates a new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance, with independency.
            </summary>
            <returns>A new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.ShallowClone">
            <summary>
            Creates a new <see cref="T:Sudoku.Drawing.View"/> instance whose contents are all come from the current instance,
            with reference cloned.
            </summary>
            <returns>
            A new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance, with reference cloned.
            </returns>
        </member>
        <member name="M:Sudoku.Drawing.View.AsSpan">
            <summary>
            Try to convert this collection as a <see cref="T:System.ReadOnlySpan`1"/> instance.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#First(System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault(System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault(System.Func{Sudoku.Drawing.ViewNode,System.Boolean},Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IWhereMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#Where(System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#ISelectMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#Select``1(System.Func{Sudoku.Drawing.ViewNode,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IOfTypeMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#OfType``1">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.op_BitwiseAnd(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <summary>
            Creates a <see cref="T:Sudoku.Drawing.View"/> whose elements contains both <paramref name="left"/> and <paramref name="right"/>.
            </summary>
            <param name="left">The left-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <param name="right">The right-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Drawing.View"/> result created.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.op_BitwiseOr(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <summary>
            Merges two <see cref="T:Sudoku.Drawing.View"/> instances into one <see cref="T:Sudoku.Drawing.View"/>.
            </summary>
            <param name="left">Indicates the left-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <param name="right">Indicates the right-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Drawing.View"/> result merged.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.op_ExclusiveOr(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <summary>
            Creates a <see cref="T:Sudoku.Drawing.View"/> instance, whose elements is from two <see cref="T:Sudoku.Drawing.View"/> collections
            <paramref name="left"/> and <paramref name="right"/>, with only one-side containing this element.
            </summary>
            <param name="left">The left-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <param name="right">The right-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Drawing.View"/> result created.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.View.op_Equality(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.View.op_Inequality(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Drawing.ViewNode">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Drawing.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Drawing.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="P:Sudoku.Drawing.ViewNode.Identifier">
            <summary>
            Indicates an instance providing with data for describing coloring.
            </summary>
            <remarks><b>
            We cannot change this property into a primary constructor parameter because here attribute <c>[StringMember]</c>
            is not supported by derived types, meaning derived types cannot detect this attribute
            because it's in primary constructor declaration by a base type.
            </b></remarks>
        </member>
        <member name="P:Sudoku.Drawing.ViewNode.TypeIdentifier">
            <summary>
            Indicates the inner identifier to distinct the different types that is derived from <see cref="T:Sudoku.Drawing.ViewNode"/>.
            </summary>
            <seealso cref="T:Sudoku.Drawing.ViewNode"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.Clone">
            <summary>
            Creates a new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance, with independency.
            </summary>
            <returns>A new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance.</returns>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.op_Equality(Sudoku.Drawing.ViewNode,Sudoku.Drawing.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.op_Inequality(Sudoku.Drawing.ViewNode,Sudoku.Drawing.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Drawing.WellKnownColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.#ctor(Sudoku.Drawing.WellKnownColorIdentifierKind)">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.Deconstruct(Sudoku.Drawing.WellKnownColorIdentifierKind@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.WellKnownColorIdentifier.Kind">
            <summary>
            The generated property declaration for parameter <c>kind</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.WellKnownColorIdentifierKind">
            <summary>
            Represents a kind of well-known <see cref="T:Sudoku.Drawing.ColorIdentifier"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Drawing.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Normal">
            <summary>
            Indicates the normal color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary1">
            <summary>
            Indicates the first auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary2">
            <summary>
            Indicates the second auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary3">
            <summary>
            Indicates the third auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Assignment">
            <summary>
            Indicates the assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.OverlappedAssignment">
            <summary>
            Indicates the overlapped assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Elimination">
            <summary>
            Indicates the elimination color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Exofin">
            <summary>
            Indicates the exo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Endofin">
            <summary>
            Indicates the endo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Cannibalism">
            <summary>
            Indicates the cannibalism color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Link">
            <summary>
            Indicates the link color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet1">
            <summary>
            Indicates the first ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet2">
            <summary>
            Indicates the second ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet3">
            <summary>
            Indicates the third ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet4">
            <summary>
            Indicates the fourth ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet5">
            <summary>
            Indicates the fifth ALS recorded.
            </summary>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionExtensions.AsSet(Sudoku.Concepts.Conclusion[])">
            <summary>
            Converts the <see cref="T:Sudoku.Concepts.Conclusion"/> array into a <see cref="T:Sudoku.Concepts.ConclusionSet"/> instance.
            </summary>
            <param name="this">The conclusion array.</param>
            <returns>A <see cref="T:Sudoku.Concepts.ConclusionSet"/> result.</returns>
        </member>
        <member name="T:Sudoku.Analytics.ConclusionTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.ConclusionType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.ConclusionType"/>
        </member>
        <member name="M:Sudoku.Analytics.ConclusionTypeExtensions.GetNotation(Sudoku.Concepts.ConclusionType)">
            <summary>
            Gets the notation of the conclusion type.
            </summary>
            <param name="this">The conclusion type kind.</param>
            <returns>The string representation of the conclusion kind.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined in enumeration type.
            </exception>
        </member>
        <member name="T:Sudoku.IO.Library.LibraryInfo">
            <summary>
            Represents an entry that plays with a puzzle library file.
            </summary>
            <param name="directory">Indicates the parent directory that stores the library.</param>
            <param name="fileId">Indicates the file name used. The value should be valid as a file name, without file extension.</param>
            <remarks><i>
            This type only supports for Windows now. For other OS platforms,
            I will allow them in the future because I'm not familiar with file systems on other OS platforms.
            </i></remarks>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.#ctor(System.String,System.String)">
            <summary>
            Represents an entry that plays with a puzzle library file.
            </summary>
            <param name="directory">Indicates the parent directory that stores the library.</param>
            <param name="fileId">Indicates the file name used. The value should be valid as a file name, without file extension.</param>
            <remarks><i>
            This type only supports for Windows now. For other OS platforms,
            I will allow them in the future because I'm not familiar with file systems on other OS platforms.
            </i></remarks>
        </member>
        <member name="F:Sudoku.IO.Library.LibraryInfo.SeparatorChar">
            <summary>
            Indicates the separator character.
            </summary>
        </member>
        <member name="F:Sudoku.IO.Library.LibraryInfo.ConfigFileHeader">
            <summary>
            Indicates the file header of config files after created or initialized.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.IsInitialized">
            <summary>
            Indicates whether the library-related files are initialized.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.Count">
            <summary>
            Indicates the number of puzzles stored in this file.
            </summary>
            <remarks>
            This property is run synchronously, calling <see cref="M:Sudoku.IO.Library.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)"/>.
            <b>Always measure performance if you want to use this property.</b>
            </remarks>
            <seealso cref="M:Sudoku.IO.Library.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.LibraryFilePath">
            <summary>
            Indicates the path of the library file. The file only contains the puzzles.
            If you want to check for details of the configuration, use <see cref="P:Sudoku.IO.Library.LibraryInfo.ConfigFilePath"/> instead.
            </summary>
            <seealso cref="P:Sudoku.IO.Library.LibraryInfo.ConfigFilePath"/>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.ConfigFilePath">
            <summary>
            Indicates the path of configuration file. The file contains the information of the library.
            </summary>
            <remarks>
            <para>
            Due to the design of the library APIs, a puzzle library contains two parts, separated with 2 files.
            One is the configuration file, and the other is the library details, only containing puzzles.
            </para>
            <para><i>
            Call this property will implicitly create config file if file is not found. No exception will be thrown here.
            </i></para>
            </remarks>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.Author">
            <summary>
            Indicates the author of the library. Return <see langword="null"/> if no author configured.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.Name">
            <summary>
            Indicates the name of the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.Description">
            <summary>
            Indicates the description to the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.Tags">
            <summary>
            Indicates the tags of the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.LastModifiedTime">
            <summary>
            Indicates the last modified time of the library file.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.ConfigFileExtension">
            <summary>
            Indicates the supported extension of config file. The extension will be used by API in runtime, recognizing config files.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.AuthorPattern">
            <remarks>
            Pattern:<br/>
            <code>author:\\s*([\\s\\S]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Uu].<br/>
            ○ Match a character in the set [Tt].<br/>
            ○ Match a character in the set [Hh].<br/>
            ○ Match a character in the set [Oo].<br/>
            ○ Match a character in the set [Rr].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.NamePattern">
            <remarks>
            Pattern:<br/>
            <code>name:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Nn].<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Mm].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.DescriptionPattern">
            <remarks>
            Pattern:<br/>
            <code>description:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Dd].<br/>
            ○ Match a character in the set [Ee].<br/>
            ○ Match a character in the set [Ss].<br/>
            ○ Match a character in the set [Cc].<br/>
            ○ Match a character in the set [Rr].<br/>
            ○ Match a character in the set [Ii].<br/>
            ○ Match a character in the set [Pp].<br/>
            ○ Match a character in the set [Tt].<br/>
            ○ Match a character in the set [Ii].<br/>
            ○ Match a character in the set [Oo].<br/>
            ○ Match a character in the set [Nn].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.TagsPattern">
            <remarks>
            Pattern:<br/>
            <code>tags:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
            ○ Match a character in the set [Tt].<br/>
            ○ Match a character in the set [Aa].<br/>
            ○ Match a character in the set [Gg].<br/>
            ○ Match a character in the set [Ss].<br/>
            ○ Match ':'.<br/>
            ○ Match a whitespace character greedily any number of times.<br/>
            ○ 1st capture group.<br/>
                ○ Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.Item(System.Int32)">
            <summary>
            Try to get the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The target <see cref="T:Sudoku.Concepts.Grid"/> instance at the specified index.</returns>
            <remarks>
            This property is run synchronously, calling <see cref="M:Sudoku.IO.Library.LibraryInfo.GetAtAsync(System.Int32,System.Threading.CancellationToken)"/>.
            <b>Always measure performance if you want to use this indexer.</b>
            </remarks>
            <seealso cref="M:Sudoku.IO.Library.LibraryInfo.GetAtAsync(System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.Deconstruct(System.String@,System.String@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.Initialize">
            <summary>
            Initializes the library-related files if not found. If initialized, throw <see cref="T:Sudoku.IO.Library.LibraryInitializationException"/>.
            </summary>
            <exception cref="T:Sudoku.IO.Library.LibraryInitializationException">Throws when the library has already been initialized.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.Delete">
            <summary>
            Delete the current library, removing files from local path.
            </summary>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.ClearPuzzles">
            <summary>
            Clears the current library, removing all puzzles stored in this library, making the file empty,
            but reserving the files not deleted.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library isn't initialized.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.Equals(Sudoku.IO.Library.LibraryInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.Any">
            <summary>
            Determines whether the library contains at least one puzzle.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            <para>
            Append a puzzle, represented as a <see cref="T:System.String"/> value,
            into the specified file path represented as a puzzle library.
            </para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grid">The grid text code to be appended.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the grid cannot be recognized.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzleAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzleAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            <para>
            Append a list of puzzles, represented as a list of <see cref="T:System.String"/> values,
            into the specified file path represented as a puzzle library.
            </para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grids">A list of grid text code to be appended.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> of an <see cref="T:System.Int32"/> instance indicating how many text code are appended into the file.
            </returns>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IAsyncEnumerable{System.String},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Grid},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.RemovePuzzleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Removes all puzzles that exactly same as the specified one from the file.
            </summary>
            <param name="grid">The grid.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throw when the library file is not initialized.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.RemovePuzzleAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.RemovePuzzleAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.RemoveDuplicatePuzzlesAsync(System.Threading.CancellationToken)">
            <summary>
            Removes a list of duplicate puzzles stored in the current library.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle should be initialized first.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.WriteAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            <para>Write a puzzle into a file just created.</para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grid">The grid to be written.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the grid cannot be recognized.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.WriteAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.WriteAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)">
            <summary>
            Calculates how many puzzles in this file.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> of an <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            <b><i>If you want to check whether the puzzle has at least one puzzle, please use method <see cref="M:Sudoku.IO.Library.LibraryInfo.Any"/> instead.</i></b>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Throws when the library file is not initialized.</exception>
            <seealso cref="M:Sudoku.IO.Library.LibraryInfo.Any"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.GetAtAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Grid"/> at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Sudoku.Concepts.Grid"/> instance as the result.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the library file is not initialized.</exception>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.CreateTextPointer">
            <summary>
            Creates a <see cref="T:Sudoku.IO.Library.TextPointer"/> instance that uses <see cref="T:System.IO.FileStream"/> to read puzzles line by line.
            </summary>
            <returns>A <see cref="T:Sudoku.IO.Library.TextPointer"/> instance that reads for the current library.</returns>
            <remarks><b>
            This method returns an instance that implements <see cref="T:System.IAsyncDisposable"/> and <see cref="T:System.IDisposable"/>,
            meaning you must call <see cref="M:System.IAsyncDisposable.DisposeAsync"/> or <see cref="M:System.IDisposable.Dispose"/>
            after you finishing using the return value:
            <code><![CDATA[await using var pointer = library.CreateTextPointer();]]></code>
            </b></remarks>
            <seealso cref="T:Sudoku.IO.Library.TextPointer"/>
            <seealso cref="T:System.IDisposable"/>
            <seealso cref="T:System.IAsyncDisposable"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.GetAsyncEnumerator(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.EnumerateTextAsync(System.Threading.CancellationToken)">
            <summary>
            Enumerates raw text codes stored in the library.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>An async-iterable collection of <see cref="T:System.String"/> values as raw text codes.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.ConfigFileReplaceOrAppend(System.Func{System.String,System.Boolean},System.String,System.String)">
            <summary>
            Replace or append the value into the file, using the specified match method.
            </summary>
            <param name="match">The matcher method.</param>
            <param name="replaceOrAppendValue">The value to replace with original value, or appened.</param>
            <param name="callerPropertyName">
            Indicates the property name as caller. This parameter shouldn't be assigned. It will be assigned by compiler.
            </param>
            <exception cref="T:System.InvalidOperationException">Throws when multiple same properties found.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.RegisterConfigFileExtension(System.String)">
            <summary>
            Registers the config file extension. Argument should contain prefix period token '<c>.</c>'.
            </summary>
            <param name="extension">The extension of the config file. Period '<c>.</c>' required.</param>
            <remarks>
            <b>Please note that only one extension can work. If you call this method multiple times, only the last one will work.</b>
            </remarks>
            <exception cref="T:System.ArgumentException">Throws when the argument <paramref name="extension"/> is not valid.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.GetSingleLineGridString(Sudoku.Concepts.Grid@)">
            <summary>
            Returns <c>grid.ToString("#")</c>.
            </summary>
        </member>
        <member name="F:Sudoku.IO.Library.LibraryInfo._directory">
            <summary>
            The generated field declaration for parameter <c>directory</c>.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInfo.FileId">
            <summary>
            The generated property declaration for parameter <c>fileId</c>.
            </summary>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.op_Equality(Sudoku.IO.Library.LibraryInfo,Sudoku.IO.Library.LibraryInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInfo.op_Inequality(Sudoku.IO.Library.LibraryInfo,Sudoku.IO.Library.LibraryInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.IO.Library.LibraryInitializationException">
            <summary>
            Represents an exception type that will be thrown if a library instance has already been initialized, but a user still calls
            method <see cref="M:Sudoku.IO.Library.LibraryInfo.Initialize"/>.
            </summary>
            <param name="directory"><inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='directory']"/></param>
            <param name="fileId"><inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='fileId']"/></param>
            <remarks><i>
            This type is only used by Windows platform because the relied type <see cref="T:Sudoku.IO.Library.LibraryInfo"/>
            is marked <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute"/>, limited in Windows.
            </i></remarks>
            <seealso cref="M:Sudoku.IO.Library.LibraryInfo.Initialize"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInitializationException.#ctor(System.String,System.String)">
            <summary>
            Represents an exception type that will be thrown if a library instance has already been initialized, but a user still calls
            method <see cref="M:Sudoku.IO.Library.LibraryInfo.Initialize"/>.
            </summary>
            <param name="directory"><inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='directory']"/></param>
            <param name="fileId"><inheritdoc cref="M:Sudoku.IO.Library.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='fileId']"/></param>
            <remarks><i>
            This type is only used by Windows platform because the relied type <see cref="T:Sudoku.IO.Library.LibraryInfo"/>
            is marked <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute"/>, limited in Windows.
            </i></remarks>
            <seealso cref="M:Sudoku.IO.Library.LibraryInfo.Initialize"/>
        </member>
        <member name="M:Sudoku.IO.Library.LibraryInitializationException.#ctor(Sudoku.IO.Library.LibraryInfo)">
            <summary>
            Initializes a <see cref="T:Sudoku.IO.Library.LibraryInitializationException"/> instance via the specified directory and file ID.
            </summary>
            <param name="library">The library instance.</param>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryInitializationException.Message">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.IO.Library.TextPointer">
            <summary>
            Represents a text pointer object that reads the detail of a <see cref="T:Sudoku.IO.Library.LibraryInfo"/>.
            </summary>
            <remarks><i>
            This type only supports for Windows now because the relied type <see cref="T:Sudoku.IO.Library.LibraryInfo"/> is limited in Windows.
            </i></remarks>
            <seealso cref="T:Sudoku.IO.Library.LibraryInfo"/>
        </member>
        <member name="F:Sudoku.IO.Library.TextPointer.MaxLimitOfPuzzleLength">
            <summary>
            Indicates the max limit of a puzzle length.
            </summary>
        </member>
        <member name="F:Sudoku.IO.Library.TextPointer._stream">
            <summary>
            Indicates the internal stream.
            </summary>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.#ctor(Sudoku.IO.Library.LibraryInfo)">
            <summary>
            Initializes a <see cref="T:Sudoku.IO.Library.TextPointer"/> instance via the specified library.
            </summary>
            <param name="library">Indicates the libary object.</param>
            <exception cref="T:System.ArgumentException">Throws when the library is not initialized.</exception>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.ForwardPuzzlesCount">
            <summary>
            Indicates the number of puzzles left to be iterated from the current position. The current puzzle will be included.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.BackPuzzlesCount">
            <summary>
            Indicates the number of puzzles left to be iterated back from the current position. The current puzzle will be included.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.Current">
            <summary>
            Indicates the currently-pointed puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.Length">
            <summary>
            Indicates the number of puzzles stored in the file, regardless of the position of the pointer.
            </summary>
            <remarks><inheritdoc cref="P:Sudoku.IO.Library.LibraryInfo.Count" path="/remarks"/></remarks>
            <seealso cref="M:Sudoku.IO.Library.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.Library">
            <summary>
            Indicates the library object.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.System#Collections#Generic#IReadOnlyCollection{System#String}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.IO.Library.TextPointer.PositionOfPointer">
            <summary>
            Indicates the position of the pointer.
            </summary>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.SetStart">
            <summary>
            Sets the pointer to the start position, 0.
            </summary>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.SetEnd">
            <summary>
            Sets the pointer to the end position, the length of the stream.
            </summary>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.Equals(Sudoku.IO.Library.TextPointer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.TryReadNextPuzzle(System.String@)">
            <summary>
            Try to read the next puzzle beginning with the current text pointer position.
            </summary>
            <param name="result">The result of the grid, represented as a <see cref="T:System.String"/> result.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the file exists the next grid.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.TryReadPreviousPuzzle(System.String@)">
            <summary>
            Try to read the previous puzzle beginning with the current text pointer position.
            </summary>
            <param name="result">The result of the grid, represented as a <see cref="T:System.String"/> result.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the file exists the previous grid.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.TrySkipNext(System.Int32)">
            <summary>
            Try to skip the number of puzzles forward, making the pointer point to the next grid after the skipped grids.
            </summary>
            <param name="count">The desired number of puzzles to be skipped. The default value is 1.</param>
            <returns>The number of puzzles skipped in fact.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.TrySkipPrevious(System.Int32)">
            <summary>
            Try to skip the number of puzzles back, making the pointer point to the next grid before the skipped grids.
            </summary>
            <param name="count">The desired number of puzzles to be skipped. The default value is 1.</param>
            <returns>The number of puzzles skipped in fact.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.TryFetchNext(System.Int32,System.ReadOnlySpan{System.String}@)">
            <summary>
            Fetch the number of puzzles beginning with the current pointer position.
            </summary>
            <param name="count">The desired number of puzzles.</param>
            <param name="result">Indicates the puzzles fetched.</param>
            <returns>The number of puzzles fetched.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.TryFetchPrevious(System.Int32,System.ReadOnlySpan{System.String}@)">
            <summary>
            Fetch the number of puzzles in previous beginning with the current pointer position.
            </summary>
            <param name="count">The desired number of puzzles.</param>
            <param name="result">Indicates the puzzles fetched.</param>
            <returns>The number of puzzles fetched.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.GetEnumerator">
            <summary>
            Returns itself. The method is consumed by <see langword="foreach"/> loops.
            </summary>
            <returns>A <see cref="T:Sudoku.IO.Library.TextPointer"/> instance that can iterate on each puzzle stored in library file.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.System#Collections#IEnumerator#MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.System#Collections#Generic#IEnumerable{System#String}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_Increment(Sudoku.IO.Library.TextPointer)">
            <summary>
            Moves the pointer to the next puzzle. If the pointer is at the end of the sequence, moves to the first element.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_CheckedIncrement(Sudoku.IO.Library.TextPointer)">
            <summary>
            Moves the pointer to the next puzzle. If the pointer is at the end of the sequence,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the pointer cannot be moved.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_Decrement(Sudoku.IO.Library.TextPointer)">
            <summary>
            Moves the pointer to the previous puzzle. If the pointer is at the start of the sequence, moves to the last element.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_CheckedDecrement(Sudoku.IO.Library.TextPointer)">
            <summary>
            Moves the pointer to the previous puzzle. If the pointer is at the start of the sequence, throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the pointer cannot be moved.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_Addition(Sudoku.IO.Library.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles forward.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_CheckedAddition(Sudoku.IO.Library.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles forward. If the pointer has already moved to the last element,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements can be skipped.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_Subtraction(Sudoku.IO.Library.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles back.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_CheckedSubtraction(Sudoku.IO.Library.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles back. If the pointer has already moved to the first element,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements can be skipped.</exception>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_Equality(Sudoku.IO.Library.TextPointer,Sudoku.IO.Library.TextPointer)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.IO.Library.TextPointer.op_Inequality(Sudoku.IO.Library.TextPointer,Sudoku.IO.Library.TextPointer)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Linq.BitStatusMapGrouping`4">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.#ctor(`3,`0@)">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Count">
            <summary>
            Indicates the number of values stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>, i.e. the shorthand of expression <c>Values.Count</c>.
            </summary>
            <seealso cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Item(System.Int32)">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.ICellMapOrCandidateMap`3.Item(System.Int32)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.Deconstruct(`3@,`0@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.Equals(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An enumerator object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.CreateMapByKeys(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,System.Int32}})">
            <summary>
            Makes a <see cref="T:Sudoku.Concepts.CellMap"/> instance that is concatenated by a list of groups
            of type <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/>, adding their keys.
            </summary>
            <param name="groups">The groups.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#IEquatable{Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey}}#Equals(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Linq#Providers#IWhereMethod{TMap,TElement}#Where(System.Func{`1,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Linq#Providers#ISelectMethod{TMap,TElement}#Select``1(System.Func{`1,``0})">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Key">
            <summary>
            The generated property declaration for parameter <c>key</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Linq.BitStatusMapGrouping`4.Values">
            <summary>
            The generated property declaration for parameter <c>values</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.op_Equality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@,Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.op_Inequality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@,Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Numerics#IEqualityOperators{Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Equality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3},Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGrouping`4.System#Numerics#IEqualityOperators{Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#BitStatusMapGrouping{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Inequality(Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3},Sudoku.Linq.BitStatusMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Linq.BitStatusMapGroupingEnumerable">
            <summary>
            Represents a list of LINQ methods used by <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Where``4(Sudoku.Linq.BitStatusMapGrouping{``0,``1,``2,``3},System.Func{``1,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
            <typeparam name="TMap">
            The type of the map that stores the <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.
            </typeparam>
            <typeparam name="TElement">
            The type of elements stored in <see cref="P:Sudoku.Linq.BitStatusMapGrouping`4.Values"/>.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>A (An) <typeparamref name="TElement"/>[] that contains elements from the input sequence that satisfy the condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Select``5(Sudoku.Linq.BitStatusMapGrouping{``0,``1,``2,``3},System.Func{``1,``4})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/summary"/>
            </summary>
            <typeparam name="TMap">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGrouping`4" path="/typeparam[@name='TMap']"/>
            </typeparam>
            <typeparam name="TElement">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGrouping`4" path="/typeparam[@name='TElement']"/>
            </typeparam>
            <typeparam name="TKey">
            <inheritdoc cref="T:Sudoku.Linq.BitStatusMapGrouping`4" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <typeparam name="TEnumerator">
            The type of enumerator.
            </typeparam>
            <typeparam name="TResult">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TResult']"/>
            </typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="selector">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='selector']"/>
            </param>
            <returns>
            An array of <typeparamref name="TResult"/> instances whose elements are the result of invoking the transform function
            on each element of the current instance.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0}},System.Func{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> of types <see cref="T:Sudoku.Concepts.CellMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results and merge
            into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Linq.BitStatusMapGroupingEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0}},System.Func{Sudoku.Linq.BitStatusMapGrouping{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> of types <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results
            and merge into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:Sudoku.Linq.CandidateMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CandidateMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.CellMapOrCandidateMapPredicate{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.FirstOrNull(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.FirstOrNull(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.CellMapOrCandidateMapPredicate{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Select``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Where(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CandidateMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CandidateMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CandidateMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.GroupBy``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.SelectMany``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each candidate (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CandidateMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Any(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.All(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.CellMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CellMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.CellMapOrCandidateMapPredicate{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements found.</exception>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.FirstOrNull(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.FirstOrNull(Sudoku.Concepts.CellMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.CellMapOrCandidateMapPredicate{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element in the current instance into the target-typed <typeparamref name="TResult"/> array,
            using the specified function to convert.
            </summary>
            <typeparam name="TResult">The type of target value.</typeparam>
            <param name="this">The current instance.</param>
            <param name="selector">The selector.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Where(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CellMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CellMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CellMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function.
            </summary>
            <typeparam name="TKey">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <param name="this">The current instance.</param>
            <param name="keySelector">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='keySelector']"/>
            </param>
            <returns>
            A list of <see cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/> instances where each value object contains a sequence of objects and a key.
            </returns>
            <seealso cref="T:Sudoku.Linq.BitStatusMapGrouping`4"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.SelectMany``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each cell (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CellMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Any(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.All(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.ConclusionsEnumerable">
            <summary>
            Provides with a list of LINQ methods used by <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="M:Sudoku.Linq.ConclusionsEnumerable.Select(System.ReadOnlySpan{Sudoku.Concepts.Conclusion},System.Func{Sudoku.Concepts.Conclusion,System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Concepts.Conclusion"/> instances, converted each instances into a <see cref="T:System.Int32"/> value,
            and merge them into a <see cref="T:Sudoku.Concepts.CellMap"/> and return it.
            </summary>
            <param name="this">A list of <see cref="T:Sudoku.Concepts.Conclusion"/> instances.</param>
            <param name="selector">The selector to project the values.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.GridEnumerable">
            <summary>
            Provides with a list of LINQ methods operating with <see cref="T:Sudoku.Concepts.Grid"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Where(Sudoku.Concepts.Grid@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters the candidates that satisfies the specified condition.
            </summary>
            <param name="this">The instance to be iterated.</param>
            <param name="predicate">The condition to filter candidates.</param>
            <returns>All candidates satisfied the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Select``1(Sudoku.Concepts.Grid@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
            <typeparam name="TResult">The type of the value returned by <paramref name="selector"/>.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>
            An array of <typeparamref name="TResult"/> elements converted.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.HouseMaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int32"/>.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Select``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.SelectMany``1(System.Int32,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int32"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int32"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Where(System.Int32,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.ListEnumerable">
            <summary>
            Represents a list of LINQ methods to be used for type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CellMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in sourece.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CandidateMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in sourece.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.MaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int16"/>.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Select``1(System.Int16,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.SelectMany``1(System.Int16,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int16"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>, flattens the resulting sequence into one sequence,
            and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int16"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Where(System.Int16,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int16"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.ViewEnumerable">
            <summary>
            Represents with LINQ methods for <see cref="T:Sudoku.Drawing.View"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Drawing.View"/>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.Select``1(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,``0})">
            <summary>
            Projects with a new transform of elements.
            </summary>
            <typeparam name="T">The type of target element.</typeparam>
            <param name="this">The view.</param>
            <param name="selector">The method to transform each element.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="T"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.Where(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Drawing.View"/>, only reserves the <see cref="T:Sudoku.Drawing.ViewNode"/> instances satisfying the specified condition.
            </summary>
            <param name="this">The view.</param>
            <param name="predicate">The filter.</param>
            <returns>A list of <see cref="T:Sudoku.Drawing.ViewNode"/> filtered.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.OfType``1(Sudoku.Drawing.View)">
            <summary>
            Filters the view nodes, only returns nodes of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the node.</typeparam>
            <returns>The target collection of element type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.First(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found;
            otherwise, throw an <see cref="T:System.InvalidOperationException"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the sequence has no elements satisfying the specified rule.
            </exception>
            <inheritdoc cref="M:Sudoku.Linq.ViewEnumerable.FirstOrDefault(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.FirstOrDefault(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the first occurrence within the entire <see cref="T:Sudoku.Drawing.View"/>.
            </summary>
            <param name="this">The view to be checked.</param>
            <param name="match">The <see cref="T:System.Func`2"/> delegate that defines the conditions of the element to search for.</param>
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found; otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.SelectMany(Sudoku.Drawing.View[],System.Func{Sudoku.Drawing.View,Sudoku.Drawing.View},System.Func{Sudoku.Drawing.View,Sudoku.Drawing.ViewNode,Sudoku.Drawing.ViewNode})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.SelectMany``3(``0[],System.Func{``0,System.ReadOnlySpan{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="T:Sudoku.Measuring.Distance">
            <summary>
            Represents the methods that calculates for distance.
            </summary>
            <param name="p">Indicates the integer part.</param>
            <param name="q">Indicates the root part.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when either <paramref name="p"/> or <paramref name="q"/> are less than 1.</exception>
            <remarks>
            This type is implemented via irrational numbers logic that only takes a square root.
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.Distance.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents the methods that calculates for distance.
            </summary>
            <param name="p">Indicates the integer part.</param>
            <param name="q">Indicates the root part.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when either <paramref name="p"/> or <paramref name="q"/> are less than 1.</exception>
            <remarks>
            This type is implemented via irrational numbers logic that only takes a square root.
            </remarks>
        </member>
        <member name="F:Sudoku.Measuring.Distance.DistanceTable">
            <summary>
            The table that displays the minimal and maximal index of cells that makes the distances least or greatest with the specified cell.
            </summary>
            <remarks>
            <para>
            The table is grouped with houses. If you want to fetch the smallest or biggest distance value from a cell to a house, you can use
            <c><see cref="F:Sudoku.Measuring.Distance.DistanceTable"/>[Cell][House]</c>, where <c>Cell</c> is between 0 and 81, and <c>House</c> is between 0 and 27.
            If the cell is inside the house, the value will be <see langword="null"/>.
            </para>
            <para>
            In further, if you want to get the distance from two cells using this table, just call method <see cref="M:Sudoku.Measuring.Distance.GetDistance(System.Int32,System.Int32)"/>.
            </para>
            </remarks>
            <seealso cref="M:Sudoku.Measuring.Distance.GetDistance(System.Int32,System.Int32)"/>
        </member>
        <member name="F:Sudoku.Measuring.Distance._p">
            <summary>
            The root value of P.
            </summary>
        </member>
        <member name="F:Sudoku.Measuring.Distance._q">
            <summary>
            The root value of Q.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.Distance.#ctor">
            <summary>
            Initializes a <see cref="T:Sudoku.Measuring.Distance"/> instance via both values 1.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.Distance.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Measuring.Distance"/> instance via the root part, with the default integer part 1.
            <i>This value will automatically simplify the root expression, e.g. sqrt(18) -> 3sqrt(2).</i>
            </summary>
            <param name="q">The root value.</param>
        </member>
        <member name="P:Sudoku.Measuring.Distance.RawValue">
            <summary>
            The raw value of the distance. The value will be ouput as a <see cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.Distance.Equals(Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.CompareTo(Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <remarks>
            The output format will be "<c>psq</c>", where <c>p</c> and <c>q</c> are the variables, and <c>s</c> means "square root of".
            For example, "<c>3s2</c>" means <c>3 * sqrt(2)</c>, i.e. <c>sqrt(18)</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetDistance(System.Int32,System.Int32)">
            <summary>
            Try to fetch the distance for the two cells.
            </summary>
            <param name="cell1">The first cell to be compared.</param>
            <param name="cell2">The second cell to be compared.</param>
            <returns>The distance result.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetDistance(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to fetch the distance for two cells stored in a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="cells">The <see cref="T:Sudoku.Concepts.CellMap"/> instance storing two cells.</param>
            <returns>The distance result.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetIntermediateCells(System.Int32,System.Int32)">
            <summary>
            Try to get the intermediate cells that are between <paramref name="cell1"/> and <paramref name="cell2"/> in logical position
            for sudoku grid.
            </summary>
            <param name="cell1">The first cell.</param>
            <param name="cell2">The second cell. The value should be greater than <paramref name="cell1"/>.</param>
            <returns>The intermediate cells.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when cells <paramref name="cell1"/> and <paramref name="cell2"/> are not in a same line (row or column).
            </exception>
        </member>
        <member name="M:Sudoku.Measuring.Distance.SimplifyRootPart(System.Int32@)">
            <summary>
            Simplifies for root part.
            </summary>
            <param name="base">The root value.</param>
            <returns>The P value.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_Implicit(Sudoku.Measuring.Distance)~System.Double">
            <summary>
            Implicit cast from the <see cref="T:Sudoku.Measuring.Distance"/> instance to a <see cref="T:System.Double"/>.
            </summary>
            <param name="distance">The distance value.</param>
        </member>
        <member name="M:Sudoku.Measuring.Distance.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_Equality(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_Inequality(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_GreaterThan(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_LessThan(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_GreaterThanOrEqual(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_LessThanOrEqual(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Measuring.EmptyArea">
            <summary>
            Provides a way to calculate empty area of a <see cref="T:Sudoku.Concepts.Grid"/> or a <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptyArea(Sudoku.Concepts.Grid@)">
            <summary>
            Try to get the maximum empty area exists in the specified grid.
            </summary>
            <param name="this">The grid to be checked.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            <inheritdoc cref="M:Sudoku.Measuring.EmptyArea.GetMaxEmptyArea(Sudoku.Concepts.CellMap@)" path="/remarks"/>
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.Grid@)">
            <summary>
            Try to get the maximum empty square area exists in the specified grid.
            </summary>
            <param name="this">The grid to be checked.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            <inheritdoc cref="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.CellMap@)" path="/remarks"/>
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptyArea(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to get the maximum empty area exists in the specified cells.
            </summary>
            <param name="this">The cells to be checked.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            This algorithm is from the puzzle called
            <see href="https://leetcode.com/problems/maximal-rectangle/"><i>Maximal Rectangle</i></see>.
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to get the maximum empty square area exists in the specified cells.
            </summary>
            <param name="this">The cells to be checked.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            This algorithm is from the puzzle called
            <see href="https://leetcode.com/problems/maximal-square/"><i>Maximal Square</i></see>.
            </remarks>
        </member>
        <member name="T:Sudoku.ModuleInitializer">
            <target name="type">
				<summary>
					<para>
						Provides with the type that contains a module initializer method, called automatically by the CLR
						(Common Language Runtime) to initialize some values.
					</para>
					<para>
						<i>
							The type is called by the compiler and the CLR (Common Language Runtime),
							which means you cannot use any members in this type manually.
						</i>
					</para>
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.ModuleInitializer.Initialize">
            <target name="method">
				<summary>
					Called by the runtime automatically while booting on this solution to initialize the values,
					data members or any other things that can or should be initialized here.
				</summary>
				<remarks>
					The concept <b>module</b> is different with <b>assembly</b>.
					The solution can contain multiple assemblies, while each assembly can contain multiple modules.
					However, due to the design of Visual Studio project file system, each assembly will only contain
					one module by default.
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Randomization.Randomizer">
            <summary>
            Provides with extension methods for <see cref="T:System.Random"/>.
            </summary>
            <seealso cref="T:System.Random"/>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.NextDigit(System.Random)">
            <summary>
            Returns a random integer that is within valid digit range (0..9).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.NextCell(System.Random)">
            <summary>
            Returns a random integer that is within valid cell range (0..81).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.NextHouse(System.Random)">
            <summary>
            Returns a random integer that is within valid house range (0..27).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.RandomlySelect(System.Random,Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Randomly select the specified number of elements from the current collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="cells">The cells to be chosen.</param>
            <param name="count">The desired number of elements.</param>
            <returns>The specified number of elements returned, represented as a <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.RandomlySelect(System.Random,Sudoku.Concepts.CandidateMap@,System.Int32)">
            <summary>
            Randomly select the specified number of elements from the current collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="cells">The cells to be chosen.</param>
            <param name="count">The desired number of elements.</param>
            <returns>The specified number of elements returned, represented as a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.CreateCellMap(System.Random,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance, with the specified number of <see cref="T:System.Int32"/>s stored in the collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="count">The desired number of elements.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Randomization.Randomizer.CreateCandidateMap(System.Random,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, with the specified number of <see cref="T:System.Int32"/>s stored in the collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="count">The desired number of elements.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Resources.CoreResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.BlockLabel">
            <summary>
              Looks up a localized string similar to Block {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CandidateLabel">
            <summary>
              Looks up a localized string similar to {0}, digit {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellLabel">
            <summary>
              Looks up a localized string similar to row {0} column {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellsLabel">
            <summary>
              Looks up a localized string similar to cells: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ColumnLabel">
            <summary>
              Looks up a localized string similar to Column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ColumnName">
            <summary>
              Looks up a localized string similar to Column.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ConjugatePairWith">
            <summary>
              Looks up a localized string similar to {0} conjugates with {1}, for digit {2}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.DigitName">
            <summary>
              Looks up a localized string similar to Digit.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Error_ArgExtensionShouldBeValid">
            <summary>
              Looks up a localized string similar to The argument should contains the prefix period token..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Error_UnrecognizedGridFormat">
            <summary>
              Looks up a localized string similar to You cannot append text that cannot be recognized as a valid sudoku grid..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_CannotAssignSuccessForFailureCases">
            <summary>
              Looks up a localized string similar to Cannot assign success field to describe such failure..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_CellsShouldInSameLine">
            <summary>
              Looks up a localized string similar to Two cells must be in a same line (row or column)..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_ComparableGridMustBeStandard">
            <summary>
              Looks up a localized string similar to The puzzle can be comparable if it must be a standard sudoku..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_ContainsEmptySegmentOnParsing">
            <summary>
              Looks up a localized string similar to The string contains empty segment..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_DifferentExistenceOfConfigAndLibraryFile">
            <summary>
              Looks up a localized string similar to Different existence of config file and library file..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_DuplicatedValuesMayExistOrInvalid">
            <summary>
              Looks up a localized string similar to Duplicated or invalid values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_FileShouldBeInitializedFirst">
            <summary>
              Looks up a localized string similar to Related files should be initialized first..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridInvalid">
            <summary>
              Looks up a localized string similar to The grid is invalid - it may contain invalid internal data, or it is invalid as an argument to the method..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridInvalidCellState">
            <summary>
              Looks up a localized string similar to The grid cannot keep invalid cell state value..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridMultipleSolutions">
            <summary>
              Looks up a localized string similar to The grid contains multiple solutions..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridNoSolution">
            <summary>
              Looks up a localized string similar to The grid has no possible solution..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_InvalidStateOnParsing">
            <summary>
              Looks up a localized string similar to Invalid state on parsing values..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_LengthMustBeMatched">
            <summary>
              Looks up a localized string similar to The length of the string must be {0}..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_LibraryShouldBeInitialized">
            <summary>
              Looks up a localized string similar to The library is not initialized. It must be initialized file, ensuring the file in local exists..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MinLexShouldBeUniqueAndNotSukaku">
            <summary>
              Looks up a localized string similar to The puzzle should be standard sudoku puzzle, and contain a unique solution..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleChuteValuesFound">
            <summary>
              Looks up a localized string similar to Multiple chute values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleConjugatePairValuesFound">
            <summary>
              Looks up a localized string similar to Multiple conjuagte pair values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleFlagsExist">
            <summary>
              Looks up a localized string similar to Multiple flags exist. The method only allows the enumeration field only holds one flag value..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleSamePropertiesFound">
            <summary>
              Looks up a localized string similar to Multiple same properties are found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NoElementsInSequence">
            <summary>
              Looks up a localized string similar to No possible elements can be found in the current sequence..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NotExist">
            <summary>
              Looks up a localized string similar to The file does not exist..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NotSupportedForSukakuPuzzles">
            <summary>
              Looks up a localized string similar to This function does not support for Sukaku puzzles..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_PlaceholderMustBeZeroOrDot">
            <summary>
              Looks up a localized string similar to The placeholder character invalid; expected: &apos;0&apos; or &apos;.&apos;..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_PointerCannotMove">
            <summary>
              Looks up a localized string similar to The pointer cannot move..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_StringValueInvalidToBeParsed">
            <summary>
              Looks up a localized string similar to The string value is invalid to be parsed..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_SubsetsExceeded">
            <summary>
              Looks up a localized string similar to Both cells count and subset size is too large, which may cause potential out of memory exception. This operator will throw this exception to calculate the result, in order to prevent any possible exceptions thrown..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.HousesLabel">
            <summary>
              Looks up a localized string similar to houses: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.LockedCandidatesLabel">
            <summary>
              Looks up a localized string similar to {0} {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaColumnLabel">
            <summary>
              Looks up a localized string similar to Mega column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaLinesLabel">
            <summary>
              Looks up a localized string similar to Mega lines: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaRowLabel">
            <summary>
              Looks up a localized string similar to Mega row {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Message_LibraryInitializedException">
            <summary>
              Looks up a localized string similar to The library (local path: &apos;{0}\{1}&apos;) has already been initialized..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.RowLabel">
            <summary>
              Looks up a localized string similar to Row {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.RowName">
            <summary>
              Looks up a localized string similar to Row.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_All">
            <summary>
              Looks up a localized string similar to All symmetry.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_AntiDiagonal">
            <summary>
              Looks up a localized string similar to Anti-diagonal.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_AxisBoth">
            <summary>
              Looks up a localized string similar to Both axes.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_Central">
            <summary>
              Looks up a localized string similar to Central.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_Diagonal">
            <summary>
              Looks up a localized string similar to Diagonal.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_DiagonalBoth">
            <summary>
              Looks up a localized string similar to Both diagonals.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_None">
            <summary>
              Looks up a localized string similar to No symmetry.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_XAxis">
            <summary>
              Looks up a localized string similar to X axis.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_YAxis">
            <summary>
              Looks up a localized string similar to Y axis.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.HouseMaskOperations">
            <summary>
            Represents a list of methods handling with <see cref="T:System.Int32"/> instances.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllBlocksMask">
            <summary>
            Indicates the mask that means all blocks.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllRowsMask">
            <summary>
            Indicates the mask that means all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllColumnsMask">
            <summary>
            Indicates the mask that means all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.MaskServices.HouseMaskOperations.AllHousesMask">
            <summary>
            Indicates the mask that means all houses.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.HouseMaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int32"/> instance via the specified houses.
            </summary>
            <param name="houses">The houses.</param>
            <returns>A <see cref="T:System.Int32"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.HouseMaskOperations.SplitMask(System.Int32)">
            <summary>
            Try to split mask into three parts.
            </summary>
            <param name="this">The mask to be split.</param>
            <returns>The mask split.</returns>
        </member>
        <member name="T:Sudoku.Runtime.MaskServices.MaskOperations">
            <summary>
            Provides with a set of methods that operates with mask defined in basic sudoku concepts, as data structures.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int16" /> instance via the specified digits.
            </summary>
            <param name="digits">
            <para>Indicates the digits to assign.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>A <see cref="T:System.Int16" /> instance.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.ReadOnlySpan{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.Create``1(``0)">
            <typeparam name="T">The type of the enumerable sequence.</typeparam>
            <inheritdoc cref="M:Sudoku.Runtime.MaskServices.MaskOperations.Create(System.ReadOnlySpan{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToDigits(System.Int16)">
            <summary>
            To get the digits that the current mask represents for. The mask must be between 0 and 512, and exclude 512.
            </summary>
            <param name="digitMask">The digit mask.</param>
            <returns>The digits returned.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToSudokuType(System.Int16)">
            <summary>
            To get the sudoku type for the specified cell mask inside a <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The cell mask.</param>
            <returns>The sudoku type configured.</returns>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.MaskToCellState(System.Int16)">
            <summary>
            To get the cell state for a mask value. The mask is an inner representation to describe a cell's state.
            For more information please visit the details of the design for type <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The mask.</param>
            <returns>The cell state.</returns>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Runtime.MaskServices.MaskOperations.SplitMask(System.Int16)">
            <summary>
            Try to split a mask into 3 parts, 3-bit as a unit.
            </summary>
            <param name="this">The mask instance to be split.</param>
            <returns>A triplet of values.</returns>
        </member>
        <member name="T:Sudoku.Snyder.PencilmarkGrid">
            <summary>
            Represents a sudoku grid that can be only used by users to append pencilmarks.
            </summary>
        </member>
        <member name="F:Sudoku.Snyder.PencilmarkGrid.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGridConstants`1.Undefined"/>
        </member>
        <member name="F:Sudoku.Snyder.PencilmarkGrid._values">
            <inheritdoc cref="P:Sudoku.Concepts.Primitives.IGrid`1.FirstMaskRef"/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.IsMissingCandidates">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.IsSolved">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Symmetry">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.GivensCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.ModifiablesCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.EmptiesCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.CandidatesCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.EmptyHouses">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.CompletedHouses">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.GivenCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.ModifiableCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.EmptyCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.BivalueCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.CandidatesMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.DigitsMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.ValuesMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Candidates">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.ConjugatePairs">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.ResetGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.ResetCandidatesGrid">
            <summary>
            Gets the grid where all empty cells are filled with all possible candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.UnfixedGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.FixedGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#IsUndefined">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGrid{Sudoku#Snyder#PencilmarkGrid}#FirstMaskRef">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#EmptyString">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#EmptyMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#ModifiableMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#GivenMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#MaxCandidatesMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridConstants{Sudoku#Snyder#PencilmarkGrid}#Undefined">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Item(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Item(Sudoku.Concepts.CellMap@,System.Boolean,System.Char)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridOperations{Sudoku#Snyder#PencilmarkGrid}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.GetExistence(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ConflictWith(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Equals(Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Exists(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Exists(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.CompareTo(Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.GetState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.GetCandidates(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.GetDigit(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Apply(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Fix">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.SetDigit(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.SetExistence(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.SetMask(System.Int32,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.SetState(System.Int32,Sudoku.Concepts.CellState)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Unfix">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ResetCandidates">
            <summary>
            Reset the sudoku grid, but only making candidates to be reset to the initial state related to the current grid
            from given and modifiable values.
            </summary>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.ToCandidateMaskArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Preserve(Sudoku.Concepts.CellMap@)">
            <summary>
            Gets a sudoku grid, removing all value digits not appearing in the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Create(System.ReadOnlySpan{System.Int16})">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int16})"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.TryParse(System.String,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.TryParse(System.String,System.IFormatProvider,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridProperties{Sudoku#Snyder#PencilmarkGrid}#OnValueChanged(Sudoku.Snyder.PencilmarkGrid@,System.Int32,System.Int16,System.Int16,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGridProperties{Sudoku#Snyder#PencilmarkGrid}#OnRefreshingCandidates(Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Sudoku#Concepts#Primitives#IGrid{Sudoku#Snyder#PencilmarkGrid}#Create(System.ReadOnlySpan{System.Int16})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.OnValueChanged(Sudoku.Snyder.PencilmarkGrid@,System.Int32,System.Int16,System.Int16,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.OnValueChanged(Sudoku.Concepts.Grid@,System.Int32,System.Int16,System.Int16,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.OnRefreshingCandidates(Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.OnRefreshingCandidates(Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_Explicit(System.Int16[])~Sudoku.Snyder.PencilmarkGrid">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_CheckedExplicit(System.Int16[])~Sudoku.Snyder.PencilmarkGrid">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_Explicit(Sudoku.Snyder.PencilmarkGrid@)~Sudoku.Concepts.Grid">
            <summary>
            Converts the current instance into a <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="this">A <see cref="T:Sudoku.Concepts.Grid"/> instance converted.</param>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_Equality(Sudoku.Snyder.PencilmarkGrid@,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_Inequality(Sudoku.Snyder.PencilmarkGrid@,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.System#Numerics#IEqualityOperators{Sudoku#Snyder#PencilmarkGrid,Sudoku#Snyder#PencilmarkGrid,System#Boolean}#op_Equality(Sudoku.Snyder.PencilmarkGrid,Sudoku.Snyder.PencilmarkGrid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.System#Numerics#IEqualityOperators{Sudoku#Snyder#PencilmarkGrid,Sudoku#Snyder#PencilmarkGrid,System#Boolean}#op_Inequality(Sudoku.Snyder.PencilmarkGrid,Sudoku.Snyder.PencilmarkGrid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_GreaterThan(Sudoku.Snyder.PencilmarkGrid@,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_LessThan(Sudoku.Snyder.PencilmarkGrid@,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_GreaterThanOrEqual(Sudoku.Snyder.PencilmarkGrid@,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.op_LessThanOrEqual(Sudoku.Snyder.PencilmarkGrid@,Sudoku.Snyder.PencilmarkGrid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.System#Numerics#IComparisonOperators{Sudoku#Snyder#PencilmarkGrid,Sudoku#Snyder#PencilmarkGrid,System#Boolean}#op_GreaterThan(Sudoku.Snyder.PencilmarkGrid,Sudoku.Snyder.PencilmarkGrid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.System#Numerics#IComparisonOperators{Sudoku#Snyder#PencilmarkGrid,Sudoku#Snyder#PencilmarkGrid,System#Boolean}#op_LessThan(Sudoku.Snyder.PencilmarkGrid,Sudoku.Snyder.PencilmarkGrid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.PencilmarkGrid.System#Numerics#IComparisonOperators{Sudoku#Snyder#PencilmarkGrid,Sudoku#Snyder#PencilmarkGrid,System#Boolean}#op_LessThanOrEqual(Sudoku.Snyder.PencilmarkGrid,Sudoku.Snyder.PencilmarkGrid)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Snyder.Converter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Snyder.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Snyder.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Snyder.PencilmarkGrid,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.SolutionFields">
            <summary>
            Provides with solution-wide read-only fields used.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.PeersCount">
            <summary>
            Indicates the number of each cell's peer cells. The value is a constant.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.TrailingZeroCountFallback">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L586">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>
        </member>
        <member name="F:Sudoku.SolutionFields.TrailingZeroCountFallbackLong">
            <summary>
            Indicates the invalid fallback value
            of methods <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>,
            which means that if the method returns an invalid value, that value must be equal to this.
            In other words, you can use this field to check whether the method invocation executes correctly.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/d4a59b36c679712b74eccf98deb1a362cdbaa6b1/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L647">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int64)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt64)"/>
        </member>
        <member name="F:Sudoku.SolutionFields.Digits">
            <summary>
            Indicates the digits used. The value can be also used for ordered houses by rows.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesOrderedByColumn">
            <summary>
            Indicates the houses ordered by column.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseFirst">
            <summary>
            Indicates the first cell offset for each house.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesCells">
            <summary>
            <para>
            The map of all cell offsets in its specified house.
            The indices is between 0 and 26, where:
            <list type="table">
            <item>
            <term><c>0..9</c></term>
            <description>Block 1 to 9.</description>
            </item>
            <item>
            <term><c>9..18</c></term>
            <description>Row 1 to 9.</description>
            </item>
            <item>
            <term><c>18..27</c></term>
            <description>Column 1 to 9.</description>
            </item>
            </list>
            </para>
            </summary>
            <example>
            '<c>HouseCells[0]</c>': all cell offsets in the house 0 (block 1).
            </example>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the cells belong to a house at the specified index.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.PeersMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the peer cells of a cell at the specified index.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.Chutes">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.Chute"/> instances representing chutes.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ChuteHouses">
            <summary>
            Indicates the chute house triplets.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseTypes">
            <summary>
            Indicates the possible house types to be iterated.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.BlockTable">
            <summary>
            Indicates a block list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.RowTable">
            <summary>
            Indicates a row list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ColumnTable">
            <summary>
            Indicates a column list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.CellMaps">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances that are initialized as singleton element by its corresponding index.
            For example, <c>CellMaps[0]</c> is to <c>CellMap.Empty + 0</c>, i.e. <c>r1c1</c>.
            </summary>
        </member>
        <member name="M:Sudoku.SolutionFields.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.SudokuType">
            <summary>
            Represents a type of sudoku puzzle.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.SudokuType.None">
            <summary>
            The placeholder of the enumeration field.
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.Standard">
            <summary>
            Indicates the sudoku puzzle is a standard.
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.Sukaku">
            <summary>
            Indicates the sudoku puzzle is a sukaku (pencilmark sudoku).
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.JustOneCell">
            <summary>
            Indicates the sudoku puzzle is a just-one-cell sudoku.
            </summary>
        </member>
        <member name="T:Sudoku.SymmetricType">
            <summary>
            Represents a symmetric type that can describe which one a pattern or a puzzle uses.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.SymmetricType.None">
            <summary>
            Indicates none of symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.Central">
            <summary>
            Indicates the central symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.Diagonal">
            <summary>
            Indicates the diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.AntiDiagonal">
            <summary>
            Indicates the anti-diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.XAxis">
            <summary>
            Indicates the x-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.YAxis">
            <summary>
            Indicates the y-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.AxisBoth">
            <summary>
            Indicates both X-axis and Y-axis symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.DiagonalBoth">
            <summary>
            Indicates both diagonal and anti-diagonal symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.All">
            <summary>
            Indicates all symmetry types should be satisfied.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_4.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_5.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_6.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_7">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitHousePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitHousePattern_7.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_7.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitIntersectionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_8.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitMegaLineGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_9.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_10.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_11">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_11.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_11.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserDigitPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_12.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSimpleMultilinePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_13.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridOpenSudokuPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_14.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridPencilmarkPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_15.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSukakuSegmentPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_16.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_17">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_17.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_17.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridShortenedSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_18.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_19">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EliminationPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EliminationPattern_19.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_19.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_20">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the AuthorPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.AuthorPattern_20.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_21">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the NamePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.NamePattern_21.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_22">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the DescriptionPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.DescriptionPattern_22.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_23">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the TagsPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.TagsPattern_23.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfAnyDecimalDigitNumberDecimalDigitNumber(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_3BCFC31BFB1AD1127D0564F4B3C20ECED086F1C7438F92ACB58165A04BF23DD9(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*+-&lt;\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_5C1843170313CB42CA4CF4E0FCD6C277723EAACCD85464A69BFC7D367CF48212(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_65EF16F1D4CC2684453DF3C3240E17C0787C2CE3C7B9F2FA94357B7AEAC8AC3F(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_85D9C34033677881D8993C4388EDB85FC6297ECDBC9E515FF9B602A26978DF84(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+-\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_CD2F1FA646F2680322897C0F819061CC86FEA149AFB0FCC253B807E2A597D6F4(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.[\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPop(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Pops 2 values from the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
            <summary>Pushes 1 value onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
            <summary>Pushes 2 values onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>Pushes 3 values onto the backtracking stack.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_asciiExceptDigits">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_800040008000400">
            <summary>Supports searching for characters in or not in "CRcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_C0004000C000400">
            <summary>Supports searching for characters in or not in "BCRbcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FE030000040000000400">
            <summary>Supports searching for characters in or not in "123456789Rr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFF7FFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFBB00FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()+,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD300ECFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'(),./:;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_2A5C7CB5C5EA60F740A02641A8398F270EECFAE3E391275B7CA8825E54AEF43F">
            <summary>Supports searching for the string "tags:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_B93F57C81E7BC3D17E6BACB73234905ED727D8DBC6420C920732A104F34ABE4E">
            <summary>Supports searching for the string "author:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_CC0D98E295A1BFFD6A5A197296B027720BD9191B4F333F50A06E1E23E638A7BB">
            <summary>Supports searching for the string "name:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_F5B4B618DDAAC8F27D5E849B92B2FD846490C682FCB36D3610B6BE0C05EA79E5">
            <summary>Supports searching for the string "description:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_nonAscii_F399137324019CEE8DA2E2200E10D0083E7A4C31A2E981061D50385C16616C8A">
            <summary>Supports searching for characters in or not in "ABCDEFGHIJKabcdefghijkK".</summary>
        </member>
    </members>
</doc>

<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Core</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Behaviors.Diff.DiffAnalysis">
            <summary>
            Provides a way to analyze difference between two grids.
            </summary>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffAnalysis.TryAnalyzeDiff(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@,Sudoku.Behaviors.Diff.DiffResult@)">
            <summary>
            Try to analyze difference between two grids if they have a same initial grid (with same digits from given cells).
            </summary>
            <param name="left">Indicates the first grid to be checked.</param>
            <param name="right">Indicates the second grid to be checked.</param>
            <param name="result">A <see cref="T:Sudoku.Behaviors.Diff.DiffResult"/> result indicating the difference result.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether two grids have a same initial grid.</returns>
            <remarks>
            It's not necessary to check validity of two grids <paramref name="left"/> and <paramref name="right"/> in this method,
            but it might be failed to check in some difference cases; no exceptions will be thrown in this method,
            except for some severe errors should be reported.
            </remarks>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.DiffResult">
            <summary>
            Represents a difference result.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.DiffResult.NotationPrefix">
            <summary>
            Indicates the notation prefix.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.DiffResult.Notation">
            <summary>
            Indicates the simplified notation of the current difference result.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.DiffResult.Type">
            <summary>
            Indicates the type of the difference.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.DiffResult.EqualityContract">
            <summary>
            Indicates the target type.
            </summary>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.Equals(Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.ToString(System.String)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
            <exception cref="T:System.FormatException">Throws when the format argument is invalid.</exception>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.Clone">
            <inheritdoc cref="M:System.ICloneable.Clone"/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.op_Equality(Sudoku.Behaviors.Diff.DiffResult,Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.DiffResult.op_Inequality(Sudoku.Behaviors.Diff.DiffResult,Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.DiffType">
            <summary>
            Represents a difference type.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.NothingChanged">
            <summary>
            Indicates two grids are same.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.AddGiven">
            <summary>
            Indicates given digits are added.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.AddModifiable">
            <summary>
            Indicates modifiable digits are added.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.AddCandidate">
            <summary>
            Indicates candidate digits are added.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.RemoveGiven">
            <summary>
            Indicates given digits are removed.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.RemoveModifiable">
            <summary>
            Indicates modifiable digits are removed.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.RemoveCandidate">
            <summary>
            Indicates candidate digits are removed.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.ChangedGiven">
            <summary>
            Indicates given digits are changed.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.ChangedModifiable">
            <summary>
            Indicates modifiable digits are changed.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.ChangedCandidate">
            <summary>
            Indicates candidate digits are changed.
            </summary>
        </member>
        <member name="F:Sudoku.Behaviors.Diff.DiffType.Reset">
            <summary>
            Indicates the second grid is the reset grid of the first one.
            </summary>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.GridDiffTooMuchException">
            <summary>
            Represents an exception that describes two grids are different, and cannot analyze difference between them.
            </summary>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.AddCandidateDiffResult">
            <summary>
            Represents a difference that describes a list of candidate digits are added.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
            <param name="areCorrect"><inheritdoc path="/param[@name='areCorrect']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddCandidateDiffResult.#ctor(Sudoku.Concepts.CandidateMap,System.Boolean)">
            <summary>
            Represents a difference that describes a list of candidate digits are added.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
            <param name="areCorrect"><inheritdoc path="/param[@name='areCorrect']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddCandidateDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddCandidateDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddCandidateDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddCandidateDiffResult.CellTypeString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddCandidateDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.AddDiffResult">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is added.
            </summary>
            <param name="candidates">
            <inheritdoc cref="M:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.#ctor(Sudoku.Concepts.CandidateMap)" path="/param[@name='candidates']"/>
            </param>
            <param name="areCorrect">Indicates whether the digits are correct to be added.</param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddDiffResult.#ctor(Sudoku.Concepts.CandidateMap,System.Boolean)">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is added.
            </summary>
            <param name="candidates">
            <inheritdoc cref="M:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.#ctor(Sudoku.Concepts.CandidateMap)" path="/param[@name='candidates']"/>
            </param>
            <param name="areCorrect">Indicates whether the digits are correct to be added.</param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddDiffResult.Equals(Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddDiffResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddDiffResult.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddDiffResult.AreCorrect">
            <summary>
            The generated property declaration for parameter <c>areCorrect</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.AddGivenDiffResult">
            <summary>
            Represents a difference that describes a list of given digits are added.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
            <param name="areCorrect"><inheritdoc path="/param[@name='areCorrect']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddGivenDiffResult.#ctor(Sudoku.Concepts.CandidateMap,System.Boolean)">
            <summary>
            Represents a difference that describes a list of given digits are added.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
            <param name="areCorrect"><inheritdoc path="/param[@name='areCorrect']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddGivenDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddGivenDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddGivenDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddGivenDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.AddModifiableDiffResult">
            <summary>
            Represents a difference that describes a list of modifiable digits are added.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
            <param name="areCorrect"><inheritdoc path="/param[@name='areCorrect']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddModifiableDiffResult.#ctor(Sudoku.Concepts.CandidateMap,System.Boolean)">
            <summary>
            Represents a difference that describes a list of modifiable digits are added.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
            <param name="areCorrect"><inheritdoc path="/param[@name='areCorrect']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddModifiableDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddModifiableDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.AddModifiableDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.AddModifiableDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.ChangedCandidateDiffResult">
            <summary>
            Represents a difference that describes a list of candidate digits is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedCandidateDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a list of candidate digits is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedCandidateDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedCandidateDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedCandidateDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedCandidateDiffResult.CellTypeString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedCandidateDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.ChangedDiffResult">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedDiffResult.Equals(Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedDiffResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedDiffResult.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.ChangedGivenDiffResult">
            <summary>
            Represents a difference that describes a list of given digits is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedGivenDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a list of given digits is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedGivenDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedGivenDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedGivenDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedGivenDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.ChangedModifiableDiffResult">
            <summary>
            Represents a difference that describes a list of modifiable digits is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedModifiableDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a list of modifiable digits is changed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedModifiableDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedModifiableDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ChangedModifiableDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ChangedModifiableDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult">
            <summary>
            Represents a result that describes two grids are same.
            </summary>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult.#ctor">
            <summary>
            Represents a result that describes two grids are same.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult.Notation">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult.Equals(Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.NothingChangedDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.RemoveCandidateDiffResult">
            <summary>
            Represents a difference that describes a list of candidate digits is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveCandidateDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a list of candidate digits is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveCandidateDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveCandidateDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveCandidateDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveCandidateDiffResult.CellTypeString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveCandidateDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.RemoveDiffResult">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveDiffResult.Equals(Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveDiffResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveDiffResult.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.RemoveGivenDiffResult">
            <summary>
            Represents a difference that describes a list of given digits is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveGivenDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a list of given digits is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveGivenDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveGivenDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveGivenDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveGivenDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.RemoveModifiableDiffResult">
            <summary>
            Represents a difference that describes a list of modifiable digits is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveModifiableDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a list of modifiable digits is removed.
            </summary>
            <param name="candidates"><inheritdoc path="/param[@name='candidates']"/></param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveModifiableDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveModifiableDiffResult.CellType">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.RemoveModifiableDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.RemoveModifiableDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.ResetDiffResult">
            <summary>
            Represents a difference result that describes candidates are reset.
            </summary>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ResetDiffResult.#ctor">
            <summary>
            Represents a difference result that describes candidates are reset.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ResetDiffResult.Notation">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.ResetDiffResult.Type">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ResetDiffResult.Equals(Sudoku.Behaviors.Diff.DiffResult)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ResetDiffResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ResetDiffResult.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.ResetDiffResult.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is updated.
            </summary>
            <param name="candidates">Indicates the candidates to be updated.</param>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.#ctor(Sudoku.Concepts.CandidateMap)">
            <summary>
            Represents a difference that describes a type of digits (given, value or candidate) is updated.
            </summary>
            <param name="candidates">Indicates the candidates to be updated.</param>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.NotationPrefix">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.Notation">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.CellType">
            <summary>
            Indicates the target cell type to be added.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.CandidatesRawString">
            <summary>
            Indicates the candidates string.
            </summary>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.CellTypeString">
            <summary>
            Indicates the target cell type string.
            </summary>
        </member>
        <member name="M:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Behaviors.Diff.Results.UpdatedDiffResult.Candidates">
            <summary>
            The generated property declaration for parameter <c>candidates</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap">
            <summary>
            Encapsulates a binary series of candidate state table.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.BackingBuffer">
            <summary>
            Indicates the internal buffer type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.BackingBuffer._firstElement">
            <summary>
            Indicates the first element of the whole buffer.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.BackingBuffer.Vectors">
            <summary>
            Returns a sequence of <see cref="T:System.Runtime.Intrinsics.Vector256`1"/> of <see cref="T:System.UInt64"/> values that can be used in SIMD scenarios.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.Equals(Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#IEquatable{Sudoku#Concepts#CandidateMap#BackingBuffer}#Equals(Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.op_Equality(Sudoku.Concepts.CandidateMap.BackingBuffer@,Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.op_Inequality(Sudoku.Concepts.CandidateMap.BackingBuffer@,Sudoku.Concepts.CandidateMap.BackingBuffer@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#BackingBuffer,Sudoku#Concepts#CandidateMap#BackingBuffer,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap.BackingBuffer,Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.BackingBuffer.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap#BackingBuffer,Sudoku#Concepts#CandidateMap#BackingBuffer,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap.BackingBuffer,Sudoku.Concepts.CandidateMap.BackingBuffer)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.CellDigitEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="_candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that can iterate on each candidate of the collection,
            with its cell and digit value in the target tuple.
            </summary>
            <param name="_candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellDigitEnumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.GetEnumerator">
            <summary>
            Returns itself, in order to iterate the value using <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator itself.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellDigitEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.CellEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each cell of the collection.
            </summary>
            <param name="_candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that can iterate on each cell of the collection.
            </summary>
            <param name="_candidates">Indicates the candidate offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.CellEnumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellEnumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.GetEnumerator">
            <summary>
            Returns itself, in order to iterate the value using <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator itself.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CellEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.Converter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CandidateMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Length">
            <summary>
            Indicates the length of the backing buffer.
            The size of the buffer is 12 <c><![CDATA[floor(729 / sizeof(long) << 6)]]></c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Full">
            <inheritdoc cref="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Full"/>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap._bits">
            <summary>
            Indicates the internal field that provides the visit entry for fixed-sized buffer type <see cref="T:Sudoku.Concepts.CandidateMap.BackingBuffer"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap.BackingBuffer"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via a list of candidate offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The candidate offsets, represented as a RxCy notation.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.ReadOnlySpan{System.String},Sudoku.Concepts.Coordinates.CoordinateParser)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via a list of candidate offsets represented as the specified notation.
            </summary>
            <param name="segments">The candidate offsets, represented as a RxCy notation.</param>
            <param name="parser">The parser.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.#ctor(System.Int32,System.Boolean)">
            <summary>
            Indicates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance with the peer candidates of the specified candidate and a <see cref="T:System.Boolean"/>
            value indicating whether the map will process itself with <see langword="true"/> value.
            </summary>
            <param name="candidate">The candidate.</param>
            <param name="withItself">Indicates whether the map will process itself with <see langword="true"/> value.</param>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Digits">
            <summary>
            Indicates the digits used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Cells">
            <summary>
            Indicates the cells used in this pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.DigitDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by digit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.CellDistribution">
            <summary>
            Returns a <see cref="T:System.Collections.Frozen.FrozenDictionary`2"/> that describes the distribution of digits appeared in cells, grouped by cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CandidateMap,System#Int32,Sudoku#Concepts#CandidateMap#Enumerator}#Full">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="item">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CompareTo(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToArrayUnsafe">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.ToArray"/>
            <remarks><b><i>
            Although the return value is an array, you cannot modify them to keep data-safety (read-only array).
            Returning other types of such value will raise extra conversion, which is slower.
            </i></b></remarks>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetDigitsFor(System.Int32)">
            <summary>
            Try to get digits that is in the current collection.
            </summary>
            <param name="cell">The desired cell.</param>
            <returns>The digits.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.EnumerateCells">
            <summary>
            Try to enumerate cells on each candidate.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.EnumerateCellDigit">
            <summary>
            Try to enumerate cell and digit value on each candidate.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Add(System.Int32)">
            <summary>
            Add a new <see cref="T:System.Int32"/> into the collection.
            </summary>
            <param name="item">The offset to be added.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Remove(System.Int32)">
            <summary>
            Removes the specified offset from the current collection.
            </summary>
            <param name="item">An offset to be removed.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the specified offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveCell(System.Int32)">
            <summary>
            Remove all <see cref="T:System.Int32"/> instances that is equal to the argument <paramref name="cell"/>.
            </summary>
            <param name="cell">The cell to be removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Toggle(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Clear">
            <summary>
            Remove all elements stored in the current collection, and set the property <see cref="P:Sudoku.Concepts.CandidateMap.Count"/> to zero.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CandidateMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Any(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CandidateMap,System#Int32}#All(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CandidateMap,System#Int32}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CandidateMap,System#Int32}#First(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#IGroupByMethod{Sudoku#Concepts#CandidateMap,System#Int32}#GroupBy``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#CandidateMap,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CandidateMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance via the specified candidates.
            </summary>
            <param name="candidates">The candidates.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.CreateByVectors(System.Runtime.Intrinsics.Vector256{System.UInt64}@,System.Runtime.Intrinsics.Vector256{System.UInt64}@,System.Runtime.Intrinsics.Vector256{System.UInt64}@)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> via a triplet of <see cref="T:System.Runtime.Intrinsics.Vector256`1"/> of <see cref="T:System.UInt64"/> values.
            </summary>
            <param name="e0">The lower 256 bits.</param>
            <param name="e1">The middle 256 bits.</param>
            <param name="e2">The higher 256 bits.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_OnesComplement(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Addition(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Subtraction(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Modulus(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_ExclusiveOr(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseAnd(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_BitwiseOr(Sudoku.Concepts.CandidateMap@,System.Range)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Division(Sudoku.Concepts.CandidateMap@,System.Int32)">
            <summary>
            Reduces the <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, only checks for candidates
            whose digit is equal to argument <paramref name="digit"/>,
            and merge into a <see cref="T:Sudoku.Concepts.CellMap"/> value.
            </summary>
            <param name="candidates">The candidates to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="_offsets">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each candidate offsets.
            </summary>
            <param name="_offsets">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CandidateMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Equality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_Inequality(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Equality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_GreaterThan(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LessThan(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_GreaterThanOrEqual(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LessThanOrEqual(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_GreaterThan(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_LessThan(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CandidateMap,Sudoku#Concepts#CandidateMap,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_True(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_True(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_False(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_False(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#ILogicalOperators{Sudoku#Concepts#CandidateMap}#op_True(Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#ILogicalOperators{Sudoku#Concepts#CandidateMap}#op_False(Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.op_LogicalNot(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_LogicalNot(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#ILogicalOperators{Sudoku#Concepts#CandidateMap}#op_LogicalNot(Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.Equals(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMap.System#IEquatable{Sudoku#Concepts#CandidateMap}#Equals(Sudoku.Concepts.CandidateMap)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CandidateMarshal">
            <summary>
            Represents methods that operates with <see cref="T:System.Int32"/> values.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Int32)">
            <summary>
            Converts the specified <see cref="T:System.Int32"/> into a singleton <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="this">The cell to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, containing only one element of <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})">
            <summary>
            Converts the specified list of <see cref="T:System.Int32"/> instances into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <param name="this">The cells to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, containing all elements come from <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.ReadOnlySpan{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.CandidateMarshal.AsCandidateMap(System.Span{System.Int32})"/>
        </member>
        <member name="T:Sudoku.Concepts.CellMap">
            <summary>
            Encapsulates a binary series of cell state table.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.CellMap.Converter">
            <summary>
            Indicates the JSON converter of <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.CellMap,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Shifting">
            <inheritdoc cref="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Shifting"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Full">
            <inheritdoc cref="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Full"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.BitwiseNotConstant">
            <summary>
            Indicates the constant that will be used on bitwise not operation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.SharedHouseConstants">
            <summary>
            Indicates the <see cref="T:System.Runtime.Intrinsics.Vector128`1"/> instances to be used for checking shared houses.
            </summary>
            <seealso cref="T:System.Runtime.Intrinsics.Vector128`1"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.SharedHouseFactorValues">
            <summary>
            Indicates the factor values for property <see cref="P:Sudoku.Concepts.CellMap.SharedHouses"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CellMap.SharedHouses"/>
        </member>
        <member name="F:Sudoku.Concepts.CellMap._vector">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. Higher 40 bits and lower 41 bits, where each bit is:
            <list type="table">
            <item>
            <term><see langword="true"/> bit (1)</term>
            <description>The corresponding cell is contained in this collection</description>
            </item>
            <item>
            <term><see langword="false"/> bit (0)</term>
            <description>The corresponding cell is not contained in this collection</description>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.#ctor(System.String[])">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a list of offsets represented as a RxCy notation.
            </summary>
            <param name="segments">The cell offsets, represented as a RxCy notation.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.#ctor(System.ReadOnlySpan{System.String},Sudoku.Concepts.Coordinates.CoordinateParser)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.CellMap"/> instance via a list of offsets represented as the specified notation.
            </summary>
            <param name="segments">The cell offsets, represented as a RxCy notation.</param>
            <param name="parser">The parser used.</param>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.IsInIntersection">
            <summary>
            Determines whether the current list of cells are all lie in an intersection area, i.e. a locked candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.CanSeeEachOther">
            <summary>
            Indicates whether every cell in the current collection cannot see each other.
            </summary>
            <remarks><b>
            Please note that this property will return <see langword="false"/> if there's no cells or 1 cell in the current collection.
            </b></remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.StringChunks">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.BlockMask">
            <summary>
            Indicates the mask of block that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned blocks are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.RowMask">
            <summary>
            Indicates the mask of row that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned rows are 0 and 3, so the return mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ColumnMask">
            <summary>
            Indicates the mask of column that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>[0, 1, 27, 28]</c>, all spanned columns are 0 and 1, so the return mask is <c>0b000000011</c> (i.e. 3).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.SharedBlock">
            <summary>
            Indicates the shared block.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.SharedLine">
            <summary>
            Indicates the shared line, i.e. a line of 9 cells that contain all possible cells stored in the current collection.
            </summary>
            <remarks><b>
            Please note that the result value may be invalid if no shared houses can be found.
            In such case, the return value will be 32 (instead of -1, intuitive value).
            </b></remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.FirstSharedHouse">
            <summary>
            Indicates the first shared house returned.
            </summary>
            <remarks>
            A shared house is a house of 9 cells that contain all possible cells stored in the current collection.
            For example, cells <c>r1c25</c> is lying in row 1, the return value will be 9 (index of row 1).
            However, <b>if the collection has no cells, the return value will be 32</b> (not -1).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.SharedHouses">
            <summary>
            Indicates all houses shared. This property is used to check all houses that all cells of this instance shared.
            For example, if the cells are <c>[0, 1]</c>, the property <see cref="P:Sudoku.Concepts.CellMap.SharedHouses"/> will return
            house indices 0 (block 1) and 9 (row 1); however, if cells span two houses or more (e.g. cells <c>[0, 1, 27]</c>),
            this property won't contain any houses.
            </summary>
            <remarks>
            The return value will be a <see cref="T:System.Int32"/> value indicating each houses. Bits set 1 are shared houses.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Houses">
            <summary>
            All houses that the map spanned. This property is used to check all houses that all cells of
            this instance spanned. For example, if the cells are <c>[0, 1]</c>, the property
            <see cref="P:Sudoku.Concepts.CellMap.Houses"/> will return the house index 0 (block 1), 9 (row 1), 18 (column 1)
            and 19 (column 2).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Symmetry">
            <summary>
            Try to get the symmetric type of the pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.ExpandedPeers">
            <summary>
            Gets the expanded peers of the current map.
            </summary>
            <remarks>
            An <b>Expanded Peers</b> is a list of cells that contains all peer cells of each cell
            appeared in the current collection. For example, if a collection contains cells <c>r1c123</c>,
            this collection will be the result of the expression <c>PeersMap[r1c1] | PeersMap[r1c2] | PeersMap[r1c3]</c>,
            where the member <c>PeersMap</c> corresponds to the array <see cref="P:Sudoku.SolutionFields.PeersMap"/>.
            </remarks>
            <seealso cref="P:Sudoku.SolutionFields.PeersMap"/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.PeerIntersection">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Shifting">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Offsets">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#MaxCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Sudoku#Concepts#ICellMapOrCandidateMap{Sudoku#Concepts#CellMap,System#Int32,Sudoku#Concepts#CellMap#Enumerator}#Full">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CopyTo(System.Int32@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ForEach(System.Action{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="item">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc cref="M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc cref="M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CompareTo(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.IndexOf(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToArrayUnsafe">
            <inheritdoc cref="M:Sudoku.Concepts.CellMap.ToArray"/>
            <remarks><b><i>
            Although the return value is an array, you cannot modify them to keep data-safety (read-only array).
            Returning other types of such value will raise extra conversion, which is slower.
            </i></b></remarks>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Add(System.Int32)">
            <summary>
            Add a new <see cref="T:System.Int32"/> into the collection.
            </summary>
            <param name="item">The offset to be added.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.AddRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Remove(System.Int32)">
            <summary>
            Removes the specified offset from the current collection.
            </summary>
            <param name="item">An offset to be removed.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the collection has already contained the specified offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.RemoveRange(System.ReadOnlySpan{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Toggle(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Clear">
            <summary>
            Remove all elements stored in the current collection, and set the property <see cref="P:Sudoku.Concepts.CellMap.Count"/> to zero.
            </summary>
            <seealso cref="P:Sudoku.Concepts.CellMap.Count"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#Any(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#CellMap,System#Int32}#All(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CellMap,System#Int32}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IFirstLastMethod{Sudoku#Concepts#CellMap,System#Int32}#First(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#CellMap,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#IGroupByMethod{Sudoku#Concepts#CellMap,System#Int32}#GroupBy``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#CellMap,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CellMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance via the specified cells.
            </summary>
            <param name="cells">The cells.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.UInt64,System.UInt64)">
            <summary>
            Initializes an instance with two binary values.
            </summary>
            <param name="high">Higher 40 bits.</param>
            <param name="low">Lower 41 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByBits(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes an instance with three binary values.
            </summary>
            <param name="high">Higher 27 bits.</param>
            <param name="mid">Medium 27 bits.</param>
            <param name="low">Lower 27 bits.</param>
            <returns>The result instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CreateByVector(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Initializes an instance with a <see cref="T:System.Runtime.Intrinsics.Vector128`1"/> of <see cref="T:System.Int64"/>.
            </summary>
            <param name="vector">Two bits, represented as high 41 and low 40 bits.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.CV(System.UInt64,System.UInt64)">
            <summary>
            Creates a <see cref="T:System.Runtime.Intrinsics.Vector128`1"/> of <see cref="T:System.UInt64"/> instance.
            </summary>
            <param name="e1">The higher 64 bits.</param>
            <param name="e0">The lower 64 bits.</param>
            <returns>A <see cref="T:System.Runtime.Intrinsics.Vector128`1"/> of <see cref="T:System.UInt64"/> instance.</returns>
            <remarks><b>
            This method will only be used in constant creation, just for readability on binary integers' positions.
            </b></remarks>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_OnesComplement(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Addition(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Subtraction(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Modulus(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_ExclusiveOr(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseAnd(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_BitwiseOr(Sudoku.Concepts.CellMap@,System.Range)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Multiply(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Expands the current <see cref="T:Sudoku.Concepts.CellMap"/> instance, inserting into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance by specified digit.
            </summary>
            <param name="cells">The cells to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Division(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Reduces the <see cref="T:Sudoku.Concepts.CellMap"/> instances, only checks for cells in the specified cells, and merge into a <see cref="T:System.Int16"/> value.
            </summary>
            <param name="cells">The cells to be checked.</param>
            <param name="house">The house to be checked.</param>
            <returns>A <see cref="T:System.Int16"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CellMap.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="_offset">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="_offset">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.CellMap.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Equality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_Inequality(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Equality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IEqualityOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_Inequality(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThan(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_GreaterThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LessThanOrEqual(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_GreaterThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThan(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#Numerics#IComparisonOperators{Sudoku#Concepts#CellMap,Sudoku#Concepts#CellMap,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.CellMap,Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_True(Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_True(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_False(Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_False(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#ILogicalOperators{Sudoku#Concepts#CellMap}#op_True(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#ILogicalOperators{Sudoku#Concepts#CellMap}#op_False(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.op_LogicalNot(Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_LogicalNot(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#ILogicalOperators{Sudoku#Concepts#CellMap}#op_LogicalNot(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.Equals(Sudoku.Concepts.CellMap@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMap.System#IEquatable{Sudoku#Concepts#CellMap}#Equals(Sudoku.Concepts.CellMap)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.CellMapOrCandidateMapPredicate`3">
            <summary>
            Represents a method that checks for an offset of type <typeparamref name="TElement" />
            in the collection of type <typeparamref name="TSelf" />, referenced from <paramref name="grid" />,
            determining whether the offset satisfies the specified condition.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="TElement">
            The type of each element in the collection of type <typeparamref name="TSelf" />.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <param name="offset">The <typeparamref name="TElement" /> offset value to be checked.</param>
            <param name="grid">The grid as candidate reference.</param>
            <returns>A <see cref="T:System.Boolean" /> result indicating that.</returns>
        </member>
        <member name="T:Sudoku.Concepts.CellMarshal">
            <summary>
            Represents a list of extension methods that operates with cell instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.CopyHouseInfo(System.Int32,System.Int32@)">
            <summary>
            Gets the row, column and block value and copies to the specified array that represents by a pointer
            of 3 elements, where the first element stores the block index, second element stores the row index
            and the third element stores the column index.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="reference">
            The specified reference to the first element in a sequence. The sequence type can be an array or a <see cref="T:System.Span`1"/>,
            only if the sequence can store at least 3 values.
            </param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="reference"/> references to <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouse(System.Byte,Sudoku.Concepts.HouseType)">
            <summary>
            Get the house index (0..27 for block 1-9, row 1-9 and column 1-9)
            for the specified cell and the house type.
            </summary>
            <param name="this">The cell. The available values must be between 0 and 80.</param>
            <param name="houseType">The house type.</param>
            <returns>The house index. The return value must be between 0 and 26.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="houseType"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouse(System.Int32,Sudoku.Concepts.HouseType)">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.ToHouse(System.Byte,Sudoku.Concepts.HouseType)"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToHouseIndices(System.Int32)">
            <summary>
            Get the house indices for the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>A <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToBand(System.Int32)">
            <summary>
            Try to get the band index (mega-row) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.ToTower(System.Int32)">
            <summary>
            Try to get the tower index (mega-column) of the specified cell.
            </summary>
            <param name="this">The cell.</param>
            <returns>The chute index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Int32)">
            <summary>
            Converts the specified <see cref="T:System.Int32"/> into a singleton <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="this">The cell to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance, containing only one element of <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})">
            <summary>
            Converts the specified list of <see cref="T:System.Int32"/> instances into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="this">The cells to be converted.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance, containing all elements come from <paramref name="this"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.ReadOnlySpan{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.CellMarshal.AsCellMap(System.Span{System.Int32})"/>
        </member>
        <member name="T:Sudoku.Concepts.CellState">
            <summary>
            Represents a cell state.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Empty">
            <summary>
            Indicates that the cell is empty.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Modifiable">
            <summary>
            Indicates the current cell has been filled a value that is not given from initial grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellState.Given">
            <summary>
            Indicates the current cell has been filled a value that cannot be modified because it exists in initial grid.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Chute">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="M:Sudoku.Concepts.Chute.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>
            Defines a chute.
            </summary>
            <param name="Index">Index of the chute. The value is between 0 and 6.</param>
            <param name="IsRow">Indicates whether the chute is in a mega-row.</param>
            <param name="HousesMask">Indicates the houses used.</param>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Index">
            <summary>Index of the chute. The value is between 0 and 6.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.IsRow">
            <summary>Indicates whether the chute is in a mega-row.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.HousesMask">
            <summary>Indicates the houses used.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Chute.Cells">
            <summary>
            Indicates the cells in this chute.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Chute.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.TryParse(System.String,Sudoku.Concepts.Chute@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Chute@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Chute.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Conclusion">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-------------------|---|---------------------------------------|
            |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-------------------|---|---------------------------------------'
                                 \_/ \_____________________________________/
                                 (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1),
            but the real type <see cref="P:Sudoku.Concepts.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type
            because C# cannot set "A bit" to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type,
            but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.Conclusion.Converter">
            <summary>
            Represents a JSON converter for type <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Conclusion,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(System.Int16)">
            <summary>
            Defines a type that can describe a candidate is the correct or wrong digit.
            </summary>
            <param name="mask">
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 15  14  13  12  11  10| 9   8   7   6   5   4   3   2   1   0 |
            |-------------------|---|---------------------------------------|
            |   |   |   |   |   | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
            '-------------------|---|---------------------------------------'
                                 \_/ \_____________________________________/
                                 (2)                   (1)
            </code>
            Where (1) is for candidate offset value (from 0 to 728), and (2) is for the conclusion type (assignment or elimination).
            Please note that the part (2) only use one bit because the target value can only be assignment (0) or elimination (1),
            but the real type <see cref="P:Sudoku.Concepts.Conclusion.ConclusionType"/> uses <see cref="T:System.Byte"/> as its underlying numeric type
            because C# cannot set "A bit" to be the underlying type. The narrowest type is <see cref="T:System.Byte"/>.
            </param>
            <remarks>
            Two <see cref="T:System.Int16"/> values can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> as the type), the instance will be greater;
            if those two hold same conclusion type,
            but one of those two holds the global index of the candidate position is greater, it is greater.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(Sudoku.Concepts.ConclusionType,System.Int32)">
            <summary>
            Initializes an instance with a conclusion type and a candidate offset.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="candidate">The candidate offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.#ctor(Sudoku.Concepts.ConclusionType,System.Int32,System.Int32)">
            <summary>
            Initializes the <see cref="T:Sudoku.Concepts.Conclusion"/> instance via the specified cell, digit and the conclusion type.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Cell">
            <summary>
            Indicates the cell the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Digit">
            <summary>
            Indicates the digit the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.Candidate">
            <summary>
            Indicates the candidate the current instance uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conclusion.ConclusionType">
            <summary>
            Indicates the conclusion type of the current instance.
            If the type is <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/>, this conclusion will be set value (Set a digit into a cell);
            otherwise, a candidate will be removed.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Deconstruct(Sudoku.Concepts.ConclusionType@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Deconstruct(Sudoku.Concepts.ConclusionType@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.CompareTo(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.GetSymmetricConclusion(Sudoku.SymmetricType,System.Int32)">
            <summary>
            Try to get a new <see cref="T:Sudoku.Concepts.Conclusion"/> instance which is symmetric with the current instance, with the specified symmetric type.
            </summary>
            <param name="symmetricType">The symmetric type to be checked.</param>
            <param name="mappingDigit">The other mapping digit.</param>
            <returns>The other symmetric <see cref="T:Sudoku.Concepts.Conclusion"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="symmetricType"/> contains multiple (greater than 2) cells
            symmetric with the current cell and digit.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.TryParse(System.String,Sudoku.Concepts.Conclusion@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Conclusion@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_OnesComplement(Sudoku.Concepts.Conclusion)">
            <summary>
            Negates the current conclusion instance, changing the conclusion type from <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/> to <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/>,
            or from <see cref="F:Sudoku.Concepts.ConclusionType.Elimination"/> to <see cref="F:Sudoku.Concepts.ConclusionType.Assignment"/>.
            </summary>
            <param name="self">The current conclusion instance to be negated.</param>
            <returns>The negation.</returns>
        </member>
        <member name="F:Sudoku.Concepts.Conclusion._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_Equality(Sudoku.Concepts.Conclusion,Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.op_Inequality(Sudoku.Concepts.Conclusion,Sudoku.Concepts.Conclusion)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conclusion.Equals(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionExtensions.AsSet(Sudoku.Concepts.Conclusion[])">
            <summary>
            Converts the <see cref="T:Sudoku.Concepts.Conclusion"/> array into a <see cref="T:Sudoku.Concepts.ConclusionSet"/> instance.
            </summary>
            <param name="this">The conclusion array.</param>
            <returns>A <see cref="T:Sudoku.Concepts.ConclusionSet"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionExtensions.AsSet(System.ReadOnlyMemory{Sudoku.Concepts.Conclusion})">
            <inheritdoc cref="M:Sudoku.Concepts.ConclusionExtensions.AsSet(Sudoku.Concepts.Conclusion[])"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionExtensions.AsSet(System.ReadOnlySpan{Sudoku.Concepts.Conclusion})">
            <inheritdoc cref="M:Sudoku.Concepts.ConclusionExtensions.AsSet(Sudoku.Concepts.Conclusion[])"/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionSet">
            <summary>
            Represents a list of conclusions.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.BitsCount">
            <summary>
            The total length of bits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.HalfBitsCount">
            <summary>
            The maximum number of candidates can exist in a grid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.Length">
            <summary>
            Indicates the total length of bit array.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet.PrimeNumbers">
            <summary>
            The prime numbers below 100.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionSet._bitArray">
            <summary>
            The internal bit array.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.ContainsAssignment">
            <summary>
            Indicates whether the collection contains any assignment conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.ContainsElimination">
            <summary>
            Indicates whether the collection contains any elimination conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Count">
            <summary>
            Indicates the number of bit array elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Empty">
            <summary>
            An empty instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConclusionSet.Item(System.Int32)">
            <summary>
            Try to get n-th element stored in the collection.
            </summary>
            <param name="index">The desired index to be checked.</param>
            <returns>The found <see cref="T:Sudoku.Concepts.Conclusion"/> instance at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Add(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.AddRange(System.ReadOnlySpan{Sudoku.Concepts.Conclusion})">
            <summary>
            Add a list of conclusions into the collection.
            </summary>
            <param name="conclusions">The conclusions to be added.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Remove(Sudoku.Concepts.Conclusion)">
            <summary>
            Remove a conclusion, represented as a global index (between 0 and 1458), from the collection.
            </summary>
            <param name="item">The item to be removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Replace(Sudoku.Concepts.ConclusionSet)">
            <summary>
            Removes all elements in the collection and add all elements from <paramref name="conclusions"/>.
            </summary>
            <param name="conclusions">The conclusions provider to replace with the current instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.CopyTo(System.Span{Sudoku.Concepts.Conclusion})">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Contains(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ContainsCell(System.Int32)">
            <summary>
            Indicates whether the collection contains the specified cell.
            </summary>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Exists(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.Any(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TrueForAll(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Providers.IAnyAllMethod`2.All(System.Func{`1,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.IsWorthFor(Sudoku.Concepts.Grid@)">
            <summary>
            Determine whether the conclusion set contains valid conclusions that can be applied to grid.
            </summary>
            <param name="grid">The grid to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.AsSpan">
            <summary>
            Converts the current collection into a <see cref="T:System.ReadOnlySpan`1"/> instance.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:Sudoku.Concepts.Conclusion"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.GetEnumerator">
            <summary>
            Try to get an enumerator type that iterates on each conclusion.
            </summary>
            <returns>An enumerator type that iterates on each conclusion.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Slice(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Linq.Providers.ISliceMethod`2.Slice(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#CopyTo(Sudoku.Concepts.Conclusion[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#ExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IntersectWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#UnionWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Any">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Any(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#IAnyAllMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#All(System.Func{Sudoku.Concepts.Conclusion,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Conclusion}#Remove(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Conclusion}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#Add(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#ISet{Sudoku#Concepts#Conclusion}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Conclusion})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IFiniteSet{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Negate">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IInfiniteSet{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#ExceptWith(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Collections#Generic#IEnumerable{Sudoku#Concepts#Conclusion}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#Linq#Providers#ISliceMethod{Sudoku#Concepts#ConclusionSet,Sudoku#Concepts#Conclusion}#Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TryParse(System.String,Sudoku.Concepts.ConclusionSet@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.ConclusionSet@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_OnesComplement(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_BitwiseAnd(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_BitwiseOr(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_ExclusiveOr(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_Equality(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_Inequality(Sudoku.Concepts.ConclusionSet,Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_True(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_True(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_False(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_False(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#ILogicalOperators{Sudoku#Concepts#ConclusionSet}#op_True(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#ILogicalOperators{Sudoku#Concepts#ConclusionSet}#op_False(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.op_LogicalNot(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_LogicalNot(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.System#ILogicalOperators{Sudoku#Concepts#ConclusionSet}#op_LogicalNot(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConclusionSet.Equals(Sudoku.Concepts.ConclusionSet)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.ConclusionType">
            <summary>
            Provides a conclusion type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionType.Assignment">
            <summary>
            Indicates the conclusion is a value filling into a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ConclusionType.Elimination">
            <summary>
            Indicates the conclusion is a candidate being remove from a cell.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Conjugate">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="_mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32)">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/Conjugate_pair.html">conjugate pair</see>.
            </summary>
            <remarks>
            A <b>Conjugate pair</b> is a pair of two candidates, in the same house where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="_mask">Indicates the target mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with from and to cell offset and a digit.
            </summary>
            <param name="from">The from cell.</param>
            <param name="to">The to cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.#ctor(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Conjugate"/> instance with the map and the digit.
            The map should contains two cells, the first one is the start one, and the second one is the end one.
            </summary>
            <param name="map">The map.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.From">
            <summary>
            Indicates the "from" cell, i.e. the base cell that starts the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.To">
            <summary>
            Indicates the "to" cell, i.e. the target cell that ends the conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Line">
            <summary>
            Indicates the target line of the two cells lie in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Houses">
            <summary>
            Indicates the house that the current conjugate pair lies in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Conjugate.Map">
            <summary>
            Indicates the cells (the "from" cell and "to" cell).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.TryParse(System.String,Sudoku.Concepts.Conjugate@)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Conjugate@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Equality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.op_Inequality(Sudoku.Concepts.Conjugate,Sudoku.Concepts.Conjugate)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Conjugate.Equals(Sudoku.Concepts.Conjugate)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CandidateMapFormatter">
            <summary>
            Provides with a formatter object that convert the current <see cref="T:Sudoku.Concepts.CandidateMap"/> instance
            into a <see cref="T:System.String"/> representation equivalent to the current object.
            </summary>
            <param name="candidates">The candidates to be converted.</param>
            <returns>The string result.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CellMapFormatter">
            <summary>
            Provides with a formatter object that convert the current <see cref="T:Sudoku.Concepts.CellMap"/> instance
            into a <see cref="T:System.String"/> representation equivalent to the current object.
            </summary>
            <param name="cells">The cells to be converted.</param>
            <returns>The string result.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateConverter">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="AssignmentToken">
            <para>Indicates the token that describes an assignment conclusion, connected with cell and digit.</para>
            <para>The value is <c>" = "</c> by default.</para>
            </param>
            <param name="EliminationToken">
            <para>Indicates the token that describes an elimination conclusion, connected with cell and digit.</para>
            <para>The value is <c>"<![CDATA[ <> ]]>"</c> by default.</para>
            </param>
            <param name="NotationBracket">
            <para>Indicates the bracket surrounding the multiple coordinate parts (especially for cell groups and candidate groups).</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
            <remarks>
            You can use types <see cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>, <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>, <see cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.#ctor(System.String,System.String,System.String,System.String,Sudoku.Concepts.Coordinates.Formatting.NotationBracket,System.Globalization.CultureInfo)">
            <summary>
            Represents an option provider for coordinates.
            </summary>
            <param name="DefaultSeparator">
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </param>
            <param name="DigitsSeparator">
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </param>
            <param name="AssignmentToken">
            <para>Indicates the token that describes an assignment conclusion, connected with cell and digit.</para>
            <para>The value is <c>" = "</c> by default.</para>
            </param>
            <param name="EliminationToken">
            <para>Indicates the token that describes an elimination conclusion, connected with cell and digit.</para>
            <para>The value is <c>"<![CDATA[ <> ]]>"</c> by default.</para>
            </param>
            <param name="NotationBracket">
            <para>Indicates the bracket surrounding the multiple coordinate parts (especially for cell groups and candidate groups).</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </param>
            <param name="CurrentCulture">
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </param>
            <remarks>
            You can use types <see cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>, <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>, <see cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            and <see cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>.
            They are the derived types of the current type.
            </remarks>
            <seealso cref="T:Sudoku.Concepts.Coordinates.RxCyConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.K9Converter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter"/>
            <seealso cref="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.DefaultSeparator">
            <summary>
            <para>Indicates the default separator. The value will be inserted into two non-digit-kind instances.</para>
            <para>The value is <c>", "</c> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.DigitsSeparator">
            <summary>
            <para>Indicates the digits separator.</para>
            <para>The value is <see langword="null"/> by default, meaning no separators will be inserted between 2 digits.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.AssignmentToken">
            <summary>
            <para>Indicates the token that describes an assignment conclusion, connected with cell and digit.</para>
            <para>The value is <c>" = "</c> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.EliminationToken">
            <summary>
            <para>Indicates the token that describes an elimination conclusion, connected with cell and digit.</para>
            <para>The value is <c>"<![CDATA[ <> ]]>"</c> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.NotationBracket">
            <summary>
            <para>Indicates the bracket surrounding the multiple coordinate parts (especially for cell groups and candidate groups).</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CurrentCulture">
            <summary>
            <para>Indicates the current culture.</para>
            <para>The value is <see langword="null"/> by default, meaning the converter uses invariant culture to output some string text.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CellConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.CandidateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.HouseConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of houses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ConclusionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of conclusions.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.DigitConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.IntersectionConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified information for an intersection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ChuteConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified list of chute.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.ConjugateConverter">
            <summary>
            The converter method that creates a <see cref="T:System.String"/> via the specified conjugate.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.TargetCurrentCulture">
            <summary>
            Indicates the target culture.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateConverter.InvariantCultureInstance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateConverter.GetInstance(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateParser">
            <summary>
            Represents for a parser instance that parses a <see cref="T:System.String"/> text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.CellParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CellMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.CandidateParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.HouseParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int32"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ConclusionParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Conclusion"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.DigitParser">
            <summary>
            The parser method that can creates a <see cref="T:System.Int16"/> via the specified text to be parsed.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.IntersectionParser">
            <summary>
            The parser method that can creates a list of pairs of <see cref="T:Sudoku.Concepts.MinilineBase"/> and <see cref="T:Sudoku.Concepts.MinilineResult"/>
            via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.MinilineBase"/>
            <seealso cref="T:Sudoku.Concepts.MinilineResult"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ChuteParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Chute"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Chute"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.ConjugateParser">
            <summary>
            The parser method that can creates a <see cref="T:Sudoku.Concepts.Conjugate"/> list via the specified text to be parsed.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conjugate"/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateParser.InvariantCultureInstance">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateParser.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateParser.GetInstance(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateSimplifier">
            <summary>
            Represents a simplifier type that can simplify the coordinates.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateSimplifier.Simplify(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to simplify parts of cells, by combining same rows and columns.
            </summary>
            <param name="cells">The cells to be simplified.</param>
            <returns>A list of parts grouped by rows and its matched columns.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateSplit">
            <summary>
            Represents a part of coordinate, described as two arrays of row and column indices ranging 0..9.
            </summary>
            <param name="Rows">Indicates row indices.</param>
            <param name="Columns">Indicates column indices.</param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateSplit.#ctor(System.Int32[],System.Int32[])">
            <summary>
            Represents a part of coordinate, described as two arrays of row and column indices ranging 0..9.
            </summary>
            <param name="Rows">Indicates row indices.</param>
            <param name="Columns">Indicates column indices.</param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateSplit.Rows">
            <summary>Indicates row indices.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.CoordinateSplit.Columns">
            <summary>Indicates column indices.</summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateType">
            <summary>
            Represents a type of notation to describe a coordinate in sudoku.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.Literal">
            <summary>
            Idnicates the notation is based on literally notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.RxCy">
            <summary>
            Indicates the notation is based on <b>RxCy</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.K9">
            <summary>
            Indicates the notation is based on <b>K9</b> notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.CoordinateType.Excel">
            <summary>
            Indicates the notation is based on <b>Excel</b> notation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.CoordinateTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateTypeExtensions.GetConverter(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance via the specified <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <returns>
            A valid <see cref="T:Sudoku.Concepts.Coordinates.CoordinateConverter"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.CoordinateTypeExtensions.GetParser(Sudoku.Concepts.Coordinates.CoordinateType)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance via the specified <see cref="T:Sudoku.Concepts.Coordinates.CoordinateType"/> instance.
            </summary>
            <param name="this">The current instance.</param>
            <returns>
            A valid <see cref="T:Sudoku.Concepts.Coordinates.CoordinateParser"/> instance. You can use cast operators to get the instance of desired type.
            </returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="NotationBracket"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.#ctor(System.Boolean,System.String,System.String,System.String,System.String,Sudoku.Concepts.Coordinates.Formatting.NotationBracket,System.Globalization.CultureInfo)">
            <summary>
            Represents for Excel coordinate-based converter.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="NotationBracket"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ExcelCoordinateConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.BitmapCandidateMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.CandidateMapFormatInfo"/> type that supports bitmap formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCandidateMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCandidateMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCandidateMapFormatInfo.FormatCore(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCandidateMapFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.BitmapCellMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.CellMapFormatInfo"/> type that supports bitmap formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCellMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCellMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCellMapFormatInfo.FormatCore(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.BitmapCellMapFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.CandidateMapFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, or parses into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.CellMapFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.CellMap"/> instance, or parses into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.CsvGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports Comma-separated-values formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.CsvGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.CsvGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.CsvGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.CsvGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.FormatInfo`1">
            <summary>
            Represents a base type for formatting information on a type.
            </summary>
            <typeparam name="T">The type of object to be formatted.</typeparam>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.FormatInfo`1.GetFormat(System.Type)">
            <inheritdoc cref="M:System.IFormatProvider.GetFormat(System.Type)"/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.FormatInfo`1.Clone">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>A new instance whose internal values are equal to the current instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.FormatInfo`1.FormatCore(`0@)">
            <summary>
            Try to format the current object into a valid string result.
            </summary>
            <param name="obj">An object to be formatted.</param>
            <returns>The <see cref="T:System.String"/> representation of the argument <paramref name="obj"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.FormatInfo`1.ParseCore(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> instance into a valid instance of type <typeparamref name="T"/>.
            </summary>
            <param name="str">The string value to be parsed.</param>
            <returns>An instance of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.FormatInfo`1.System#IFormatProvider#GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo">
            <summary>
            Represents extra options that formats a <see cref="T:Sudoku.Concepts.Grid"/> instance, or parses into a <see cref="T:Sudoku.Concepts.Grid"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
            <seealso cref="T:System.Globalization.NumberFormatInfo"/>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.ValuesRouter">
            <summary>
            Indicates the table of format and creator.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.WithCandidates">
            <summary>
            <para>Indicates whether the formatter will reserve candidates as pre-elimination.</para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.WithModifiables">
            <summary>
            <para>
            Indicates whether the formatter will output and distinct modifiable and given digits.
            If so, the modifiable digits will be displayed as <c>+digit</c>, where <c>digit</c> will be replaced
            with the real digit number (from 1 to 9).
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.ShortenSusser">
            <summary>
            <para>
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </para>
            <para>
            This option will omit the continuous empty cells to a <c>*</c> in a single line. For example, the code
            <code><![CDATA[
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            ]]></code>
            will be displayed as
            <code><![CDATA[
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            ]]></code>
            via this option.
            We use the colon <c>,</c> to separate each line of 9 numbers, and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.NegateEliminationsTripletRule">
            <summary>
            <para>
            Indicates whether the parser will negate the rule, treating all digits as candidates existing in the grid
            instead of removed ones.
            </para>
            <para>The default value is <see langword="false"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.TreatValueAsGiven">
            <summary>
            Indicates whether the formatter will treat all values as givens, regardless of its value state.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.SubtleGridLines">
            <summary>
            Indicates whether the formatter will subtle grid lines to make a good-look.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.IsCompatibleMode">
            <summary>
            Indicates whether the formatter will use compatible mode to output grid values.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.Multiline">
            <summary>
            Indicates whether the formatter will handle the value with multiple-line mode.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.RemoveGridLines">
            <summary>
            Indicates whether the parsing operation will use simple way, removing all grid lines for multi-line formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.OnlyEliminations">
            <summary>
            Indicates whether the formatting operation will output for eliminations.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.Placeholder">
            <summary>
            Indicates the placeholder of the grid text formatter.
            </summary>
            <value>The new placeholder text character to be set. The value must be <c>'.'</c> or <c>'0'</c>.</value>
            <returns>The placeholder text.</returns>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.Separator">
            <summary>
            Indicates the separator used. By default, it's comma <c>", "</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.InvariantCulture">
            <summary>
            Gets a read-only <see cref="T:System.IFormatProvider"/> object that is culture-independent (invariant).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.CurrentCulture">
            <summary>
            Gets a <see cref="T:System.IFormatProvider"/> that formats values based on the current culture.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.CsvFormat">
            <summary>
            Represents CSV format rule.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.InlineSusserFormat">
            <summary>
            Represents inline Susser format rule.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.MaskFormat">
            <summary>
            Represents mask format rule.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.MultipleLineFormat">
            <summary>
            Represents multiple line format rule.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.OpenSudokuFormat">
            <summary>
            Represents open sudoku format rule.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.PencilmarkFormat">
            <summary>
            Represents pencilmark format rule.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.SukakuFormat">
            <summary>
            Represents Sukaku format rule.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.SusserFormat">
            <summary>
            Represents standard format tule (Susser rule).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.GetInstance(System.IFormatProvider)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> associated with the specified <see cref="T:System.IFormatProvider"/>.
            </summary>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> used to get the <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/>.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> associated with the specified <see cref="T:System.IFormatProvider"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo.GetInstance(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> instance that holds the specified format.
            </summary>
            <param name="format">The format.</param>
            <returns>A valid <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.HodokuTripletCandidateMapFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.CandidateMapFormatInfo"/> type that supports Hodoku elimination candidates formatting.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.HodokuTripletCandidateMapFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.HodokuTripletCandidateMapFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.HodokuTripletCandidateMapFormatInfo.FormatCore(Sudoku.Concepts.CandidateMap@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.HodokuTripletCandidateMapFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports inline Susser grid formatting.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo.PlusToken">
            <summary>
            Indicates the plus token that describes for modifiable values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo.EmptyString">
            <summary>
            Indicates the empty string.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?[\\d\\.]|\\[[1-9]{1,9}\\])</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             1st capture group.<br/>
                 Match with 2 alternative expressions, atomically.<br/>
                     Match a sequence of expressions.<br/>
                         Match '+' atomically, optionally.<br/>
                         Match a character in the set [.\d].<br/>
                     Match a sequence of expressions.<br/>
                         Match '['.<br/>
                         Match a character in the set [1-9] atomically at least 1 and at most 9 times.<br/>
                         Match ']'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.InlineSusserGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.MaskGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports mask formatting.
            </summary>
            <remarks>
            <para>This type is used by diagnostic only.</para>
            <para>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MaskGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MaskGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MaskGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MaskGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.MultipleLineGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports multiple formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.MultipleLineGridFormatInfo.GridSusserDigitPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\+?\\d|\\.)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             1st capture group.<br/>
                 Match with 2 alternative expressions, atomically.<br/>
                     Match a sequence of expressions.<br/>
                         Match '+' atomically, optionally.<br/>
                         Match a Unicode digit.<br/>
                     Match '.'.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.MultipleLineGridFormatInfo.GridSimpleMultilinePattern">
            <remarks>
            Pattern:<br/>
            <code>([\\d\\.\\+]{9}(\\r|\\n|\\r\\n)){8}[\\d\\.\\+]{9}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Loop exactly 8 times.<br/>
                 1st capture group.<br/>
                     Match a character in the set [+.\d] exactly 9 times.<br/>
                     2nd capture group.<br/>
                         Match with 2 alternative expressions.<br/>
                             Match a character in the set [\n\r].<br/>
                             Match the string "\r\n".<br/>
             Match a character in the set [+.\d] exactly 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MultipleLineGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MultipleLineGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MultipleLineGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.MultipleLineGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.NotationBracket">
            <summary>
            Represents a kind of notation bracket that will be used on formatting combined coordinates.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None">
            <summary>
            Indicates there's no bracket that combines multiple parts, like <c>r2c2, r3c3</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.Round">
            <summary>
            Indicates there's a round bracket <c>()</c> that combines multiple parts, like <c>(r2c2, r3c3)</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.Square">
            <summary>
            Indicates there's a square bracket <c>[]</c> that combines multiple parts, like <c>[r2c2, r3c3]</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.Curly">
            <summary>
            Indicates there's a curly bracket <c>{}</c> that combines multiple parts, like <c>{r2c2, r3c3}</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.Angle">
            <summary>
            Indicates there's an angle bracket <c><![CDATA[<>]]></c> that combines multiple parts, like <c><![CDATA[<r2c2, r2c3>]]></c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.NotationBracketExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Coordinates.Formatting.NotationBracket"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Coordinates.Formatting.NotationBracket"/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.NotationBracketExtensions.GetOpenBracket(Sudoku.Concepts.Coordinates.Formatting.NotationBracket)">
            <summary>
            Try to get open bracket token.
            </summary>
            <param name="this">The bracket.</param>
            <returns>The open bracket token.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.NotationBracketExtensions.GetClosedBracket(Sudoku.Concepts.Coordinates.Formatting.NotationBracket)">
            <summary>
            Try to get closed bracket token.
            </summary>
            <param name="this">The bracket.</param>
            <returns>The closed bracket token.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.OnOffNotationFix">
            <summary>
            Represents a kind of fix that describes on/off state of a chain node.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.OnOffNotationFix.None">
            <summary>
            Indicates no fix here to describe on/off state.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.OnOffNotationFix.Prefix">
            <summary>
            Indicates the fix type is prefix.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.OnOffNotationFix.Suffix">
            <summary>
            Indicates the fix type is suffix.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.OpenSudokuGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports OpenSudoku formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.OpenSudokuGridFormatInfo.GridOpenSudokuPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d(\\|\\d){242}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a Unicode digit.<br/>
             Loop exactly 242 times.<br/>
                 1st capture group.<br/>
                     Match '|'.<br/>
                     Match a Unicode digit.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.OpenSudokuGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.OpenSudokuGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.OpenSudokuGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.OpenSudokuGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.PencilmarkGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports pencilmark grid formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.PencilmarkGridFormatInfo.GridPencilmarkPattern">
            <remarks>
            Pattern:<br/>
            <code>(\\&lt;\\d\\&gt;|\\*\\d\\*|\\d*[\\+\\-]?\\d+)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             1st capture group.<br/>
                 Match with 3 alternative expressions, atomically.<br/>
                     Match a sequence of expressions.<br/>
                         Match '&lt;'.<br/>
                         Match a Unicode digit.<br/>
                         Match '&gt;'.<br/>
                     Match a sequence of expressions.<br/>
                         Match '*'.<br/>
                         Match a Unicode digit.<br/>
                         Match '*'.<br/>
                     Match a sequence of expressions.<br/>
                         Match a Unicode digit greedily any number of times.<br/>
                         Match a character in the set [+-] atomically, optionally.<br/>
                         Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.PencilmarkGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.PencilmarkGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.PencilmarkGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.PencilmarkGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.SukakuGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports Sukaku formatting.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.SukakuGridFormatInfo.GridSukakuSegmentPattern">
            <remarks>
            Pattern:<br/>
            <code>\\d*[\\-\\+]?\\d+</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a Unicode digit greedily any number of times.<br/>
             Match a character in the set [+-] atomically, optionally.<br/>
             Match a Unicode digit atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SukakuGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SukakuGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SukakuGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SukakuGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo">
            <summary>
            Represents a <see cref="T:Sudoku.Concepts.Coordinates.Formatting.GridFormatInfo"/> type that supports Susser formatting.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.ModifiablePrefix">
            <summary>
            Indicates the modifiable prefix character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.LineLimit">
            <summary>
            Indicates the line separator character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.Star">
            <summary>
            Indicates the star character used by shortening Susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.Dot">
            <summary>
            Indicates the dot character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.Zero">
            <summary>
            Indicates the zero character.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.PreeliminationPrefix">
            <summary>
            Indicates the pre-elimination prefix character.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.GridSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\+]{80,}(\\:(\\d{3}\\s+)*\\d{3})?</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [+.\d] greedily at least 80 times.<br/>
             Optional (greedy).<br/>
                 1st capture group.<br/>
                     Match ':'.<br/>
                     Loop greedily any number of times.<br/>
                         2nd capture group.<br/>
                             Match a Unicode digit exactly 3 times.<br/>
                             Match a whitespace character atomically at least once.<br/>
                     Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.GridShortenedSusserPattern">
            <remarks>
            Pattern:<br/>
            <code>[\\d\\.\\*]{1,9}(,[\\d\\.\\*]{1,9}){8}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
             Loop exactly 8 times.<br/>
                 1st capture group.<br/>
                     Match ','.<br/>
                     Match a character in the set [*.\d] atomically at least 1 and at most 9 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.EliminationPattern">
            <remarks>
            Pattern:<br/>
            <code>(?&lt;=\\:)(\\d{3}\\s+)*\\d{3}</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Zero-width positive lookbehind.<br/>
                 Match ':' right-to-left.<br/>
             Loop greedily any number of times.<br/>
                 1st capture group.<br/>
                     Match a Unicode digit exactly 3 times.<br/>
                     Match a whitespace character atomically at least once.<br/>
             Match a Unicode digit exactly 3 times.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.FormatCore(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.Formatting.SusserGridFormatInfo.ParseCore(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.ICoordinateProvider`1">
            <summary>
            Represents a type that supports formatting or parsing rules around coordinates.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.ICoordinateProvider`1.InvariantCultureInstance">
            <summary>
            Indicates the <typeparamref name="TSelf"/> instance for the invariant culture, meaning it ignores culture your device uses.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.ICoordinateProvider`1.GetInstance(System.IFormatProvider)">
            <summary>
            Try to get a <typeparamref name="TSelf"/> instance from the specified culture.
            </summary>
            <param name="formatProvider">The format provider instance.</param>
            <returns>A <typeparamref name="TSelf"/> instance from the specified culture.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.K9Converter">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="AlwaysOutputBracket">
            <para>Indicates whether brackets will always be included in output text.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distinct with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="NotationBracket"><inheritdoc/></param>
            <param name="DigitBracketInCandidateGroups">
            <para>Indicates the bracket surrounding digits in candidate output notation.</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Converter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Char,System.String,System.String,System.String,System.String,Sudoku.Concepts.Coordinates.Formatting.NotationBracket,Sudoku.Concepts.Coordinates.Formatting.NotationBracket,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using K9 notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="AlwaysOutputBracket">
            <para>Indicates whether brackets will always be included in output text.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="FinalRowLetter">
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distinct with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="NotationBracket"><inheritdoc/></param>
            <param name="DigitBracketInCandidateGroups">
            <para>Indicates the bracket surrounding digits in candidate output notation.</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.MakeDigitBeforeCell">
            <summary>
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.AlwaysOutputBracket">
            <summary>
            <para>Indicates whether brackets will always be included in output text.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.FinalRowLetter">
            <summary>
            <para>
            Indicates the character that displays for the last row. Generally it uses <c>'I'</c> to be the last row,
            but sometimes it may produce much difficulty on distinct with digit 1 and i (They are nearly same by its shape).
            This option will change the last row letter if you want to change it.
            </para>
            <para>The value is <c>'I'</c> by default. You can set the value to <c>'J'</c> or <c>'K'</c>; other letters are not suggested.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.DigitBracketInCandidateGroups">
            <summary>
            <para>Indicates the bracket surrounding digits in candidate output notation.</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Converter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Converter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.K9Parser">
            <summary>
            Represents a parser type that uses <b>K9</b> notation rule to parse text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.ConjugateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[a-k]+[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+)([1-9]+)\\.([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             1st capture group.<br/>
                 Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
             2nd capture group.<br/>
                 Match a character in the set [1-9] atomically at least once.<br/>
             Match '.'.<br/>
             3rd capture group.<br/>
                 Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k]+[1-9]+(,\\s*[a-k]+[1-9]+)*)\\s*(==?|!=|&lt;&gt;)\\s*([1-9]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             1st capture group.<br/>
                 Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                 Match a character in the set [1-9] greedily at least once.<br/>
                 Loop greedily any number of times.<br/>
                     2nd capture group.<br/>
                         Match ','.<br/>
                         Match a whitespace character atomically any number of times.<br/>
                         Match a character in the set [A-Ka-k\u212A] atomically at least once.<br/>
                         Match a character in the set [1-9] atomically at least once.<br/>
             Match a whitespace character atomically any number of times.<br/>
             3rd capture group.<br/>
                 Match with 3 alternative expressions.<br/>
                     Match '=' atomically at least 1 and at most 2 times.<br/>
                     Match the string "!=".<br/>
                     Match the string "&lt;&gt;".<br/>
             Match a whitespace character atomically any number of times.<br/>
             4th capture group.<br/>
                 Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.K9Parser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>([a-k][1-9])\\s*={2}\\s*([a-k][1-9])\\.([1-9])</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             1st capture group.<br/>
                 Match a character in the set [A-Ka-k\u212A].<br/>
                 Match a character in the set [1-9].<br/>
             Match a whitespace character atomically any number of times.<br/>
             Match the string "==".<br/>
             Match a whitespace character atomically any number of times.<br/>
             2nd capture group.<br/>
                 Match a character in the set [A-Ka-k\u212A].<br/>
                 Match a character in the set [1-9].<br/>
             Match '.'.<br/>
             3rd capture group.<br/>
                 Match a character in the set [1-9].<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.K9Parser.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.#ctor(System.String,System.String,System.String,System.String,System.Globalization.CultureInfo)">
            <summary>
            Represents a converter that outputs coordinates as literally-speaking representation.
            </summary>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.LiteralCoordinateConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.RxCyConverter">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="AlwaysOutputBracket">
            <para>Indicates whether brackets will be always included in output text.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="NotationBracket"><inheritdoc/></param>
            <param name="DigitBracketInCandidateGroups">
            <para>Indicates the bracket surrounding digits in candidate output notation.</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.String,System.String,System.String,Sudoku.Concepts.Coordinates.Formatting.NotationBracket,Sudoku.Concepts.Coordinates.Formatting.NotationBracket,System.Globalization.CultureInfo)">
            <summary>
            Represents a coordinate converter using RxCy notation.
            </summary>
            <param name="MakeLettersUpperCase">
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="MakeDigitBeforeCell">
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="AlwaysOutputBracket">
            <para>Indicates whether brackets will be always included in output text.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="HouseNotationOnlyDisplayCapitals">
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </param>
            <param name="DefaultSeparator"><inheritdoc/></param>
            <param name="DigitsSeparator"><inheritdoc/></param>
            <param name="AssignmentToken"><inheritdoc/></param>
            <param name="EliminationToken"><inheritdoc/></param>
            <param name="NotationBracket"><inheritdoc/></param>
            <param name="DigitBracketInCandidateGroups">
            <para>Indicates the bracket surrounding digits in candidate output notation.</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </param>
            <param name="CurrentCulture"><inheritdoc/></param>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.MakeLettersUpperCase">
            <summary>
            <para>Indicates whether we make the letters <c>'r'</c>, <c>'c'</c> and <c>'b'</c> to be upper-casing.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.MakeDigitBeforeCell">
            <summary>
            <para>Indicates whether digits will be displayed before the cell coordinates.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.AlwaysOutputBracket">
            <summary>
            <para>Indicates whether brackets will be always included in output text.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.HouseNotationOnlyDisplayCapitals">
            <summary>
            <para>Indicates whether the houses will be displayed its capitals only.</para>
            <para>The value is <see langword="false"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.DigitBracketInCandidateGroups">
            <summary>
            <para>Indicates the bracket surrounding digits in candidate output notation.</para>
            <para>The value is <see cref="F:Sudoku.Concepts.Coordinates.Formatting.NotationBracket.None"/> by default.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.CellConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.CandidateConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.HouseConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ConclusionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.DigitConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.IntersectionConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ChuteConverter">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyConverter.ConjugateConverter">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyConverter.GetLabel(System.Byte)">
            <summary>
            Get the label of each house.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>The label.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Coordinates.RxCyParser">
            <summary>
            Represents a parser type that uses <b>RxCy</b> notation rule to parse text,
            converting into a valid instance that can be represented as a sudoku concept.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.CellParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.CandidateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.HouseParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ConclusionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.DigitParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ChuteParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.ConjugateParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.IntersectionParser">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitCellGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Rr].<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
             Match a character in the set [Cc].<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitCandidateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+\\([1-9]+\\)|[1-9]+r[1-9]+c[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match with 2 alternative expressions, atomically.<br/>
                 Match a sequence of expressions.<br/>
                     Match an empty string.<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
                     Match a character in the set [Cc].<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
                     Match '('.<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
                     Match ')'.<br/>
                 Match a sequence of expressions.<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
                     Match a character in the set [Rr].<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
                     Match a character in the set [Cc].<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitConclusionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]+c[1-9]+(,\\s*r[1-9]+c[1-9]+)*\\s*(==?|!=|&lt;&gt;)\\s*[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Rr].<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
             Match a character in the set [Cc].<br/>
             Match a character in the set [1-9] greedily at least once.<br/>
             Loop greedily any number of times.<br/>
                 1st capture group.<br/>
                     Match ','.<br/>
                     Match a whitespace character atomically any number of times.<br/>
                     Match a character in the set [Rr].<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
                     Match a character in the set [Cc].<br/>
                     Match a character in the set [1-9] atomically at least once.<br/>
             Match a whitespace character atomically any number of times.<br/>
             2nd capture group.<br/>
                 Match with 3 alternative expressions.<br/>
                     Match '=' atomically at least 1 and at most 2 times.<br/>
                     Match the string "!=".<br/>
                     Match the string "&lt;&gt;".<br/>
             Match a whitespace character atomically any number of times.<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitHousePattern">
            <remarks>
            Pattern:<br/>
            <code>[rcb][1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [BCRbcr].<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitIntersectionGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>[rc][1-9]+b[1-9]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [CRcr].<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
             Match a character in the set [Bb].<br/>
             Match a character in the set [1-9] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitMegaLineGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>m[rc][1-3]+</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Mm].<br/>
             Match a character in the set [CRcr].<br/>
             Match a character in the set [1-3] atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Coordinates.RxCyParser.UnitConjugateGroupPattern">
            <remarks>
            Pattern:<br/>
            <code>r[1-9]c[1-9]\\s*={2}\\s*r[1-9]c[1-9]\\([1-9]\\)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Rr].<br/>
             Match a character in the set [1-9].<br/>
             Match a character in the set [Cc].<br/>
             Match a character in the set [1-9].<br/>
             Match a whitespace character atomically any number of times.<br/>
             Match the string "==".<br/>
             Match a whitespace character atomically any number of times.<br/>
             Match a character in the set [Rr].<br/>
             Match a character in the set [1-9].<br/>
             Match a character in the set [Cc].<br/>
             Match a character in the set [1-9].<br/>
             Match '('.<br/>
             Match a character in the set [1-9].<br/>
             Match ')'.<br/>
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Coordinates.RxCyParser.GetFormat(System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.AdjacentCellDirection">
            <summary>
            Represents a direction between two adjacent cells.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
            <seealso cref="T:System.FlagsAttribute" />
        </member>
        <member name="F:Sudoku.Concepts.Graphs.AdjacentCellDirection.None">
            <summary>
            Indicates the default value.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.AdjacentCellDirection.Up">
            <summary>
            Indicates the direction is up.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.AdjacentCellDirection.Down">
            <summary>
            Indicates the direction is down.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.AdjacentCellDirection.Left">
            <summary>
            Indicates the direction is left.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.AdjacentCellDirection.Right">
            <summary>
            Indicates the direction is right.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.AdjacentCellDirections">
            <summary>
            Represents constants of <see cref="T:Sudoku.Concepts.Graphs.AdjacentCellDirection"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Graphs.AdjacentCellDirection"/>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.AdjacentCellDirections.All">
            <summary>
            Indicates all directions.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.AdjacentCellGraph">
            <summary>
            Represents a graph that displays a list of <see cref="T:System.Int32"/> instances connected with rows and columns of adjacent positions.
            This graph will be useful to measure border lines.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.AdjacentCellGraph.Cells">
            <summary>
            Indicates the backing field of cells.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.#ctor(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates an <see cref="T:Sudoku.Concepts.Graphs.AdjacentCellGraph"/> instance via a list of cells connected by rows and columns.
            </summary>
            <param name="cells">A list of cells.</param>
            <returns>An <see cref="T:Sudoku.Concepts.Graphs.AdjacentCellGraph"/> instance created.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when at least one cell is missing connection with all rows and columns of the other cells.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.AdjacentCellGraph.InnerBorderLines">
            <summary>
            Try to get a list of cells and its corresponding directions that inner border lines will be created.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.op_Equality(Sudoku.Concepts.Graphs.AdjacentCellGraph,Sudoku.Concepts.Graphs.AdjacentCellGraph)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.op_Inequality(Sudoku.Concepts.Graphs.AdjacentCellGraph,Sudoku.Concepts.Graphs.AdjacentCellGraph)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.AdjacentCellGraph.Equals(Sudoku.Concepts.Graphs.AdjacentCellGraph)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.CellGraph">
            <summary>
            <para>Represents a list of cells that form a undirected graph.</para>
            <para>
            Please visit <see href="https://en.wikipedia.org/wiki/Component_(graph_theory)">this link</see>
            to learn more information about concept Component.
            </para>
            </summary>
            <seealso href="https://en.wikipedia.org/wiki/Component_(graph_theory)">Wikipedia - Component (Graph Theory)</seealso>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.CellGraph.Empty">
            <summary>
            Indicates the default empty graph without any cells.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.CellGraph._cells">
            <summary>
            Indicates the cells used.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.CellGraph._invalidCells">
            <summary>
            Indicates invalid cells. Such cells may not be covered from the grid.
            <see cref="M:Sudoku.Concepts.Graphs.CellGraph.GetComponentOf(System.Int32,System.ReadOnlySpan{Sudoku.Concepts.Graphs.CellGraphDepth}@)"/> will ignore them.
            </summary>
            <seealso cref="M:Sudoku.Concepts.Graphs.CellGraph.GetComponentOf(System.Int32,System.ReadOnlySpan{Sudoku.Concepts.Graphs.CellGraphDepth}@)"/>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.CellGraph._directlyConnectedCellsDictionary">
            <summary>
            Indicates the directly-connected cells.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.#ctor(Sudoku.Concepts.CellMap@)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance with the specified cells.
            </summary>
            <param name="cells">The cells.</param>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.#ctor(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance with the specified cells,
            and some invalid cells that will be used by confliction checking.
            </summary>
            <param name="cells">Indicates the cells used.</param>
            <param name="invalidCells">
            <para>Indicates invalid cells. Such cells will interrupt the conjugate pair connection from a cell to a cell.</para>
            <para>
            In general, this argument is an empty collection of <see cref="T:Sudoku.Concepts.CellMap"/> (i.e. a <see cref="F:Sudoku.Concepts.CellMap.Empty"/> or <c>[]</c>),
            but sometimes it can be useful for calculation of confliction on conjugate pair parity checks.
            </para>
            </param>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.IsConnected">
            <summary>
            Indicates whether the graph is connected, i.e. all nodes in the graph is a part of the whole graph without being separated.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.IsEmpty">
            <summary>
            Indicates whether the current graph is an empty graph, i.e. there's no cells inside the current graph.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.IsBipartite">
            <summary>
            Indicates whether the graph is bipartite graph.
            </summary>
            <remarks>
            <para>
            In general, a bipartite graph is a graph that can color with only 2 colors in a cyclic path,
            through alternating coloring rule. If the graph is of an odd length, it may not be a bipartite graph
            because we can find at least one pair of adjacent cells in a same color.
            </para>
            <para>
            For more information about "Bipartite Graph", please visit
            <see href="https://en.wikipedia.org/wiki/Bipartite_graph">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.VerticesCount">
            <summary>
            Indicates the vertices count, i.e. the number of cells in the graph.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.Map">
            <summary>
            Indicates the internal map.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.Components">
            <summary>
            Indicates all possible connected components of the graph.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.System#Collections#Generic#IReadOnlyCollection{System#Int32}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.Item(System.Int32)">
            <summary>
            Try to get all cells whose degree is the specified value.
            </summary>
            <param name="degree">The degree. The value must be between 0 and 3.</param>
            <returns>All cells whose degree is equal to the specified value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.GetDegreeOf(System.Int32)">
            <summary>
            Try to get the degree of the specified cell.
            </summary>
            <param name="cell">The desired cell.</param>
            <returns>An <see cref="T:System.Int32"/> indicating that. If the cell isn't in the current graph, -1 will be returned.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.GetHamiltonianCycles">
            <summary>
            Try to find a path that connects with all possible cells of the graph, by advancing with the next cell in a same house.
            </summary>
            <returns>
            The found path. If multiple paths exist, only the first one will be returned.
            If no such loops found, an empty sequence will be returned.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.GetConnectedCells(System.Int32)">
            <summary>
            Try to get connected cells for the specified cell. 
            </summary>
            <param name="cell">Indicates the cell to be checked.</param>
            <returns>All cells that connect the current cell.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.GetEnumerator">
            <summary>
            Creates an enumerator type that can iterate on each cell in the collection.
            </summary>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.GetComponentOf(System.Int32,System.ReadOnlySpan{Sudoku.Concepts.Graphs.CellGraphDepth}@)">
            <summary>
            Try to get a <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> that contains the specified cell.
            </summary>
            <param name="cell">The desired cell.</param>
            <param name="depths">A list of <see cref="T:Sudoku.Concepts.Graphs.CellGraphDepth"/> values.</param>
            <returns>A <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Contains(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Create(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates an <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance via the specified cells.
            </summary>
            <param name="cells">The cells.</param>
            <returns>An <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Create(System.ReadOnlySpan{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.Graphs.CellGraph.Create(Sudoku.Concepts.CellMap@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.CreateFromConjugatePair(Sudoku.Concepts.Grid@,System.Int32,Sudoku.Concepts.CellMap@)">
            <summary>
            Initializes an <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance via a list of cells, checking conjugate pairs.
            </summary>
            <param name="grid">The grid to be used.</param>
            <param name="digit">The digit to be used.</param>
            <param name="cells">The cells to be used.</param>
            <returns>An <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.CellGraph.Enumerator">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="_offset">Indicates the offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Enumerator.#ctor(System.Int32[])">
            <summary>
            Represents an enumerator type that iterates on each cell offsets.
            </summary>
            <param name="_offset">Indicates the offsets.</param>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.CellGraph.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraph.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.op_Equality(Sudoku.Concepts.Graphs.CellGraph,Sudoku.Concepts.Graphs.CellGraph)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.op_Inequality(Sudoku.Concepts.Graphs.CellGraph,Sudoku.Concepts.Graphs.CellGraph)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraph.Equals(Sudoku.Concepts.Graphs.CellGraph)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.CellGraphDepth">
            <summary>
            Represents a node that describes for a graph node inside a <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/>, with depth from a node.
            </summary>
            <param name="Depth">Indicates the depth.</param>
            <param name="Cell">The cell.</param>
            <seealso cref="T:Sudoku.Concepts.Graphs.CellGraph"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraphDepth.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents a node that describes for a graph node inside a <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/>, with depth from a node.
            </summary>
            <param name="Depth">Indicates the depth.</param>
            <param name="Cell">The cell.</param>
            <seealso cref="T:Sudoku.Concepts.Graphs.CellGraph"/>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraphDepth.Depth">
            <summary>Indicates the depth.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.CellGraphDepth.Cell">
            <summary>The cell.</summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.CellGraphDepth.PrintMembers(System.Text.StringBuilder)">
            <target name="method" cref="M:Sudoku.Concepts.Graphs.CellGraphDepth.PrintMembers(System.Text.StringBuilder)">
				<summary>
					Provides an easy way to concatenate output members inside a <see langword="record" />
					or a <see langword="record struct" /> type.
				</summary>
				<param name="builder">
					A <see cref="T:System.Text.StringBuilder" /> instance to concatenate values.
				</param>
				<returns>
					A <see cref="T:System.Boolean" /> value indicating whether the method should be consumed by compiler,
					by implementing to-string method <see cref="M:Sudoku.Concepts.Graphs.CellGraphDepth.ToString" />.
				</returns>
				<remarks>
					<para>
						By design of <see langword="record" /> and <see langword="record struct" /> types,
						emit text should be formatted as follows:
						<code><![CDATA[RecordType { Property1 = Value1, Property2 = Value2, Property3 = { NestedProperty = Value3 } }]]></code>
					</para>
					<para>
						This method won't emit type name and curly brackets. If you want to customize emit text,
						you can only change values inside a pair of brackets.
					</para>
					<para>
						The suggested implementation is like this:
						<code><![CDATA[private bool PrintMembers(StringBuilder builder)
{
    builder.Append($"{nameof(Property1)} = {Property1}");
    builder.Append(", ");
    builder.Append($"{nameof(Property2)} = {Property2}");
    builder.Append(", ");
    builder.Append($"{nameof(Property3)} = {{ {Property3} }}");
    return true;
}]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.Cluster">
            <summary>
            <para>Represents a cluster. A cluster is a group of candidates which are all connected with strong links.</para>
            <para>
            This data structure will simplify the definition, only reserving for single-digit strong links (i.e. conjugate pairs),
            in order to make the implementation behave well and easily on representing data.
            </para>
            <para>
            Please visit <see href="http://sudopedia.enjoysudoku.com/Cluster.html">this link</see> to learn more information.
            </para>
            </summary>
            <param name="grid">Indicates the grid used.</param>
            <param name="digit">Indicates the digit used.</param>
            <param name="map">Indicates the cells used.</param>
            <seealso href="http://sudopedia.enjoysudoku.com/Cluster.html">Sudopedia Mirror - Cluster</seealso>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.#ctor(Sudoku.Concepts.Grid@,System.Int32,Sudoku.Concepts.CellMap@)">
            <summary>
            <para>Represents a cluster. A cluster is a group of candidates which are all connected with strong links.</para>
            <para>
            This data structure will simplify the definition, only reserving for single-digit strong links (i.e. conjugate pairs),
            in order to make the implementation behave well and easily on representing data.
            </para>
            <para>
            Please visit <see href="http://sudopedia.enjoysudoku.com/Cluster.html">this link</see> to learn more information.
            </para>
            </summary>
            <param name="grid">Indicates the grid used.</param>
            <param name="digit">Indicates the digit used.</param>
            <param name="map">Indicates the cells used.</param>
            <seealso href="http://sudopedia.enjoysudoku.com/Cluster.html">Sudopedia Mirror - Cluster</seealso>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.Cluster.Map">
            <summary>
            Indicates the internal map.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.Cluster.WrapContradictions">
            <summary>
            Represents a list of cells that will form wrap contradictions in the cluster.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.Cluster.TrapContradictions">
            <summary>
            Represents a list of cells that will form trap contradictions in the cluster.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.Create(Sudoku.Concepts.Grid@,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Graphs.Cluster"/> instance via the specified grid.
            </summary>
            <param name="grid">The grid to be used.</param>
            <param name="digit">Indicates the digits used.</param>
            <returns>A <see cref="T:Sudoku.Concepts.Graphs.Cluster"/> instance.</returns>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.Cluster._grid">
            <summary>
            The generated field declaration for parameter <c>grid</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.Cluster._map">
            <summary>
            The generated field declaration for parameter <c>map</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.Cluster.Digit">
            <summary>
            The generated property declaration for parameter <c>digit</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.op_Equality(Sudoku.Concepts.Graphs.Cluster,Sudoku.Concepts.Graphs.Cluster)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.op_Inequality(Sudoku.Concepts.Graphs.Cluster,Sudoku.Concepts.Graphs.Cluster)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Cluster.Equals(Sudoku.Concepts.Graphs.Cluster)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.HamiltonianCycle">
            <summary>
            Represents the concept "<see href="https://en.wikipedia.org/wiki/Hamiltonian_path">Hamiltonian Path</see>"
            that will be applied to a <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance.
            </summary>
            <param name="cells">Indicates the cells.</param>
            <seealso cref="T:Sudoku.Concepts.Graphs.CellGraph"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.#ctor(System.Int32[])">
            <summary>
            Represents the concept "<see href="https://en.wikipedia.org/wiki/Hamiltonian_path">Hamiltonian Path</see>"
            that will be applied to a <see cref="T:Sudoku.Concepts.Graphs.CellGraph"/> instance.
            </summary>
            <param name="cells">Indicates the cells.</param>
            <seealso cref="T:Sudoku.Concepts.Graphs.CellGraph"/>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.HamiltonianCycle.Length">
            <summary>
            Indicates the number of cells used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.HamiltonianCycle.Cells">
            <summary>
            Indicates the sequence of cells in order.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.HamiltonianCycle.System#Collections#Generic#IReadOnlyCollection{System#Int32}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.HamiltonianCycle.Item(System.Int32)">
            <summary>
            Returns the cell at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The cell at the specified index.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.Equals(Sudoku.Concepts.Graphs.HamiltonianCycle)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.Equals(Sudoku.Concepts.Graphs.HamiltonianCycle,Sudoku.Concepts.Graphs.HamiltonianCycleComparison)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Graphs.HamiltonianCycle"/> instances are considered as equal under the specified comparison rule.
            </summary>
            <param name="other">Indicates the other object to be compared.</param>
            <param name="comparison">The comparison rule to be used.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="comparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.GetHashCode(Sudoku.Concepts.Graphs.HamiltonianCycleComparison)">
            <summary>
            Returns the hash code of the current instance, using the specified comparison rule.
            </summary>
            <param name="comparison">The comparison rule.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the result.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="comparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.ToString(Sudoku.Concepts.Coordinates.CoordinateConverter)">
            <summary>
            Returns a string that represents the current object, using the specified coordinate converter object to format cells.
            </summary>
            <param name="converter">
            Indicates the converter. If <see langword="null"/> is assigned, RxCy notation will be adopted.
            </param>
            <returns>A <see cref="T:System.String"/> that represents the current object.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.HamiltonianCycle._cells">
            <summary>
            The generated field declaration for parameter <c>cells</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.op_Equality(Sudoku.Concepts.Graphs.HamiltonianCycle,Sudoku.Concepts.Graphs.HamiltonianCycle)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.HamiltonianCycle.op_Inequality(Sudoku.Concepts.Graphs.HamiltonianCycle,Sudoku.Concepts.Graphs.HamiltonianCycle)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.HamiltonianCycleComparison">
            <summary>
            Represents a comparison rule to a <see cref="T:Sudoku.Concepts.Graphs.HamiltonianCycle"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Graphs.HamiltonianCycle"/>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.HamiltonianCycleComparison.Default">
            <summary>
            Indicates the comparison rule will consider direction.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Graphs.HamiltonianCycleComparison.IgnoreDirection">
            <summary>
            Indicates the comparison rule won't consider direction.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Graphs.Parity">
            <summary>
            <para>Represents one state of a candidate in a <see cref="T:Sudoku.Concepts.Graphs.Cluster"/>.</para>
            <para>
            Please visit <see href="http://sudopedia.enjoysudoku.com/Parity.html">this link</see>
            to learn more information about this concept.
            </para>
            </summary>
            <param name="ParityFlag">
            <para>Indicates which parity the current set belongs to.</para>
            <para>
            Due to limitation of this concept, there can only be 2 parities in one cluster.
            Therefore, this value is a <see cref="T:System.Boolean"/> indicating "on" and "off" state - they are opposite to each other.
            </para>
            </param>
            <param name="Cells">Indicates the cells used.</param>
            <seealso cref="T:Sudoku.Concepts.Graphs.Cluster"/>
            <seealso href="http://sudopedia.enjoysudoku.com/Parity.html">Sudopedia Mirror - Parity</seealso>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Parity.#ctor(System.Boolean,Sudoku.Concepts.CellMap@)">
            <summary>
            <para>Represents one state of a candidate in a <see cref="T:Sudoku.Concepts.Graphs.Cluster"/>.</para>
            <para>
            Please visit <see href="http://sudopedia.enjoysudoku.com/Parity.html">this link</see>
            to learn more information about this concept.
            </para>
            </summary>
            <param name="ParityFlag">
            <para>Indicates which parity the current set belongs to.</para>
            <para>
            Due to limitation of this concept, there can only be 2 parities in one cluster.
            Therefore, this value is a <see cref="T:System.Boolean"/> indicating "on" and "off" state - they are opposite to each other.
            </para>
            </param>
            <param name="Cells">Indicates the cells used.</param>
            <seealso cref="T:Sudoku.Concepts.Graphs.Cluster"/>
            <seealso href="http://sudopedia.enjoysudoku.com/Parity.html">Sudopedia Mirror - Parity</seealso>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.Parity.ParityFlag">
            <summary>
            <para>Indicates which parity the current set belongs to.</para>
            <para>
            Due to limitation of this concept, there can only be 2 parities in one cluster.
            Therefore, this value is a <see cref="T:System.Boolean"/> indicating "on" and "off" state - they are opposite to each other.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Graphs.Parity.Cells">
            <summary>Indicates the cells used.</summary>
        </member>
        <member name="M:Sudoku.Concepts.Graphs.Parity.Create(Sudoku.Concepts.Graphs.CellGraph@)">
            <summary>
            Try to get all pairs of parities of all components of the specified graph.
            </summary>
            <param name="graph">The graph.</param>
            <returns>A list of pairs of parities of components of the specified graph.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Grid">
            <summary>
            Represents a sudoku grid.
            </summary>
            <remarks>
            <para><large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure></para>
            </remarks>
        </member>
        <member name="T:Sudoku.Concepts.Grid.Converter">
            <summary>
            Indicates the JSON converter of the current type.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Converter.HandleNull">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Grid,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.DefaultMask">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.DefaultMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.MaxCandidatesMask">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.MaxCandidatesMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyMask">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.EmptyMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.ModifiableMask">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.ModifiableMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.GivenMask">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.GivenMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.EmptyString">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.EmptyString"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Empty">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.Empty"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid.Undefined">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.Undefined"/>
        </member>
        <member name="F:Sudoku.Concepts.Grid._values">
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.FirstMaskRef"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.#ctor(System.Int32@,Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the pointer of the first element of the cell digit, and the creating option.
            </summary>
            <param name="firstElement">The reference of the first element.</param>
            <param name="creatingOption">The creating option.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="firstElement"/> is <see langword="null"/> reference.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsUndefined">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsSolved">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.IsMissingCandidates">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Symmetry">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.PuzzleType">
            <summary>
            Indicates the type of the puzzle.
            </summary>
            <remarks>
            By design, this property can only be either <see cref="F:Sudoku.SudokuType.Standard"/> or <see cref="F:Sudoku.SudokuType.Sukaku"/>;
            other values like <see cref="F:Sudoku.SudokuType.JustOneCell"/> won't be created here.
            </remarks>
            <seealso cref="F:Sudoku.SudokuType.Standard"/>
            <seealso cref="F:Sudoku.SudokuType.Sukaku"/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivenCellsCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiableCellsCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyCellsCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesCount">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyHouses">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CompletedHouses">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.GivenCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ModifiableCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.EmptyCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.BivalueCells">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.CandidatesMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.DigitsMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ValuesMap">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Candidates">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ConjugatePairs">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.ResetCandidatesGrid">
            <summary>
            Gets the grid where all empty cells are filled with all possible candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Grid.UnfixedGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.FixedGrid">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#FirstMaskRef">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#EmptyString">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#DefaultMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#MaxCandidatesMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#EmptyMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#ModifiableMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#GivenMask">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#Empty">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#Undefined">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Item(Sudoku.Concepts.CellMap@,System.Boolean,Sudoku.Concepts.MaskAggregator)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Deconstruct(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@,System.ReadOnlySpan{Sudoku.Concepts.CellMap}@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ConflictWith(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetExistence(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Exists(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CompareTo(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle type is Sukaku.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToDigitsArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToCandidateMaskArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ToMaskArray">
            <summary>
            Creates an array of <see cref="T:System.Int16"/> values that is a copy for the current inline array data structure.
            </summary>
            <returns>An array of <see cref="T:System.Int16"/> values.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetCandidates(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetDigit(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ResetCandidates">
            <summary>
            Reset the sudoku grid, but only making candidates to be reset to the initial state related to the current grid
            from given and modifiable values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Fix">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Unfix">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Apply(Sudoku.Concepts.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetState(System.Int32,Sudoku.Concepts.CellState)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetCandidates(System.Int32,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetMask(System.Int32,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.ReplaceDigit(System.Int32,System.Int32)">
            <summary>
            Replace the specified cell with the specified digit.
            </summary>
            <param name="cell">The cell to be set.</param>
            <param name="digit">The digit to be set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="digit"/> is invalid (e.g. -1).</exception>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetDigit(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.SetExistence(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHeaderBits(System.Int32)">
            <summary>
            Gets the header 4 bits. The value can be <see cref="F:Sudoku.SudokuType.Sukaku"/> if and only if the puzzle is Sukaku,
            and the argument <paramref name="cell"/> is 0.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The header 4 bits, represented as a <see cref="T:System.Int16"/>, left-shifted.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.GetHeaderBitsUnshifted(System.Int32)">
            <summary>
            Gets the header 4 bits. The value can be <see cref="F:Sudoku.SudokuType.Sukaku"/> if and only if the puzzle is Sukaku,
            and the argument <paramref name="cell"/> is 0.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The header 4 bits, represented as a <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.AddSukakuHeader">
            <summary>
            Appends for Sukaku puzzle header.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.RemoveSukakuHeader">
            <summary>
            Removes for Sukaku puzzle header.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IElementSwappingTransformable{Sudoku#Concepts#Grid,System#Int32}#Shuffle">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Linq#Providers#IWhereMethod{Sudoku#Concepts#Grid,System#Int32}#Where(System.Func{System.Int32,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Linq#Providers#ISelectMethod{Sudoku#Concepts#Grid,System#Int32}#Select``1(System.Func{System.Int32,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IBoardTransformable{Sudoku#Concepts#Grid}#MirrorLeftRight">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IBoardTransformable{Sudoku#Concepts#Grid}#MirrorTopBottom">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IBoardTransformable{Sudoku#Concepts#Grid}#MirrorDiagonal">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IBoardTransformable{Sudoku#Concepts#Grid}#MirrorAntidiagonal">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IBoardTransformable{Sudoku#Concepts#Grid}#RotateClockwise">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IBoardTransformable{Sudoku#Concepts#Grid}#RotateCounterclockwise">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Puzzles#Meta#Transforming#IElementSwappingTransformable{Sudoku#Concepts#Grid,System#Int32}#SwapElement(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Preserve(Sudoku.Concepts.CellMap@)">
            <summary>
            Gets a sudoku grid, removing all value digits not appearing in the specified <paramref name="pattern"/>.
            </summary>
            <param name="pattern">The pattern.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.String,System.IFormatProvider,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.Int32[],Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using grid values.
            </summary>
            <param name="gridValues">The array of grid values.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int32},Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance via the array of cell digits
            of type <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Int32"/>.
            </summary>
            <param name="gridValues">The list of cell digits.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.CreateEqualityComparer(Puzzles.Meta.Transforming.BoardComparison)">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> instance from the basic grid checking rule.
            </summary>
            <param name="comparison">Indicates the comparison rule.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#OnValueChanged(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#OnRefreshingCandidates(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Sudoku#Concepts#IGrid{Sudoku#Concepts#Grid}#Create(System.ReadOnlySpan{System.Int16})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Create(System.ReadOnlySpan{System.Int16})">
            <summary>
            Returns a <see cref="T:Sudoku.Concepts.Grid"/> instance via the raw mask values.
            </summary>
            <param name="values">
            <para>The raw mask values.</para>
            <para>
            This value can contain 1 or 81 elements.
            If the array contain 1 element, all elements in the target sudoku grid will be initialized by it, the uniform value;
            if the array contain 81 elements, elements will be initialized by the array one by one using the array elements respectively.
            </para>
            </param>
            <returns>A <see cref="T:Sudoku.Concepts.Grid"/> result.</returns>
            <remarks><b><i>
            This creation ignores header bits. Please don't use this method in the puzzle creation.
            </i></b></remarks>
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnValueChanged(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.IGrid`1.OnValueChanged(`0@,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.OnRefreshingCandidates(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Concepts.IGrid`1.OnRefreshingCandidates(`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Subtraction(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_CheckedSubtraction(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Equality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_Inequality(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Equality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IEqualityOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_Inequality(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_GreaterThan(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_LessThan(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_GreaterThanOrEqual(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.op_LessThanOrEqual(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_GreaterThan(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_LessThan(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#Numerics#IComparisonOperators{Sudoku#Concepts#Grid,Sudoku#Concepts#Grid,System#Boolean}#op_LessThanOrEqual(Sudoku.Concepts.Grid,Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.Equals(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Grid.System#IEquatable{Sudoku#Concepts#Grid}#Equals(Sudoku.Concepts.Grid)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.GridCreatingOption">
            <summary>
            Indicates the grid creating option.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.None">
            <summary>
            Indicates the option is none.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.MinusOne">
            <summary>
            Indicates each value should minus one before creation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridPredicates">
            <summary>
            Represents a list of methods to filter the cells.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a given cell.
            </summary>
            <typeparam name="TGrid">The type of the grid.</typeparam>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.ModifiableCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a modifiable cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.EmptyCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is an empty cell.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.BivalueCells``1(``0@,System.Int32)">
            <summary>
            Determines whether the specified cell in the specified grid is a bi-value cell, which means the cell is an empty cell,
            and contains and only contains 2 candidates.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.CandidatesMap``1(``0@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell.
            </summary>
            <typeparam name="TGrid">The type of the grid.</typeparam>
            <param name="g">The grid.</param>
            <param name="cell">The cell to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.DigitsMap``1(``0@,System.Int32,System.Int32)">
            <summary>
            Checks the existence of the specified digit in the specified cell, or whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.GivenCells``1(``0@,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.GridPredicates.ValuesMap``1(``0@,System.Int32,System.Int32)">
            <summary>
            Checks whether the cell is a value cell, being filled by the digit.
            </summary>
            <inheritdoc cref="M:Sudoku.Concepts.GridPredicates.CandidatesMap``1(``0@,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Sudoku.Concepts.HouseMarshal">
            <summary>
            Represents a list of extension methods that operates with house instances, as <see cref="T:System.Int32"/> representation.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseMarshal.ToHouseType(System.Int32)">
            <summary>
            Get the house type for the specified house index.
            </summary>
            <param name="houseIndex">The house index.</param>
            <returns>
            The house type. The possible return values are:
            <list type="table">
            <listheader>
            <term>House indices</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 0 and < 9]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Block"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 9 and < 18]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Row"/></description>
            </item>
            <item>
            <term><paramref name="houseIndex"/> is <![CDATA[>= 18 and < 27]]></term>
            <description><see cref="F:Sudoku.Concepts.HouseType.Column"/></description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseMaskOperations">
            <summary>
            Represents a list of methods handling with <see cref="T:System.Int32"/> instances.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="F:Sudoku.Concepts.HouseMaskOperations.AllBlocksMask">
            <summary>
            Indicates the mask that means all blocks.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseMaskOperations.AllRowsMask">
            <summary>
            Indicates the mask that means all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseMaskOperations.AllColumnsMask">
            <summary>
            Indicates the mask that means all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseMaskOperations.AllHousesMask">
            <summary>
            Indicates the mask that means all houses.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.HouseMaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int32"/> instance via the specified houses.
            </summary>
            <param name="houses">The houses.</param>
            <returns>A <see cref="T:System.Int32"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.HouseMaskOperations.SplitMask(System.Int32)">
            <summary>
            Try to split mask into three parts.
            </summary>
            <param name="this">The mask to be split.</param>
            <returns>The mask split.</returns>
        </member>
        <member name="T:Sudoku.Concepts.HouseType">
            <summary>
            Represents a <see href="http://sudopedia.enjoysudoku.com/House.html">house type</see>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Block">
            <summary>
            Indicates the house type is a block.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Row">
            <summary>
            Indicates the house type is a row.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.HouseType.Column">
            <summary>
            Indicates the house type is a column.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.HouseTypeExtensions">
            <summary>
            Provides extension methods on <see cref="T:Sudoku.Concepts.HouseType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.HouseType"/>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetLabel(Sudoku.Concepts.HouseType)">
            <summary>
            Try to get the label of the specified house type.
            </summary>
            <param name="this">The house type.</param>
            <returns>A character that represents a house type.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.HouseTypeExtensions.GetProgramOrder(Sudoku.Concepts.HouseType)">
            <summary>
            Gets the ordering of the house type. The result value will be 0, 1 and 2.
            </summary>
            <param name="this">The house type.</param>
            <returns>The program order.</returns>
        </member>
        <member name="T:Sudoku.Concepts.ICellMapOrCandidateMap`3">
            <summary>
            Extracts a base type that describes state table from elements of <typeparamref name="TSelf" /> type.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
            <typeparam name="TElement">The type of each element.</typeparam>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
        </member>
        <member name="F:Sudoku.Concepts.ICellMapOrCandidateMap`3.MaxLimit">
            <summary>
            Indicates the size of combinatorial calculation.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.StringChunks">
            <summary>
            Gets all chunks of the current collection, meaning a list of <see cref="T:System.String"/> values that can describe
            all offset values (cell indices and candidate indices), grouped with same row/column.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.PeerIntersection">
            <summary>
            Indicates the peer intersection of the current instance.
            </summary>
            <remarks>
            A <b>Peer Intersection</b> is a set of offsets that all offsets from the base collection can be seen.
            For more information please visit <see href="http://sudopedia.enjoysudoku.com/Peer.html">this link</see>.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Shifting">
            <summary>
            Indicates the size of each unit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Offsets">
            <summary>
            Indicates the offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Empty">
            <summary>
            Indicates an empty instance containing no elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Full">
            <summary>
            Indicates an instance that contains all possible elements.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.MaxCount">
            <summary>
            Indicates the maximum number of elements that the collection can be reached.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IAdditiveIdentity{TSelf,TSelf}#AdditiveIdentity">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IMinMaxValue{TSelf}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IMinMaxValue{TSelf}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Item(`1)">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlyList{TElement}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.AddRange(System.ReadOnlySpan{`1})">
            <summary>
            Adds a list of offsets into the current collection.
            </summary>
            <param name="offsets">
            <para>Offsets to be added.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>The number of offsets succeeded to be added.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.RemoveRange(System.ReadOnlySpan{`1})">
            <summary>
            Removes a list of offsets from the current collection.
            </summary>
            <param name="offsets">
            <para>Offsets to be removed.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>The number of offsets succeeded to be removed.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.CopyTo(`1@,System.Int32)">
            <summary>
            Copies the current instance to the target sequence specified as a reference
            to an element of type <typeparamref name="TElement"/>.
            </summary>
            <param name="sequence">
            The reference that points to the first element in a sequence of type <typeparamref name="TElement"/>.
            </param>
            <param name="length">The length of that array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="sequence"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Throws when the capacity isn't enough to store all values.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.ForEach(System.Action{`1})">
            <summary>
            Iterates on each element in this collection.
            </summary>
            <param name="action">The visitor that handles for each element in this collection.</param>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.Toggle(`1)">
            <summary>
            Try to toggle the offset, which means the value will be added if not exist in collection, or removed if exists.
            </summary>
            <param name="offset">The offset to be added or removed.</param>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.IndexOf(`1)">
            <summary>
            Try to get the specified index of the offset.
            </summary>
            <param name="offset">The desired offset.</param>
            <returns>The index of the offset.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.CompareTo(`0@)">
            <summary>
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/summary"/>
            </summary>
            <param name="other"><inheritdoc cref="M:System.IComparable`1.CompareTo(`0)" path="/param[@name='other']"/></param>
            <returns>
            <para>The result value only contains 3 possible values: 1, 0 and -1.</para>
            <para>
            The comparison rule is:
            <list type="number">
            <item>
            If <see langword="this"/> holds more offsets than <paramref name="other"/>, then return 1
            indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <see langword="this"/> holds fewer offsets than <paramref name="other"/>, then return -1
            indicating <paramref name="other"/> is greater.
            </item>
            <item>
            If they two hold same offsets, then checks for indices held:
            <list type="bullet">
            <item>
            If <see langword="this"/> holds a cell whose index is greater than all offsets appeared in <paramref name="other"/>,
            then return 1 indicating <see langword="this"/> is greater.
            </item>
            <item>
            If <paramref name="other"/> holds a cell whose index is greater than all offsets
            appeared in <paramref name="other"/>, then return -1 indicating <paramref name="other"/> is greater.
            </item>
            </list>
            </item>
            </list>
            If all rules are compared, but they are still considered equal, then return 0.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.Equals(`0@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.ToArray">
            <summary>
            Returns an array of <typeparamref name="TElement"/> offsets having stored in the current collection.
            </summary>
            <returns>An array of offsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.Slice(System.Int32,System.Int32)">
            <summary>
            Slices the current instance, and get the new instance with some of elements between two indices.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The number of elements.</param>
            <returns>The target instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#CopyTo(`1[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#IEquatable{TSelf}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#ExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#IntersectWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ISet{TElement}#UnionWith(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#Overlaps(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#SetEquals(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSubsetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IReadOnlySet{TElement}#IsSupersetOf(System.Collections.Generic.IEnumerable{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#ICollection{TElement}#Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Linq#Providers#IContainsMethod{TSelf,TElement}#Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Linq#Providers#ICountMethod{TSelf,TElement}#Count">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#IComparable{TSelf}#CompareTo(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAt(System.Index)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAtOrDefault(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Linq#Providers#IElementAtMethod{TSelf,TElement}#ElementAtOrDefault(System.Index)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IFiniteSet{TSelf,TElement}#Negate">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IInfiniteSet{TSelf,TElement}#ExceptWith(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Linq#Providers#IGetSubsetMethod{TSelf,TElement}#GetSubsets(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_LogicalNot(`0@)">
            <summary>
            Determines whether the current collection is empty.
            </summary>
            <param name="offsets">The offsets to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <remarks>
            The type of the current collection supports using <see cref="T:System.Boolean"/>-like expression to determine whether the collection is not empty,
            for example:
            <code><![CDATA[
            if (collection)
                // ...
            ]]></code>
            The statement <c>collection</c> will be expanded to <c>collection.Count != 0</c>. Therefore, the negation operator <c>!</c>
            will invert the result of above expression. This is why I use <see langword="operator"/> <c>!</c> to determine on this.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_OnesComplement(`0@)">
            <summary>
            Reverse state for all offsets, which means all <see langword="true"/> bits
            will be set <see langword="false"/>, and all <see langword="false"/> bits
            will be set <see langword="true"/>.
            </summary>
            <param name="offsets">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_True(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is not empty.
            </summary>
            <param name="map">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_False(`0@)">
            <summary>
            Determines whether the specified <typeparamref name="TSelf"/> collection is empty.
            </summary>
            <param name="map">The collection.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_Equality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_Inequality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_Addition(`0@,`1)">
            <summary>
            Adds the specified <paramref name="offset"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be added.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_Subtraction(`0@,`1)">
            <summary>
            Removes the specified <paramref name="offset"/> from the <paramref name="collection"/>,
            and returns the removed result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_BitwiseAnd(`0@,`0@)">
            <summary>
            Get the elements that both <paramref name="left"/> and <paramref name="right"/> contain.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_BitwiseOr(`0@,`0@)">
            <summary>
            Combine the elements from <paramref name="left"/> and <paramref name="right"/>,
            and return the merged result.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_ExclusiveOr(`0@,`0@)">
            <summary>
            Get the elements that either <paramref name="left"/> or <paramref name="right"/> contains.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_Modulus(`0@,`0@)">
            <summary>
            Expands the operator to <c><![CDATA[(a & b).PeerIntersection & b]]></c>.
            </summary>
            <param name="base">The base map.</param>
            <param name="template">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
            <remarks>
            <para>
            The operator is commonly used for checking eliminations, especially in type 2 of deadly patterns. 
            </para>
            <para>
            For example, if we should check the eliminations
            of digit <c>d</c>, we may use the expression
            <code><![CDATA[
            (urCells & grid.CandidatesMap[d]).PeerIntersection & grid.CandidatesMap[d]
            ]]></code>
            to express the eliminations are the peer intersection of cells of digit <c>d</c>
            appeared in <c>urCells</c>. This expression can be simplified to
            <code><![CDATA[
            urCells % grid.CandidatesMap[d]
            ]]></code>
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_BitwiseAnd(`0@,System.Int32)">
            <summary>
            Gets the subsets of the current collection via the specified size indicating the number of elements of the each subset.
            </summary>
            <param name="map">The instance to check for subsets.</param>
            <param name="subsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="subsetSize"/> &gt; Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term><c><paramref name="subsetSize"/> == Count</c></term>
            <description>
            Will return an array that contains only one element, same as the current instance.
            </description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.NotSupportedException">
            Throws when both the count of the current instance and <paramref name="subsetSize"/> are greater than 30.
            </exception>
            <remarks>
            For example, if the current instance is <c>r1c1</c>, <c>r1c2</c> and <c>r1c3</c>
            and the argument <paramref name="subsetSize"/> is 2,
            the method will return an array of 3 elements given below: <c>r1c12</c>, <c>r1c13</c> and <c>r1c23</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_BitwiseOr(`0@,System.Int32)">
            <summary>
            Gets all subsets of the current collection via the specified size
            indicating the <b>maximum</b> number of elements of the each subset.
            </summary>
            <param name="map">The instance to check subsets.</param>
            <param name="subsetSize">The desired size.</param>
            <returns>
            All possible subsets. If <paramref name="subsetSize"/> is greater than <see cref="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Count"/>,
            this method will return all possible subsets without throwing exceptions.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.op_BitwiseOr(`0@,System.Range)">
            <summary>
            Gets all subsets of the current collection via the specified range of the subset size.
            </summary>
            <param name="map">The instance to check subsets.</param>
            <param name="subsetSizeRange">The desired size.</param>
            <returns>All possible subsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#ILogicalOperators{TSelf}#op_LogicalNot(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Equality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Inequality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IAdditionOperators{TSelf,TElement,TSelf}#op_Addition(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#ISubtractionOperators{TSelf,TElement,TSelf}#op_Subtraction(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IModulusOperators{TSelf,TSelf,TSelf}#op_Modulus(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_OnesComplement(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseAnd(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_BitwiseOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ICellMapOrCandidateMap`3.System#Numerics#IBitwiseOperators{TSelf,TSelf,TSelf}#op_ExclusiveOr(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.IGrid`1">
            <summary>
            Represents a type that supports all basic functions that operates with a sudoku puzzle.
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
        </member>
        <member name="F:Sudoku.Concepts.IGrid`1.HeaderShift">
            <summary>
            Indicates the shifting bits count for header bits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.IGrid`1.SukakuHeader">
            <summary>
            Indicates ths header bits describing the sudoku type is a Sukaku.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.IsMissingCandidates">
            <summary>
            Determines whether the current grid contains any missing candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.IsEmpty">
            <summary>
            Indicates whether the grid is <see cref="P:Sudoku.Concepts.IGrid`1.Empty"/>, which means the grid holds totally same value with <see cref="P:Sudoku.Concepts.IGrid`1.Empty"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.IsUndefined">
            <summary>
            Indicates whether the grid is <see cref="P:Sudoku.Concepts.IGrid`1.Undefined"/>, which means the grid holds totally same value with <see cref="P:Sudoku.Concepts.IGrid`1.Undefined"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.IsSolved">
            <summary>
            Indicates the grid has already solved. If the value is <see langword="true"/>, the grid is solved;
            otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Symmetry">
            <summary>
            Try to get the symmetry of the puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.GivenCellsCount">
            <summary>
            Indicates the total number of given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.ModifiableCellsCount">
            <summary>
            Indicates the total number of modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.EmptyCellsCount">
            <summary>
            Indicates the total number of empty cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.GivenCells">
            <summary>
            Gets a cell list that only contains the given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.ModifiableCells">
            <summary>
            Gets a cell list that only contains the modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.EmptyCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid is empty.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.BivalueCells">
            <summary>
            Indicates a cell list whose corresponding position in this grid contain two candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.CandidatesCount">
            <summary>
            Indicates the number of total candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.CandidatesMap">
            <summary>
            Indicates the map of possible positions of the existence of the candidate value for each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.DigitsMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of each digit. The return value will
            be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.IGrid`1.CandidatesMap"/>, this property contains all givens, modifiables and
            empty cells only if it contains the digit in the mask.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.ValuesMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of that value of each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.IGrid`1.CandidatesMap"/>, the value only contains the given or modifiable
            cells whose mask contain the set bit of that digit.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Candidates">
            <summary>
            Indicates all possible candidates in the current grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.ConjugatePairs">
            <summary>
            Indicates all possible conjugate pairs appeared in this grid.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.EmptyHouses">
            <summary>
            <para>Indicates which houses are empty houses.</para>
            <para>An <b>Empty House</b> is a house holding 9 empty cells, i.e. all cells in this house are empty.</para>
            <para>
            The property returns a <see cref="T:System.Int32"/> value as a mask that contains all possible house indices.
            For example, if the row 5, column 5 and block 5 (1-9) are null houses, the property will return
            the result <see cref="T:System.Int32"/> value, <c>000010000_000010000_000010000</c> as binary.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.CompletedHouses">
            <summary>
            <para>Indicates which houses are completed, regardless of ways of filling.</para>
            <para><inheritdoc cref="P:Sudoku.Concepts.IGrid`1.EmptyHouses" path="//summary/para[3]"/></para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.ResetGrid">
            <summary>
            Gets the grid where all modifiable cells are empty cells (i.e. the initial one).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.UnfixedGrid">
            <summary>
            Indicates the unfixed grid for the current grid, meaning all given digits will be replaced with modifiable ones.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.FixedGrid">
            <summary>
            Indicates the fixed grid for the current grid, meaning all modifiable digits will be replaced with given ones.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.FirstMaskRef">
            <summary>
            Indicates the inner array that stores the masks of the sudoku grid, which stores the in-time sudoku grid inner information.
            </summary>
            <remarks>
            The field uses the mask table of length 81 to indicate the state and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            | 15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0 |
            |---------------|-----------|-----------------------------------|
            |   |   |   |   | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
            '---------------|-----------|-----------------------------------'
             \_____________/ \_________/ \_________________________________/
                   (3)           (2)                     (1)
            </code>
            Here the 9 bits in (1) indicate whether each digit is possible candidate in the current cell for each bit respectively,
            and the higher 3 bits in (2) indicate the cell state. The possible cell state are:
            <list type="table">
            <listheader>
            <term>State name</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Empty cell (flag: <see cref="F:Sudoku.Concepts.CellState.Empty"/>)</term>
            <description>The cell is currently empty, and wait for being filled.</description>
            </item>
            <item>
            <term>Modifiable cell (flag: <see cref="F:Sudoku.Concepts.CellState.Modifiable"/>)</term>
            <description>The cell is filled by a digit, but the digit isn't the given by the initial grid.</description>
            </item>
            <item>
            <term>Given cell (flag: <see cref="F:Sudoku.Concepts.CellState.Given"/>)</term>
            <description>The cell is filled by a digit, which is given by the initial grid and can't be modified.</description>
            </item>
            </list>
            Part (3) is for the reserved bits. Such bits won't be used except for the array element at index 0 -
            The first element in the array will use (3) to represent the sudoku grid type. There are only two kinds of grid type value:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>0b0000</term>
            <description>Represents standard sudoku type (flag: <see cref="F:Sudoku.SudokuType.Standard"/>)</description>
            </item>
            <item>
            <term>0b0010</term>
            <description>Represents Sukaku (flag: <see cref="F:Sudoku.SudokuType.Sukaku"/>)</description>
            </item>
            </list>
            Other values won't be supported for now, even if the flags are defined in type <see cref="T:Sudoku.SudokuType"/>.
            </remarks>
            <seealso cref="T:Sudoku.Concepts.CellState"/>
            <seealso cref="T:Sudoku.SudokuType"/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Puzzles#Meta#Concepts#IBoard#Rows">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Puzzles#Meta#Concepts#IBoard#Columns">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.EmptyString">
            <summary>
            Represents a string value that describes a <typeparamref name="TSelf"/> instance can be parsed into <see cref="P:Sudoku.Concepts.IGrid`1.Empty"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.DefaultMask">
            <summary>
            Indicates the default mask of a cell (an empty cell, with all 9 candidates left).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.EmptyMask">
            <summary>
            Indicates the empty mask, modifiable mask and given mask.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.ModifiableMask">
            <summary>
            Indicates the modifiable mask.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.GivenMask">
            <summary>
            Indicates the given mask.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.MaxCandidatesMask">
            <summary>
            Indicates the maximum candidate mask that used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Empty">
            <summary>
            The empty grid that is valid during implementation or running the program
            (all values are <see cref="P:Sudoku.Concepts.IGrid`1.DefaultMask"/>, i.e. empty cells).
            </summary>
            <remarks>
            This field is initialized by the static constructor of this structure.
            </remarks>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.DefaultMask"/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Undefined">
            <summary>
            Indicates the default grid that all values are initialized 0.
            This value is equivalent to <see langword="default"/>(<typeparamref name="TSelf"/>).
            </summary>
            <remarks>
            This value can be used for non-candidate-based sudoku operations, e.g. a sudoku grid canvas.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.System#Numerics#IMinMaxValue{TSelf}#MinValue">
            <summary>
            Indicates the minimum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.System#Numerics#IMinMaxValue{TSelf}#MaxValue">
            <summary>
            Indicates the maximum possible grid value that the current type can reach.
            </summary>
            <remarks>
            This value is found out via backtracking algorithm.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Item(System.Int32)">
            <summary>
            Gets the mask at the specified position.
            </summary>
            <param name="cell">The desired cell index.</param>
            <returns>The reference to the mask.</returns>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Item(Sudoku.Concepts.CellMap@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">A list of desired cells.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.Item(Sudoku.Concepts.CellMap@,System.Boolean,Sudoku.Concepts.MaskAggregator)">
            <summary>
            <inheritdoc cref="P:Sudoku.Concepts.IGrid`1.Item(Sudoku.Concepts.CellMap@)" path="/summary"/>
            </summary>
            <param name="cells"><inheritdoc cref="P:Sudoku.Concepts.IGrid`1.Item(Sudoku.Concepts.CellMap@)" path="/param[@name='cells']"/></param>
            <param name="withValueCells">
            Indicates whether the value cells (given or modifiable ones) will be included to be checked.
            If <see langword="true"/>, all value cells (no matter what kind of cell) will be summed up.
            </param>
            <param name="aggregator">
            Indicates the aggregator method.
            <list type="bullet">
            <item><c>'<![CDATA[&]]>'</c>: Use <b>bitwise and</b> operator to merge masks.</item>
            <item><c>'<![CDATA[|]]>'</c>: Use <b>bitwise or</b> operator to merge masks.</item>
            <item><c>'<![CDATA[~]]>'</c>: Use <b>bitwise nand</b> operator to merge masks.</item>
            </list>
            By default, the value is <c>'<![CDATA[|]]>'</c>. You can reference <see cref="T:Sudoku.Concepts.MaskAggregator"/> constants to set values.
            </param>
            <returns><inheritdoc cref="P:Sudoku.Concepts.IGrid`1.Item(Sudoku.Concepts.CellMap@)" path="/returns"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when <paramref name="aggregator"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Reset">
            <summary>
            Reset the sudoku grid, making all modifiable values to empty ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Fix">
            <summary>
            Fix the current grid, making all modifiable values will be changed to given ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Unfix">
            <summary>
            Unfix the current grid, making all given values will be changed to modifiable ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Apply(Sudoku.Concepts.Conclusion)">
            <summary>
            Try to apply the specified conclusion.
            </summary>
            <param name="conclusion">The conclusion to be applied.</param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.SetState(System.Int32,Sudoku.Concepts.CellState)">
            <summary>
            Set the specified cell to the specified state.
            </summary>
            <param name="cell">The cell.</param>
            <param name="state">The state.</param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.SetCandidates(System.Int32,System.Int16)">
            <summary>
            Set the specified cell with specified candidates.
            </summary>
            <param name="cell">The cell.</param>
            <param name="mask">The mask that holds a list of desired digits.</param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.SetMask(System.Int32,System.Int16)">
            <summary>
            Set the specified cell to the specified mask.
            </summary>
            <param name="cell">The cell.</param>
            <param name="mask">The mask to set.</param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.SetDigit(System.Int32,System.Int32)">
            <summary>
            Set the specified digit into the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">
            <para>
            The value you want to set. The value should be between 0 and 8.
            If assigning -1, the grid will execute an implicit behavior that candidates in <b>all</b> empty cells will be re-computed.
            </para>
            <para>
            The values set into the grid will be regarded as the modifiable values.
            If the cell contains a digit, it will be covered when it is a modifiable value.
            If the cell is a given cell, the setter will do nothing.
            </para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.SetExistence(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the target candidate state.
            </summary>
            <param name="cell">The cell offset between 0 and 80.</param>
            <param name="digit">The digit between 0 and 8.</param>
            <param name="isOn">
            The case you want to set. <see langword="false"/> means that this candidate
            doesn't exist in this current sudoku grid; otherwise, <see langword="true"/>.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.GetExistence(System.Int32,System.Int32)">
            <summary>
            Sets a candidate existence case with a <see cref="T:System.Boolean"/> value.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <inheritdoc cref="M:Sudoku.Concepts.IGrid`1.SetExistence(System.Int32,System.Int32,System.Boolean)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Equals(`0@)">
            <summary>
            Determines whether the current instance has same mask values with the other object.
            </summary>
            <param name="other">The other instance.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.ConflictWith(System.Int32,System.Int32)">
            <summary>
            Determine whether the digit in the target cell is conflict with a certain cell in the peers of the current cell,
            if the digit is filled into the cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Exists(System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.IGrid`1.Exists(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Exists(System.Int32,System.Int32)">
            <summary>
            Indicates whether the current grid contains the digit in the specified cell.
            </summary>
            <param name="cell">The cell to be checked.</param>
            <param name="digit">The digit to be checked.</param>
            <returns>
            The method will return a <see cref="T:System.Boolean"/>? value
            (containing three possible cases: <see langword="true"/>, <see langword="false"/> and <see langword="null"/>).
            All values corresponding to the cases are below:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Case description on this value</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>
            The cell is an empty cell <b>and</b> contains the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            The cell is an empty cell <b>but doesn't</b> contain the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The cell is <b>not</b> an empty cell.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Note that the method will return a <see cref="T:System.Boolean"/>?, so you should use the code
            '<c>grid.Exists(cell, digit) is true</c>' or '<c>grid.Exists(cell, digit) == true</c>'
            to decide whether a condition is true.
            </para>
            <para>
            In addition, because the type is <see cref="T:System.Boolean"/>? rather than <see cref="T:System.Boolean"/>,
            the result case will be more precisely than the indexer <see cref="M:Sudoku.Concepts.IGrid`1.GetExistence(System.Int32,System.Int32)"/>,
            which is the main difference between this method and that indexer.
            </para>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.IGrid`1.GetExistence(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.CompareTo(`0@)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.ToString(System.String)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.GetState(System.Int32)">
            <summary>
            Get the cell state at the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The cell state.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.GetCandidates(System.Int32)">
            <summary>
            Get the candidate mask part of the specified cell.
            </summary>
            <param name="cell">The cell offset you want to get.</param>
            <returns>
            <para>
            The candidate mask. The return value is a 9-bit <see cref="T:System.Int16"/> value, where each bit will be:
            <list type="table">
            <item>
            <term><c>0</c></term>
            <description>The cell <b>doesn't contain</b> the possibility of the digit.</description>
            </item>
            <item>
            <term><c>1</c></term>
            <description>The cell <b>contains</b> the possibility of the digit.</description>
            </item>
            </list>
            </para>
            <para>
            For example, if the result mask is 266 (i.e. <c>0b<b>1</b>00_00<b>1</b>_0<b>1</b>0</c> in binary),
            the value will indicate the cell contains the digit 2, 4 and 9.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.GetDigit(System.Int32)">
            <summary>
            Try to get the digit filled in the specified cell.
            </summary>
            <param name="cell">The cell used.</param>
            <returns>The digit that the current cell filled. If the cell is empty, return -1.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the specified cell keeps a wrong cell state value.</exception>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.ToCandidateMaskArray">
            <summary>
            Serializes this instance to an array, where all digit value will be stored.
            </summary>
            <returns>
            This array. All elements are the raw masks
            that are between 0 and <see cref="P:Sudoku.Concepts.IGrid`1.MaxCandidatesMask"/> (i.e. 511).
            </returns>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.MaxCandidatesMask"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.ToDigitsArray">
            <summary>
            Try to create a new array of <see cref="T:System.Int32"/> instances indicating filling digits inside cells.
            </summary>
            <returns>An array of <see cref="T:System.Int32"/> instances.</returns>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#IEquatable{TSelf}#Equals(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#IComparable{TSelf}#CompareTo(`0)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.IGrid`1.System#Collections#Generic#IReadOnlyCollection{System#Int32}#Count">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Linq#Providers#IToArrayMethod{TSelf,System#Int32}#ToArray">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.TryParse(System.String,System.IFormatProvider,`0@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)">
            <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.TryParse(System.String,`0@)">
            <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.TryParse(System.ReadOnlySpan{System.Char},`0@)">
            <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Create(System.ReadOnlySpan{System.Int16})">
            <summary>
            Creates a <typeparamref name="TSelf"/> instance via the specified list of <see cref="T:System.Int16"/> values.
            </summary>
            <param name="values">The values to be created.</param>
            <returns>A <typeparamref name="TSelf"/> instance created.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Parse(System.String)">
            <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.Parse(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.OnValueChanged(`0@,System.Int32,System.Int32)">
            <summary>
            Event handler on value changed.
            </summary>
            <param name="this">The grid itself.</param>
            <param name="cell">Indicates the cell changed.</param>
            <param name="setValue">
            Indicates the set value. If to clear the cell, the value will be -1.
            In fact, if the value is -1, this method will do nothing.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.OnRefreshingCandidates(`0@)">
            <summary>
            Event handler on refreshing candidates.
            </summary>
            <param name="this">The grid itself.</param>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.GetMap(`0@,)">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.IGrid`1.EmptyCells"/> and <see cref="P:Sudoku.Concepts.IGrid`1.BivalueCells"/>.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">The predicate.</param>
            <returns>The map.</returns>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.EmptyCells"/>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.BivalueCells"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.GetMaps(`0@,)">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.IGrid`1.CandidatesMap"/>, <see cref="P:Sudoku.Concepts.IGrid`1.DigitsMap"/> and <see cref="P:Sudoku.Concepts.IGrid`1.ValuesMap"/>.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">The predicate.</param>
            <returns>The map indexed by each digit.</returns>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.CandidatesMap"/>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.DigitsMap"/>
            <seealso cref="P:Sudoku.Concepts.IGrid`1.ValuesMap"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_Equality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_Inequality(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_GreaterThan(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_GreaterThanOrEqual(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_LessThan(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_LessThanOrEqual(`0@,`0@)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_Subtraction(`0@,`0@)">
            <summary>
            Analyzes difference between two grids.
            If two grids are not same from given cells, the return value will be <see langword="null"/>.
            </summary>
            <param name="left">The first grid to be checked.</param>
            <param name="right">The second grid to be checked.</param>
            <returns>The difference between two grids.</returns>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.op_CheckedSubtraction(`0@,`0@)">
            <summary>
            Analyzes difference between two grids.
            If two grids are not same from given cells, a <see cref="T:Sudoku.Behaviors.Diff.GridDiffTooMuchException"/> instance will be thrown.
            </summary>
            <param name="left">The first grid to be checked.</param>
            <param name="right">The second grid to be checked.</param>
            <returns>The difference between two grids.</returns>
            <exception cref="T:Sudoku.Behaviors.Diff.GridDiffTooMuchException">Throws when two grids are not same from given cells.</exception>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Equality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#IEqualityOperators{TSelf,TSelf,System#Boolean}#op_Inequality(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_GreaterThan(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_LessThan(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_GreaterThanOrEqual(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#IComparisonOperators{TSelf,TSelf,System#Boolean}#op_LessThanOrEqual(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#ISubtractionOperators{TSelf,TSelf,Sudoku#Behaviors#Diff#DiffResult}#op_Subtraction(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.IGrid`1.System#Numerics#ISubtractionOperators{TSelf,TSelf,Sudoku#Behaviors#Diff#DiffResult}#op_CheckedSubtraction(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.MaskAggregator">
            <summary>
            Represents an aggregator of mask merging.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.MaskAggregator.Or">
            <summary>
            Indicates the method is "or".
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.MaskAggregator.And">
            <summary>
            Indicates the method is "and".
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.MaskAggregator.AndNot">
            <summary>
            Indicates the method is "and not".
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.MaskOperations">
            <summary>
            Provides with a set of methods that operates with mask defined in basic sudoku concepts, as data structures.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.ToBinaryString(System.Int16,System.Boolean)">
            <summary>
            Try to convert the current mask value into a valid <see cref="T:System.String"/> representation of binary format.
            </summary>
            <param name="mask">The mask to be formatted.</param>
            <param name="upperCasedPrefix">
            Indicates whether the prefix <c>"0b"</c> will become upper-cased (i.e. <c>"0B"</c>).
            The default value is <see langword="false"/>.
            </param>
            <returns>A <see cref="T:System.String"/> result representing the current mask value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.ToOctalString(System.Int16,System.Boolean)">
            <summary>
            Try to convert the current mask value into a valid <see cref="T:System.String"/> representation of octal format.
            </summary>
            <param name="mask">The mask to be formatted.</param>
            <param name="upperCasedPrefix">
            Indicates whether the prefix <c>"0o"</c> will become upper-cased (i.e. <c>"0O"</c>).
            The default value is <see langword="false"/>.
            </param>
            <returns>A <see cref="T:System.String"/> result representing the current mask value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.ToHexadecimalString(System.Int16,System.Boolean)">
            <summary>
            Try to convert the current mask value into a valid <see cref="T:System.String"/> representation of hexadecimal format.
            </summary>
            <param name="mask">The mask to be formatted.</param>
            <param name="upperCasedPrefix">
            Indicates whether the prefix <c>"0x"</c> will become upper-cased (i.e. <c>"0X"</c>).
            The default value is <see langword="false"/>.
            </param>
            <returns>A <see cref="T:System.String"/> result representing the current mask value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.Create(System.ReadOnlySpan{System.Int32})">
            <summary>
            Creates for a <see cref="T:System.Int16" /> instance via the specified digits.
            </summary>
            <param name="digits">
            <para>Indicates the digits to assign.</para>
            <target name="parameter">
				<para>
					If a <see langword="ref struct" />-typed parameter is marked as <see langword="params" />,
					it will be implicit-<see langword="scoped" />, which means you must use this variables inside the method.
					Value-storages are not permitted.
				</para>
				<para>
					Use <see cref="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute" /> if you want to store variable values.
				</para>
			</target>
            </param>
            <returns>A <see cref="T:System.Int16" /> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.Create(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Concepts.MaskOperations.Create(System.ReadOnlySpan{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.Create``1(``0)">
            <typeparam name="TDigits">The type of the enumerable sequence.</typeparam>
            <inheritdoc cref="M:Sudoku.Concepts.MaskOperations.Create(System.ReadOnlySpan{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.MaskToDigits(System.Int16)">
            <summary>
            To get the digits that the current mask represents for. The mask must be between 0 and 512, and exclude 512.
            </summary>
            <param name="digitMask">The digit mask.</param>
            <returns>The digits returned.</returns>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.MaskToSudokuType(System.Int16)">
            <summary>
            To get the sudoku type for the specified cell mask inside a <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The cell mask.</param>
            <returns>The sudoku type configured.</returns>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.MaskToCellState(System.Int16)">
            <summary>
            To get the cell state for a mask value. The mask is an inner representation to describe a cell's state.
            For more information please visit the details of the design for type <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <param name="mask">The mask.</param>
            <returns>The cell state.</returns>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.MaskOperations.SplitMask(System.Int16)">
            <summary>
            Try to split a mask into 3 parts, 3-bit as a unit.
            </summary>
            <param name="this">The mask instance to be split.</param>
            <returns>A triplet of values.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Miniline">
            <summary>
            Represents a miniline (mini-row or mini-column).
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="M:Sudoku.Concepts.Miniline.#ctor(Sudoku.Concepts.MinilineBase@,Sudoku.Concepts.MinilineResult@)">
            <summary>
            Represents a miniline (mini-row or mini-column).
            </summary>
            <param name="Base">Indicates the base that describes the block and line index.</param>
            <param name="Result">Indicates the result values.</param>
        </member>
        <member name="P:Sudoku.Concepts.Miniline.Base">
            <summary>Indicates the base that describes the block and line index.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Miniline.Result">
            <summary>Indicates the result values.</summary>
        </member>
        <member name="F:Sudoku.Concepts.Miniline.MinilinesGroupedByChuteIndex">
            <summary>
            Indicates the mini-lines to be iterated, grouped by chute index.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Miniline.Map">
            <summary>
            <para>
            Indicates all maps that forms the each intersection. The pattern will be like:
            <code><![CDATA[
            .-------.-------.-------.
            | C C C | A A A | A A A |
            | B B B | . . . | . . . |
            | B B B | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            </para>
            <para>
            In addition, in this data pattern, a <b>CoverSet</b> is a block and a <b>BaseSet</b> is a line.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Miniline.IntersectionBlockTable">
            <summary>
            Indicates the internal intersection block combinations.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Miniline.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Concepts.MinilineBase">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="M:Sudoku.Concepts.MinilineBase.#ctor(System.Byte,System.Byte)">
            <summary>
            Defines a pair of houses that means the target pair can form an intersection by the specified line and block.
            </summary>
            <param name="Line">The index of the line.</param>
            <param name="Block">The index of the block.</param>
        </member>
        <member name="P:Sudoku.Concepts.MinilineBase.Line">
            <summary>The index of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineBase.Block">
            <summary>The index of the block.</summary>
        </member>
        <member name="T:Sudoku.Concepts.MinilineResult">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used,
            especially used by <see cref="F:Sudoku.Concepts.Miniline.Map"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Miniline.Map"/>
        </member>
        <member name="M:Sudoku.Concepts.MinilineResult.#ctor(Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,Sudoku.Concepts.CellMap@,System.Byte[])">
            <summary>
            Defines a tuple of <see cref="T:Sudoku.Concepts.CellMap"/> instances that represents the house cells used,
            especially used by <see cref="F:Sudoku.Concepts.Miniline.Map"/> property.
            </summary>
            <param name="LineMap">The map of the line.</param>
            <param name="BlockMap">The map of the block.</param>
            <param name="IntersectionMap">The map of the intersection.</param>
            <param name="OtherBlocks">
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </param>
            <seealso cref="F:Sudoku.Concepts.Miniline.Map"/>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.LineMap">
            <summary>The map of the line.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.BlockMap">
            <summary>The map of the block.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.IntersectionMap">
            <summary>The map of the intersection.</summary>
        </member>
        <member name="P:Sudoku.Concepts.MinilineResult.OtherBlocks">
            <summary>
            Other blocks that the intersection map data does not cover. This property will be used by techniques such as Sue de Coq.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Supersymmetry.Space">
            <summary>
            Represents a supersymmetric space. This type can also be used as representation for truth or link concept
            defined in another project called <see href="https://sudoku.allanbarker.com/index.html">XSudo</see>.
            </summary>
            <param name="mask">Indicates the backing mask.</param>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.#ctor(System.Int16)">
            <summary>
            Represents a supersymmetric space. This type can also be used as representation for truth or link concept
            defined in another project called <see href="https://sudoku.allanbarker.com/index.html">XSudo</see>.
            </summary>
            <param name="mask">Indicates the backing mask.</param>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.IsHouseRelated">
            <summary>
            Indicates whether the space is house-related.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.IsCellRelated">
            <summary>
            Indicates whether the space is cell-related.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Type">
            <summary>
            Indicates the space type.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Row">
            <summary>
            Indicates the row value,
            or -1 if <see cref="P:Sudoku.Concepts.Supersymmetry.Space.Type"/> is not <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowColumn"/> or <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowNumber"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Column">
            <summary>
            Indicates the column value,
            or -1 if <see cref="P:Sudoku.Concepts.Supersymmetry.Space.Type"/> is not <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowColumn"/> or <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.ColumnNumber"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Block">
            <summary>
            Indicates the block value, or -1 if <see cref="P:Sudoku.Concepts.Supersymmetry.Space.Type"/> is not <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.BlockNumber"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Cell">
            <summary>
            Indicates the target cell, or -1 if <see cref="P:Sudoku.Concepts.Supersymmetry.Space.Type"/> is not <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowColumn"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Digit">
            <summary>
            Indicates the target digit, or -1 if <see cref="P:Sudoku.Concepts.Supersymmetry.Space.Type"/> is <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowColumn"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.House">
            <summary>
            Indicates the target house, or -1 if <see cref="P:Sudoku.Concepts.Supersymmetry.Space.Type"/> is <see cref="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowColumn"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Letter">
            <summary>
            Indicates the represented letter.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Primary">
            <summary>
            Indicates the primary value, written after letter.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.Space.Secondary">
            <summary>
            Indicates the secondary value, written before letter.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.Deconstruct(Sudoku.Concepts.Supersymmetry.SpaceType@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.RowNumber(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> for row-number space.
            </summary>
            <param name="row">Indicates the row index.</param>
            <param name="digit">Indicates the number.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> instance created.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when argument is greater than 9.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.ColumnNumber(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> for column-number space.
            </summary>
            <param name="column">Indicates the column index.</param>
            <param name="digit">Indicates the number.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> instance created.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when argument is greater than 9.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.BlockNumber(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> for block-number space.
            </summary>
            <param name="block">Indicates the block index.</param>
            <param name="digit">Indicates the number.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> instance created.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when argument is greater than 9.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.RowColumn(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> for row-column space.
            </summary>
            <param name="row">Indicates the row index.</param>
            <param name="column">Indicates the number.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> instance created.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when argument is greater than 9.</exception>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.Space._mask">
            <summary>
            The generated field declaration for parameter <c>mask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.op_Equality(Sudoku.Concepts.Supersymmetry.Space,Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.op_Inequality(Sudoku.Concepts.Supersymmetry.Space,Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.Space.Equals(Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Supersymmetry.SpaceSet">
            <summary>
            Represents a set of <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Supersymmetry.Space"/>
        </member>
        <member name="T:Sudoku.Concepts.Supersymmetry.SpaceSet.BackingBuffer">
            <summary>
            Represents a backing buffer type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceSet.BackingBuffer._map">
            <summary>
            Indicates the backing field.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator">
            <summary>
            Represents an enumerator type that can iterate on each state bit.
            </summary>
            <param name="set">The set.</param>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.#ctor(Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <summary>
            Represents an enumerator type that can iterate on each state bit.
            </summary>
            <param name="set">The set.</param>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator._set">
            <summary>
            Indicates the backing set.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator._index">
            <summary>
            Indicates the current index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.StatesArray">
            <summary>
            Returns a state array.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator.System#Collections#Generic#IEnumerable{System#Boolean}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceSet.Empty">
            <summary>
            Indicates the empty instance.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceSet._field">
            <summary>
            Indicates the buffer entry field.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Supersymmetry#Space}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IReadOnlyList{Sudoku#Concepts#Supersymmetry#Space}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.CopyTo(Sudoku.Concepts.Supersymmetry.Space[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Contains(Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.EnumerateBitStates">
            <summary>
            Returns a <see cref="T:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator"/> instance that can iterate on each bit state.
            </summary>
            <returns>A <see cref="T:Sudoku.Concepts.Supersymmetry.SpaceSet.BitmapEnumerator"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.ToArray">
            <summary>
            Converts the current object into an array of <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> instances.
            </summary>
            <returns>An array of <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> instances.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Add(Sudoku.Concepts.Supersymmetry.Space)">
            <summary>
            Adds a new space into the collection.
            </summary>
            <param name="space">The space.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the adding operation is success.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Remove(Sudoku.Concepts.Supersymmetry.Space)">
            <summary>
            Removes a space from the current collection.
            </summary>
            <param name="space">The space.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the removing operation is success.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.AddRange(System.ReadOnlySpan{Sudoku.Concepts.Supersymmetry.Space})">
            <summary>
            Adds a list of new spaces into the collection.
            </summary>
            <param name="spaces">The spaces.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating how many spaces adding successfully.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Supersymmetry#Space}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Supersymmetry#Space}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Supersymmetry#Space}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Supersymmetry#Space}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Supersymmetry#Space}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IReadOnlySet{Sudoku#Concepts#Supersymmetry#Space}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#IsSubsetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#IsSupersetOf(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#Overlaps(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#SetEquals(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IFiniteSet{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#Space}#Negate">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IEnumerable{Sudoku#Concepts#Supersymmetry#Space}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#ExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#IntersectWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ISet{Sudoku#Concepts#Supersymmetry#Space}#UnionWith(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Supersymmetry.Space})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#ICollection{Sudoku#Concepts#Supersymmetry#Space}#Add(Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Collections#Generic#IInfiniteSet{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#Space}#ExceptWith(Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_OnesComplement(Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_OnesComplement(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_Addition(Sudoku.Concepts.Supersymmetry.SpaceSet@,Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc cref="M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_Subtraction(Sudoku.Concepts.Supersymmetry.SpaceSet@,Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc cref="M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_BitwiseAnd(Sudoku.Concepts.Supersymmetry.SpaceSet@,Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_BitwiseAnd(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_BitwiseOr(Sudoku.Concepts.Supersymmetry.SpaceSet@,Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_BitwiseOr(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_ExclusiveOr(Sudoku.Concepts.Supersymmetry.SpaceSet@,Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.Numerics.IBitwiseOperators`3.op_ExclusiveOr(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#IBitwiseOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet}#op_OnesComplement(Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#IBitwiseOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet}#op_BitwiseAnd(Sudoku.Concepts.Supersymmetry.SpaceSet,Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#IBitwiseOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet}#op_BitwiseOr(Sudoku.Concepts.Supersymmetry.SpaceSet,Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#IBitwiseOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet}#op_ExclusiveOr(Sudoku.Concepts.Supersymmetry.SpaceSet,Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#IAdditionOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#Space,Sudoku#Concepts#Supersymmetry#SpaceSet}#op_Addition(Sudoku.Concepts.Supersymmetry.SpaceSet,Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#ISubtractionOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#Space,Sudoku#Concepts#Supersymmetry#SpaceSet}#op_Subtraction(Sudoku.Concepts.Supersymmetry.SpaceSet,Sudoku.Concepts.Supersymmetry.Space)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator">
            <summary>
            Represents an enumerator type that can iterate on each <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> of the current type.
            </summary>
            <param name="set">The set instance.</param>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator.#ctor(Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <summary>
            Represents an enumerator type that can iterate on each <see cref="T:Sudoku.Concepts.Supersymmetry.Space"/> of the current type.
            </summary>
            <param name="set">The set instance.</param>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator._set">
            <summary>
            Indicates the set.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator._index">
            <summary>
            Indicates the current index.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_Equality(Sudoku.Concepts.Supersymmetry.SpaceSet@,Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_Inequality(Sudoku.Concepts.Supersymmetry.SpaceSet@,Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#IEqualityOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet,System#Boolean}#op_Equality(Sudoku.Concepts.Supersymmetry.SpaceSet,Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#Numerics#IEqualityOperators{Sudoku#Concepts#Supersymmetry#SpaceSet,Sudoku#Concepts#Supersymmetry#SpaceSet,System#Boolean}#op_Inequality(Sudoku.Concepts.Supersymmetry.SpaceSet,Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_True(Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_True(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_False(Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_False(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#ILogicalOperators{Sudoku#Concepts#Supersymmetry#SpaceSet}#op_True(Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#ILogicalOperators{Sudoku#Concepts#Supersymmetry#SpaceSet}#op_False(Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.op_LogicalNot(Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.ILogicalOperators`1.op_LogicalNot(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#ILogicalOperators{Sudoku#Concepts#Supersymmetry#SpaceSet}#op_LogicalNot(Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.Equals(Sudoku.Concepts.Supersymmetry.SpaceSet@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Concepts.Supersymmetry.SpaceSet.System#IEquatable{Sudoku#Concepts#Supersymmetry#SpaceSet}#Equals(Sudoku.Concepts.Supersymmetry.SpaceSet)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Supersymmetry.SpaceType">
            <summary>
            Represents a type of space.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowColumn">
            <summary>
            Indicates row-column space (RC space). The notation will be <c>XnY</c>, meaning cell at row X and column Y
            (equivalent to <c>rXcY</c>).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceType.RowNumber">
            <summary>
            Indicates row-number space (RN space). The notation will be <c>XrY</c>, meaning digit X in row Y.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceType.ColumnNumber">
            <summary>
            Indicates column-number space (CN space). The notation will be <c>XcY</c>, meaning digit X in column Y.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Supersymmetry.SpaceType.BlockNumber">
            <summary>
            Indicates block-number space (BN space). The notation will be <c>XbY</c>, meaning digit X in block Y.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.SymmetricTypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.SymmetricType"/>.
            </summary>
            <seealso cref="T:Sudoku.SymmetricType"/>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetSymmetryCellsCount(Sudoku.SymmetricType)">
            <summary>
            Try to get the number of cells that the current symmetry should be formed a complete symmetric pattern.
            </summary>
            <param name="this">The symmetric type.</param>
            <returns>
            The number of cells should form a complete pattern:
            <list type="table">
            <listheader>
            <term>Argument</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><see cref="F:Sudoku.SymmetricType.None"/> (0)</term>
            <description>1 (Itself)</description>
            </item>
            <item>
            <term>
            <see cref="F:Sudoku.SymmetricType.Central"/>,
            <see cref="F:Sudoku.SymmetricType.Diagonal"/>, <see cref="F:Sudoku.SymmetricType.AntiDiagonal"/>,
            <see cref="F:Sudoku.SymmetricType.XAxis"/>, <see cref="F:Sudoku.SymmetricType.YAxis"/>
            </term>
            <description>2</description>
            </item>
            <item>
            <term>The other defined values</term>
            <description>4</description>
            </item>
            <item>
            <term>Otherwise</term>
            <description><see cref="T:System.ArgumentOutOfRangeException"/> thrown</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetAxisDimension(Sudoku.SymmetricType)">
            <summary>
            Try to get the number of axes of the specified symmetric type.
            </summary>
            <param name="this">The symmetry.</param>
            <returns>
            The number of axes the current symmetric type contains.
            If <paramref name="this"/> is <see cref="F:Sudoku.SymmetricType.None"/>, -1 will be returned.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="this"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetName(Sudoku.SymmetricType,System.IFormatProvider)">
            <summary>
            Gets the name of thr symmetry.
            </summary>
            <param name="this">The symmetry value.</param>
            <param name="formatProvider">The culture.</param>
            <returns>The string.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the argument holds multiple flag values.</exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCellsInSymmetryAxis(Sudoku.SymmetricType)">
            <summary>
            Try to get all possible cells in symmetry axis (or point).
            </summary>
            <param name="this">The symmetry.</param>
            <returns>Returns cells in the symmetry axis (or point).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined or <see cref="F:Sudoku.SymmetricType.None"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32)">
            <inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)"/>
            <param name="this"><inheritdoc cref="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)"/></param>
            <param name="cell">Indicates the target cell to be checked.</param>
        </member>
        <member name="M:Sudoku.Concepts.SymmetricTypeExtensions.GetCells(Sudoku.SymmetricType,System.Int32,System.Int32)">
            <summary>
            Get the cells that is used for swapping via the specified symmetric type, and the specified row and column value.
            </summary>
            <param name="this">The symmetric type.</param>
            <param name="row">The row value.</param>
            <param name="column">The column value.</param>
            <returns>The cells.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Tokenization.CellMapToken">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Concepts.Tokenization.CellMapToken.GetToken(Sudoku.Concepts.CellMap@)">
            <summary>
            Indicates the token to the current instance.
            </summary>
            <param name="this">The instance.</param>
            <returns>The string token.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Tokenization.CellMapToken.CreateFromToken(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.Tokenization.CellMapToken.CreateFromToken(System.String)"/>
        </member>
        <member name="M:Sudoku.Concepts.Tokenization.CellMapToken.CreateFromToken(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance using the specified token of length 18.
            </summary>
            <param name="token">Indicates the token.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> result.</returns>
            <exception cref="T:System.FormatException">Throws when the length of the argument mismatched.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Tokenization.GridToken">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="P:Sudoku.Concepts.Tokenization.GridToken.Base32CharSpan">
            <inheritdoc/>
            <summary>
            The character span that indicates all possible characters appeared in a number with base 32.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Tokenization.GridToken.GetToken(Sudoku.Concepts.Grid@)">
            <summary>
            Indicates the token of the grid at the initial state.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <returns>The token.</returns>
            <remarks>
            A raw string example is:
            <code><![CDATA[
            35i4ra00rlr4btf9a8s573tsk1ldni00ccfg094v02pk54ff1hc6e7
            ]]></code>
            We should cut them by 6 characters as a group:
            <code><![CDATA[
            35i4ra 00rlr4 btf9a8 s573ts k1ldni 00ccfg 094v02 pk54ff 1hc6e7
            ]]></code>
            9 groups in total.
            Then we should convert it into a valid 9-digit number by treating them as 32-based integers.
            Finally, combinate all groups, then we are done.
            The final text is
            <code><![CDATA[
            106500970000907108400008520945000380672839410000406000009600002860000751051780039
            ]]></code>
            </remarks>
            <exception cref="T:System.NotSupportedException">Throws when the puzzle type is Sukaku.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Tokenization.GridToken.CreateFromToken(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:Sudoku.Concepts.Tokenization.GridToken.CreateFromToken(System.String)"/>
        </member>
        <member name="M:Sudoku.Concepts.Tokenization.GridToken.CreateFromToken(System.String)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Grid"/> instance using the specified token of length 54.
            </summary>
            <param name="token">Indicates the token.</param>
            <returns>A <see cref="T:Sudoku.Concepts.Grid"/> result.</returns>
            <exception cref="T:System.FormatException">Throws when the length of the argument mismatched.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Tokenization.GridToken.GetDigitViaToken(System.String)">
            <summary>
            Get digit via token.
            </summary>
            <param name="s">The string.</param>
            <returns>The result digit.</returns>
        </member>
        <member name="T:Sudoku.Drawing.ColorColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="alpha">Indicates the color alpha raw values to be assigned.</param>
            <param name="red">Indicates the color red raw values to be assigned.</param>
            <param name="green">Indicates the color green raw values to be assigned.</param>
            <param name="blue">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="alpha">Indicates the color alpha raw values to be assigned.</param>
            <param name="red">Indicates the color red raw values to be assigned.</param>
            <param name="green">Indicates the color green raw values to be assigned.</param>
            <param name="blue">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.ColorColorIdentifier.Alpha">
            <summary>
            The generated property declaration for parameter <c>alpha</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.ColorColorIdentifier.Red">
            <summary>
            The generated property declaration for parameter <c>red</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.ColorColorIdentifier.Green">
            <summary>
            The generated property declaration for parameter <c>green</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.ColorColorIdentifier.Blue">
            <summary>
            The generated property declaration for parameter <c>blue</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.ColorIdentifier">
            <summary>
            Represents an identifier that is used for describing target rendering item.
            </summary>
            <completionlist cref="T:Sudoku.Drawing.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Normal">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Normal"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Auxiliary1">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary1"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Auxiliary2">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary2"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Auxiliary3">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary3"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Assignment">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Assignment"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.OverlappedAssignment">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.OverlappedAssignment"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Elimination">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Elimination"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Cannibalism">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Cannibalism"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Exofin">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Exofin"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Endofin">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Endofin"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Link">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Link"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet1">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet1"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet2">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet2"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet3">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet3"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet4">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet4"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.AlmostLockedSet5">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet5"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Rectangle1">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Rectangle1"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Rectangle2">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Rectangle2"/>
        </member>
        <member name="F:Sudoku.Drawing.ColorIdentifier.Rectangle3">
            <inheritdoc cref="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Rectangle3"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Implicit(System.Int32)~Sudoku.Drawing.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/> to <see cref="T:Sudoku.Drawing.ColorIdentifier"/>.
            </summary>
            <param name="paletteId">The <see cref="T:System.Int32"/> instance indicating the palette ID.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Implicit(Sudoku.Drawing.WellKnownColorIdentifierKind)~Sudoku.Drawing.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:Sudoku.Drawing.WellKnownColorIdentifierKind"/> to <see cref="T:Sudoku.Drawing.ColorIdentifier"/>.
            </summary>
            <param name="kind">The <see cref="T:Sudoku.Drawing.WellKnownColorIdentifierKind"/> instance.</param>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Equality(Sudoku.Drawing.ColorIdentifier,Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.ColorIdentifier.op_Inequality(Sudoku.Drawing.ColorIdentifier,Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Drawing.DashArray">
            <summary>
            Defines a dash array of <see cref="T:System.Double"/> values. The values can be used in UI as dash array of a double collection.
            </summary>
        </member>
        <member name="T:Sudoku.Drawing.DashArray.Converter">
            <summary>
            Defines JSON serialization converter on type <see cref="T:Sudoku.Drawing.DashArray"/>.
            </summary>
            <seealso cref="T:Sudoku.Drawing.DashArray"/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Converter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Converter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Drawing.DashArray,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.#ctor">
            <summary>
            Defines a dash array of <see cref="T:System.Double"/> values. The values can be used in UI as dash array of a double collection.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.DashArray.InvalidValue">
            <summary>
            Indicates the invalid value.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.DashArray._doubles">
            <summary>
            The double values.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.DashArray.Count">
            <summary>
            Indicates the number of values.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Add(System.Double)">
            <summary>
            Adds a new value into the collection.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Equals(Sudoku.Drawing.DashArray)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.ToArray">
            <summary>
            Converts the current collection into an array of <see cref="T:System.Double"/> values.
            </summary>
            <returns>An array of <see cref="T:System.Double"/> values.</returns>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.System#Collections#Generic#IEnumerable{System#Double}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.DashArray.Enumerator">
            <summary>
            Defines an enumerator of this type.
            </summary>
            <param name="_doubles">The double values.</param>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Enumerator.#ctor(System.Collections.Generic.List{System.Double})">
            <summary>
            Defines an enumerator of this type.
            </summary>
            <param name="_doubles">The double values.</param>
        </member>
        <member name="F:Sudoku.Drawing.DashArray.Enumerator._index">
            <summary>
            Indicates the index of the current position.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.DashArray.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:Sudoku.Drawing.DashArray.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Enumerator.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Enumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.op_Equality(Sudoku.Drawing.DashArray,Sudoku.Drawing.DashArray)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.DashArray.op_Inequality(Sudoku.Drawing.DashArray,Sudoku.Drawing.DashArray)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Drawing.Drawing2D.IPointCalculator">
            <summary>
            Represents a base type of pointer calculator.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.Width">
            <summary>
            Indicates the width of the picture to draw.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.Height">
            <summary>
            Indicates the height of the picture to draw.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.Padding">
            <summary>
            Indicates the padding of the gap between the picture box outline and the sudoku grid outline.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.ControlSize">
            <summary>
            Indicates the control size.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.GridSize">
            <summary>
            Indicates the grid size.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.CellSize">
            <summary>
            Indicates the cell size.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.CandidateSize">
            <summary>
            Indicates the candidate size.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Drawing2D.IPointCalculator.GridPoints">
            <summary>
            Indicates the absolutely points in grid cross-lines.
            This property will be assigned later (and not <see langword="null"/>).
            </summary>
            <remarks>Note that the size of this 2D array is always 28 by 28.</remarks>
        </member>
        <member name="T:Sudoku.Drawing.IDrawable">
            <summary>
            Represents a drawable instance that can be used for drawing, providing with base data structure to be used by drawing APIs.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.IDrawable.Conclusions">
            <summary>
            Indicates the conclusions that the step can be eliminated or assigned to.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.IDrawable.Views">
            <summary>
            Indicates the views of the step that may be displayed onto the screen using pictures.
            </summary>
        </member>
        <member name="T:Sudoku.Drawing.IDrawableItem">
            <summary>
            Represents a drawable item (<see cref="T:Sudoku.Drawing.ViewNode"/>, <see cref="T:Sudoku.Concepts.CandidateMap"/> or <see cref="T:Sudoku.Concepts.Conclusion"/>).
            </summary>
            <seealso cref="T:Sudoku.Drawing.ViewNode"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="T:Sudoku.Drawing.LinkShape">
            <summary>
            Represents a link shape.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.LinkShape.Chain">
            <summary>
            Indicates the link is inside a chain.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.LinkShape.Cell">
            <summary>
            Indicates the link is between two cells.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.LinkShape.ConjugatePair">
            <summary>
            Indicates the link is inside a conjugate pair.
            </summary>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.BabaGroupViewNode">
            <summary>
            Defines a view node that highlights for a baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32,System.Char,System.Int16)">
            <summary>
            Defines a view node that highlights for a baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.#ctor(System.Int32,System.Char,System.Int16)">
            <summary>
            Initializes a <see cref="T:Sudoku.Drawing.Nodes.BabaGroupViewNode"/> instance via the specified values.
            </summary>
            <inheritdoc cref="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32,System.Char,System.Int16)"/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.DigitsMaskString">
            <summary>
            Indicates the digits mask string.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@,System.Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@,System.Int16@,System.Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.UnknownValueChar">
            <summary>
            The generated property declaration for parameter <c>unknownValueChar</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.BabaGroupViewNode.DigitsMask">
            <summary>
            The generated property declaration for parameter <c>digitsMask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BabaGroupViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.BasicViewNode">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.BasicViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CandidateViewNode">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CandidateViewNode.Cell">
            <summary>
            Indicates the target cell.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CandidateViewNode.CandidateString">
            <summary>
            Indicates the candidate string.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CandidateViewNode.Candidate">
            <summary>
            The generated property declaration for parameter <c>candidate</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CandidateViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CellLinkViewNode">
            <summary>
            Defines a view node that highlights for a cell link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellLinkViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32,System.Int32)">
            <summary>
            Defines a view node that highlights for a cell link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#Start">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#End">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#Shape">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellLinkViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellLinkViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellLinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellLinkViewNode.Start">
            <summary>
            The generated property declaration for parameter <c>start</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellLinkViewNode.End">
            <summary>
            The generated property declaration for parameter <c>end</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellLinkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellLinkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CellViewNode">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.CellViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CellViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.ChainLinkViewNode">
            <summary>
            Defines a view node that highlights for a chain link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="isStrongLink">Indicates whether the link is a strong link.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.CandidateMap,Sudoku.Concepts.CandidateMap,System.Boolean)">
            <summary>
            Defines a view node that highlights for a chain link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="isStrongLink">Indicates whether the link is a strong link.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#Start">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#End">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#Shape">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.CandidateMap@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
            <remarks><b>Chain links may not check for color identifiers by design.</b></remarks>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.Start">
            <summary>
            The generated property declaration for parameter <c>start</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.End">
            <summary>
            The generated property declaration for parameter <c>end</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChainLinkViewNode.IsStrongLink">
            <summary>
            The generated property declaration for parameter <c>isStrongLink</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChainLinkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.ChuteViewNode">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChuteViewNode.IsRow">
            <summary>
            Indicates whether the chute is in a row.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChuteViewNode.HousesMask">
            <summary>
            <para>
            Indicates a <see cref="T:System.Int32"/> that represents for the houses used.
            The result mask is a 27-bit digit that represents every possible houses using cases.
            </para>
            <para>
            Please note that the first 9-bit always keep the zero value because they is reserved bits
            for block houses, but all chutes don't use them.
            </para>
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ChuteViewNode.ChuteIndex">
            <summary>
            The generated property declaration for parameter <c>chuteIndex</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ChuteViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CircleViewNode">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CircleViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CircleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.ConjugateLinkViewNode">
            <summary>
            Defines a view node that highlights for a conjugate pair.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="digit">Indicates the digit used.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32,System.Int32,System.Int32)">
            <summary>
            Defines a view node that highlights for a conjugate pair.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="digit">Indicates the digit used.</param>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.ConjugatePair">
            <summary>
            Indicates the target conjugate pair.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#Start">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#End">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Sudoku#Drawing#Nodes#ILinkViewNode#Shape">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@,System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Start">
            <summary>
            The generated property declaration for parameter <c>start</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.End">
            <summary>
            The generated property declaration for parameter <c>end</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.Digit">
            <summary>
            The generated property declaration for parameter <c>digit</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ConjugateLinkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.CrossViewNode">
            <summary>
            Defines a cross view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CrossViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a cross view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.CrossViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.DiamondViewNode">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.DiamondViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.DiamondViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.HeartViewNode">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HeartViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HeartViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.HouseViewNode">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.HouseViewNode.House">
            <summary>
            The generated property declaration for parameter <c>house</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.HouseViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.IconViewNode">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.ViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.ViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.IconViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.IconViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.ILinkViewNode">
            <summary>
            Represents a view node kind that is represented as a link.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ILinkViewNode.Start">
            <summary>
            Indicates the start element.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ILinkViewNode.End">
            <summary>
            Indicates the end element.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ILinkViewNode.Shape">
            <summary>
            Indicates the link shape.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.Nodes.ILinkViewNode.Identifier">
            <summary>
            Indicates the color identifier.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.ILinkViewNode.Deconstruct(Sudoku.Drawing.ColorIdentifier@,System.Object@,System.Object@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.SquareViewNode">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.SquareViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.SquareViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.StarViewNode">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.StarViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.StarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Nodes.TriangleViewNode">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.TriangleViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Drawing.Nodes.IconViewNode.#ctor(Sudoku.Drawing.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Drawing.Nodes.TriangleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.PaletteIdColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.#ctor(System.Int32)">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.PaletteIdColorIdentifier.Value">
            <summary>
            The generated property declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.PaletteIdColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.ArgumentParser">
            <summary>
            Represents a parser type that parses arguments for one kind of drawing item.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.ArgumentParser.TryParse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser,System.ReadOnlySpan{Sudoku.Drawing.ViewNode}@)">
            <summary>
            Try to parse the arguments and return a list of <see cref="T:Sudoku.Drawing.ViewNode"/> instances indicating the result,
            assigned to <paramref name="result"/>.
            </summary>
            <param name="arguments">The raw arguments.</param>
            <param name="colorIdentifier">The color identifier.</param>
            <param name="coordinateParser">The coordinate parser.</param>
            <param name="result">A list of <see cref="T:Sudoku.Drawing.ViewNode"/> instances.</param>
            <returns>
            A <see cref="T:System.Boolean"/> result indicating whether the operation is successfully handled, and arguments are valid.
            </returns>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.ArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <summary>
            Parses the arguments and returns a list of <see cref="T:Sudoku.Drawing.ViewNode"/> instances indicating the result.
            </summary>
            <param name="arguments">The raw arguments.</param>
            <param name="colorIdentifier">The color identifier.</param>
            <param name="coordinateParser">The coordinate parser.</param>
            <returns>A list of <see cref="T:Sudoku.Drawing.ViewNode"/> instances.</returns>
            <exception cref="T:System.FormatException">Throws when the arguments are invalid.</exception>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.BabaGroupArgumentParser">
            <summary>
            Represents a baba group argument parser.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.BabaGroupArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.CandidateArgumentParser">
            <summary>
            Represents a candidate argument parser.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.CandidateArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.CellArgumentParser">
            <summary>
            Represents a cell argument parser.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.CellArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.ChuteArgumentParser">
            <summary>
            Represents a chute argument parser.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.ChuteArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.DrawingCommandParser">
            <summary>
            Represents a parser that generates a list of drawing items.
            </summary>
            <remarks>
            Please visit <see href="https://sudokustudio.kazusa.tech/user-manual/drawing-command-line">this link</see>
            to learn more information about drawing command syntax.
            </remarks>
        </member>
        <member name="F:Sudoku.Drawing.Parsing.DrawingCommandParser.WellKnownIdentifiers">
            <summary>
            Indicates the well-known identifiers, and their own key used in parsing.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.Parsing.DrawingCommandParser.ArgumentParsers">
            <summary>
            Indicates argument parsers.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.DrawingCommandParser.TryParse(System.String,Sudoku.Drawing.View@,Sudoku.Concepts.Coordinates.CoordinateParser,System.StringComparison)">
            <summary>
            Try to parse the string, split by line separator; return <see langword="false"/> if failed to be parsed.
            This method never throws <see cref="T:System.FormatException"/>.
            </summary>
            <param name="str">The string.</param>
            <param name="result">The result view.</param>
            <param name="parser">The parser. By default it's <see langword="new"/> <see cref="T:Sudoku.Concepts.Coordinates.RxCyParser"/>().</param>
            <param name="comparison">The comparison. By default it's <see cref="F:System.StringComparison.OrdinalIgnoreCase"/>.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the command-line syntax is valid.</returns>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.DrawingCommandParser.Parse(System.String,Sudoku.Concepts.Coordinates.CoordinateParser,System.StringComparison)">
            <summary>
            Parses the string, split by line separator.
            </summary>
            <param name="str">The string.</param>
            <param name="parser">The parser. By default it's <see langword="new"/> <see cref="T:Sudoku.Concepts.Coordinates.RxCyParser"/>().</param>
            <param name="comparison">The comparison. By default it's <see cref="F:System.StringComparison.OrdinalIgnoreCase"/>.</param>
            <exception cref="T:System.FormatException">Throws when a line is invalid.</exception>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.DrawingCommandParser.ParseColorIdentifier(System.String,System.StringComparison)">
            <summary>
            Parses a string and returns the equivalent color identifier.
            </summary>
            <param name="str">The string to be parsed.</param>
            <param name="comparison">The comparison. By default it's <see cref="F:System.StringComparison.OrdinalIgnoreCase"/>.</param>
            <returns>A <see cref="T:Sudoku.Drawing.ColorIdentifier"/> value returned.</returns>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.DrawingCommandParser.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.DrawingCommandParser.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.DrawingCommandParser.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.HouseArgumentParser">
            <summary>
            Represents a house argument parser.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.HouseArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.IconArgumentParser">
            <summary>
            Represents an icon argument parser.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.IconArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.Parsing.LinkArgumentParser">
            <summary>
            Represents link argument parser.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.Parsing.LinkArgumentParser.Parse(System.ReadOnlySpan{System.String},Sudoku.Drawing.ColorIdentifier,Sudoku.Concepts.Coordinates.CoordinateParser)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.View">
            <summary>
            Provides with a data structure that displays a view for basic information.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.View.Empty">
            <summary>
            Indicates an empty <see cref="T:Sudoku.Drawing.View"/> instance. You can use this property to create a new instance.
            </summary>
        </member>
        <member name="P:Sudoku.Drawing.View.SetComparer">
            <summary>
            Represents a <see cref="T:System.Collections.IEqualityComparer"/> of <see cref="T:Sudoku.Drawing.View"/> type that can compares equality of a whole set
            with specified equality comparison rules on each element of type <see cref="T:Sudoku.Drawing.ViewNode"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.IEqualityComparer`1"/>
            <seealso cref="T:Sudoku.Drawing.ViewNode"/>
        </member>
        <member name="M:Sudoku.Drawing.View.AddRange``1(System.ReadOnlySpan{``0})">
            <summary>
            Adds a list of <see cref="T:Sudoku.Drawing.ViewNode"/>s into the collection.
            </summary>
            <typeparam name="TViewNode">The type of each element.</typeparam>
            <param name="nodes">A list of <see cref="T:Sudoku.Drawing.ViewNode"/> instance.</param>
        </member>
        <member name="M:Sudoku.Drawing.View.FindCell(System.Int32)">
            <summary>
            Try to find the candidate whose cell is specified one.
            </summary>
            <param name="cell">The cell to be found.</param>
            <returns>The found node; or <see langword="null"/> if none found.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.FindCandidate(System.Int32)">
            <summary>
            Try to find the candidate whose candidate is specified one.
            </summary>
            <param name="candidate">The candidate to be found.</param>
            <returns>The found node; or <see langword="null"/> if none found.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.Equals(Sudoku.Drawing.View)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.ExceptWith(Sudoku.Drawing.View)">
            <inheritdoc cref="M:System.Linq.Providers.IExceptMethod`2.Except(System.Collections.Generic.IEnumerable{`1})"/>
        </member>
        <member name="M:Sudoku.Drawing.View.Clone">
            <summary>
            Creates a new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance, with independency.
            </summary>
            <returns>A new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.ShallowClone">
            <summary>
            Creates a new <see cref="T:Sudoku.Drawing.View"/> instance whose contents are all come from the current instance,
            with reference cloned.
            </summary>
            <returns>
            A new <see cref="T:Sudoku.Drawing.View"/> instance with same values as the current instance, with reference cloned.
            </returns>
        </member>
        <member name="M:Sudoku.Drawing.View.AsSpan">
            <summary>
            Try to convert this collection as a <see cref="T:System.ReadOnlySpan`1"/> instance.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#First">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#First(System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault(System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IFirstLastMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#FirstOrDefault(System.Func{Sudoku.Drawing.ViewNode,System.Boolean},Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IWhereMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#Where(System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IExceptMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#Except(System.Collections.Generic.IEnumerable{Sudoku.Drawing.ViewNode})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IExceptMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#Except(System.Collections.Generic.IEnumerable{Sudoku.Drawing.ViewNode},System.Collections.Generic.IEqualityComparer{Sudoku.Drawing.ViewNode})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#ISelectMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#Select``1(System.Func{Sudoku.Drawing.ViewNode,``0})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.System#Linq#Providers#IOfTypeMethod{Sudoku#Drawing#View,Sudoku#Drawing#ViewNode}#OfType``1">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.View.op_BitwiseAnd(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <summary>
            Creates a <see cref="T:Sudoku.Drawing.View"/> whose elements contains both <paramref name="left"/> and <paramref name="right"/>.
            </summary>
            <param name="left">The left-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <param name="right">The right-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Drawing.View"/> result created.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.op_BitwiseOr(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <summary>
            Merges two <see cref="T:Sudoku.Drawing.View"/> instances into one <see cref="T:Sudoku.Drawing.View"/>.
            </summary>
            <param name="left">Indicates the left-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <param name="right">Indicates the right-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Drawing.View"/> result merged.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.op_ExclusiveOr(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <summary>
            Creates a <see cref="T:Sudoku.Drawing.View"/> instance, whose elements is from two <see cref="T:Sudoku.Drawing.View"/> collections
            <paramref name="left"/> and <paramref name="right"/>, with only one-side containing this element.
            </summary>
            <param name="left">The left-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <param name="right">The right-side <see cref="T:Sudoku.Drawing.View"/> instance.</param>
            <returns>A <see cref="T:Sudoku.Drawing.View"/> result created.</returns>
        </member>
        <member name="M:Sudoku.Drawing.View.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.View.op_Equality(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.View.op_Inequality(Sudoku.Drawing.View,Sudoku.Drawing.View)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Drawing.ViewNode">
            <summary>
            Represents an item that can be drawn by GDI+ graphics module or UI shape controls.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Drawing.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.#ctor(Sudoku.Drawing.ColorIdentifier)">
            <summary>
            Represents an item that can be drawn by GDI+ graphics module or UI shape controls.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Drawing.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="P:Sudoku.Drawing.ViewNode.Identifier">
            <summary>
            Indicates an instance providing with data for describing coloring.
            </summary>
            <remarks><b>
            We cannot change this property into a primary constructor parameter because here attribute <c>[StringMember]</c>
            is not supported by derived types, meaning derived types cannot detect this attribute
            because it's in primary constructor declaration by a base type.
            </b></remarks>
        </member>
        <member name="P:Sudoku.Drawing.ViewNode.TypeIdentifier">
            <summary>
            Indicates the inner identifier to distinct the different types that is derived from <see cref="T:Sudoku.Drawing.ViewNode"/>.
            </summary>
            <seealso cref="T:Sudoku.Drawing.ViewNode"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.Clone">
            <inheritdoc cref="M:System.ICloneable.Clone"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.op_Equality(Sudoku.Drawing.ViewNode,Sudoku.Drawing.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.op_Inequality(Sudoku.Drawing.ViewNode,Sudoku.Drawing.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Drawing.ViewNode.Equals(Sudoku.Drawing.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Drawing.WellKnownColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.#ctor(Sudoku.Drawing.WellKnownColorIdentifierKind)">
            <summary>
            Defines a <see cref="T:Sudoku.Drawing.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.Deconstruct(Sudoku.Drawing.WellKnownColorIdentifierKind@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.Equals(Sudoku.Drawing.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Drawing.WellKnownColorIdentifier.Kind">
            <summary>
            The generated property declaration for parameter <c>kind</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Drawing.WellKnownColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Drawing.WellKnownColorIdentifierKind">
            <summary>
            Represents a kind of well-known <see cref="T:Sudoku.Drawing.ColorIdentifier"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Drawing.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Normal">
            <summary>
            Indicates the normal color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary1">
            <summary>
            Indicates the first auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary2">
            <summary>
            Indicates the second auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Auxiliary3">
            <summary>
            Indicates the third auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Assignment">
            <summary>
            Indicates the assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.OverlappedAssignment">
            <summary>
            Indicates the overlapped assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Elimination">
            <summary>
            Indicates the elimination color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Exofin">
            <summary>
            Indicates the exo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Endofin">
            <summary>
            Indicates the endo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Cannibalism">
            <summary>
            Indicates the cannibalism color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Link">
            <summary>
            Indicates the link color.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet1">
            <summary>
            Indicates the first ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet2">
            <summary>
            Indicates the second ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet3">
            <summary>
            Indicates the third ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet4">
            <summary>
            Indicates the fourth ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.AlmostLockedSet5">
            <summary>
            Indicates the fifth ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Rectangle1">
            <summary>
            Indicates the first AUR or AAR recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Rectangle2">
            <summary>
            Indicates the second AUR or AAR recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Drawing.WellKnownColorIdentifierKind.Rectangle3">
            <summary>
            Indicates the third AUR or AAR recorded.
            </summary>
        </member>
        <member name="T:Sudoku.Generating.FilteredGeneratorProgress">
            <summary>
            Represents a progress data type that is nearly same as <see cref="T:Sudoku.Generating.GeneratorProgress"/>, but with filtered data.
            </summary>
            <param name="Count">The number of checked puzzles.</param>
            <param name="Succeeded">The number of succeeded puzzles.</param>
            <seealso cref="T:Sudoku.Generating.GeneratorProgress"/>
        </member>
        <member name="M:Sudoku.Generating.FilteredGeneratorProgress.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents a progress data type that is nearly same as <see cref="T:Sudoku.Generating.GeneratorProgress"/>, but with filtered data.
            </summary>
            <param name="Count">The number of checked puzzles.</param>
            <param name="Succeeded">The number of succeeded puzzles.</param>
            <seealso cref="T:Sudoku.Generating.GeneratorProgress"/>
        </member>
        <member name="P:Sudoku.Generating.FilteredGeneratorProgress.Count">
            <summary>The number of checked puzzles.</summary>
        </member>
        <member name="P:Sudoku.Generating.FilteredGeneratorProgress.Succeeded">
            <summary>The number of succeeded puzzles.</summary>
        </member>
        <member name="P:Sudoku.Generating.FilteredGeneratorProgress.Percentage">
            <summary>
            Indicates the percentage.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.FilteredGeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#FilteredGeneratorProgress}#ToDisplayString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Generating.FilteredGeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#FilteredGeneratorProgress}#Create(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Generating.Generator">
            <summary>
            Represents a puzzle generator, implemented by HoDoKu.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.Generator.#ctor">
            <summary>
            Represents a puzzle generator, implemented by HoDoKu.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator.AutoClues">
            <summary>
            Indicates the auto clues count.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._useCustomizedSolution">
            <summary>
            Indicates whether the solution grid can be configured by user.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._generateIndices">
            <summary>
            The order in which cells are set when generating a full grid.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._rng">
            <summary>
            A random generator for creating new puzzles.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._solver">
            <summary>
            Indicates the internal fast solver.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._stack">
            <summary>
            The recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._newFullSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.Generator._newValidSudoku">
            <summary>
            The final grid to be used.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.Generator.#ctor(Sudoku.Concepts.Grid@)">
            <summary>
            Initializes a <see cref="T:Sudoku.Generating.Generator"/> instance via the specified template.
            </summary>
            <param name="template">The template.</param>
        </member>
        <member name="M:Sudoku.Generating.Generator.Generate(System.Int32,Sudoku.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            Try to generate a puzzle randomly, or return <see cref="F:Sudoku.Concepts.Grid.Undefined"/> if a user cancelled the operation.
            </summary>
            <param name="cluesCount">
            <para>Indicates the number of clues the generator supports for <b>approximately</b>.</para>
            <para>
            Please note that the target puzzle may not contain the same number of givens as this value.
            If the number of givens from a puzzle is below this value but it also has a unique solution,
            this puzzle will be still treated as valid one.
            </para>
            </param>
            <param name="symmetricType">The symmetric type to be specified. The value is <see cref="F:Sudoku.SymmetricType.Central"/> by default.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>The result grid, or <see cref="F:Sudoku.Concepts.Grid.Undefined"/> if a user cancelled the operation.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="symmetricType"/> holds multiple flags,
            or the argument <paramref name="cluesCount"/> is invalid.
            </exception>
        </member>
        <member name="M:Sudoku.Generating.Generator.GenerateInitPos(System.Int32,Sudoku.SymmetricType,System.Threading.CancellationToken)">
            <summary>
            Takes a full sudoku from <see cref="F:Sudoku.Generating.Generator._newFullSudoku"/> and generates a valid puzzle by deleting cells.
            If a deletion produces a grid with more than one solution it is of course undone.
            </summary>
            <inheritdoc cref="M:Sudoku.Generating.Generator.Generate(System.Int32,Sudoku.SymmetricType,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Generating.Generator.GenerateForFullGrid">
            <summary>
            Generate a solution grid.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the generation operation is succeeded.</returns>
        </member>
        <member name="M:Sudoku.Generating.Generator.Sudoku#Generating#IGenerator{Sudoku#Concepts#Grid}#Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Generating.Generator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Generating.Generator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Generating.Generator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Generating.GeneratorProgress">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Generating.GeneratorProgress.#ctor(System.Int32)">
            <summary>
            Represents a progress used by <see cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="Count">The number of puzzles generated currently.</param>
            <seealso cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Generating.GeneratorProgress.Count">
            <summary>The number of puzzles generated currently.</summary>
        </member>
        <member name="M:Sudoku.Generating.GeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#GeneratorProgress}#ToDisplayString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Generating.GeneratorProgress.Sudoku#Generating#IProgressDataProvider{Sudoku#Generating#GeneratorProgress}#Create(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Generating.GeneratorRecursionStackEntry">
            <summary>
            One entry in recursion stack.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.GeneratorRecursionStackEntry.#ctor">
            <summary>
            One entry in recursion stack.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.Candidates">
            <summary>
            The candidates for cells <see cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Cell"/>.
            </summary>
            <seealso cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Cell"/>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.Cell">
            <summary>
            The index of the cell that's being tried.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.CandidateIndex">
            <summary>
            The index of the last tried candidate in <see cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Candidates"/>.
            </summary>
            <seealso cref="F:Sudoku.Generating.GeneratorRecursionStackEntry.Candidates"/>
        </member>
        <member name="F:Sudoku.Generating.GeneratorRecursionStackEntry.SudokuGrid">
            <summary>
            The current state of the sudoku.
            </summary>
        </member>
        <member name="T:Sudoku.Generating.HardPatternPuzzleGenerator">
            <summary>
            Defines a puzzle generator that makes the given pattern as a hard one.
            A <b>hard pattern</b> doesn't mean the puzzle will be hard or fiendish.
            </summary>
        </member>
        <member name="F:Sudoku.Generating.HardPatternPuzzleGenerator._solver">
            <summary>
            Indicates the inner solver that can fast solve a sudoku puzzle, to check the validity
            of a puzzle being generated.
            </summary>
        </member>
        <member name="P:Sudoku.Generating.HardPatternPuzzleGenerator.BlockFactor">
            <summary>
            Indicates the block factor.
            </summary>
        </member>
        <member name="P:Sudoku.Generating.HardPatternPuzzleGenerator.SwappingFactor">
            <summary>
            Indicates the swapping factor.
            </summary>
        </member>
        <member name="P:Sudoku.Generating.HardPatternPuzzleGenerator.Rng">
            <summary>
            Indicates the backing random.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.GenerateAnswerGrid(System.Span{System.Char},System.Span{System.Char})">
            <summary>
            Generates the answer sudoku grid via the specified puzzle and the solution variable pointer.
            </summary>
            <param name="puzzleString">The pointer that points to the puzzle.</param>
            <param name="solutionString">
            The pointer that points to the solution. The result value will be changed here.
            </param>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.CreatePattern(System.Span{System.Int32})">
            <summary>
            Creates a start pattern based on a base pattern.
            </summary>
            <param name="pattern">The base pattern.</param>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.RecreatePattern(System.Span{System.Int32})">
            <summary>
            To re-create the pattern.
            </summary>
            <param name="pattern">The pointer that points to an array of the pattern values.</param>
        </member>
        <member name="M:Sudoku.Generating.HardPatternPuzzleGenerator.CheckDuplicate(System.Span{System.Char},System.Int32)">
            <summary>
            Check whether the digit in its peer cells has duplicate ones.
            </summary>
            <param name="gridString">The pointer that points to a grid.</param>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="T:Sudoku.Generating.IGenerator`1">
            <summary>
            Represents a generator type that produces a complex data type <typeparamref name="TResult"/>,
            encapsulating the details of the result.
            </summary>
            <typeparam name="TResult">The type of the result. This type is generally <see cref="T:Sudoku.Concepts.Grid"/>.</typeparam>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <summary>
            Generates a puzzle and return an instance of type <typeparamref name="TResult"/> indicating the result.
            </summary>
            <param name="progress">An <see cref="T:System.IProgress`1"/> instance that is used for reporting the state.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>The result returned.</returns>
        </member>
        <member name="T:Sudoku.Generating.IProgressDataProvider`1">
            <summary>
            Indicates the data provider type,
            </summary>
            <typeparam name="TSelf"><self-type-constraint>
		<para>Indicates the type implementing this interface.</para>
		<para>
			This type doesn't use any extra syntax to constraint such usage, but C# will check for it.
			The type will include a <see langword="where" /> constraint that implements the interface itself
			to declare such "self constraint" usage:
			<code><![CDATA[interface ISelfType<TSelf> where TSelf : ISelfType<TSelf>]]></code>
			In addition, the type should be named <c>TSelf</c> in order to tell type parameters with the others.
		</para>
	</self-type-constraint></typeparam>
        </member>
        <member name="P:Sudoku.Generating.IProgressDataProvider`1.Count">
            <summary>
            Indicates the number of puzzles having been generated.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.IProgressDataProvider`1.ToDisplayString">
            <summary>
            Try to fetch display string for the current instance.
            </summary>
            <returns>The display string.</returns>
        </member>
        <member name="M:Sudoku.Generating.IProgressDataProvider`1.Create(System.Int32,System.Int32)">
            <summary>
            Try to create a <typeparamref name="TSelf"/> instance.
            </summary>
            <param name="count">The number of puzzles generated.</param>
            <param name="succeeded">The number of puzzles has passed the checking.</param>
            <returns>A <typeparamref name="TSelf"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Generating.PatternBasedPuzzleGenerator">
            <summary>
            Represents a generator that is based on pattern.
            </summary>
            <param name="missingDigit">Indicates the missing digit that can be used.</param>
            <param name="seedPattern">Indicates the predefind pattern used.</param>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.#ctor(Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Represents a generator that is based on pattern.
            </summary>
            <param name="missingDigit">Indicates the missing digit that can be used.</param>
            <param name="seedPattern">Indicates the predefind pattern used.</param>
        </member>
        <member name="F:Sudoku.Generating.PatternBasedPuzzleGenerator._isCancelled">
            <summary>
            Indicates whether the generator is cancelled.
            </summary>
        </member>
        <member name="P:Sudoku.Generating.PatternBasedPuzzleGenerator.SeedPattern">
            <summary>
            Indicates the pattern of cells.
            </summary>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Generating.IGenerator`1.Generate(System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.GenerateCore(System.Int32[],Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@,System.Int32,System.Int32@,System.IProgress{Sudoku.Generating.GeneratorProgress},System.Threading.CancellationToken)">
            <summary>
            The back method to generate a valid sudoku grid puzzle.
            </summary>
            <param name="patternCellsSorted">The cells ordered by the number of related cells.</param>
            <param name="playground">The playground to be operated with.</param>
            <param name="resultGrid">The result grid to be returned.</param>
            <param name="i">The index that the current searching is on.</param>
            <param name="count">The number of puzzles generated.</param>
            <param name="progress">The progress instance.</param>
            <param name="cancellationToken">The cancellation token that can cancel the operation.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether a puzzle was generated or a user cancelled the operation.</returns>
        </member>
        <member name="M:Sudoku.Generating.PatternBasedPuzzleGenerator.OrderCellsViaConnectionComplexity">
            <summary>
            Order the pattern cells via connection complexity.
            </summary>
            <returns>The cells ordered.</returns>
        </member>
        <member name="F:Sudoku.Generating.PatternBasedPuzzleGenerator._seedPattern">
            <summary>
            The generated field declaration for parameter <c>seedPattern</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Generating.PatternBasedPuzzleGenerator.MissingDigit">
            <summary>
            The generated property declaration for parameter <c>missingDigit</c>.
            </summary>
        </member>
        <member name="T:Sudoku.IO.Library">
            <summary>
            Represents a library.
            </summary>
            <param name="directoryPath">Indicates the directory path.</param>
            <param name="identifier">Indicates the library identifier.</param>
        </member>
        <member name="M:Sudoku.IO.Library.#ctor(System.String,System.String)">
            <summary>
            Represents a library.
            </summary>
            <param name="directoryPath">Indicates the directory path.</param>
            <param name="identifier">Indicates the library identifier.</param>
        </member>
        <member name="F:Sudoku.IO.Library.Lock">
            <summary>
            Indicates the lock object to keep operation thread-safe.
            </summary>
        </member>
        <member name="F:Sudoku.IO.Library.DefaultSerializerOptions">
            <summary>
            Indicates the JSON options to serialize or deserialize object.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.InfoPath">
            <summary>
            Indicates the information path.
            </summary>
        </member>
        <member name="P:Sudoku.IO.Library.LibraryPath">
            <summary>
            Indicates the library path.
            </summary>
        </member>
        <member name="M:Sudoku.IO.Library.WriteName(System.String)">
            <summary>
            Writes the name to the library information file.
            </summary>
            <param name="value">The value to be set.</param>
        </member>
        <member name="M:Sudoku.IO.Library.WriteDescription(System.String)">
            <summary>
            Writes the description to the library information file.
            </summary>
            <param name="value">The value to be set.</param>
        </member>
        <member name="M:Sudoku.IO.Library.WriteAuthor(System.String)">
            <summary>
            Writes the author to the library information file.
            </summary>
            <param name="value">The value to be set.</param>
        </member>
        <member name="M:Sudoku.IO.Library.WriteTags(System.ReadOnlyMemory{System.String})">
            <summary>
            Writes the tags to the library information file.
            </summary>
            <param name="value">The value to be set.</param>
        </member>
        <member name="M:Sudoku.IO.Library.ReadName">
            <summary>
            Reads the name of the library information file.
            </summary>
            <returns>The name.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.ReadDescription">
            <summary>
            Reads the description of the library information file.
            </summary>
            <returns>The description.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.ReadAuthor">
            <summary>
            Reads the author of the library information file.
            </summary>
            <returns>The author.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.ReadTags">
            <summary>
            Reads the tags of the library information file.
            </summary>
            <returns>The tags.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.WriteLineAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <summary>
            Writes a new grid into the target file; if the file doesn't exist, it will create a new file,
            and then append the puzzle into the file.
            </summary>
            <param name="grid">The grid to be appended.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> object that handles the asynchronous operation.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.TryMergeFromAsync(Sudoku.IO.Library,System.Threading.CancellationToken)">
            <summary>
            Loads the other library, and reads for all puzzles and appends to the current library file.
            If any exceptions thrown or cancelled, no updates will be applied
            (the current file will keep the original state, rather than successfully written some puzzles before cancelled
            or exception encountered).
            </summary>
            <param name="other">The other library to merge into the current library.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current operation</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> object that handles the asynchronous operation;
            with a <see cref="T:System.Boolean"/> result indicating whether the operation is failed (cancelled, exception encountered, etc.).
            </returns>
        </member>
        <member name="M:Sudoku.IO.Library.GetPuzzlesCountAsync">
            <summary>
            Totals the number of puzzles up, and return the result.
            </summary>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> object that handles the asynchronous operation;
            with a result type <see cref="T:System.Int64"/> indicating the number of lines.
            </returns>
        </member>
        <member name="M:Sudoku.IO.Library.ReadRangeAsync(System.UInt64,System.UInt64,System.Threading.CancellationToken)">
            <summary>
            Reads the specified number of puzzles from the library file;
            if the file doesn't exist, nothing will be returned.
            </summary>
            <param name="start">Indicates the start index.</param>
            <param name="length">Indicates the desired number of puzzles.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current operation.</param>
            <returns>An enumerable object that allows iterating values asynchronously.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.GetAsyncEnumerator(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.IO.Library.WriteProperty``1(System.Action{Sudoku.IO.LibraryInfo,``0},``0)">
            <summary>
            Writes the property of type <typeparamref name="T"/> to the file.
            </summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="valueAssignment">The result value assigning method.</param>
            <param name="value">The value to be set.</param>
        </member>
        <member name="M:Sudoku.IO.Library.Save(Sudoku.IO.LibraryInfo)">
            <summary>
            Saves the file.
            </summary>
            <param name="info">The information to be saved.</param>
        </member>
        <member name="M:Sudoku.IO.Library.ReadProperty``1(System.Func{Sudoku.IO.LibraryInfo,``0})">
            <summary>
            Reads the property of value of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="resultValueCreator">The result value creator.</param>
            <returns>The result value.</returns>
        </member>
        <member name="M:Sudoku.IO.Library.LoadOrCreate">
            <summary>
            Loads the file, or creates the default instance if the file doesn't exist.
            </summary>
            <returns>The file loaded.</returns>
        </member>
        <member name="F:Sudoku.IO.Library._directoryPath">
            <summary>
            The generated field declaration for parameter <c>directoryPath</c>.
            </summary>
        </member>
        <member name="F:Sudoku.IO.Library._identifier">
            <summary>
            The generated field declaration for parameter <c>identifier</c>.
            </summary>
        </member>
        <member name="T:Sudoku.IO.LibraryFileReader">
            <summary>
            Represents a UTF-8 format library file reader.
            </summary>
        </member>
        <member name="F:Sudoku.IO.LibraryFileReader.Lf">
            <summary>
            Represents constant line feed <c>'\n'</c>.
            </summary>
        </member>
        <member name="F:Sudoku.IO.LibraryFileReader.Cr">
            <summary>
            Represents constant carriage return <c>'\r'</c>.
            </summary>
        </member>
        <member name="F:Sudoku.IO.LibraryFileReader._readerStream">
            <summary>
            Indicates the reader stream.
            </summary>
        </member>
        <member name="M:Sudoku.IO.LibraryFileReader.#ctor(System.String,System.Int32,System.Boolean@)">
            <summary>
            Initializes a <see cref="T:Sudoku.IO.LibraryFileReader"/> instance.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="bufferSize">The buffer size.</param>
            <param name="exists">Indicates whether the file exists.</param>
        </member>
        <member name="P:Sudoku.IO.LibraryFileReader.FilePath">
            <summary>
            Indicates the file path.
            </summary>
        </member>
        <member name="P:Sudoku.IO.LibraryFileReader.BufferSize">
            <summary>
            Indicates the buffer size.
            </summary>
        </member>
        <member name="M:Sudoku.IO.LibraryFileReader.#ctor(System.String,System.Boolean@)">
            <summary>
            Initializes a <see cref="T:Sudoku.IO.LibraryFileReader"/> instance via the specified file path.
            </summary>
            <param name="path">The file path.</param>
            <param name="exists">Indicates whether the file exists.</param>
        </member>
        <member name="M:Sudoku.IO.LibraryFileReader.CountLines">
            <summary>
            Count the number of lines of the file.
            </summary>
            <returns>The number of lines.</returns>
        </member>
        <member name="M:Sudoku.IO.LibraryFileReader.ReadLinesRangeAsync(System.UInt64,System.UInt64,System.Threading.CancellationToken)">
            <summary>
            Asynchronously read for the specified lines.
            </summary>
            <param name="startLine">Indicates the start line index.</param>
            <param name="endLine">Indicates the end line index.</param>
            <param name="cancellationToken">Indicates the cancellation token.</param>
            <returns>An asynchronous enumerator instance.</returns>
            <exception cref="T:System.OperationCanceledException">Throws when <paramref name="cancellationToken"/> is requested.</exception>
        </member>
        <member name="M:Sudoku.IO.LibraryFileReader.ReadLinesAsync(System.Threading.CancellationToken)">
            <summary>
            Loads the puzzles line by line, and enumerate them without loading them together.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current operation.</param>
            <returns>An enumerator object that allows iterating values asynchronously.</returns>
            <exception cref="T:System.OperationCanceledException">Throws when <paramref name="cancellationToken"/> is requested.</exception>
        </member>
        <member name="F:Sudoku.IO.LibraryFileReader._isDisposed">
            <summary>
            Indicates whether the object had already been disposed before <see cref="M:Sudoku.IO.LibraryFileReader.DisposeAsync"/> was called.
            If this field holds <see langword="false"/> value, <see cref="M:Sudoku.IO.LibraryFileReader.DisposeAsync"/> will throw an
            <see cref="T:System.ObjectDisposedException"/> to report the error.
            </summary>
            <seealso cref="M:Sudoku.IO.LibraryFileReader.DisposeAsync"/>
            <seealso cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Sudoku.IO.LibraryFileReader.DisposeAsync">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:Sudoku.IO.LibraryFileWriter">
            <summary>
            Represents a UTF-8 format library file writer.
            </summary>
        </member>
        <member name="F:Sudoku.IO.LibraryFileWriter.FlushThreshold">
            <summary>
            Indicates the flush threashold. If the maximum number of characters is reached, a flush operation will be triggered.
            </summary>
        </member>
        <member name="F:Sudoku.IO.LibraryFileWriter._writer">
            <summary>
            Indicates the writer.
            </summary>
        </member>
        <member name="F:Sudoku.IO.LibraryFileWriter._semaphore">
            <summary>
            Indicates the semaphore.
            </summary>
        </member>
        <member name="F:Sudoku.IO.LibraryFileWriter._buffer">
            <summary>
            Indicates the buffer.
            </summary>
        </member>
        <member name="M:Sudoku.IO.LibraryFileWriter.#ctor(System.String,System.Int32,System.Boolean@)">
            <summary>
            Initializes a <see cref="T:Sudoku.IO.LibraryFileWriter"/> instance.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="bufferSize">The buffer size.</param>
            <param name="exists">Indicates whether the file exists.</param>
        </member>
        <member name="P:Sudoku.IO.LibraryFileWriter.FilePath">
            <summary>
            Indicates the file path.
            </summary>
        </member>
        <member name="P:Sudoku.IO.LibraryFileWriter.BufferSize">
            <summary>
            Indicates the buffer size.
            </summary>
        </member>
        <member name="M:Sudoku.IO.LibraryFileWriter.#ctor(System.String,System.Boolean@)">
            <summary>
            Initializes a <see cref="T:Sudoku.IO.LibraryFileWriter"/> instance via the specified file path;
            if the specified path doesn't exist, a new file will be created.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="exists">Indicates whether the file exists.</param>
        </member>
        <member name="P:Sudoku.IO.LibraryFileWriter.AutoFlush">
            <summary>
            Indicates whether the flush operation will be automatically triggered.
            </summary>
        </member>
        <member name="M:Sudoku.IO.LibraryFileWriter.WriteLineAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Write a new line of values into the file.
            </summary>
            <param name="line">A line.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> object that can be used as asynchronous operation.</returns>
        </member>
        <member name="M:Sudoku.IO.LibraryFileWriter.FlushAsync">
            <summary>
            Flushes the buffer and write them into file.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> object that can be used as asynchronous operation.</returns>
        </member>
        <member name="M:Sudoku.IO.LibraryFileWriter.FlushInternalAsync">
            <summary>
            The backing logic on flushing the buffer, writting the buffer into the file.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> object that can be used as asynchronous operation.</returns>
        </member>
        <member name="F:Sudoku.IO.LibraryFileWriter._isDisposed">
            <summary>
            Indicates whether the object had already been disposed before <see cref="M:Sudoku.IO.LibraryFileWriter.DisposeAsync"/> was called.
            If this field holds <see langword="false"/> value, <see cref="M:Sudoku.IO.LibraryFileWriter.DisposeAsync"/> will throw an
            <see cref="T:System.ObjectDisposedException"/> to report the error.
            </summary>
            <seealso cref="M:Sudoku.IO.LibraryFileWriter.DisposeAsync"/>
            <seealso cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Sudoku.IO.LibraryFileWriter.DisposeAsync">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:Sudoku.IO.LibraryInfo">
            <summary>
            Represents information about a library.
            </summary>
        </member>
        <member name="P:Sudoku.IO.LibraryInfo.Name">
            <summary>
            Indicates the name of the library.
            </summary>
        </member>
        <member name="P:Sudoku.IO.LibraryInfo.Description">
            <summary>
            Indicates the description to the library.
            </summary>
        </member>
        <member name="P:Sudoku.IO.LibraryInfo.Author">
            <summary>
            Indicates the author of the library.
            </summary>
        </member>
        <member name="P:Sudoku.IO.LibraryInfo.Tags">
            <summary>
            Indicates the tags of the library.
            </summary>
        </member>
        <member name="T:Sudoku.Linq.CandidateMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CandidateMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate or -1 if none found.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.First(Sudoku.Concepts.CandidateMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.CellMapOrCandidateMapPredicate{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator})">
            <summary>
            Finds the first candidate that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found candidate or -1 if none found.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Select``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Where(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CandidateMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CandidateMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CandidateMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.GroupBy``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,``0})">
            <inheritdoc cref="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})"/>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.SelectMany``1(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each candidate (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CandidateMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.Any(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CandidateMapEnumerable.All(Sudoku.Concepts.CandidateMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.CellMapEnumerable">
            <summary>
            Represents a list of LINQ methods that can operate with <see cref="T:Sudoku.Concepts.CellMap"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell or -1 if none found.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.First(Sudoku.Concepts.CellMap@,Sudoku.Concepts.Grid@,Sudoku.Concepts.CellMapOrCandidateMapPredicate{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator})">
            <summary>
            Finds the first cell that satisfies the specified condition.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="grid">The grid to be used.</param>
            <param name="match">The condition to be used.</param>
            <returns>The first found cell or -1 if none found.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Select``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element in the current instance into the target-typed <typeparamref name="TResult"/> array,
            using the specified function to convert.
            </summary>
            <typeparam name="TResult">The type of target value.</typeparam>
            <param name="this">The current instance.</param>
            <param name="selector">The selector.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Where(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Concepts.CellMap"/> collection based on a predicate.
            </summary>
            <param name="this">The current instance.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            A <see cref="T:Sudoku.Concepts.CellMap"/> that contains elements from the input <see cref="T:Sudoku.Concepts.CellMap"/> satisfying the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.GroupBy``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,``0})">
            <summary>
            Groups the elements of a sequence according to a specified key selector function.
            </summary>
            <typeparam name="TKey">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <param name="this">The current instance.</param>
            <param name="keySelector">
            <inheritdoc cref="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='keySelector']"/>
            </param>
            <returns>
            A list of <see cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4"/> instances where each value object contains a sequence of objects and a key.
            </returns>
            <seealso cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.SelectMany``1(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Int16},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each cell (of type <see cref="T:System.Int32"/>) of a <see cref="T:Sudoku.Concepts.CellMap"/> to a mask (of type <see cref="T:System.Int16"/>),
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate mask (of type <see cref="T:System.Int16"/>).</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.Any(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Indicates whether at least one element satisfies the specified condition.
            </summary>
            <param name="this">The cell to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether at least one element satisfies the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapEnumerable.All(Sudoku.Concepts.CellMap@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Determine whether all <see cref="T:System.Int32"/>s satisfy the specified condition.
            </summary>
            <param name="this">The candidate to be checked.</param>
            <param name="match">The match method.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether all elements satisfy the specified condition.</returns>
        </member>
        <member name="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.#ctor(`3,`0@)">
            <summary>
            Represents a map group for <see cref="T:Sudoku.Concepts.CandidateMap"/> and <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
            <typeparam name="TMap">The type of the map that stores the <see cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TElement">The type of elements stored in <see cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>.</typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="key">Indicates the key used.</param>
            <param name="values">Indicates the candidates.</param>
            <seealso cref="T:Sudoku.Concepts.CellMap"/>
            <seealso cref="T:Sudoku.Concepts.CandidateMap"/>
        </member>
        <member name="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Count">
            <summary>
            Indicates the number of values stored in <see cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>, i.e. the shorthand of expression <c>Values.Count</c>.
            </summary>
            <seealso cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>
        </member>
        <member name="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Item(`1)">
            <inheritdoc cref="P:Sudoku.Concepts.ICellMapOrCandidateMap`3.Item(`1)"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Deconstruct(`3@,`0@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An enumerator object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.CreateMapByKeys(System.ReadOnlySpan{Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,System.Int32}})">
            <summary>
            Makes a <see cref="T:Sudoku.Concepts.CellMap"/> instance that is concatenated by a list of groups
            of type <see cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4"/>, adding their keys.
            </summary>
            <param name="groups">The groups.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.System#Linq#Providers#IWhereMethod{TMap,TElement}#Where(System.Func{`1,System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.System#Linq#Providers#ISelectMethod{TMap,TElement}#Select``1(System.Func{`1,``0})">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Key">
            <summary>
            The generated property declaration for parameter <c>key</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values">
            <summary>
            The generated property declaration for parameter <c>values</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.op_Equality(Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3}@,Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.op_Inequality(Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3}@,Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.System#Numerics#IEqualityOperators{Sudoku#Linq#CellMapOrCandidateMapGrouping{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#CellMapOrCandidateMapGrouping{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Equality(Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3},Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.System#Numerics#IEqualityOperators{Sudoku#Linq#CellMapOrCandidateMapGrouping{TMap,TElement,TEnumerator,TKey},Sudoku#Linq#CellMapOrCandidateMapGrouping{TMap,TElement,TEnumerator,TKey},System#Boolean}#op_Inequality(Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3},Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Equals(Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3}@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.System#IEquatable{Sudoku#Linq#CellMapOrCandidateMapGrouping{TMap,TElement,TEnumerator,TKey}}#Equals(Sudoku.Linq.CellMapOrCandidateMapGrouping{`0,`1,`2,`3})">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Linq.CellMapOrCandidateMapGroupingEnumerable">
            <summary>
            Represents a list of LINQ methods used by <see cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4"/>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGroupingEnumerable.Where``4(Sudoku.Linq.CellMapOrCandidateMapGrouping{``0,``1,``2,``3},System.Func{``1,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
            <typeparam name="TMap">
            The type of the map that stores the <see cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>.
            </typeparam>
            <typeparam name="TElement">
            The type of elements stored in <see cref="P:Sudoku.Linq.CellMapOrCandidateMapGrouping`4.Values"/>.
            </typeparam>
            <typeparam name="TEnumerator">The type of enumerator.</typeparam>
            <typeparam name="TKey">The type of the key in the group.</typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            An array of <typeparamref name="TElement"/> instances
            that contains elements from the input sequence that satisfy the condition.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGroupingEnumerable.Select``5(Sudoku.Linq.CellMapOrCandidateMapGrouping{``0,``1,``2,``3},System.Func{``1,``4})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/summary"/>
            </summary>
            <typeparam name="TMap">
            <inheritdoc cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4" path="/typeparam[@name='TMap']"/>
            </typeparam>
            <typeparam name="TElement">
            <inheritdoc cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4" path="/typeparam[@name='TElement']"/>
            </typeparam>
            <typeparam name="TKey">
            <inheritdoc cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4" path="/typeparam[@name='TKey']"/>
            </typeparam>
            <typeparam name="TEnumerator">
            The type of enumerator.
            </typeparam>
            <typeparam name="TResult">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/typeparam[@name='TResult']"/>
            </typeparam>
            <param name="this">The instance to be checked.</param>
            <param name="selector">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='selector']"/>
            </param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> instances
            whose elements are the result of invoking the transform function on each element of the current instance.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGroupingEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.CellMapOrCandidateMapGrouping{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0}},System.Func{Sudoku.Linq.CellMapOrCandidateMapGrouping{Sudoku.Concepts.CellMap,System.Int32,Sudoku.Concepts.CellMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4"/> of types <see cref="T:Sudoku.Concepts.CellMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results and merge
            into a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Linq.CellMapOrCandidateMapGroupingEnumerable.Select``1(System.ReadOnlySpan{Sudoku.Linq.CellMapOrCandidateMapGrouping{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0}},System.Func{Sudoku.Linq.CellMapOrCandidateMapGrouping{Sudoku.Concepts.CandidateMap,System.Int32,Sudoku.Concepts.CandidateMap.Enumerator,``0},System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Linq.CellMapOrCandidateMapGrouping`4"/> of types <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            <see cref="T:System.Int32"/> and <typeparamref name="TKey"/>, into a <see cref="T:System.Int32"/> value; collect converted results
            and merge into a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.
            </summary>
            <typeparam name="TKey">The type of the grouping.</typeparam>
            <param name="this">The list to be checked.</param>
            <param name="selector">The transform method to apply to each element.</param>
            <returns>The result.</returns>
        </member>
        <member name="T:Sudoku.Linq.ConclusionsEnumerable">
            <summary>
            Provides with a list of LINQ methods used by <see cref="T:Sudoku.Concepts.Conclusion"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="M:Sudoku.Linq.ConclusionsEnumerable.Select(System.ReadOnlySpan{Sudoku.Concepts.Conclusion},System.Func{Sudoku.Concepts.Conclusion,System.Int32})">
            <summary>
            Projects a list of <see cref="T:Sudoku.Concepts.Conclusion"/> instances, converted each instances into a <see cref="T:System.Int32"/> value,
            and merge them into a <see cref="T:Sudoku.Concepts.CellMap"/> and return it.
            </summary>
            <param name="this">A list of <see cref="T:Sudoku.Concepts.Conclusion"/> instances.</param>
            <param name="selector">The selector to project the values.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.GridEnumerable">
            <summary>
            Provides with a list of LINQ methods operating with <see cref="T:Sudoku.Concepts.Grid"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Where(Sudoku.Concepts.Grid@,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters the candidates that satisfies the specified condition.
            </summary>
            <param name="this">The instance to be iterated.</param>
            <param name="predicate">The condition to filter candidates.</param>
            <returns>All candidates satisfied the specified condition.</returns>
        </member>
        <member name="M:Sudoku.Linq.GridEnumerable.Select``1(Sudoku.Concepts.Grid@,System.Func{System.Int32,``0})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
            <typeparam name="TResult">The type of the value returned by <paramref name="selector"/>.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>
            An array of <typeparamref name="TResult"/> elements converted.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.HouseMaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int32"/>.
            </summary>
            <seealso cref="T:System.Int32"/>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Select``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.SelectMany``1(System.Int32,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int32"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int32"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.HouseMaskEnumerable.Where(System.Int32,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.ListEnumerable">
            <summary>
            Represents a list of LINQ methods to be used for type <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CellMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in source.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.ListEnumerable.SelectMany``2(System.Collections.Generic.List{``0},System.Func{``0,Sudoku.Concepts.CandidateMap},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element in a <see cref="T:System.Collections.Generic.List`1"/> to a <see cref="T:Sudoku.Concepts.CandidateMap"/>,
            flattens the resulting sequence into one sequence, and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TSource">The type of the elements in source.</typeparam>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="this">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Collections.Generic.List`1"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CandidateMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result
            of invoking the one-to-many transform function <paramref name="collectionSelector"/> on each element of <paramref name="this"/>
            and then mapping each of those sequences and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="T:Sudoku.Linq.MaskEnumerable">
            <summary>
            Represents a list of methods for iteration on a <see cref="T:System.Int16"/>.
            </summary>
            <seealso cref="T:System.Int16"/>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Select``1(System.Int16,System.Func{System.Int32,``0})">
            <summary>
            Projects each bit from a specified mask, converting it into a (an) <typeparamref name="T"/> instance,
            with specified method to be called.
            </summary>
            <typeparam name="T">The target type of values for each bit converted.</typeparam>
            <param name="this">A mask instance.</param>
            <param name="selector">The selector method to be converted.</param>
            <returns>A list of converted result, encapsulated by a <see cref="T:System.ReadOnlySpan`1"/> type.</returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.SelectMany``1(System.Int16,System.Func{System.Int32,Sudoku.Concepts.CellMap},System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Projects each <see cref="T:System.Int32"/> of a <see cref="T:System.Int16"/> to a <see cref="T:Sudoku.Concepts.CellMap"/>, flattens the resulting sequence into one sequence,
            and invokes a result selector function on each element therein.
            </summary>
            <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
            <param name="source">A sequence of values to project.</param>
            <param name="collectionSelector">A transform function to apply to each element of the input <see cref="T:System.Int16"/>.</param>
            <param name="resultSelector">A transform function to apply to each element of the intermediate <see cref="T:Sudoku.Concepts.CellMap"/>.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequences
            and their corresponding source element to a result element.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.MaskEnumerable.Where(System.Int16,System.Func{System.Int32,System.Boolean})">
            <summary>
            Filters bits via the specified condition.
            </summary>
            <param name="this">The mask type of bits.</param>
            <param name="predicate">The condition that filters bits, removing bits not satisfying the condition.</param>
            <returns>A new <see cref="T:System.Int16"/> result.</returns>
        </member>
        <member name="T:Sudoku.Linq.ViewEnumerable">
            <summary>
            Represents with LINQ methods for <see cref="T:Sudoku.Drawing.View"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Drawing.View"/>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.Select``1(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,``0})">
            <summary>
            Projects with a new transform of elements.
            </summary>
            <typeparam name="T">The type of target element.</typeparam>
            <param name="this">The view.</param>
            <param name="selector">The method to transform each element.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="T"/> elements.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.Where(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <summary>
            Filters a <see cref="T:Sudoku.Drawing.View"/>, only reserves the <see cref="T:Sudoku.Drawing.ViewNode"/> instances satisfying the specified condition.
            </summary>
            <param name="this">The view.</param>
            <param name="predicate">The filter.</param>
            <returns>A list of <see cref="T:Sudoku.Drawing.ViewNode"/> filtered.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.OfType``1(Sudoku.Drawing.View)">
            <summary>
            Filters the view nodes, only returns nodes of type <typeparamref name="TViewNode"/>.
            </summary>
            <typeparam name="TViewNode">The type of the node.</typeparam>
            <returns>The target collection of element type <typeparamref name="TViewNode"/>.</returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.First(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found;
            otherwise, throw an <see cref="T:System.InvalidOperationException"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the sequence has no elements satisfying the specified rule.
            </exception>
            <inheritdoc cref="M:Sudoku.Linq.ViewEnumerable.FirstOrDefault(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})"/>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.FirstOrDefault(Sudoku.Drawing.View,System.Func{Sudoku.Drawing.ViewNode,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the first occurrence within the entire <see cref="T:Sudoku.Drawing.View"/>.
            </summary>
            <param name="this">The view to be checked.</param>
            <param name="match">The <see cref="T:System.Func`2"/> delegate that defines the conditions of the element to search for.</param>
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found; otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Linq.ViewEnumerable.SelectMany(Sudoku.Drawing.View[],System.Func{Sudoku.Drawing.View,Sudoku.Drawing.View},System.Func{Sudoku.Drawing.View,Sudoku.Drawing.ViewNode,Sudoku.Drawing.ViewNode})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.SelectMany``3(``0[],System.Func{``0,System.ReadOnlySpan{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="T:Sudoku.Measuring.Distance">
            <summary>
            Represents the methods that calculates for distance.
            </summary>
            <param name="p">Indicates the integer part.</param>
            <param name="q">Indicates the root part.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when either <paramref name="p"/> or <paramref name="q"/> are less than 1.</exception>
            <remarks>
            This type is implemented via irrational numbers logic that only takes a square root.
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.Distance.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents the methods that calculates for distance.
            </summary>
            <param name="p">Indicates the integer part.</param>
            <param name="q">Indicates the root part.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when either <paramref name="p"/> or <paramref name="q"/> are less than 1.</exception>
            <remarks>
            This type is implemented via irrational numbers logic that only takes a square root.
            </remarks>
        </member>
        <member name="F:Sudoku.Measuring.Distance.RootPartSpecifier">
            <summary>
            Indicates the default root part specifier.
            </summary>
        </member>
        <member name="F:Sudoku.Measuring.Distance.DistanceTable">
            <summary>
            The table that displays the minimal and maximal index of cells that makes the distances least or greatest with the specified cell.
            </summary>
            <remarks>
            <para>
            The table is grouped with houses. If you want to fetch the smallest or largest distance value from a cell to a house, you can use
            <c><see cref="F:Sudoku.Measuring.Distance.DistanceTable"/>[Cell][House]</c>, where <c>Cell</c> is between 0 and 81, and <c>House</c> is between 0 and 27.
            If the cell is inside the house, the value will be <see langword="null"/>.
            </para>
            <para>
            In further, if you want to get the distance from two cells using this table, just call method <see cref="M:Sudoku.Measuring.Distance.GetDistance(System.Int32,System.Int32)"/>.
            </para>
            </remarks>
            <seealso cref="M:Sudoku.Measuring.Distance.GetDistance(System.Int32,System.Int32)"/>
        </member>
        <member name="F:Sudoku.Measuring.Distance._p">
            <summary>
            The root value of P.
            </summary>
        </member>
        <member name="F:Sudoku.Measuring.Distance._q">
            <summary>
            The root value of Q.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.Distance.#ctor">
            <summary>
            Initializes a <see cref="T:Sudoku.Measuring.Distance"/> instance via both values 1.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.Distance.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Measuring.Distance"/> instance via the root part, with the default integer part 1.
            <i>This value will automatically simplify the root expression, e.g. sqrt(18) -> 3sqrt(2).</i>
            </summary>
            <param name="q">The root value.</param>
        </member>
        <member name="P:Sudoku.Measuring.Distance.RawValue">
            <summary>
            The raw value of the distance. The value will be output as a <see cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.Distance.Equals(Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.CompareTo(Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <remarks>
            The output format will be "<c>psq</c>", where <c>p</c> and <c>q</c> are the variables, and <c>s</c> means "square root of".
            For example, "<c>3s2</c>" means <c>3 * sqrt(2)</c>, i.e. <c>sqrt(18)</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetDistance(System.Int32,System.Int32)">
            <summary>
            Try to fetch the distance for the two cells.
            </summary>
            <param name="cell1">The first cell to be compared.</param>
            <param name="cell2">The second cell to be compared.</param>
            <returns>The distance result.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetDistance(Sudoku.Concepts.CellMap@)">
            <summary>
            Try to fetch the distance for two cells stored in a <see cref="T:Sudoku.Concepts.CellMap"/> instance.
            </summary>
            <param name="cells">The <see cref="T:Sudoku.Concepts.CellMap"/> instance storing two cells.</param>
            <returns>The distance result.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetDistanceTo(System.Int32,System.Int32)">
            <summary>
            Try to get the minimal and maximal distance to the specified house from the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <param name="house">The house.</param>
            <returns>The minimal and maximal distance value.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetIntermediateCells(System.Int32,System.Int32)">
            <summary>
            Try to get the intermediate cells that are between <paramref name="cell1"/> and <paramref name="cell2"/> in logical position
            for sudoku grid.
            </summary>
            <param name="cell1">The first cell.</param>
            <param name="cell2">The second cell. The value should be greater than <paramref name="cell1"/>.</param>
            <returns>The intermediate cells.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when cells <paramref name="cell1"/> and <paramref name="cell2"/> are not in a same line (row or column).
            </exception>
        </member>
        <member name="M:Sudoku.Measuring.Distance.SimplifyRootPart(System.Int32@)">
            <summary>
            Simplifies for root part.
            </summary>
            <param name="base">The root value.</param>
            <returns>The P value.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Distance.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_Equality(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_Inequality(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_GreaterThan(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_LessThan(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_GreaterThanOrEqual(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Measuring.Distance.op_LessThanOrEqual(Sudoku.Measuring.Distance,Sudoku.Measuring.Distance)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Measuring.EmptyArea">
            <summary>
            Provides a way to calculate empty area of a <see cref="T:Sudoku.Concepts.Grid"/> or a <see cref="T:Sudoku.Concepts.CellMap"/>.
            </summary>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptyArea(Sudoku.Concepts.Grid@,System.Int32@)">
            <summary>
            Try to get the maximum empty area exists in the specified grid.
            </summary>
            <param name="this">The grid to be checked.</param>
            <param name="topLeftCell">
            <inheritdoc cref="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.CellMap@,System.Int32@)" path="/param[@name='topLeftCell']"/>
            </param>
            <returns>A <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            <inheritdoc cref="M:Sudoku.Measuring.EmptyArea.GetMaxEmptyArea(Sudoku.Concepts.CellMap@,System.Int32@)" path="/remarks"/>
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.Grid@,System.Int32@)">
            <summary>
            Try to get the maximum empty square area exists in the specified grid.
            </summary>
            <param name="this">The grid to be checked.</param>
            <param name="topLeftCell">
            <inheritdoc cref="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.CellMap@,System.Int32@)" path="/param[@name='topLeftCell']"/>
            </param>
            <returns>A <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            <inheritdoc cref="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.CellMap@,System.Int32@)" path="/remarks"/>
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptyArea(Sudoku.Concepts.CellMap@,System.Int32@)">
            <summary>
            Try to get the maximum empty area exists in the specified cells.
            </summary>
            <param name="this">The cells to be checked.</param>
            <param name="topLeftCell">
            <inheritdoc cref="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.CellMap@,System.Int32@)" path="/param[@name='topLeftCell']"/>
            </param>
            <returns>A <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            This algorithm is from the puzzle called
            <see href="https://leetcode.com/problems/maximal-rectangle/"><i>Maximal Rectangle</i></see>.
            </remarks>
        </member>
        <member name="M:Sudoku.Measuring.EmptyArea.GetMaxEmptySquareArea(Sudoku.Concepts.CellMap@,System.Int32@)">
            <summary>
            Try to get the maximum empty square area exists in the specified cells.
            </summary>
            <param name="this">The cells to be checked.</param>
            <param name="topLeftCell">Indicates the cell at the top left index of the square.</param>
            <returns>A <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            This algorithm is from the puzzle called
            <see href="https://leetcode.com/problems/maximal-square/"><i>Maximal Square</i></see>.
            </remarks>
        </member>
        <member name="T:Sudoku.Measuring.Minimal">
            <summary>
            Represents extension methods on <see cref="T:Sudoku.Concepts.Grid"/> for minimal.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Measuring.Minimal.GetIsMinimal(Sudoku.Concepts.Grid@)">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Measuring.Minimal.CheckMinimal(Sudoku.Concepts.Grid@,System.Int32@)">
            <summary>
            Determines whether the puzzle is a minimal puzzle, which means the puzzle will become multiple solution
            if arbitrary one given digit will be removed from the grid.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="firstCandidateMakePuzzleNotMinimal">
            <para>
            Indicates the first found candidate that can make the puzzle not minimal, which means
            if we remove the digit in the cell, the puzzle will still keep unique.
            </para>
            <para>If the return value is <see langword="true"/>, this argument will be -1.</para>
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle is invalid (i.e. not unique).</exception>
        </member>
        <member name="T:Sudoku.ModuleInitializer">
            <target name="type">
				<summary>
					<para>
						Provides with the type that contains a module initializer method, called automatically by the CLR
						(Common Language Runtime) to initialize some values.
					</para>
					<para>
						<i>
							The type is called by the compiler and the CLR (Common Language Runtime),
							which means you cannot use any members in this type manually.
						</i>
					</para>
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.ModuleInitializer.Initialize">
            <target name="method">
				<summary>
					Called by the runtime automatically while booting on this solution to initialize the values,
					data members or any other things that can or should be initialized here.
				</summary>
				<remarks>
					The concept <b>module</b> is different with <b>assembly</b>.
					The solution can contain multiple assemblies, while each assembly can contain multiple modules.
					However, due to the design of Visual Studio project file system, each assembly will only contain
					one module by default.
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Resources.CoreResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.BlockLabel">
            <summary>
              Looks up a localized string similar to Block {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.BlockName">
            <summary>
              Looks up a localized string similar to Block.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CandidateLabel">
            <summary>
              Looks up a localized string similar to {0}, digit {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellLabel">
            <summary>
              Looks up a localized string similar to row {0} column {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.CellsLabel">
            <summary>
              Looks up a localized string similar to cells: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ColumnLabel">
            <summary>
              Looks up a localized string similar to Column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ColumnName">
            <summary>
              Looks up a localized string similar to Column.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ConjugatePairWith">
            <summary>
              Looks up a localized string similar to {0} conjugates with {1}, for digit {2}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.DigitName">
            <summary>
              Looks up a localized string similar to Digit.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Error_ArgExtensionShouldBeValid">
            <summary>
              Looks up a localized string similar to The argument should contains the prefix period token..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Error_UnrecognizedGridFormat">
            <summary>
              Looks up a localized string similar to You cannot append text that cannot be recognized as a valid sudoku grid..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_AllCellsMustBeConnectedWithAdjacentPositions">
            <summary>
              Looks up a localized string similar to All cells must be connected with adjacent positions. For example, r1c1 and r1c2 is a valid pair, but r1c1 and r2c2 is not..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_CannotAssignSuccessForFailureCases">
            <summary>
              Looks up a localized string similar to Cannot assign success field to describe such failure..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_CellsShouldInSameLine">
            <summary>
              Looks up a localized string similar to Two cells must be in a same line (row or column)..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_ComparableGridMustBeStandard">
            <summary>
              Looks up a localized string similar to The puzzle can be comparable if it must be a standard sudoku..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_ContainsEmptySegmentOnParsing">
            <summary>
              Looks up a localized string similar to The string contains empty segment..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_DifferentExistenceOfConfigAndLibraryFile">
            <summary>
              Looks up a localized string similar to Different existence of config file and library file..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_DuplicatedValuesMayExistOrInvalid">
            <summary>
              Looks up a localized string similar to Duplicated or invalid values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_FileShouldBeInitializedFirst">
            <summary>
              Looks up a localized string similar to Related files should be initialized first..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridInvalid">
            <summary>
              Looks up a localized string similar to The grid is invalid - it may contain invalid internal data, or it is invalid as an argument to the method..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridInvalidCellState">
            <summary>
              Looks up a localized string similar to The grid cannot keep invalid cell state value..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridMultipleSolutions">
            <summary>
              Looks up a localized string similar to The grid contains multiple solutions..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_GridNoSolution">
            <summary>
              Looks up a localized string similar to The grid has no possible solution..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_InvalidStateOnParsing">
            <summary>
              Looks up a localized string similar to Invalid state on parsing values..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_LengthMustBeMatched">
            <summary>
              Looks up a localized string similar to The length of the string must be {0}..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_LibraryShouldBeInitialized">
            <summary>
              Looks up a localized string similar to The library is not initialized. It must be initialized file, ensuring the file in local exists..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MinLexShouldBeUniqueAndNotSukaku">
            <summary>
              Looks up a localized string similar to The puzzle should be standard sudoku puzzle, and contain a unique solution..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleChuteValuesFound">
            <summary>
              Looks up a localized string similar to Multiple chute values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleConjugatePairValuesFound">
            <summary>
              Looks up a localized string similar to Multiple conjuagte pair values found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleFlagsExist">
            <summary>
              Looks up a localized string similar to Multiple flags exist. The method only allows the enumeration field only holds one flag value..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_MultipleSamePropertiesFound">
            <summary>
              Looks up a localized string similar to Multiple same properties are found..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NoElementsInSequence">
            <summary>
              Looks up a localized string similar to No possible elements can be found in the current sequence..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NotExist">
            <summary>
              Looks up a localized string similar to The file does not exist..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_NotSupportedForSukakuPuzzles">
            <summary>
              Looks up a localized string similar to This function does not support for Sukaku puzzles..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_PlaceholderMustBeZeroOrDot">
            <summary>
              Looks up a localized string similar to The placeholder character invalid; expected: &apos;0&apos; or &apos;.&apos;..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_PointerCannotMove">
            <summary>
              Looks up a localized string similar to The pointer cannot move..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_StringValueInvalidToBeParsed">
            <summary>
              Looks up a localized string similar to The string value is invalid to be parsed..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.ErrorInfo_SubsetsExceeded">
            <summary>
              Looks up a localized string similar to Both cells count and subset size is too large, which may cause potential out of memory exception. This operator will throw this exception to calculate the result, in order to prevent any possible exceptions thrown..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.HousesLabel">
            <summary>
              Looks up a localized string similar to houses: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.LockedCandidatesLabel">
            <summary>
              Looks up a localized string similar to {0} {1}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaColumnLabel">
            <summary>
              Looks up a localized string similar to Mega column {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaLinesLabel">
            <summary>
              Looks up a localized string similar to Mega lines: {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.MegaRowLabel">
            <summary>
              Looks up a localized string similar to Mega row {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Message_LibraryInitializedException">
            <summary>
              Looks up a localized string similar to The library (local path: &apos;{0}\{1}&apos;) has already been initialized..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.Message_MultipleSolutionException">
            <summary>
              Looks up a localized string similar to The puzzle has multiple solutions..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.RowLabel">
            <summary>
              Looks up a localized string similar to Row {0}.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.RowName">
            <summary>
              Looks up a localized string similar to Row.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SettingsPage_GridSizeDescription2">
            <summary>
              Looks up a localized string similar to Also, please note that the pixels are changed in higher DPIs. If your computer is set *1.5 scale, sudoku grid pane of 610 pixel size will be zoomed in to 915 pixels (610 * 1.5 = 915)..
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_All">
            <summary>
              Looks up a localized string similar to All symmetry.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_AntiDiagonal">
            <summary>
              Looks up a localized string similar to Anti-diagonal.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_AxisBoth">
            <summary>
              Looks up a localized string similar to Both axes.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_Central">
            <summary>
              Looks up a localized string similar to Central.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_Diagonal">
            <summary>
              Looks up a localized string similar to Diagonal.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_DiagonalBoth">
            <summary>
              Looks up a localized string similar to Both diagonals.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_None">
            <summary>
              Looks up a localized string similar to No symmetry.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_XAxis">
            <summary>
              Looks up a localized string similar to X axis.
            </summary>
        </member>
        <member name="P:Sudoku.Resources.CoreResources.SymmetricType_YAxis">
            <summary>
              Looks up a localized string similar to Y axis.
            </summary>
        </member>
        <member name="T:Sudoku.Resources.LanguageNameComparisonExtensions">
            <summary>
            Represents a type that compares culture language names.
            </summary>
        </member>
        <member name="M:Sudoku.Resources.LanguageNameComparisonExtensions.IsCultureNameEqual(System.String,System.String)">
            <summary>
            Compares two <see cref="T:System.String"/> values, treated as culture name,
            to get a <see cref="T:System.Boolean"/> result indicating whether they are same culture name,
            or <paramref name="this"/> includes <paramref name="otherName"/>.
            </summary>
            <param name="this">The culture.</param>
            <param name="otherName">The other name to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:Sudoku.Runtime.InterceptorServices.InterceptorInstanceRoutingDefaultBehavior">
            <summary>
            Indicates the default behavior on routing for interceptor instance type checking.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.InterceptorServices.InterceptorInstanceRoutingDefaultBehavior.DoNothingOrReturnDefault">
            <summary>
            Indicates the default behavior is to return <see langword="default"/> or do nothing.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.InterceptorServices.InterceptorInstanceRoutingDefaultBehavior.ThrowNotSupportedException">
            <summary>
            Indicates the default behavior is to throw a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.InterceptorServices.InterceptorInstanceTypesAttribute">
             <summary>
             Represents an attribute type that can be applied to a method, indicating the method uses interceptor,
             but the target method is an instance method with inheritance. Specified types are the possible derived types of the instance.
             </summary>
             <param name="types">Indicates all possible types.</param>
             <remarks>
             <para>
             This attribute will be used by source generator to generate an extra entry to consume all possible types,
             which is useful for <see langword="abstract"/>, <see langword="virtual"/> and <see langword="sealed"/> methods.
             </para>
             <para>
             Usage:
             <code><![CDATA[
             [InterceptorMethodCaller]
             [InterceptorInstanceTypes(typeof(XChainingRule), typeof(YChainingRule))]
             public static void InitializeLinks(in Grid grid, LinkType linkTypes, StepGathererOptions options, out ChainingRuleCollection rules)
             {
                 rules = from linkType in linkTypes select ChainingRulePool.TryCreate(linkType)!;
                 if (!StrongLinkTypesCollected.HasFlag(linkTypes) || !WeakLinkTypesCollected.HasFlag(linkTypes))
                 {
                     var context = new ChainingRuleLinkContext(in grid, new LinkDictionary(), new LinkDictionary(), options);
                     foreach (var rule in rules)
                         rule.GetLinks(ref context);
                 }
            
                 // ...
             }
             ]]></code>
             </para>
             </remarks>
        </member>
        <member name="M:Sudoku.Runtime.InterceptorServices.InterceptorInstanceTypesAttribute.#ctor(System.Type[])">
             <summary>
             Represents an attribute type that can be applied to a method, indicating the method uses interceptor,
             but the target method is an instance method with inheritance. Specified types are the possible derived types of the instance.
             </summary>
             <param name="types">Indicates all possible types.</param>
             <remarks>
             <para>
             This attribute will be used by source generator to generate an extra entry to consume all possible types,
             which is useful for <see langword="abstract"/>, <see langword="virtual"/> and <see langword="sealed"/> methods.
             </para>
             <para>
             Usage:
             <code><![CDATA[
             [InterceptorMethodCaller]
             [InterceptorInstanceTypes(typeof(XChainingRule), typeof(YChainingRule))]
             public static void InitializeLinks(in Grid grid, LinkType linkTypes, StepGathererOptions options, out ChainingRuleCollection rules)
             {
                 rules = from linkType in linkTypes select ChainingRulePool.TryCreate(linkType)!;
                 if (!StrongLinkTypesCollected.HasFlag(linkTypes) || !WeakLinkTypesCollected.HasFlag(linkTypes))
                 {
                     var context = new ChainingRuleLinkContext(in grid, new LinkDictionary(), new LinkDictionary(), options);
                     foreach (var rule in rules)
                         rule.GetLinks(ref context);
                 }
            
                 // ...
             }
             ]]></code>
             </para>
             </remarks>
        </member>
        <member name="P:Sudoku.Runtime.InterceptorServices.InterceptorInstanceTypesAttribute.DefaultBehavior">
            <summary>
            Indicates the routing default behavior on generated method for <see langword="default"/> label
            or <see langword="_"/> token in <see langword="switch"/> statement or expression respectively.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.InterceptorServices.InterceptorInstanceTypesAttribute.Types">
            <summary>
            The generated property declaration for parameter <c>types</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.InterceptorServices.InterceptorMethodCallerAttribute">
            <summary>
            Indicates the target method marked this attribute will be replaced with intercepted methods.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.LibraryServices.LibraryInfo">
            <summary>
            Represents an entry that plays with a puzzle library file.
            </summary>
            <param name="directory">Indicates the parent directory that stores the library.</param>
            <param name="fileId">Indicates the file name used. The value should be valid as a file name, without file extension.</param>
            <remarks><i>
            This type only supports for Windows now. For other OS platforms,
            I will allow them in the future because I'm not familiar with file systems on other OS platforms.
            </i></remarks>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.#ctor(System.String,System.String)">
            <summary>
            Represents an entry that plays with a puzzle library file.
            </summary>
            <param name="directory">Indicates the parent directory that stores the library.</param>
            <param name="fileId">Indicates the file name used. The value should be valid as a file name, without file extension.</param>
            <remarks><i>
            This type only supports for Windows now. For other OS platforms,
            I will allow them in the future because I'm not familiar with file systems on other OS platforms.
            </i></remarks>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.LibraryInfo.SeparatorChar">
            <summary>
            Indicates the separator character.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.LibraryInfo.ConfigFileHeader">
            <summary>
            Indicates the file header of config files after created or initialized.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.IsInitialized">
            <summary>
            Indicates whether the library-related files are initialized.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.Count">
            <summary>
            Indicates the number of puzzles stored in this file.
            </summary>
            <remarks>
            This property is run synchronously, calling <see cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)"/>.
            <b>Always measure performance if you want to use this property.</b>
            </remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.LibraryFilePath">
            <summary>
            Indicates the path of the library file. The file only contains the puzzles.
            If you want to check for details of the configuration, use <see cref="P:Sudoku.Runtime.LibraryServices.LibraryInfo.ConfigFilePath"/> instead.
            </summary>
            <seealso cref="P:Sudoku.Runtime.LibraryServices.LibraryInfo.ConfigFilePath"/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.ConfigFilePath">
            <summary>
            Indicates the path of configuration file. The file contains the information of the library.
            </summary>
            <remarks>
            <para>
            Due to the design of the library APIs, a puzzle library contains two parts, separated with 2 files.
            One is the configuration file, and the other is the library details, only containing puzzles.
            </para>
            <para><i>
            Call this property will implicitly create config file if file is not found. No exception will be thrown here.
            </i></para>
            </remarks>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.Author">
            <summary>
            Indicates the author of the library. Return <see langword="null"/> if no author configured.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.Name">
            <summary>
            Indicates the name of the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.Description">
            <summary>
            Indicates the description to the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.Tags">
            <summary>
            Indicates the tags of the library.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library is not initialized.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Throws when the config file is missing.</exception>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.LastModifiedTime">
            <summary>
            Indicates the last modified time of the library file.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.ConfigFileExtension">
            <summary>
            Indicates the supported extension of config file. The extension will be used by API in runtime, recognizing config files.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.AuthorPattern">
            <remarks>
            Pattern:<br/>
            <code>author:\\s*([\\s\\S]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Aa].<br/>
             Match a character in the set [Uu].<br/>
             Match a character in the set [Tt].<br/>
             Match a character in the set [Hh].<br/>
             Match a character in the set [Oo].<br/>
             Match a character in the set [Rr].<br/>
             Match ':'.<br/>
             Match a whitespace character greedily any number of times.<br/>
             1st capture group.<br/>
                 Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.NamePattern">
            <remarks>
            Pattern:<br/>
            <code>name:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Nn].<br/>
             Match a character in the set [Aa].<br/>
             Match a character in the set [Mm].<br/>
             Match a character in the set [Ee].<br/>
             Match ':'.<br/>
             Match a whitespace character greedily any number of times.<br/>
             1st capture group.<br/>
                 Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.DescriptionPattern">
            <remarks>
            Pattern:<br/>
            <code>description:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Dd].<br/>
             Match a character in the set [Ee].<br/>
             Match a character in the set [Ss].<br/>
             Match a character in the set [Cc].<br/>
             Match a character in the set [Rr].<br/>
             Match a character in the set [Ii].<br/>
             Match a character in the set [Pp].<br/>
             Match a character in the set [Tt].<br/>
             Match a character in the set [Ii].<br/>
             Match a character in the set [Oo].<br/>
             Match a character in the set [Nn].<br/>
             Match ':'.<br/>
             Match a whitespace character greedily any number of times.<br/>
             1st capture group.<br/>
                 Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.TagsPattern">
            <remarks>
            Pattern:<br/>
            <code>tags:\\s*([\\S\\s]+)</code><br/>
            Options:<br/>
            <code>RegexOptions.IgnoreCase | RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             Match a character in the set [Tt].<br/>
             Match a character in the set [Aa].<br/>
             Match a character in the set [Gg].<br/>
             Match a character in the set [Ss].<br/>
             Match ':'.<br/>
             Match a whitespace character greedily any number of times.<br/>
             1st capture group.<br/>
                 Match any character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.Item(System.Int32)">
            <summary>
            Try to get the element at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The target <see cref="T:Sudoku.Concepts.Grid"/> instance at the specified index.</returns>
            <remarks>
            This property is run synchronously, calling <see cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetAtAsync(System.Int32,System.Threading.CancellationToken)"/>.
            <b>Always measure performance if you want to use this indexer.</b>
            </remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetAtAsync(System.Int32,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Deconstruct(System.String@,System.String@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax like <c>(a, b, c)</c> to define your own deconstruction logic.
				</summary>
			</target>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Initialize">
            <summary>
            Initializes the library-related files if not found. If initialized, throw <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInitializationException"/>.
            </summary>
            <exception cref="T:Sudoku.Runtime.LibraryServices.LibraryInitializationException">Throws when the library has already been initialized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Delete">
            <summary>
            Delete the current library, removing files from local path.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.ClearPuzzles">
            <summary>
            Clears the current library, removing all puzzles stored in this library, making the file empty,
            but reserving the files not deleted.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the library isn't initialized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Any">
            <summary>
            Determines whether the library contains at least one puzzle.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            <para>
            Append a puzzle, represented as a <see cref="T:System.String"/> value,
            into the specified file path represented as a puzzle library.
            </para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grid">The grid text code to be appended.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the grid cannot be recognized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzleAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzleAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            <para>
            Append a list of puzzles, represented as a list of <see cref="T:System.String"/> values,
            into the specified file path represented as a puzzle library.
            </para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grids">A list of grid text code to be appended.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task`1"/> of an <see cref="T:System.Int32"/> instance indicating how many text code are appended into the file.
            </returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IAsyncEnumerable{System.String},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{Sudoku.Concepts.Grid},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.AppendPuzzlesAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.RemovePuzzleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Removes all puzzles that exactly same as the specified one from the file.
            </summary>
            <param name="grid">The grid.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throw when the library file is not initialized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.RemovePuzzleAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.RemovePuzzleAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.RemoveDuplicatePuzzlesAsync(System.Threading.CancellationToken)">
            <summary>
            Removes a list of duplicate puzzles stored in the current library.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle should be initialized first.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.WriteAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            <para>Write a puzzle into a file just created.</para>
            <para>
            If the library is not initialized, it will be automatically initialized. No exceptions will be thrown on this case.
            </para>
            </summary>
            <param name="grid">The grid to be written.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that can be used in <see langword="await"/> expression.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the grid cannot be recognized.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.WriteAsync(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.WriteAsync(System.String,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)">
            <summary>
            Calculates how many puzzles in this file.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> of an <see cref="T:System.Int32"/> value indicating the result.</returns>
            <remarks>
            <b><i>If you want to check whether the puzzle has at least one puzzle, please use method <see cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Any"/> instead.</i></b>
            </remarks>
            <exception cref="T:System.InvalidOperationException">Throws when the library file is not initialized.</exception>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Any"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetAtAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Grid"/> at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> of <see cref="T:Sudoku.Concepts.Grid"/> instance as the result.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the library file is not initialized.</exception>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the index is out of range.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.CreateTextPointer">
            <summary>
            Creates a <see cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/> instance that uses <see cref="T:System.IO.FileStream"/> to read puzzles line by line.
            </summary>
            <returns>A <see cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/> instance that reads for the current library.</returns>
            <remarks><b>
            This method returns an instance that implements <see cref="T:System.IAsyncDisposable"/> and <see cref="T:System.IDisposable"/>,
            meaning you must call <see cref="M:System.IAsyncDisposable.DisposeAsync"/> or <see cref="M:System.IDisposable.Dispose"/>
            after you finishing using the return value:
            <code><![CDATA[await using var pointer = library.CreateTextPointer();]]></code>
            </b></remarks>
            <seealso cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/>
            <seealso cref="T:System.IDisposable"/>
            <seealso cref="T:System.IAsyncDisposable"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetAsyncEnumerator(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.EnumerateTextAsync(System.Threading.CancellationToken)">
            <summary>
            Enumerates raw text codes stored in the library.
            </summary>
            <param name="cancellationToken">The cancellation token that can cancel the current asynchronous operation.</param>
            <returns>An async-iterable collection of <see cref="T:System.String"/> values as raw text codes.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.ConfigFileReplaceOrAppend(System.Func{System.String,System.Boolean},System.String,System.String)">
            <summary>
            Replace or append the value into the file, using the specified match method.
            </summary>
            <param name="match">The matcher method.</param>
            <param name="replaceOrAppendValue">The value to replace with original value, or appened.</param>
            <param name="callerPropertyName">
            Indicates the property name as caller. This parameter shouldn't be assigned. It will be assigned by compiler.
            </param>
            <exception cref="T:System.InvalidOperationException">Throws when multiple same properties found.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.RegisterConfigFileExtension(System.String)">
            <summary>
            Registers the config file extension. Argument should contain prefix period token '<c>.</c>'.
            </summary>
            <param name="extension">The extension of the config file. Period '<c>.</c>' required.</param>
            <remarks>
            <b>Please note that only one extension can work. If you call this method multiple times, only the last one will work.</b>
            </remarks>
            <exception cref="T:System.ArgumentException">Throws when the argument <paramref name="extension"/> is not valid.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetSingleLineGridString(Sudoku.Concepts.Grid@)">
            <summary>
            Returns <c>grid.ToString("#")</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.LibraryInfo._directory">
            <summary>
            The generated field declaration for parameter <c>directory</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInfo.FileId">
            <summary>
            The generated property declaration for parameter <c>fileId</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.op_Equality(Sudoku.Runtime.LibraryServices.LibraryInfo,Sudoku.Runtime.LibraryServices.LibraryInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.op_Inequality(Sudoku.Runtime.LibraryServices.LibraryInfo,Sudoku.Runtime.LibraryServices.LibraryInfo)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Equals(Sudoku.Runtime.LibraryServices.LibraryInfo)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Runtime.LibraryServices.LibraryInitializationException">
            <summary>
            Represents an exception type that will be thrown if a library instance has already been initialized, but a user still calls
            method <see cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Initialize"/>.
            </summary>
            <param name="_directory"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='directory']"/></param>
            <param name="_fileId"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='fileId']"/></param>
            <remarks><i>
            This type is only used by Windows platform because the relied type <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/>
            is marked <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute"/>, limited in Windows.
            </i></remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Initialize"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInitializationException.#ctor(System.String,System.String)">
            <summary>
            Represents an exception type that will be thrown if a library instance has already been initialized, but a user still calls
            method <see cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Initialize"/>.
            </summary>
            <param name="_directory"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='directory']"/></param>
            <param name="_fileId"><inheritdoc cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.#ctor(System.String,System.String)" path="/param[@name='fileId']"/></param>
            <remarks><i>
            This type is only used by Windows platform because the relied type <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/>
            is marked <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute"/>, limited in Windows.
            </i></remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.Initialize"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.LibraryInitializationException.#ctor(Sudoku.Runtime.LibraryServices.LibraryInfo)">
            <summary>
            Initializes a <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInitializationException"/> instance via the specified directory and file ID.
            </summary>
            <param name="library">The library instance.</param>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.LibraryInitializationException.Message">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Runtime.LibraryServices.TextPointer">
            <summary>
            Represents a text pointer object that reads the detail of a <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/>.
            </summary>
            <remarks><i>
            This type only supports for Windows now because the relied type <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/> is limited in Windows.
            </i></remarks>
            <seealso cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.#ctor(Sudoku.Runtime.LibraryServices.LibraryInfo)">
            <summary>
            Represents a text pointer object that reads the detail of a <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/>.
            </summary>
            <remarks><i>
            This type only supports for Windows now because the relied type <see cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/> is limited in Windows.
            </i></remarks>
            <seealso cref="T:Sudoku.Runtime.LibraryServices.LibraryInfo"/>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.TextPointer.MaxLimitOfPuzzleLength">
            <summary>
            Indicates the max limit of a puzzle length.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.TextPointer._stream">
            <summary>
            Indicates the internal stream.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.ForwardPuzzlesCount">
            <summary>
            Indicates the number of puzzles left to be iterated from the current position. The current puzzle will be included.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.BackPuzzlesCount">
            <summary>
            Indicates the number of puzzles left to be iterated back from the current position. The current puzzle will be included.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.Current">
            <summary>
            Indicates the currently-pointed puzzle.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.Length">
            <summary>
            Indicates the number of puzzles stored in the file, regardless of the position of the pointer.
            </summary>
            <remarks><inheritdoc cref="P:Sudoku.Runtime.LibraryServices.LibraryInfo.Count" path="/remarks"/></remarks>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.LibraryInfo.GetCountAsync(System.Threading.CancellationToken)"/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.Library">
            <summary>
            Indicates the library object.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerator#Current">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#Generic#IReadOnlyCollection{System#String}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Runtime.LibraryServices.TextPointer.PositionOfPointer">
            <summary>
            Indicates the position of the pointer.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.SetStart">
            <summary>
            Sets the pointer to the start position, 0.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.SetEnd">
            <summary>
            Sets the pointer to the end position, the length of the stream.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryReadNextPuzzle(System.String@)">
            <summary>
            Try to read the next puzzle beginning with the current text pointer position.
            </summary>
            <param name="result">The result of the grid, represented as a <see cref="T:System.String"/> result.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the file exists the next grid.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryReadPreviousPuzzle(System.String@)">
            <summary>
            Try to read the previous puzzle beginning with the current text pointer position.
            </summary>
            <param name="result">The result of the grid, represented as a <see cref="T:System.String"/> result.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether the file exists the previous grid.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TrySkipNext(System.Int32)">
            <summary>
            Try to skip the number of puzzles forward, making the pointer point to the next grid after the skipped grids.
            </summary>
            <param name="count">The desired number of puzzles to be skipped. The default value is 1.</param>
            <returns>The number of puzzles skipped in fact.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TrySkipPrevious(System.Int32)">
            <summary>
            Try to skip the number of puzzles back, making the pointer point to the next grid before the skipped grids.
            </summary>
            <param name="count">The desired number of puzzles to be skipped. The default value is 1.</param>
            <returns>The number of puzzles skipped in fact.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryFetchNext(System.Int32,System.ReadOnlySpan{System.String}@)">
            <summary>
            Fetch the number of puzzles beginning with the current pointer position.
            </summary>
            <param name="count">The desired number of puzzles.</param>
            <param name="result">Indicates the puzzles fetched.</param>
            <returns>The number of puzzles fetched.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.TryFetchPrevious(System.Int32,System.ReadOnlySpan{System.String}@)">
            <summary>
            Fetch the number of puzzles in previous beginning with the current pointer position.
            </summary>
            <param name="count">The desired number of puzzles.</param>
            <param name="result">Indicates the puzzles fetched.</param>
            <returns>The number of puzzles fetched.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.GetEnumerator">
            <summary>
            Returns itself. The method is consumed by <see langword="foreach"/> loops.
            </summary>
            <returns>A <see cref="T:Sudoku.Runtime.LibraryServices.TextPointer"/> instance that can iterate on each puzzle stored in library file.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerator#Reset">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerator#MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.System#Collections#Generic#IEnumerable{System#String}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Increment(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the next puzzle. If the pointer is at the end of the sequence, moves to the first element.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedIncrement(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the next puzzle. If the pointer is at the end of the sequence,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the pointer cannot be moved.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Decrement(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the previous puzzle. If the pointer is at the start of the sequence, moves to the last element.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedDecrement(Sudoku.Runtime.LibraryServices.TextPointer)">
            <summary>
            Moves the pointer to the previous puzzle. If the pointer is at the start of the sequence, throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The instance to be moved.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when the pointer cannot be moved.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Addition(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles forward.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedAddition(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles forward. If the pointer has already moved to the last element,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements can be skipped.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Subtraction(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles back.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_CheckedSubtraction(Sudoku.Runtime.LibraryServices.TextPointer,System.Int32)">
            <summary>
            Skips the specified number of puzzles back. If the pointer has already moved to the first element,
            throw <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <param name="value">The value to be used.</param>
            <param name="count">The number of puzzles to be skipped.</param>
            <returns>A reference that is same as argument <paramref name="value"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when no elements can be skipped.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Equality(Sudoku.Runtime.LibraryServices.TextPointer,Sudoku.Runtime.LibraryServices.TextPointer)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.op_Inequality(Sudoku.Runtime.LibraryServices.TextPointer,Sudoku.Runtime.LibraryServices.TextPointer)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.Equals(Sudoku.Runtime.LibraryServices.TextPointer)">
            <inheritdoc/>
        </member>
        <member name="F:Sudoku.Runtime.LibraryServices.TextPointer._isDisposed">
            <summary>
            Indicates whether the object had already been disposed before <see cref="M:Sudoku.Runtime.LibraryServices.TextPointer.Dispose"/> was called.
            If this field holds <see langword="false"/> value, <see cref="M:Sudoku.Runtime.LibraryServices.TextPointer.Dispose"/> will throw an
            <see cref="T:System.ObjectDisposedException"/> to report the error.
            </summary>
            <seealso cref="M:Sudoku.Runtime.LibraryServices.TextPointer.Dispose"/>
            <seealso cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.Dispose">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="M:Sudoku.Runtime.LibraryServices.TextPointer.DisposeAsync">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException">Throws when the object had already been disposed.</exception>
        </member>
        <member name="T:Sudoku.Shuffling.Minlex.BestTripletPermutation">
            <summary>
            Represents the permutation information for best triplet.
            </summary>
            <param name="bestResult">Indicates the best result.</param>
            <param name="resultMask">Indicates the result mask.</param>
            <param name="resultNumberOfBits">Indicates the result number of bits.</param>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.BestTripletPermutation.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Represents the permutation information for best triplet.
            </summary>
            <param name="bestResult">Indicates the best result.</param>
            <param name="resultMask">Indicates the result mask.</param>
            <param name="resultNumberOfBits">Indicates the result number of bits.</param>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.BestTripletPermutation.Perm">
            <summary>
            Indicates the permutation cases.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.BestTripletPermutation.BestTripletPermutations">
            <summary>
            Indicates all best triplet permutations.
            </summary>
        </member>
        <member name="P:Sudoku.Shuffling.Minlex.BestTripletPermutation.BestResult">
            <summary>
            The generated property declaration for parameter <c>bestResult</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Shuffling.Minlex.BestTripletPermutation.ResultMask">
            <summary>
            The generated property declaration for parameter <c>resultMask</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Shuffling.Minlex.BestTripletPermutation.ResultNumberOfBits">
            <summary>
            The generated property declaration for parameter <c>resultNumberOfBits</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Shuffling.Minlex.GridMinlexComparisonExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/> for minlex.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridMinlexComparisonExtensions.Equals(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@,Puzzles.Meta.Transforming.BoardComparison)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Grid"/> instance hold the same values as the current instance,
            by using the specified comparison type.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="other">The instance to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="comparisonType"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridMinlexComparisonExtensions.GetHashCode(Sudoku.Concepts.Grid@,Puzzles.Meta.Transforming.BoardComparison)">
            <inheritdoc cref="M:Sudoku.Concepts.Grid.GetHashCode"/>
            <param name="this">Indicates the current instance.</param>
            <param name="comparisonType">
            Indicates the comparison type that specifies the target grid to be calculated its hash code.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="comparisonType"/> isn't defined.
            </exception>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridMinlexComparisonExtensions.CompareTo(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@,Puzzles.Meta.Transforming.BoardComparison)">
            <summary>
            Compares the current instance with another object of the same type and returns an integer
            that indicates whether the current instance precedes, follows or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="this">Indicates the current instance.</param>
            <param name="other">The other object to be compared.</param>
            <param name="comparisonType">The comparison type to be used.</param>
            <returns>A value that indicates the relative order of the objects being compared.</returns>
            <exception cref="T:System.InvalidOperationException">Throws when one of the grids to be compared is a Sukaku puzzle.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="comparisonType"/> is not defined.</exception>
        </member>
        <member name="T:Sudoku.Shuffling.Minlex.GridMinlexExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/>, by checking min-lex-related properties.
            </summary>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridMinlexExtensions.IsMinLexGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Checks whether the current grid is the minimal lexicographical form, which means the corresponding string text code
            is the minimum value in all equivalent transforming cases in lexicographical order.
            </summary>
            <param name="this">The grid to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridMinlexExtensions.GetMinLexGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Checks the minimal lexicographical grid form.
            </summary>
            <param name="this">The grid to be checked.</param>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridMinlexExtensions.MakeMinLex(Sudoku.Concepts.Grid@)">
            <summary>
            Adjust the grid to minimal lexicographical form.
            </summary>
            <param name="this">The grid to be changed.</param>
        </member>
        <member name="T:Sudoku.Shuffling.Minlex.GridPattern">
            <summary>
            Represents a pattern for a sudoku grid.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.GridPattern.MinCanNineBits">
            <summary>
            A precomputed min-lexicographical-ordered recompositing of the bit triplets for a 9-bits input.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.GridPattern.Rows">
            <summary>
            Indicates the rows.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.GridPattern.Digits">
            <summary>
            Indicates the digit.
            </summary>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridPattern.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridPattern.BestTopRowScore(Sudoku.Shuffling.Minlex.GridPattern@)">
            <summary>
            Try to calculate the best top row score from the specified <see cref="T:Sudoku.Shuffling.Minlex.GridPattern"/> instance.
            </summary>
            <param name="p">The grid pattern instance.</param>
            <returns>The score value calculated.</returns>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.GridPattern.FromString(System.String,System.ReadOnlySpan{Sudoku.Shuffling.Minlex.GridPattern}@)">
            <summary>
            Initializes for normal and transposed <see cref="T:Sudoku.Shuffling.Minlex.GridPattern"/> instances from a string grid code.
            </summary>
            <param name="grid">Indicates the grid code to be used.</param>
            <param name="resultPair">Indicates the 2 <see cref="T:Sudoku.Shuffling.Minlex.GridPattern"/> instances for normal and transposed cases.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the number of given cells.</returns>
        </member>
        <member name="T:Sudoku.Shuffling.Minlex.Mapper">
            <summary>
            Indicates a data structure that describes the cell and label handled.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.Mapper.Cell">
            <summary>
            Indicates the cell <see cref="T:System.Byte"/> values.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.Mapper.Label">
            <summary>
            Indicates the label <see cref="T:System.Byte"/> values.
            </summary>
        </member>
        <member name="T:Sudoku.Shuffling.Minlex.MinlexCandidate">
            <summary>
            Indicates a node representing the min-lexicographical candidate.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.MinlexCandidate.IsTransposed">
            <summary>
            A flag field indicating whether the candidate is handled as transposed.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.MinlexCandidate.MapRowsForward">
            <summary>
            Indicates the map bits on forward rows.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.MinlexCandidate.MapRowsBackward">
            <summary>
            Indicates the map bits on backward rows.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.MinlexCandidate.StacksPermutation">
            <summary>
            Indicates the stack permutation.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.MinlexCandidate.ColumnsPermutationMask">
            <summary>
            Indicates mask bit values for column permutation.
            </summary>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.MinlexCandidate.#ctor">
            <summary>
            Initializes a <see cref="T:Sudoku.Shuffling.Minlex.MinlexCandidate"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.MinlexCandidate.#ctor(System.SByte,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Shuffling.Minlex.MinlexCandidate"/> instance via the specified flag for transpose case and top row.
            </summary>
            <param name="transpose">The value for transpose flag. The value can only be 0 or 1.</param>
            <param name="topRow">The top row used.</param>
        </member>
        <member name="P:Sudoku.Shuffling.Minlex.MinlexCandidate.Empty">
            <summary>
            Represents an empty <see cref="T:Sudoku.Shuffling.Minlex.MinlexCandidate"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.MinlexCandidate.ExpandStacks(System.ReadOnlySpan{Sudoku.Shuffling.Minlex.GridPattern},System.Int32,System.Span{Sudoku.Shuffling.Minlex.MinlexCandidate},System.Int32@)">
            <summary>
            To expand stacks.
            </summary>
            <param name="pair">A pair of <see cref="T:Sudoku.Shuffling.Minlex.GridPattern"/> instance.</param>
            <param name="topKey">Indicates the top key.</param>
            <param name="results">Indicates the results.</param>
            <param name="resultCount">The result count.</param>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.MinlexCandidate.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Shuffling.Minlex.MinlexFinder">
            <summary>
            Represents a finder type.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.MinlexFinder.CandidateListTotal">
            <summary>
            Indicates the total number of candidate list, which means the worst case.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Minlex.MinlexFinder._mappers">
            <summary>
            Indicates the internal mappers.
            </summary>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.MinlexFinder.Find(Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Shuffling.Minlex.MinlexFinder.Find(System.String)"/>
        </member>
        <member name="M:Sudoku.Shuffling.Minlex.MinlexFinder.Find(System.String)">
            <summary>
            Finds the minimal lexicographical form of the source grid code.
            </summary>
            <param name="grid">Indicates the source grid.</param>
            <returns>The corresponding minimal lexicographical form of the grid.</returns>
        </member>
        <member name="T:Sudoku.Shuffling.Transforming.GridTransformingExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.GridTransformingExtensions.Transform(Sudoku.Concepts.Grid@,Sudoku.Shuffling.Transforming.TransformType)">
            <summary>
            Transforms the grid by the specified type.
            </summary>
            <param name="grid">The grid to be transformed.</param>
            <param name="transformTypes">
            The transform types can be applied. You can use <c><see cref="T:Sudoku.Shuffling.Transforming.TransformType"/>.<see langword="operator"/> |</c> to combine flags.
            </param>
        </member>
        <member name="T:Sudoku.Shuffling.Transforming.RandomizationExtensions">
            <summary>
            Provides with extension methods for <see cref="T:System.Random"/>.
            </summary>
            <seealso cref="T:System.Random"/>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.RandomizationExtensions.NextDigit(System.Random)">
            <summary>
            Returns a random integer that is within valid digit range (0..9).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.RandomizationExtensions.NextCell(System.Random)">
            <summary>
            Returns a random integer that is within valid cell range (0..81).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.RandomizationExtensions.NextHouse(System.Random)">
            <summary>
            Returns a random integer that is within valid house range (0..27).
            </summary>
            <param name="random">The random instance.</param>
            <returns>
            An integer that represents a valid <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.RandomizationExtensions.RandomlySelect(System.Random,Sudoku.Concepts.CellMap@,System.Int32)">
            <summary>
            Randomly select the specified number of elements from the current collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="cells">The cells to be chosen.</param>
            <param name="count">The desired number of elements.</param>
            <returns>The specified number of elements returned, represented as a <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.RandomizationExtensions.RandomlySelect(System.Random,Sudoku.Concepts.CandidateMap@,System.Int32)">
            <summary>
            Randomly select the specified number of elements from the current collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="cells">The cells to be chosen.</param>
            <param name="count">The desired number of elements.</param>
            <returns>The specified number of elements returned, represented as a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.RandomizationExtensions.CreateCellMap(System.Random,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CellMap"/> instance, with the specified number of <see cref="T:System.Int32"/>s stored in the collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="count">The desired number of elements.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CellMap"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.RandomizationExtensions.CreateCandidateMap(System.Random,System.Int32)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.CandidateMap"/> instance, with the specified number of <see cref="T:System.Int32"/>s stored in the collection.
            </summary>
            <param name="random">The random instance.</param>
            <param name="count">The desired number of elements.</param>
            <returns>A <see cref="T:Sudoku.Concepts.CandidateMap"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Shuffling.Transforming.Transformation">
            <summary>
            Provides methods for <see cref="T:Sudoku.Concepts.Grid"/> instances on transformations.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.Transformation.ClockwiseTable">
            <summary>
            The table of clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.Transformation.CounterclockwiseTable">
            <summary>
            The table of counter-clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.Transformation.PiRotateTable">
            <summary>
            The table of pi-rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.Transformation.SwappableHouses">
            <summary>
            Indicates the swappable pairs, which means the swappable houses.
            </summary>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.MirrorLeftRight(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror left-right the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.MirrorTopBottom(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror top-bottom the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.MirrorDiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.Transpose(Sudoku.Concepts.Grid@)">
            <summary>
            Transpose the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.MirrorAntidiagonal(Sudoku.Concepts.Grid@)">
            <summary>
            Mirror anti-diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.RotateClockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid clockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.RotateCounterclockwise(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid counterclockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.RotatePi(Sudoku.Concepts.Grid@)">
            <summary>
            Rotate the grid <c><see cref="F:System.Math.PI"/></c> degrees.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
            <remarks>
            This method will return the reference that is same as the argument,
            in order to inline multiple transformation operations.
            </remarks>
            <seealso cref="F:System.Math.PI"/>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.SwapDigit(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap two digits.
            </summary>
            <param name="this">The grid.</param>
            <param name="digit1">The digit 1 to be swapped.</param>
            <param name="digit2">The digit 2 to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">Throws when the puzzle is not solved.</exception>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.SwapHouse(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap to houses.
            </summary>
            <param name="this">The grid.</param>
            <param name="houseIndex1">The house 1 to be swapped.</param>
            <param name="houseIndex2">The house 2 to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when two specified house argument is not in valid range (0..27),
            two houses are not in same house type, or are not swappable.
            </exception>
            <remarks>
            This method will return the reference that is same as the argument <paramref name="this"/>,
            in order to inline multiple transformation operations.
            </remarks>
        </member>
        <member name="M:Sudoku.Shuffling.Transforming.Transformation.SwapChute(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap chutes (i.e. mega-rows or mega-columns).
            </summary>
            <param name="this">The grid.</param>
            <param name="chuteIndex1">The first chute to be swapped.</param>
            <param name="chuteIndex2">The second chute to be swapped.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">Throws when two specified chute index is not in valid range (0..6).</exception>
        </member>
        <member name="T:Sudoku.Shuffling.Transforming.TransformType">
            <summary>
            Represents a type of transformation.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.None">
            <summary>
            The placeholder of this type.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.DigitSwap">
            <summary>
            Indicates the transform type is to swap digits.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.RowSwap">
            <summary>
            Indicates the transform type is to swap rows.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.ColumnSwap">
            <summary>
            Indicates the transform type is to swap columns.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.BandSwap">
            <summary>
            Indicates the transform type is to swap bands.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.TowerSwap">
            <summary>
            Indicates the transform type is to swap towers.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.MirrorLeftRight">
            <summary>
            Indicates the transform type is to mirror left and right.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.MirrorTopBottom">
            <summary>
            Indicates the transform type is to mirror top and bottom.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.MirrorDiagonal">
            <summary>
            Indicates the transform type is to mirror diagonal.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.MirrorAntidiagonal">
            <summary>
            Indicates the transform type is to mirror anti-diagonal.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.RotateClockwise">
            <summary>
            Indicates the transform type is to rotate clockwise.
            </summary>
        </member>
        <member name="F:Sudoku.Shuffling.Transforming.TransformType.RotateCounterclockwise">
            <summary>
            Indicates the transform type is to ratate counter-clockwise.
            </summary>
        </member>
        <member name="T:Sudoku.SolutionFields">
            <summary>
            Provides with solution-wide read-only fields used.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.PeersCount">
            <summary>
            Indicates the number of each cell's peer cells. The value is a constant.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseTypes">
            <summary>
            Indicates the possible house types to be iterated.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.Digits">
            <summary>
            Indicates the digits used. The value can be also used for ordered houses by rows.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesOrderedByColumn">
            <summary>
            Indicates the houses ordered by column.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HouseFirst">
            <summary>
            Indicates the first cell offset for each house.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesCells">
            <summary>
            <para>
            The map of all cell offsets in its specified house.
            The indices are between 0 and 26, where:
            <list type="table">
            <item>
            <term><c>0..9</c></term>
            <description>Block 1 to 9.</description>
            </item>
            <item>
            <term><c>9..18</c></term>
            <description>Row 1 to 9.</description>
            </item>
            <item>
            <term><c>18..27</c></term>
            <description>Column 1 to 9.</description>
            </item>
            </list>
            </para>
            </summary>
            <example>
            '<c>HouseCells[0]</c>': all cell offsets in the house 0 (block 1).
            </example>
        </member>
        <member name="F:Sudoku.SolutionFields.BlockTable">
            <summary>
            Indicates a block list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.RowTable">
            <summary>
            Indicates a row list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ColumnTable">
            <summary>
            Indicates a column list that each cell belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.CellMaps">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances that are initialized as singleton element by its corresponding index.
            For example, <c>CellMaps[0]</c> is to <c>CellMap.Empty + 0</c>, i.e. <c>r1c1</c>.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.HousesMapBackingField">
            <summary>
            Backing field of <see cref="P:Sudoku.SolutionFields.HousesMap"/>.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.PeersMapBackingField">
            <summary>
            Backing field of <see cref="P:Sudoku.SolutionFields.PeersMap"/>.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ChuteMapsBackingField">
            <summary>
            Backing field of <see cref="P:Sudoku.SolutionFields.ChuteMaps"/>.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ChutesBackingField">
            <summary>
            Backing field of <see cref="P:Sudoku.SolutionFields.Chutes"/>.
            </summary>
        </member>
        <member name="F:Sudoku.SolutionFields.ChuteHouses">
            <summary>
            Indicates the chute house triplets.
            </summary>
        </member>
        <member name="P:Sudoku.SolutionFields.HousesMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the cells belong to a house at the specified index.
            </summary>
        </member>
        <member name="P:Sudoku.SolutionFields.PeersMap">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.CellMap"/> instances representing the peer cells of a cell at the specified index.
            </summary>
        </member>
        <member name="P:Sudoku.SolutionFields.ChuteMaps">
            <summary>
            Indicates the chute maps.
            </summary>
        </member>
        <member name="P:Sudoku.SolutionFields.Chutes">
            <summary>
            Indicates a list of <see cref="T:Sudoku.Concepts.Chute"/> instances representing chutes.
            </summary>
        </member>
        <member name="M:Sudoku.SolutionFields.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Solving.Backtracking.BacktrackingSolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using backtracking algorithm.
            </summary>
            <remarks>
            <para>
            Please note that the current type has no optimization on solving. Therefore sometimes the puzzle will be
            extremely slowly to be solved although it is not very hard by manually solved.
            One of the examples satisfying the above condition is:
            <code>
            ..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9
            </code>
            The current solver may spend about 4.5 min on solving this puzzle on my machine.
            </para>
            <para>
            For more information, please visit
            <see href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms#cite_note-difficult_17_clue-1">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="P:Sudoku.Solving.Backtracking.BacktrackingSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Solving.Backtracking.BacktrackingSolver.UseBreadthFirstSearch">
            <summary>
            Indicates whether the solver uses breadth-first searching algorithm instead of traditional depth-first searching.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Backtracking.BacktrackingSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Backtracking.BacktrackingSolver.IsValid(Sudoku.Concepts.Grid@,System.Int32,System.Int32)">
            <summary>
            Determine whether the specified grid has confliction with the specified row and column.
            </summary>
            <param name="grid">The grid to be checked.</param>
            <param name="r">The row index.</param>
            <param name="c">The column index.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Solving.Backtracking.BacktrackingSolver.IsValid(System.Int32[],System.Int32,System.Int32)">
            <inheritdoc cref="M:Sudoku.Solving.Backtracking.BacktrackingSolver.IsValid(Sudoku.Concepts.Grid@,System.Int32,System.Int32)"/>
        </member>
        <member name="T:Sudoku.Solving.Bitwise.BitwiseSolver">
            <summary>
            Indicates the solver that is able to solve a sudoku puzzle, and then get the solution of that sudoku.
            </summary>
            <remarks>
            <para>
            The reason why the type name contains the word <i>bitwise</i> is that the solver uses the bitwise algorithm
            to handle a sudoku grid, which is more efficient.
            </para>
            <para><b>
            This type is thread-unsafe. If you want to use this type in multi-threading, please use <see langword="lock"/> statement.
            </b></para>
            </remarks>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver.BufferLength">
            <summary>
            The buffer length of a solution puzzle.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver.BitSet27">
            <summary>
            All pencil marks set - 27 bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver._stack">
            <summary>
            Stack to store current and previous states.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver._singleApplied">
            <summary>
            Nasty global flag telling if <see cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.ApplySingleOrEmptyCells"/> found anything.
            </summary>
            <seealso cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.ApplySingleOrEmptyCells"/>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver._solution">
            <summary>
            Pointer to where to store the first solution. This value can be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver._numSolutions">
            <summary>
            Indicates the number of solutions found so far.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver._limitSolutions">
            <summary>
            Indicates the number of solutions you want to search.
            Assign <see cref="F:System.Int32.MaxValue"/> if you want to find all possible solutions,
            and assign 2 if you only want to check validity of the puzzle (if 2 solutions found, the puzzle will become invalid).
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolver._g">
            <summary>
            Pointer to the currently active slot.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Bitwise.BitwiseSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="E:Sudoku.Solving.Bitwise.BitwiseSolver.SolutionFound">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.SolveString(System.Char*,System.Char*,System.Int32)">
            <summary>
            Solves the puzzle represented as a string value.
            </summary>
            <param name="puzzle">The puzzle represented as a string.</param>
            <param name="solution">The solution.</param>
            <param name="limit">The limit of solutions to be checked.</param>
            <returns>A <see cref="T:System.Int64"/> value indicating the number of solutions.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.SolveString(System.String,System.Char*,System.Int32)">
            <inheritdoc cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.SolveString(System.Char*,System.Char*,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.SolveString(System.String,System.String@,System.Int32)">
            <inheritdoc cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.SolveString(System.Char*,System.Char*,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char*)">
            <summary>
            Same as <see cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="grid"/> is <see langword="null"/>.
            </exception>
            <seealso cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char@)">
            <inheritdoc cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char*)"/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String)">
            <inheritdoc cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.Char*)"/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.CheckValidity(System.String,System.String@)">
            <summary>
            Check the validity of the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="solutionIfUnique">The solution if the puzzle is unique.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.Solve(Sudoku.Concepts.Grid@)">
            <summary>
            To solve the puzzle, and get the solution.
            </summary>
            <param name="puzzle">The puzzle to solve.</param>
            <returns>The solution. If failed to solve, <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.</returns>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.Sudoku#Solving#ISolutionEnumerableSolver#EnumerateSolutionsCore(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.ClearStack">
            <summary>
            To clear the field <see cref="F:Sudoku.Solving.Bitwise.BitwiseSolver._stack"/>.
            </summary>
            <seealso cref="F:Sudoku.Solving.Bitwise.BitwiseSolver._stack"/>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.SetSolvedDigit(System.Int32,System.Int32)">
            <summary>
            Set a cell as solved - used in <see cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.EliminateDigit(System.Int32,System.Int32)">
            <summary>
            Eliminate a digit - used in <see cref="M:Sudoku.Solving.Bitwise.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.SetSolvedMask(System.Int32,System.UInt32)">
            <summary>
            Set a cell as solved - used in various guess routines.
            </summary>
            <param name="band">The band.</param>
            <param name="mask">The mask.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.InitSudoku(System.Char*)">
            <summary>
            Setup everything and load the puzzle.
            </summary>
            <param name="puzzle">The pointer that points to a puzzle buffer.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.Update">
            <summary>
            Core of fast processing.
            </summary>
            <returns>The <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.ApplySingleOrEmptyCells">
            <summary>
            Find singles, bi-value cells, and impossible cells.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.InternalSolve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The internal solving method.
            </summary>
            <param name="puzzle">The pointer to the puzzle string.</param>
            <param name="solutionPtr">The pointer to the solution string.</param>
            <param name="limit">The limitation for the number of all final solutions.</param>
            <returns>The number of solutions found.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.ExtractSolution(System.Char*)">
            <summary>
            Extract solution as a string.
            </summary>
            <param name="solution">
            The solution pointer. <b>The buffer should be at least <see cref="F:Sudoku.Solving.Bitwise.BitwiseSolver.BufferLength"/>
            of value of length.</b>
            </param>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.GuessBiValueInCell">
            <summary>
            Try both options for cells with exactly two pencil marks.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.GuessFirstCell">
            <summary>
            Guess all possibilities in first unsolved cell.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.Guess">
            <summary>
            Either already solved, or guess and recurse.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.FullUpdate">
            <summary>
            Get as far as possible without guessing.
            </summary>
            <returns>A <see cref="T:System.Byte"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.BitPos(System.UInt32)">
            <summary>
            Get the bit position.
            </summary>
            <param name="map">The map.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:Sudoku.Solving.Bitwise.BitwiseSolver.StringLengthOf(System.Char*)">
            <summary>
            Get the length of the specified string which is represented by a <see cref="T:System.Char"/>*.
            </summary>
            <param name="ptr">The pointer.</param>
            <returns>The total length.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="ptr"/> is <see langword="null"/>.
            </exception>
            <remarks>
            In C#, this function is unsafe because the implementation of
            <see cref="T:System.String"/> types between C and C# is totally different.
            In C, <see cref="T:System.String"/> is like a <see cref="T:System.Char"/>* or a
            <see cref="T:System.Char"/>[], they ends with the terminator symbol <c>'\0'</c>.
            However, C# not.
            </remarks>
        </member>
        <member name="T:Sudoku.Solving.Bitwise.BitwiseSolverState">
            <summary>
            Represents a data structure, used by type <see cref="T:Sudoku.Solving.Bitwise.BitwiseSolver" />, describing state for a current grid using binary values.
            </summary>
            <remarks>
            <large-structure>
		<b>
			<i>
				This is a large structure, which means it may cost more time to copy instance than normal structures.
				I strongly recommend you append <see langword="ref readonly" /> to modify the type, as parameter or local variable modifiers,
				to tell runtime that it should be copied by its reference instead of internal value.
			</i>
		</b>
	</large-structure>
            </remarks>
            <seealso cref="T:Sudoku.Solving.Bitwise.BitwiseSolver" />
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolverState.Bands">
            <summary>
            Pencil marks in bands by digit.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolverState.PrevBands">
            <summary>
            Value of bands last time it was calculated.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolverState.UnsolvedCells">
            <summary>
            Bit vector of unsolved cells.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolverState.UnsolvedRows">
            <summary>
            Bit vector of unsolved rows - three bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Bitwise.BitwiseSolverState.Pairs">
            <summary>
            Bit vector of cells with exactly two pencil marks.
            </summary>
        </member>
        <member name="T:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver">
            <summary>
            Defines a <see cref="T:System.Collections.Generic.Dictionary`2"/>-based LINQ solver that solves a sudoku grid,
            using a different algorithm with the other one of type <see cref="T:Sudoku.Solving.EnumerableQuery.EnumerableQuerySolver"/>.
            </summary>
            <remarks>
            <para>
            This algorithm is originally written by Python, posted from <see href="http://norvig.com/sudo.py">here</see>
            by Richard Birkby, June 2007. For more information, please visit
            <see href="http://norvig.com/sudoku.html">this link</see>.
            </para>
            <para>
            Also, <see href="https://bugzilla.mozilla.org/attachment.cgi?id=266577">this link</see> is for the same algorithm
            written by JavaScript 1.8+.
            </para>
            </remarks>
            <seealso cref="T:Sudoku.Solving.EnumerableQuery.EnumerableQuerySolver"/>
        </member>
        <member name="F:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Rows">
            <summary>
            Indicates the characters of all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Columns">
            <summary>
            Indicates the characters of all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Digits">
            <summary>
            Indicates the characters of all digits.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Coordinates">
            <summary>
            Indicates all possible coordinates.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Peers">
            <summary>
            Indicates the peers.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Houses">
            <summary>
            Indicates the houses.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.AllNotNull``1(System.ReadOnlySpan{``0})">
            <summary>
            Determines whether all elements in this collection are not <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the element in the sequence.</typeparam>
            <param name="sequence">The whole sequence.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.AllNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.AllNotNull``1(System.ReadOnlySpan{``0})"/>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Zip(System.String[],System.String[])">
            <summary>
            To zip two lists of <see cref="T:System.String"/>s.
            </summary>
            <param name="a">The first array.</param>
            <param name="b">The second array.</param>
            <returns>The final zipped collection.</returns>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.ParseGrid(System.String)">
            <summary>
            Given a string of 81 digits (or <c>'.'</c>, <c>'0'</c> or <c>'-'</c>),
            and return a dictionary of a key-value pair of cell and the candidates.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Search(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Using depth-first search and propagation to try all possible values.
            </summary>
            <returns>A first found solution.</returns>
            <remarks>
            This algorithm is hard to determine whether the puzzle has multiple solutions, due to DFS.
            </remarks>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Assign(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate all the other values (except <paramref name="d"/>)
            from <c><paramref name="values"/>[<paramref name="s"/>]</c> and propagate.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.DictionaryQuery.DictionaryQuerySolver.Eliminate(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Eliminate d from <c><paramref name="values"/>[<paramref name="s"/>]</c>; propagate when values or places &lt;= 2.
            </summary>
        </member>
        <member name="T:Sudoku.Solving.Dlx.ColumnNode">
            <summary>
            Represents a column node.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Dlx.ColumnNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Solving.Dlx.ColumnNode"/> instance via the specified ID value.
            </summary>
            <param name="candidate">The candidate.</param>
        </member>
        <member name="P:Sudoku.Solving.Dlx.ColumnNode.Size">
            <summary>
            Indicates the size of the node.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Dlx.ColumnNode.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Solving.Dlx.DancingLink">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="_root">The root node.</param>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLink.#ctor(Sudoku.Solving.Dlx.ColumnNode)">
            <summary>
            Represents as a dancing link.
            </summary>
            <param name="_root">The root node.</param>
        </member>
        <member name="F:Sudoku.Solving.Dlx.DancingLink.NodesCount">
            <summary>
            Indicates the number of nodes created in the data model.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLink.RawColumns">
            <summary>
            Indicates the raw columns.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLink.Entry">
            <summary>
            Indicates the entry instance. Use this propeprty to create links:
            <code><![CDATA[
            var grid = ...;
            DancingLink.Entry.Create(in grid);
            ]]></code>
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLink.Create(Sudoku.Concepts.Grid@)">
            <summary>
            Try to create a <see cref="T:Sudoku.Solving.Dlx.ColumnNode"/> instance, including connection
            with all candidates from the specified grid.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The column node for the root node.</returns>
            <seealso cref="T:Sudoku.Solving.Dlx.ColumnNode"/>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLink.Create(System.Int32[])">
            <inheritdoc cref="M:Sudoku.Solving.Dlx.DancingLink.Create(Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="T:Sudoku.Solving.Dlx.DancingLinkNode">
            <summary>
            Represents a dancing link node.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinkNode.#ctor(System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Solving.Dlx.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="candidate">The candidate.</param>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinkNode.#ctor(System.Int32,Sudoku.Solving.Dlx.ColumnNode)">
            <summary>
            Initializes a <see cref="T:Sudoku.Solving.Dlx.DancingLinkNode"/> instance via the specified ID value and the column node.
            </summary>
            <param name="candidate">The candidate.</param>
            <param name="column">The column node.</param>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLinkNode.Candidate">
            <summary>
            Indicates the candidate of the node.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLinkNode.Column">
            <summary>
            Indicates the current column node.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLinkNode.Left">
            <summary>
            Indicates the pointer that points to the left node.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLinkNode.Right">
            <summary>
            Indicates the pointer that points to the right node.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLinkNode.Up">
            <summary>
            Indicates the pointer that points to the up node.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLinkNode.Down">
            <summary>
            Indicates the pointer that points to the down node.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinkNode.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinkNode.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinkNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Solving.Dlx.DancingLinksSolver">
            <summary>
            Defines a solver that uses the dancing links algorithm.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Dlx.DancingLinksSolver._answerNodesStack">
            <summary>
            Indicates the stack that stores the raw data for the solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Dlx.DancingLinksSolver._solutionCount">
            <summary>
            indicates the number of all found solutions.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Dlx.DancingLinksSolver._solution">
            <summary>
            Indicates the found solution.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Dlx.DancingLinksSolver._root">
            <summary>
            Indicates the root node of the full link map.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.Dlx.DancingLinksSolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="E:Sudoku.Solving.Dlx.DancingLinksSolver.SolutionFound">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.Solve(System.Int32[],Sudoku.Concepts.Grid@)">
            <inheritdoc cref="M:Sudoku.Solving.Dlx.DancingLinksSolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)"/>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.Sudoku#Solving#ISolutionEnumerableSolver#EnumerateSolutionsCore(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.Search(,)">
            <summary>
            Try to search the full dancing link map and get the possible solution.
            </summary>
            <param name="multipleSolutionGuard">A method that guards the case that multiple solutions (at least 2) are found.</param>
            <param name="resultTargeting">A method that assigns or consume the result raw value.</param>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle has multiple solutions.</exception>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.Cover(Sudoku.Solving.Dlx.DancingLinkNode)">
            <summary>
            Cover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.Uncover(Sudoku.Solving.Dlx.DancingLinkNode)">
            <summary>
            Uncover the nodes for the specified column.
            </summary>
            <param name="column">The column.</param>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.ChooseNextColumn">
            <summary>
            Try to choose the next column node.
            </summary>
            <returns>The chosen next column node.</returns>
        </member>
        <member name="M:Sudoku.Solving.Dlx.DancingLinksSolver.ToGrid(System.Collections.Generic.Stack{Sudoku.Solving.Dlx.DancingLinkNode})">
            <summary>
            Converts a list of <see cref="T:Sudoku.Solving.Dlx.DancingLinkNode"/> as solution.
            </summary>
            <param name="answer">The solution nodes.</param>
            <returns>A grid converted.</returns>
        </member>
        <member name="T:Sudoku.Solving.Dlx.MatrixRow">
            <summary>
            Represents a type describing for a matrix row.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.Dlx.MatrixRow.#ctor(Sudoku.Solving.Dlx.DancingLinkNode,Sudoku.Solving.Dlx.DancingLinkNode,Sudoku.Solving.Dlx.DancingLinkNode,Sudoku.Solving.Dlx.DancingLinkNode)">
            <summary>
            Represents a type describing for a matrix row.
            </summary>
        </member>
        <member name="T:Sudoku.Solving.EnumerableQuery.EnumerableQuerySolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using LINQ.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.EnumerableQuery.EnumerableQuerySolver.DigitCharacters">
            <summary>
            Indicates the characters for 1 to 9.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.EnumerableQuery.EnumerableQuerySolver.UriLink">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.EnumerableQuery.EnumerableQuerySolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.EnumerableQuery.EnumerableQuerySolver.SolveCore(System.String)">
            <summary>
            The core method to solve puzzles.
            </summary>
            <param name="puzzle">Indicates the puzzles.</param>
            <returns>A list of puzzles found.</returns>
        </member>
        <member name="T:Sudoku.Solving.GridSolvingExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/> for solving.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="F:Sudoku.Solving.GridSolvingExtensions.PuzzleSolvingSynchronizer">
            <summary>
            The internal field that can be used for making threads run in order while using <see cref="F:Sudoku.Solving.GridSolvingExtensions.Solver"/>,
            keeping the type being thread-safe.
            </summary>
            <seealso cref="F:Sudoku.Solving.GridSolvingExtensions.Solver"/>
        </member>
        <member name="F:Sudoku.Solving.GridSolvingExtensions.Solver">
            <summary>
            Indicates the backing solver.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.GridSolvingExtensions.GetIsValid(Sudoku.Concepts.Grid@)">
            <summary>
            Indicates whether the puzzle is valid (solved or a normal puzzle with a unique solution).
            </summary>
        </member>
        <member name="M:Sudoku.Solving.GridSolvingExtensions.GetUniqueness(Sudoku.Concepts.Grid@)">
            <summary>
            Checks the uniqueness of the current sudoku puzzle.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the puzzle has already been solved.</exception>
        </member>
        <member name="M:Sudoku.Solving.GridSolvingExtensions.GetSolutionGrid(Sudoku.Concepts.Grid@)">
            <summary>
            Indicates the solution of the current grid. If the puzzle has no solution or multiple solutions,
            this property will return <see cref="F:Sudoku.Concepts.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Grid.Undefined"/>
        </member>
        <member name="T:Sudoku.Solving.ISolutionEnumerableSolver">
            <summary>
            Represents a solver that can find all possible solutions with detection on every operation of new solution found.
            </summary>
        </member>
        <member name="E:Sudoku.Solving.ISolutionEnumerableSolver.SolutionFound">
            <summary>
            Provide a way to detect event to be triggered when a solution is found;
            no matter whether the puzzle has a unique solution or not (multiple solutions).
            </summary>
        </member>
        <member name="M:Sudoku.Solving.ISolutionEnumerableSolver.EnumerateSolutionsCore(Sudoku.Concepts.Grid,System.Threading.CancellationToken)">
            <summary>
            Try to perform enumeration on solutions.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="cancellationToken">The cancellation token that can cancel the current operation.</param>
        </member>
        <member name="T:Sudoku.Solving.ISolver">
            <summary>
            Represents a solver that can provide with a basic function to solve a sudoku puzzle given with a <see cref="T:Sudoku.Concepts.Grid"/> instance,
            and returns its solution grid.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.ISolver.UriLink">
            <summary>
            Indicates the URI link that links to the introduction of the algorithm.
            </summary>
            <remarks>
            This property is reserved as information that is offered to the algorithm learners.
            </remarks>
        </member>
        <member name="M:Sudoku.Solving.ISolver.Solve(Sudoku.Concepts.Grid@,Sudoku.Concepts.Grid@)">
            <summary>
            Solve the specified grid, and return the solution via argument <paramref name="result"/>
            with returning a <see cref="T:System.Boolean"/>? value indicating the solved state.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Please note that if the return value is not <see langword="true"/>,
            the value should be a discard and should not be used, because the argument
            keeps a memory-randomized value currently.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Solving.MultipleSolutionException">
            <summary>
            Represents an exception type that will be thrown if a puzzle has multiple solutions,
            which is an unexpected case in operation handling.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.MultipleSolutionException.Message">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Solving.SolverSolutionFoundEventArgs">
            <summary>
            Provides extra data for event <see cref="E:Sudoku.Solving.ISolutionEnumerableSolver.SolutionFound"/>.
            </summary>
            <param name="solution">Indicates the target solution.</param>
            <seealso cref="E:Sudoku.Solving.ISolutionEnumerableSolver.SolutionFound"/>
        </member>
        <member name="M:Sudoku.Solving.SolverSolutionFoundEventArgs.#ctor(Sudoku.Concepts.Grid)">
            <summary>
            Provides extra data for event <see cref="E:Sudoku.Solving.ISolutionEnumerableSolver.SolutionFound"/>.
            </summary>
            <param name="solution">Indicates the target solution.</param>
            <seealso cref="E:Sudoku.Solving.ISolutionEnumerableSolver.SolutionFound"/>
        </member>
        <member name="P:Sudoku.Solving.SolverSolutionFoundEventArgs.Solution">
            <summary>
            The generated property declaration for parameter <c>solution</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Solving.SolverSolutionFoundEventHandler">
            <summary>
            Provides a mechanism to declare a callback to be called when a solution is found in solving operation by a solver.
            </summary>
            <param name="sender">The sender which triggers this event.</param>
            <param name="e">The event arguments provided.</param>
        </member>
        <member name="T:Sudoku.SudokuType">
            <summary>
            Represents a type of sudoku puzzle.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.SudokuType.None">
            <summary>
            The placeholder of the enumeration field.
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.Standard">
            <summary>
            Indicates the sudoku puzzle is a standard.
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.Sukaku">
            <summary>
            Indicates the sudoku puzzle is a sukaku (pencilmark sudoku).
            </summary>
        </member>
        <member name="F:Sudoku.SudokuType.JustOneCell">
            <summary>
            Indicates the sudoku puzzle is a just-one-cell sudoku.
            </summary>
        </member>
        <member name="T:Sudoku.SymmetricType">
            <summary>
            Represents a symmetric type that can describe which one a pattern or a puzzle uses.
            </summary>
            <remarks><flags-attribute>
		<para>
			<i>
				This type is marked <see cref="T:System.FlagsAttribute" />, which means you can use
				<see langword="operator" /> | to combine multiple fields.
			</i>
		</para>
	</flags-attribute></remarks>
        </member>
        <member name="F:Sudoku.SymmetricType.None">
            <summary>
            Indicates none of symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.Central">
            <summary>
            Indicates the central symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.Diagonal">
            <summary>
            Indicates the diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.AntiDiagonal">
            <summary>
            Indicates the anti-diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.XAxis">
            <summary>
            Indicates the x-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.YAxis">
            <summary>
            Indicates the y-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.AxisBoth">
            <summary>
            Indicates both X-axis and Y-axis symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.DiagonalBoth">
            <summary>
            Indicates both diagonal and anti-diagonal symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.SymmetricType.All">
            <summary>
            Indicates all symmetry types should be satisfied.
            </summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_0.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserDigitPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserDigitPattern_1.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSimpleMultilinePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSimpleMultilinePattern_2.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridOpenSudokuPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridOpenSudokuPattern_3.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridPencilmarkPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridPencilmarkPattern_4.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSukakuSegmentPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSukakuSegmentPattern_5.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_6">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridSusserPattern_6.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_6.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_6.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_6.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridSusserPattern_6.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_6.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_6.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridSusserPattern_6.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the GridShortenedSusserPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.GridShortenedSusserPattern_7.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_8">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the EliminationPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.EliminationPattern_8.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_8.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_8.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_8.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.EliminationPattern_8.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_8.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_8.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.EliminationPattern_8.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_9.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_10.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_11.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_12.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCellGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCellGroupPattern_13.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitCandidateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitCandidateGroupPattern_14.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConclusionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConclusionGroupPattern_15.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_16">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitHousePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitHousePattern_16.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitHousePattern_16.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitIntersectionGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitIntersectionGroupPattern_17.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitMegaLineGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitMegaLineGroupPattern_18.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the UnitConjugateGroupPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.UnitConjugateGroupPattern_19.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_20">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the AuthorPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.AuthorPattern_20.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.AuthorPattern_20.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_21">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the NamePattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.NamePattern_21.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NamePattern_21.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_22">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the DescriptionPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.DescriptionPattern_22.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.DescriptionPattern_22.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_23">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the TagsPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.TagsPattern_23.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner.TryFindNextPossibleStartingPosition(System.ReadOnlySpan{System.Char})">
            <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if a possible match was found; false if no more matches are possible.</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.TagsPattern_23.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.Utilities">
            <summary>Helper methods used by generated <see cref="T:System.Text.RegularExpressions.Regex"/>-derived implementations.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout">
            <summary>Default timeout value set in <see cref="T:System.AppContext"/>, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_hasTimeout">
            <summary>Whether <see cref="F:System.Text.RegularExpressions.Generated.Utilities.s_defaultTimeout"/> is non-infinite.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfAnyDecimalDigitNumberDecimalDigitNumber(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_3BCFC31BFB1AD1127D0564F4B3C20ECED086F1C7438F92ACB58165A04BF23DD9(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*+-&lt;\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_5C1843170313CB42CA4CF4E0FCD6C277723EAACCD85464A69BFC7D367CF48212(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_65EF16F1D4CC2684453DF3C3240E17C0787C2CE3C7B9F2FA94357B7AEAC8AC3F(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [*.\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_85D9C34033677881D8993C4388EDB85FC6297ECDBC9E515FF9B602A26978DF84(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+-\d\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.IndexOfNonAsciiOrAny_CD2F1FA646F2680322897C0F819061CC86FEA149AFB0FCC253B807E2A597D6F4(System.ReadOnlySpan{System.Char})">
            <summary>Finds the next index of any character that matches a character in the set [+.[\d].</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPop(System.Int32[],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Pops 2 values from the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32)">
            <summary>Pushes 1 value onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32)">
            <summary>Pushes 2 values onto the backtracking stack.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.Utilities.StackPush(System.Int32[]@,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>Pushes 3 values onto the backtracking stack.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_asciiExceptDigits">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_800040008000400">
            <summary>Supports searching for characters in or not in "CRcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_C0004000C000400">
            <summary>Supports searching for characters in or not in "BCRbcr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FE030000040000000400">
            <summary>Supports searching for characters in or not in "123456789Rr".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFF7FFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFB700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFBB00FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()+,-/:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD300ECFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'(),./:;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_ascii_FFFFFFFFFFD700FCFFFFFFFFFFFFFFFF">
            <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*,./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_2A5C7CB5C5EA60F740A02641A8398F270EECFAE3E391275B7CA8825E54AEF43F">
            <summary>Supports searching for the string "tags:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_B93F57C81E7BC3D17E6BACB73234905ED727D8DBC6420C920732A104F34ABE4E">
            <summary>Supports searching for the string "author:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_CC0D98E295A1BFFD6A5A197296B027720BD9191B4F333F50A06E1E23E638A7BB">
            <summary>Supports searching for the string "name:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_indexOfString_F5B4B618DDAAC8F27D5E849B92B2FD846490C682FCB36D3610B6BE0C05EA79E5">
            <summary>Supports searching for the string "description:".</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.Utilities.s_nonAscii_F399137324019CEE8DA2E2200E10D0083E7A4C31A2E981061D50385C16616C8A">
            <summary>Supports searching for characters in or not in "ABCDEFGHIJKabcdefghijk".</summary>
        </member>
    </members>
</doc>

<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Core</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Concepts.CellStatus">
            <summary>
            Represents a cell status.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Undefined">
            <summary>
            Indicates the cell status is invalid.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Empty">
            <summary>
            Indicates that the cell is empty.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Modifiable">
            <summary>
            Indicates that the cell has already filled a value,
            but the value doesn't exist when the puzzle begins.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.CellStatus.Given">
            <summary>
            Indicates that the cell has already filled a value,
            and the value does exist when the puzzle begins. In
            other words, the value is a given (or a hint, clue, etc.).
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Candidates">
            <summary>
            Encapsulates a map that contains 729 positions to represent a candidate.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates.Shifting">
            <summary>
            Indicates the size of each unit.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates.Empty">
            <summary>
            <para>Indicates an empty instance (all bits are 0).</para>
            <para>
            I strongly recommend you <b>should</b> use this instance instead of the expression
            <see langword="default"/>(<see cref="T:Sudoku.Concepts.Collections.Candidates"/>).
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._0">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._1">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._2">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._3">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._4">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._5">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._6">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._7">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._8">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._9">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._10">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Candidates._11">
            <summary>
            The inner binary values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor">
            <summary>
            </summary>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Int32)">
            <summary>
            Initializes an instance with the specified candidate and its peers.
            </summary>
            <param name="candidate">The candidate.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Int32*,System.Int32)">
            <summary>
            Initializes an instance with the candidate list specified as a pointer.
            </summary>
            <param name="candidates">The pointer points to an array of elements.</param>
            <param name="length">The length of the array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="candidates"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Int32,System.Boolean)">
            <summary>
            Indicates an instance with the peer candidates of the specified candidate and a <see cref="T:System.Boolean"/>
            value indicating whether the map will process itself with <see langword="true"/> value.
            </summary>
            <param name="candidate">The candidate.</param>
            <param name="setItself">
            Indicates whether the map will process itself with <see langword="true"/> value.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Int32[])">
            <summary>
            Initializes an instance with the specified candidates.
            </summary>
            <param name="candidates">The candidates.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Int64[])">
            <summary>
            Initializes an instance with the binary array.
            </summary>
            <param name="binary">The array.</param>
            <exception cref="T:System.ArgumentException">Throws when the length is invalid.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Int64*,System.Int32)">
            <summary>
            Initializes an instance with the pointer to the binary array and the length.
            </summary>
            <param name="binary">The pointer to the binary array.</param>
            <param name="length">The length.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="binary"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentException">Throws when the length is invalid.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Initializes an instance with the specified <see cref="T:Sudoku.Concepts.Collections.Cells"/> and the number
            representing.
            </summary>
            <param name="map">The map.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.ReadOnlySpan{System.Int32}@)">
            <summary>
            Initializes an instance with the specified candidates.
            </summary>
            <param name="candidates">The candidates.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Initializes an instance with the specified candidates.
            </summary>
            <param name="candidates">The candidates.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Copies the values into the collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Candidates.Count">
            <summary>
            Indicates the number of the values stored in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Candidates.System#IDefaultable{Sudoku#Concepts#Collections#Candidates}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Candidates.System#IDefaultable{Sudoku#Concepts#Collections#Candidates}#Default">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Candidates.Offsets">
            <summary>
            Indicates all indices of set bits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Candidates.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.CopyTo(System.Int32*,System.Int32)">
            <summary>
            Copies the current instance to the target array specified as an <see cref="T:System.Int32"/>*.
            </summary>
            <param name="arr">The pointer that points to an array of type <see cref="T:System.Int32"/>.</param>
            <param name="length">The length of that array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="arr"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Throws when the capacity isn't enough to store all values.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.CopyTo(System.Span{System.Int32}@)">
            <summary>
            Copies the current instance to the target <see cref="T:System.Span`1"/> instance.
            </summary>
            <param name="span">
            The target <see cref="T:System.Span`1"/> instance.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="offset">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="offset"/> is out of range.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Equals(Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Collections.Candidates"/> instance holds the same
            bits as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.ToArray">
            <summary>
            Get all offsets whose bits are set <see langword="true"/>.
            </summary>
            <returns>An array of offsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.GetSubviewMask(System.Int32,System.Int32)">
            <summary>
            Get the subview mask of this map.
            </summary>
            <param name="region">The region.</param>
            <param name="digit">The digit.</param>
            <returns>The mask.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Reduce(System.Int32)">
            <summary>
            Get the final <see cref="T:Sudoku.Concepts.Collections.Cells"/> to get all cells that the corresponding indices
            are set <see langword="true"/>.
            </summary>
            <param name="digit">The digit.</param>
            <returns>The map of all cells chosen.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.ToSpan">
            <summary>
            Converts the current instance to a <see cref="T:System.Span`1"/> of type <see cref="T:System.Int32"/>.
            </summary>
            <returns>The <see cref="T:System.Span`1"/> of <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.ToReadOnlySpan">
            <summary>
            Converts the current instance to a <see cref="T:System.ReadOnlySpan`1"/> of type <see cref="T:System.Int32"/>.
            </summary>
            <returns>The <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Int32"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Add(System.Int32)">
            <summary>
            Set the specified offset as <see langword="true"/> or <see langword="false"/> value.
            </summary>
            <param name="offset">
            The offset. This value can be positive and negative. If 
            negative, the offset will be assigned <see langword="false"/>
            into the corresponding bit position of its absolute value.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.AddAnyway(System.Int32)">
            <summary>
            Set the specified offset as <see langword="true"/> value.
            </summary>
            <param name="offset">The offset.</param>
            <remarks>
            Different with <see cref="M:Sudoku.Concepts.Collections.Candidates.Add(System.Int32)"/>, the method will process negative values,
            but this won't.
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Collections.Candidates.Add(System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Remove(System.Int32)">
            <summary>
            Set the specified offset as <see langword="false"/> value.
            </summary>
            <param name="offset">The offset.</param>
            <remarks>
            Different with <see cref="M:Sudoku.Concepts.Collections.Candidates.Add(System.Int32)"/>, this method <b>can't</b> receive the negative value as the parameter.
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Collections.Candidates.Add(System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.AddRange(System.ReadOnlySpan{System.Int32}@)">
            <summary>
            Set the specified offsets as <see langword="true"/> value.
            </summary>
            <param name="offsets">The offsets to add.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.AddRange(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.Collections.Candidates.AddRange(System.ReadOnlySpan{System.Int32}@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Clear">
            <summary>
            Clear all bits.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IEquatable{Sudoku#Concepts#Collections#Candidates}#Equals(Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.InternalAdd(System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.Parse(System.String,Sudoku.Concepts.Parsing.CandidatesParsingOptions)">
            <summary>
            Parse a <see cref="T:System.String"/> and convert to the <see cref="T:Sudoku.Concepts.Collections.Candidates"/> instance.
            </summary>
            <param name="str">The string text.</param>
            <param name="options">The options to parse.</param>
            <returns>The result instance.</returns>
            <exception cref="T:System.ArgumentException">Throws when <paramref name="options"/> is invalid.</exception>
            <exception cref="T:System.FormatException">Throws when the specified text is invalid to parse.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.TryParse(System.String,Sudoku.Concepts.Collections.Candidates@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_LogicalNot(Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Gets the peer intersection of the current instance.
            </summary>
            <param name="offsets">The offsets.</param>
            <returns>The result list that is the peer intersection of the current instance.</returns>
            <remarks>
            A <b>Peer Intersection</b> is a set of candidates that all candidates
            from the base collection can be seen.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_OnesComplement(Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Reverse status for all offsets, which means all <see langword="true"/> bits
            will be set <see langword="false"/>, and all <see langword="false"/> bits
            will be set <see langword="true"/>.
            </summary>
            <param name="offsets">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_GreaterThan(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            The syntactic sugar for <c>(<paramref name="left"/> - <paramref name="right"/>).Count != 0</c>.
            </summary>
            <param name="left">The subtrahend.</param>
            <param name="right">The subtractor.</param>
            <returns>The <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_LessThan(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            The syntactic sugar for <c>(<paramref name="left"/> - <paramref name="right"/>).Count == 0</c>.
            </summary>
            <param name="left">The subtrahend.</param>
            <param name="right">The subtractor.</param>
            <returns>The <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_BitwiseAnd(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Get the elements that both <paramref name="left"/> and <paramref name="right"/> contain.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_BitwiseOr(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Combine the elements from <paramref name="left"/> and <paramref name="right"/>,
            and return the merged result.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_ExclusiveOr(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Get the elements that either <paramref name="left"/> or <paramref name="right"/> contains.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Subtraction(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Get a <see cref="T:Sudoku.Concepts.Collections.Candidates"/> that contains all <paramref name="left"/> instance
            but not in <paramref name="right"/> instance.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Subtraction(Sudoku.Concepts.Collections.Candidates@,System.Int32)">
            <summary>
            Removes the specified <paramref name="offset"/> from the <paramref name="collection"/>,
            and returns the removed result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="offset"/> is out of range.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Addition(Sudoku.Concepts.Collections.Candidates@,System.Int32)">
            <summary>
            Adds the specified <paramref name="offset"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="offset"/> is out of range.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Modulus(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            <para>Expands the operator to <c><![CDATA[!(a & b) & b]]></c>.</para>
            <para>The operator is used for searching for and checking eliminations.</para>
            </summary>
            <param name="base">The base map.</param>
            <param name="template">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Division(Sudoku.Concepts.Collections.Candidates@,System.Int32)">
            <summary>
            Simplified calls <see cref="M:Sudoku.Concepts.Collections.Candidates.Reduce(System.Int32)"/>.
            </summary>
            <param name="candidates">The candidates.</param>
            <param name="digit">The digit.</param>
            <returns>The cells.</returns>
            <seealso cref="M:Sudoku.Concepts.Collections.Candidates.Reduce(System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Equality(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Determine whether the two <see cref="T:Sudoku.Concepts.Collections.Candidates"/> instance hold same bits.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Inequality(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Determine whether the two <see cref="T:Sudoku.Concepts.Collections.Candidates"/> instance don't hold same bits.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IEqualityOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_Equality(Sudoku.Concepts.Collections.Candidates,Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IEqualityOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_Inequality(Sudoku.Concepts.Collections.Candidates,Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IAdditionOperators{Sudoku#Concepts#Collections#Candidates,System#Int32,Sudoku#Concepts#Collections#Candidates}#op_Addition(Sudoku.Concepts.Collections.Candidates,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#ISubtractionOperators{Sudoku#Concepts#Collections#Candidates,System#Int32,Sudoku#Concepts#Collections#Candidates}#op_Subtraction(Sudoku.Concepts.Collections.Candidates,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#ISubtractionOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_Subtraction(Sudoku.Concepts.Collections.Candidates,Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IDivisionOperators{Sudoku#Concepts#Collections#Candidates,System#Int32,Sudoku#Concepts#Collections#Cells}#op_Division(Sudoku.Concepts.Collections.Candidates,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IModulusOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_Modulus(Sudoku.Concepts.Collections.Candidates,Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IBitwiseOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_OnesComplement(Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IBitwiseOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_BitwiseAnd(Sudoku.Concepts.Collections.Candidates,Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IBitwiseOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_BitwiseOr(Sudoku.Concepts.Collections.Candidates,Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.System#IBitwiseOperators{Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates,Sudoku#Concepts#Collections#Candidates}#op_ExclusiveOr(Sudoku.Concepts.Collections.Candidates,Sudoku.Concepts.Collections.Candidates)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Implicit(System.Int32[])~Sudoku.Concepts.Collections.Candidates">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/>[] to <see cref="T:Sudoku.Concepts.Collections.Candidates"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Implicit(System.Span{System.Int32}@)~Sudoku.Concepts.Collections.Candidates">
            <summary>
            Implicit cast from <see cref="T:System.Span`1"/> to <see cref="T:Sudoku.Concepts.Collections.Candidates"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Implicit(System.ReadOnlySpan{System.Int32}@)~Sudoku.Concepts.Collections.Candidates">
            <summary>
            Implicit cast from <see cref="T:System.ReadOnlySpan`1"/> to <see cref="T:Sudoku.Concepts.Collections.Candidates"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Explicit(Sudoku.Concepts.Collections.Candidates@)~System.Int32[]">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Concepts.Collections.Candidates"/> to <see cref="T:System.Int32"/>[].
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Explicit(Sudoku.Concepts.Collections.Candidates@)~System.Span{System.Int32}">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Concepts.Collections.Candidates"/> to <see cref="T:System.Span`1"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Candidates.op_Explicit(Sudoku.Concepts.Collections.Candidates@)~System.ReadOnlySpan{System.Int32}">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Concepts.Collections.Candidates"/> to <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Cells">
            <summary>
            Encapsulates a binary series of cell status table.
            </summary>
            <remarks>
            The instance stores two <see cref="T:System.Int64"/> values, consisting of 81 bits,
            where <see langword="true"/> bit (1) is for the cell having that digit,
            and the <see langword="false"/> bit (0) is for the cell not containing
            the digit.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Cells.Shifting">
            <summary>
            The value used for shifting.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Cells.Empty">
            <summary>
            <para>Indicates an empty instance (all bits are 0).</para>
            <para>
            I strongly recommend you <b>should</b> use this instance instead of the expression
            <see langword="default"/>(<see cref="T:Sudoku.Concepts.Collections.Cells"/>).
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Cells._high">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.Collections.Cells._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.Collections.Cells._low"/> represents the lower 41 bits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Cells._low">
            <summary>
            Indicates the internal two <see cref="T:System.Int64"/> values,
            which represents 81 bits. <see cref="F:Sudoku.Concepts.Collections.Cells._high"/> represent the higher
            40 bits and <see cref="F:Sudoku.Concepts.Collections.Cells._low"/> represents the lower 41 bits.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor">
            <summary>
            </summary>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
            <seealso cref="F:Sudoku.Concepts.Collections.Cells.Empty"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Int32)">
            <summary>
            Initializes an instance with the specified cell offset
            (Sets itself and all peers).
            </summary>
            <param name="cell">The cell offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Int32*,System.Int32)">
            <summary>
            Initializes an instance with the candidate list specified as a pointer.
            </summary>
            <param name="cells">The pointer points to an array of elements.</param>
            <param name="length">The length of the array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="cells"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Int32[])">
            <summary>
            Same behavior of the constructor as <see cref="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Collections.Generic.IEnumerable{System.Int32})"/>:
            Initializes an instance with the specified array of cells.
            </summary>
            <param name="cells">All cells.</param>
            <remarks>
            This constructor is defined after another constructor with
            <see cref="T:System.ReadOnlySpan`1"/> had defined. Although this constructor
            doesn't initialize something (use the other one instead),
            while initializing with the type <see cref="T:System.Int32"/>[], the compiler
            gives me an error without this constructor (ambiguity of two
            constructors). However, unfortunately, <see cref="T:System.ReadOnlySpan`1"/>
            doesn't implemented the interface <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Collections.Generic.IEnumerable{System.Int32})"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Index)">
            <summary>
            Initializes an instance with the cell offset specified as an <see cref="T:System.Index"/>
            (Sets itself and all peers).
            </summary>
            <param name="cellIndex">The cell offset specified as an <see cref="T:System.Index"/>.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Span{System.Int32})">
            <summary>
            Initializes an instance with a series of cell offsets.
            </summary>
            <param name="cells">cell offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.ReadOnlySpan{System.Int32})">
            <summary>
            Initializes an instance with a series of cell offsets.
            </summary>
            <param name="cells">cell offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Initializes an instance with a series of cell offsets.
            </summary>
            <param name="cells">cell offsets.</param>
            <remarks>
            Note that all offsets will be set <see langword="true"/>, but their own peers
            won't be set <see langword="true"/>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes an instance with two binary values.
            </summary>
            <param name="high">Higher 40 bits.</param>
            <param name="low">Lower 41 bits.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes an instance with three binary values.
            </summary>
            <param name="high">Higher 27 bits.</param>
            <param name="mid">Medium 27 bits.</param>
            <param name="low">Lower 27 bits.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Int32@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Collections.Cells" /> instance using the specified reference for the array of cells.
            </summary>
            <param name="cell">
            <para>The reference to the array of cells.</para>
            <para>
            <target name="in-parameter">
				<i>
					Please note that the parameter is an <see langword="in" /> parameter, which has the same meaning
					for <see langword="ref readonly" /> returns or locals. You can treat it as the first element
					in an array of elements. Different with <see langword="ref" /> parameter, <see langword="in" />
					modifier has the same semantic as <see langword="ref readonly var" />
					instead of <see langword="ref var" />.
				</i>
			</target>
            </para>
            </param>
            <param name="length">The length of the array.</param>
            <remarks>
            <target name="method">
				<i>
					C# 7.3 introduces a new keyword <see langword="in" /> as the parameter modifier to make the parameter
					pass by reference and be read-only. Therefore, this keyword contains 2 usages:
					<list type="number">
						<item>
							Ensure the argument to <b>be read-only</b> and cannot be modified. Otherwise,
							a new copied instance will be created to prevent any modifications on the original variable.
						</item>
						<item>
							Ensure the argument to <b>pass by reference</b> in order to treat it as the pointer or array of elements
							of this type, and treat the argument as the first element of the whole element series.
						</item>
					</list>
					From the above meaning on this keyword, we can conclude that
					we should regard it as <see langword="ref readonly" /> parameters,
					but C# requires us using the keyword <see langword="in" /> as the modifier
					on a parameter rather than <see langword="ref readonly" />.
				</i>
			</target>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes an instance with the specified cell offset.
            This will set all bits of all peers of this cell. Another
            <see cref="T:System.Boolean"/> value indicates whether this initialization
            will set the bit of itself.
            </summary>
            <param name="cell">The cell offset.</param>
            <param name="setItself">
            A <see cref="T:System.Boolean"/> value indicating whether this initialization
            will set the bit of itself.
            </param>
            <remarks>
            If you want to use this constructor, please use <see cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.PeerMaps"/> instead.
            </remarks>
            <seealso cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.PeerMaps"/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.InOneRegion">
            <summary>
            Same as <see cref="M:Sudoku.Concepts.Collections.Cells.AllSetsAreInOneRegion(System.Int32@)"/>, but only contains
            the <see cref="T:System.Boolean"/> result.
            </summary>
            <seealso cref="M:Sudoku.Concepts.Collections.Cells.AllSetsAreInOneRegion(System.Int32@)"/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.BlockMask">
            <summary>
            Indicates the mask of block that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>{ 0, 1, 27, 28 }</c>, all spanned blocks are 0 and 3, so the return
            mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.RowMask">
            <summary>
            Indicates the mask of row that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>{ 0, 1, 27, 28 }</c>, all spanned rows are 0 and 3, so the return
            mask is <c>0b000001001</c> (i.e. 9).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.ColumnMask">
            <summary>
            Indicates the mask of column that all cells in this collection spanned.
            </summary>
            <remarks>
            For example, if the cells are <c>{ 0, 1, 27, 28 }</c>, all spanned columns are 0 and 1, so the return
            mask is <c>0b000000011</c> (i.e. 3).
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.CoveredLine">
            <summary>
            Indicates the covered line.
            </summary>
            <remarks>
            When the covered region can't be found, it'll return 32. For more information,
            please visit <see href="https://source.dot.net/#System.Private.CoreLib/BitOperations.cs,515">this link</see>.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.Count">
            <summary>
            Indicates the number of the values stored in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.CoveredRegions">
            <summary>
            Indicates all regions covered. This property is used to check all regions that all cells
            of this instance covered. For example, if the cells are <c>{ 0, 1 }</c>, the property
            <see cref="P:Sudoku.Concepts.Collections.Cells.CoveredRegions"/> will return the region 0 (block 1) and region 9 (row 1);
            however, if cells spanned two regions or more (e.g. cells <c>{ 0, 1, 27 }</c>),
            this property won't contain any regions.
            </summary>
            <remarks>
            The return value will be an <see cref="T:System.Int32"/> value indicating each regions.
            Bits set 1 are covered regions.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.Regions">
            <summary>
            All regions that the map spanned. This property is used to check all regions that all cells of
            this instance spanned. For example, if the cells are <c>{ 0, 1 }</c>, the property
            <see cref="P:Sudoku.Concepts.Collections.Cells.Regions"/> will return the region 0 (block 1), region 9 (row 1), region 18 (column 1)
            and the region 19 (column 2).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.System#IDefaultable{Sudoku#Concepts#Collections#Cells}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.System#IDefaultable{Sudoku#Concepts#Collections#Cells}#Default">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.Offsets">
            <summary>
            Indicates the cell offsets in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Cells.Item(System.Int32)">
            <summary>
            Get the offset at the specified position index.
            </summary>
            <param name="index">The index.</param>
            <returns>
            The offset at the specified position index. If the value is invalid, the return value will be <c>-1</c>.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.CopyTo(System.Int32*,System.Int32)">
            <summary>
            Copies the current instance to the target array specified as an <see cref="T:System.Int32"/>*.
            </summary>
            <param name="arr">The pointer that points to an array of type <see cref="T:System.Int32"/>.</param>
            <param name="length">The length of that array.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="arr"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Throws when the capacity isn't enough to store all values.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.CopyTo(System.Span{System.Int32}@)">
            <summary>
            Copies the current instance to the target <see cref="T:System.Span`1"/> instance.
            </summary>
            <param name="span">
            The target <see cref="T:System.Span`1"/> instance.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.AllSetsAreInOneRegion(System.Int32@)">
            <summary>
            Indicates whether all cells in this instance are in one region.
            </summary>
            <param name="region">
            The region covered. If the return value
            is false, this value will be the constant -1.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <remarks>
            If you don't want to use the <see langword="out"/> parameter value, please
            use the property <see cref="P:Sudoku.Concepts.Collections.Cells.InOneRegion"/> to improve the performance.
            </remarks>
            <seealso cref="P:Sudoku.Concepts.Collections.Cells.InOneRegion"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Contains(System.Int32)">
            <summary>
            Determine whether the map contains the specified offset.
            </summary>
            <param name="offset">The offset.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Equals(Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Determine whether the two elements are equal.
            </summary>
            <param name="other">The object to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.GetSubviewMask(System.Int32)">
            <summary>
            Get the subview mask of this map.
            </summary>
            <param name="region">The region.</param>
            <returns>The mask.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.ToArray">
            <summary>
            Get all offsets whose bits are set <see langword="true"/>.
            </summary>
            <returns>An array of offsets.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.ToVector">
            <summary>
            Gets the <see cref="T:System.Runtime.Intrinsics.Vector128`1"/> instance via the basic data.
            </summary>
            <returns>The <see cref="T:System.Runtime.Intrinsics.Vector128`1"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Slice(System.Int32,System.Int32)">
            <summary>
            Gets the <see cref="T:Sudoku.Concepts.Collections.Cells"/> instance that starts with the specified index.
            </summary>
            <param name="start">The start index.</param>
            <param name="count">The desired number of offsets.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Collections.Cells"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.CreateMask(System.Int32,System.Int32)">
            <summary>
            Being called by <see cref="P:Sudoku.Concepts.Collections.Cells.RowMask"/>, <see cref="P:Sudoku.Concepts.Collections.Cells.ColumnMask"/> and <see cref="P:Sudoku.Concepts.Collections.Cells.BlockMask"/>.
            </summary>
            <param name="start">The start index.</param>
            <param name="end">The end index.</param>
            <returns>The region mask.</returns>
            <seealso cref="P:Sudoku.Concepts.Collections.Cells.RowMask"/>
            <seealso cref="P:Sudoku.Concepts.Collections.Cells.ColumnMask"/>
            <seealso cref="P:Sudoku.Concepts.Collections.Cells.BlockMask"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Add(System.Int32)">
            <summary>
            Set the specified offset as <see langword="true"/> value.
            </summary>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Add(System.String)">
            <summary>
            Set the specified cell as <see langword="true"/> value.
            </summary>
            <param name="offset">The cell to add, represented as a <see cref="T:System.String"/> value.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.AddRange(System.ReadOnlySpan{System.Int32}@)">
            <summary>
            Set the specified offsets as <see langword="true"/> value.
            </summary>
            <param name="offsets">The offsets to add.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.AddRange(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc cref="M:Sudoku.Concepts.Collections.Cells.AddRange(System.ReadOnlySpan{System.Int32}@)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Remove(System.Int32)">
            <summary>
            Set the specified offset as <see langword="false"/> value.
            </summary>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Clear">
            <summary>
            Clear all bits.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IEquatable{Sudoku#Concepts#Collections#Cells}#Equals(Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#Collections#Generic#IEnumerable{System#Int32}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.InternalAdd(System.Int32,System.Boolean)">
            <summary>
            The internal operation for adding an offset into the current collection.
            </summary>
            <param name="offset">The cell to add into.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.TryParse(System.String,Sudoku.Concepts.Collections.Cells@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_LogicalNot(Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Gets the peer intersection of the current instance.
            </summary>
            <param name="offsets">The offsets.</param>
            <returns>The result list that is the peer intersection of the current instance.</returns>
            <remarks>
            A <b>Peer Intersection</b> is a set of cells that all cells from the base collection can be seen.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_OnesComplement(Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Reverse status for all offsets, which means all <see langword="true"/> bits
            will be set <see langword="false"/>, and all <see langword="false"/> bits
            will be set <see langword="true"/>.
            </summary>
            <param name="offsets">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_GreaterThan(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            The syntactic sugar for <c>(<paramref name="left"/> - <paramref name="right"/>).Count != 0</c>.
            </summary>
            <param name="left">The subtrahend.</param>
            <param name="right">The subtractor.</param>
            <returns>The <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_LessThan(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            The syntactic sugar for <c>(<paramref name="left"/> - <paramref name="right"/>).Count == 0</c>.
            </summary>
            <param name="left">The subtrahend.</param>
            <param name="right">The subtractor.</param>
            <returns>The <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Addition(Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Adds the specified <paramref name="offset"/> to the <paramref name="collection"/>,
            and returns the added result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Subtraction(Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Removes the specified <paramref name="offset"/> from the <paramref name="collection"/>,
            and returns the removed result.
            </summary>
            <param name="collection">The collection.</param>
            <param name="offset">The offset to be removed.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Subtraction(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Get a <see cref="T:Sudoku.Concepts.Collections.Cells"/> that contains all <paramref name="left"/> instance
            but not in <paramref name="right"/> instance.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_BitwiseAnd(Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Gets the subsets of the current collection via the specified size
            indicating the number of elements of the each subset.
            </summary>
            <param name="cell">Indicates the base template cells.</param>
            <param name="subsetSize">The size to get.</param>
            <returns>
            All possible subsets. If:
            <list type="table">
            <listheader>
            <term>Condition</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><c><paramref name="subsetSize"/> &gt; <paramref name="cell"/>.Count</c></term>
            <description>Will return an empty array</description>
            </item>
            <item>
            <term><c><paramref name="subsetSize"/> == <paramref name="cell"/>.Count</c></term>
            <description>
            Will return an array that contains only one element, same as the argument <paramref name="cell"/>.
            </description>
            </item>
            <item>
            <term>Other cases</term>
            <description>The valid combinations.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_BitwiseAnd(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Get the elements that both <paramref name="left"/> and <paramref name="right"/> contain.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_BitwiseOr(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Combine the elements from <paramref name="left"/> and <paramref name="right"/>,
            and return the merged result.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_ExclusiveOr(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Get the elements that either <paramref name="left"/> or <paramref name="right"/> contains.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Modulus(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            <para>Expands the operator to <c><![CDATA[!(a & b) & b]]></c>.</para>
            <para>The operator is used for searching for and checking eliminations.</para>
            </summary>
            <param name="base">The base map.</param>
            <param name="template">The template map that the base map to check and cover.</param>
            <returns>The result map.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Multiply(Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Expands via the specified digit.
            </summary>
            <param name="base">The base map.</param>
            <param name="digit">The digit.</param>
            <returns>The result instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Division(Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Get the subview mask of this map.
            </summary>
            <param name="map">The map.</param>
            <param name="region">The region.</param>
            <returns>The mask.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Equality(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Indicates whether the two <see cref="T:Sudoku.Concepts.Collections.Cells"/> collection hold a same set of cells.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Inequality(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Indicates whether the two <see cref="T:Sudoku.Concepts.Collections.Cells"/> collection don't hold a same set of cells.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IAdditionOperators{Sudoku#Concepts#Collections#Cells,System#Int32,Sudoku#Concepts#Collections#Cells}#op_Addition(Sudoku.Concepts.Collections.Cells,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#ISubtractionOperators{Sudoku#Concepts#Collections#Cells,System#Int32,Sudoku#Concepts#Collections#Cells}#op_Subtraction(Sudoku.Concepts.Collections.Cells,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#ISubtractionOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_Subtraction(Sudoku.Concepts.Collections.Cells,Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IDivisionOperators{Sudoku#Concepts#Collections#Cells,System#Int32,System#Int16}#op_Division(Sudoku.Concepts.Collections.Cells,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IModulusOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_Modulus(Sudoku.Concepts.Collections.Cells,Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IBitwiseOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_OnesComplement(Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IBitwiseOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_BitwiseAnd(Sudoku.Concepts.Collections.Cells,Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IBitwiseOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_BitwiseOr(Sudoku.Concepts.Collections.Cells,Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IBitwiseOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_ExclusiveOr(Sudoku.Concepts.Collections.Cells,Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IEqualityOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_Equality(Sudoku.Concepts.Collections.Cells,Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.System#IEqualityOperators{Sudoku#Concepts#Collections#Cells,Sudoku#Concepts#Collections#Cells}#op_Inequality(Sudoku.Concepts.Collections.Cells,Sudoku.Concepts.Collections.Cells)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Implicit(System.Int32[])~Sudoku.Concepts.Collections.Cells">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/>[] to <see cref="T:Sudoku.Concepts.Collections.Cells"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Implicit(System.Span{System.Int32}@)~Sudoku.Concepts.Collections.Cells">
            <summary>
            Implicit cast from <see cref="T:System.Span`1"/> to <see cref="T:Sudoku.Concepts.Collections.Cells"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Implicit(System.ReadOnlySpan{System.Int32}@)~Sudoku.Concepts.Collections.Cells">
            <summary>
            Implicit cast from <see cref="T:System.ReadOnlySpan`1"/> to <see cref="T:Sudoku.Concepts.Collections.Cells"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Explicit(Sudoku.Concepts.Collections.Cells@)~System.Int32[]">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Concepts.Collections.Cells"/> to <see cref="T:System.Int32"/>[].
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Explicit(Sudoku.Concepts.Collections.Cells@)~System.Span{System.Int32}">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Concepts.Collections.Cells"/> to <see cref="T:System.Span`1"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Cells.op_Explicit(Sudoku.Concepts.Collections.Cells@)~System.ReadOnlySpan{System.Int32}">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Concepts.Collections.Cells"/> to <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <param name="offsets">The offsets.</param>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Grid">
            <summary>
            Represents a sudoku grid that uses the mask list to construct the data structure.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator">
            <summary>
            Defines the default enumerator that iterates the <see cref="T:Sudoku.Concepts.Collections.Grid"/>
            through the candidates in the current <see cref="T:Sudoku.Concepts.Collections.Grid"/> instance.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator._start">
            <summary>
            The pointer to the start value.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator._currentPointer">
            <summary>
            The current pointer.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator._currentMask">
            <summary>
            Indicates the current mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator._currentIndex">
            <summary>
            The current index.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.#ctor(System.Int16*)">
            <summary>
            Initializes an instance with the specified pointer to an array to iterate.
            </summary>
            <param name="arr">The pointer to an array.</param>
            <remarks>
            Note here we should point at the one-unit-lengthed memory before the array start.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>If the enumerator was successfully advanced to the next element.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>If the enumerator has passed the end of the collection.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element
            in the collection.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.CandidateCollectionEnumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.DefaultMask">
            <summary>
            Indicates the default mask of a cell (an empty cell, with all 9 candidates left).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.MaxCandidatesMask">
            <summary>
            Indicates the maximum candidate mask that used.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.EmptyMask">
            <summary>
            Indicates the empty mask, modifiable mask and given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.ModifiableMask">
            <summary>
            Indicates the modifiable mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.GivenMask">
            <summary>
            Indicates the given mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.ExtendedSusserEliminationsRegexPattern">
            <summary>
            Indicates the eliminations in the extended susser format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.EmptyString">
            <summary>
            Indicates the empty grid string.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.ValueChanged">
            <summary>
            Indicates the event triggered when the value is changed.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.RefreshingCandidates">
            <summary>
            Indicates the event triggered when should re-compute candidates.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.Undefined">
            <summary>
            Indicates the default grid that all values are initialized 0.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.Empty">
            <summary>
            The empty grid that is valid during implementation or running the program
            (all values are <see cref="F:Sudoku.Concepts.Collections.Grid.DefaultMask"/>, i.e. empty cells).
            </summary>
            <remarks>
            This field is initialized by the static constructor of this structure.
            </remarks>
            <seealso cref="F:Sudoku.Concepts.Collections.Grid.DefaultMask"/>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.Solver">
            <summary>
            Indicates the solver that uses the bitwise algorithm to solve a puzzle as fast as possible.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid._values">
            <summary>
            Indicates the inner array that stores the masks of the sudoku grid, which
            stores the in-time sudoku grid inner information.
            </summary>
            <remarks>
            The field uses the mask table of length 81 to indicate the status and all possible candidates
            holding for each cell. Each mask uses a <see cref="T:System.Int16"/> value, but only uses 11 of 16 bits.
            <code>
            16       8       0
             |-------|-------|
             |   |--|--------|
            16  12  9        0
            </code>
            Here the first-nine bits indicate whether the digit 1-9 is possible candidate in the current cell respectively,
            and the higher 3 bits indicate the cell status. The possible cell status are:
            <list type="table">
            <listheader>
            <term>Status name</term>
            <description>Description</description>
            </listheader>
            <item>
            <term>Empty cell (i.e. <see cref="F:Sudoku.Concepts.CellStatus.Empty"/>)</term>
            <description>The cell is currently empty, and wait for being filled.</description>
            </item>
            <item>
            <term>Modifiable cell (i.e. <see cref="F:Sudoku.Concepts.CellStatus.Modifiable"/>)</term>
            <description>
            The cell is filled by a digit, but the digit isn't the given by the initial grid.
            </description>
            </item>
            <item>
            <term>Given cell (i.e. <see cref="F:Sudoku.Concepts.CellStatus.Given"/>)</term>
            <description>
            The cell is filled by a digit, which is given by the initial grid and can't be modified.
            </description>
            </item>
            </list>
            </remarks>
            <seealso cref="T:Sudoku.Concepts.CellStatus"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.#ctor">
            <summary>
            </summary>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.#ctor(System.Int32[],Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates an instance using grid values.
            </summary>
            <param name="gridValues">The array of grid values.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.#ctor(System.Int32*,Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Collections.Grid"/> instance via the array of cell digits of type <see cref="T:System.Int32"/>*.
            </summary>
            <param name="pGridValues">The pointer parameter indicating the array of cell digits.</param>
            <param name="creatingOption">The grid creating option.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="pGridValues"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.#ctor(System.ReadOnlySpan{System.Int32},Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Collections.Grid"/> instance via the array of cell digits
            of type <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <param name="gridValues">The list of cell digits.</param>
            <param name="creatingOption">The grid creating option.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.#ctor(System.Int16[])">
             <summary>
             Initializes an instance with the specified mask array.
             </summary>
             <param name="masks">The masks.</param>
             <remarks>
             In order to decrease the memory allocation, you can use the system buffer,
             whose corresponding code will be implemented like this:
             <code><![CDATA[
             // Rents the buffer memory.
             short[] buffer = ArrayPool<short>.Shared.Rent(81);
             
             // Initialize the memory in order to be used later.
             fixed (short* pBuffer = buffer, pGrid = this)
             {
                 Unsafe.CopyBlock(pBuffer, pGrid, sizeof(short) * 81);
             }
            
             // Gets the result sudoku grid instance.
             try
             {
                 var targetGrid = new Grid(buffer); // Now the result grid is created here.
            
                 // Do something to use 'targetGrid'.
             }
             finally
             {
                 // Returns the buffer memory to system.
                 ArrayPool<short>.Shared.Return(buffer, false);
             }
             ]]></code>
             In this way we can get the sudoku grid without any allocations.
             </remarks>
             <exception cref="T:System.ArgumentException">Throws when <see cref="P:System.Array.Length"/> is not 81.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.#ctor(System.Int32@,Sudoku.Concepts.GridCreatingOption)">
            <summary>
            Creates a <see cref="T:Sudoku.Concepts.Collections.Grid" /> instance via the pointer of the first element of the cell digit,
            and the creating option.
            </summary>
            <param name="firstElement">
            <para>The reference of the first element.</para>
            <para>
            <target name="in-parameter">
				<i>
					Please note that the parameter is an <see langword="in" /> parameter, which has the same meaning
					for <see langword="ref readonly" /> returns or locals. You can treat it as the first element
					in an array of elements. Different with <see langword="ref" /> parameter, <see langword="in" />
					modifier has the same semantic as <see langword="ref readonly var" />
					instead of <see langword="ref var" />.
				</i>
			</target>
            </para>
            </param>
            <param name="creatingOption">The creating option.</param>
            <remarks>
            <target name="method">
				<i>
					C# 7.3 introduces a new keyword <see langword="in" /> as the parameter modifier to make the parameter
					pass by reference and be read-only. Therefore, this keyword contains 2 usages:
					<list type="number">
						<item>
							Ensure the argument to <b>be read-only</b> and cannot be modified. Otherwise,
							a new copied instance will be created to prevent any modifications on the original variable.
						</item>
						<item>
							Ensure the argument to <b>pass by reference</b> in order to treat it as the pointer or array of elements
							of this type, and treat the argument as the first element of the whole element series.
						</item>
					</list>
					From the above meaning on this keyword, we can conclude that
					we should regard it as <see langword="ref readonly" /> parameters,
					but C# requires us using the keyword <see langword="in" /> as the modifier
					on a parameter rather than <see langword="ref readonly" />.
				</i>
			</target>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.IsSolved">
            <summary>
            Indicates the grid has already solved. If the value is <see langword="true"/>,
            the grid is solved; otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.IsValid">
            <summary>
            Indicates whether the puzzle is valid, which means the puzzle contains a unique solution.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.IsUndefined">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>, which means the grid
            holds totally same value with <see cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.IsEmpty">
            <summary>
            Indicates whether the grid is <see cref="F:Sudoku.Concepts.Collections.Grid.Empty"/>, which means the grid
            holds totally same value with <see cref="F:Sudoku.Concepts.Collections.Grid.Empty"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Collections.Grid.Empty"/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.CandidatesCount">
            <summary>
            Indicates the number of total candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.GivensCount">
            <summary>
            Indicates the total number of given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.ModifiablesCount">
            <summary>
            Indicates the total number of modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.EmptiesCount">
            <summary>
            Indicates the total number of empty cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.NullRegions">
            <summary>
            <para>Indicates which regions are null regions.</para>
            <para>A <b>Null Region</b> is a region whose hold cells are all empty cells.</para>
            <para>
            The property returns an <see cref="T:System.Int32"/> value as a mask that contains all possible regions.
            For example, if the row 5, column 5 and block 5 (1-9) are null regions, the property will return
            the result <see cref="T:System.Int32"/> value, <c>000010000_000010000_000010000</c> as binary.
            </para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.GivenCells">
            <summary>
            Gets the cell template that only contains the given cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.ModifiableCells">
            <summary>
            Gets the cell template that only contains the modifiable cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.EmptyCells">
            <summary>
            Indicates the cells that corresponding position in this grid is empty.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.BivalueCells">
            <summary>
            Indicates the cells that corresponding position in this grid contain two candidates.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.CandidatesMap">
            <summary>
            Indicates the map of possible positions of the existence of the candidate value for each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.DigitsMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of each digit. The return value will
            be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Collections.Grid.CandidatesMap"/>, this property contains all givens, modifiables and
            empty cells only if it contains the digit in the mask.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.ValuesMap">
            <summary>
            <para>
            Indicates the map of possible positions of the existence of that value of each digit.
            The return value will be an array of 9 elements, which stands for the statuses of 9 digits.
            </para>
            <para>
            Different with <see cref="P:Sudoku.Concepts.Collections.Grid.CandidatesMap"/>, the value only contains the given or modifiable
            cells whose mask contain the set bit of that digit.
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.CandidatesMap"/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.ResetGrid">
            <summary>
            Gets the grid where all modifiable cells are empty cells (i.e. the initial one).
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.Solution">
            <summary>
            Indicates the solution of the grid. If failed to solve (for example,
            the puzzle contains multiple solutions), the property will return <see cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>.
            </summary>
            <see cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.System#IDefaultable{Sudoku#Concepts#Collections#Grid}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.System#IDefaultable{Sudoku#Concepts#Collections#Grid}#Default">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.Item(System.Int32)">
            <summary>
            Gets or sets the value in the specified cell.
            </summary>
            <param name="cell">The cell you want to get or set a value.</param>
            <value>
            <para>
            The value you want to set. The value should be between 0 and 8. If assigning -1,
            that means to re-compute all candidates.
            </para>
            <para>In addition, values set into the grid will be regarded as the modifiable values.</para>
            </value>
            <returns>
            The value that the cell filled with. The possible values are:
            <list type="table">
            <item>
            <term>-1</term>
            <description>The status of the specified cell is <see cref="F:Sudoku.Concepts.CellStatus.Empty"/>.</description>
            </item>
            <item>
            <term>0 to 8</term>
            <description>
            The actual value that the cell filled with. 0 is for the digit 1, 1 is for the digit 2, etc..
            </description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified cell keeps a wrong cell status value.
            For example, <see cref="F:Sudoku.Concepts.CellStatus.Undefined"/>.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets a candidate existence case with a <see cref="T:System.Boolean"/> value.
            </summary>
            <param name="cell">The cell offset between 0 and 80.</param>
            <param name="digit">The digit between 0 and 8.</param>
            <value>
            The case you want to set. <see langword="false"/> means that this candidate
            doesn't exist in this current sudoku grid; otherwise, <see langword="true"/>.
            </value>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Equals(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Collections.Grid"/> instance hold the same values
            as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Exists(System.Int32)">
            <summary>
            Indicates whether the current grid contains the specified candidate offset.
            </summary>
            <param name="candidate">The candidate offset.</param>
            <returns>
            The method will return a <see cref="T:System.Boolean"/>? value (contains three possible cases:
            <see langword="true"/>, <see langword="false"/> and <see langword="null"/>).
            All values corresponding to the cases are below:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The cell that the candidate specified is an empty cell <b>and</b> contains the specified digit
            that the candidate specified.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            The cell that the candidate specified is an empty cell <b>but doesn't</b> contain the specified digit
            that the candidate specified.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            The cell that the candidate specified is <b>not</b> an empty cell that the candidate specified.
            </description>
            </item>
            </list>
            </returns>
            <remarks>
            Note that the method will return a <see cref="T:System.Boolean"/>?, so you should use the code
            '<c>grid.Exists(candidate) is true</c>' or '<c>grid.Exists(candidate) == true</c>'
            to decide whether a condition is true.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Exists(System.Int32,System.Int32)">
            <summary>
            Indicates whether the current grid contains the digit in the specified cell.
            </summary>
            <param name="cell">The cell offset.</param>
            <param name="digit">The digit.</param>
            <returns>
            The method will return a <see cref="T:System.Boolean"/>? value (contains three possible cases:
            <see langword="true"/>, <see langword="false"/> and <see langword="null"/>).
            All values corresponding to the cases are below:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>
            The cell is an empty cell <b>and</b> contains the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            The cell is an empty cell <b>but doesn't</b> contain the specified digit.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The cell is <b>not</b> an empty cell.</description>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Note that the method will return a <see cref="T:System.Boolean"/>?, so you should use the code
            '<c>grid.Exists(cell, digit) is true</c>' or '<c>grid.Exists(cell, digit) == true</c>'
            to decide whether a condition is true.
            </para>
            <para>
            In addition, because the type is <see cref="T:System.Boolean"/>? rather than <see cref="T:System.Boolean"/>,
            the result case will be more precisely than the indexer <see cref="P:Sudoku.Concepts.Collections.Grid.Item(System.Int32,System.Int32)"/>,
            which is the main difference between this method and that indexer.
            </para>
            </remarks>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.Item(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.ToArray">
            <summary>
            Serializes this instance to an array, where all digit value will be stored.
            </summary>
            <returns>
            This array. All elements are between 0 to 9, where 0 means the
            cell is <see cref="F:Sudoku.Concepts.CellStatus.Empty"/> now.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetMask(System.Int32)">
            <summary>
            Get a mask at the specified cell.
            </summary>
            <param name="offset">The cell offset you want to get.</param>
            <returns>The mask.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetCandidates(System.Int32)">
            <summary>
            Get the candidate mask part of the specified cell.
            </summary>
            <param name="cell">The cell offset you want to get.</param>
            <returns>
            <para>
            The candidate mask. The return value is a 9-bit <see cref="T:System.Int16"/>
            value, where each bit will be:
            <list type="table">
            <item>
            <term><c>0</c></term>
            <description>The cell <b>doesn't contain</b> the possibility of the digit.</description>
            </item>
            <item>
            <term><c>1</c></term>
            <description>The cell <b>contains</b> the possibility of the digit.</description>
            </item>
            </list>
            </para>
            <para>
            For example, if the result mask is 266 (i.e. <c>0b<b>1</b>00_00<b>1</b>_0<b>1</b>0</c> in binary),
            the value will indicate the cell contains the digit 2, 4 and 9.
            </para>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetDigitsUnion(System.Int32[])">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetDigitsUnion(Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetDigitsUnion(Sudoku.Concepts.Collections.Cells@,System.Boolean)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <param name="withValueCells">
            Indicates whether the value cells (given or modifiable ones) will be included to be gathered.
            If <see langword="true"/>, all value cells (no matter what kind of cell) will be summed up.
            </param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetDigitsIntersection(Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Creates a mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9,
            ranged in a specified list of cells in the current sudoku grid,
            to determine which digits are not used.
            </summary>
            <param name="cells">The list of cells to gather the usages on all digits.</param>
            <returns>A mask of type <see cref="T:System.Int16"/> that represents the usages of digits 1 to 9.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetPinnableReference">
            <summary>
            Returns a reference to the element of the <see cref="T:Sudoku.Concepts.Collections.Grid"/> at index zero.
            </summary>
            <returns>A reference to the element of the <see cref="T:Sudoku.Concepts.Collections.Grid"/> at index zero.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.ToMaskString">
            <summary>
            Get all masks and print them.
            </summary>
            <returns>The result.</returns>
            <remarks>
            Please note that the method cannot be called with a correct behavior using
            <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/> to output. It seems that Visual Studio
            doesn't print correct values when indices of this grid aren't 0. In other words,
            when we call this method using <see cref="T:System.Diagnostics.DebuggerDisplayAttribute"/>, only <c>grid[0]</c>
            can be output correctly, and other values will be incorrect: they're always 0.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.ToString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetStatus(System.Int32)">
            <summary>
            Get the cell status at the specified cell.
            </summary>
            <param name="cell">The cell.</param>
            <returns>The cell status.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.EnumerateCandidates">
            <summary>
            Try to enumerate all possible candidates in the current grid.
            </summary>
            <returns>
            An enumerator that allows us using <see langword="foreach"/> statement
            to iterate all possible candidates in the current grid.
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.EnumerateMasks">
            <summary>
            Try to enumerate the mask table of the current grid.
            </summary>
            <returns>
            An enumerator that allows us using <see langword="foreach"/> statement
            to iterate all masks in the current grid. The mask list must contain 81 masks.
            </returns>
            <remarks>
            Please note that the iterator will iterate all masks by reference, which means
            you can apply <see langword="ref"/> and <see langword="ref readonly"/> modifier
            onto the iteration variable:
            <code>
            foreach (ref readonly short mask in grid)
            {
                // Do something.
            }
            </code>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Reset">
            <summary>
            Reset the sudoku grid, to set all modifiable values to empty ones.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Fix">
            <summary>
            To fix the current grid (all modifiable values will be changed to given ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Unfix">
            <summary>
            To unfix the current grid (all given values will be changed to modifiable ones).
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.SetStatus(System.Int32,Sudoku.Concepts.CellStatus)">
            <summary>
            Set the specified cell to the specified status.
            </summary>
            <param name="cell">The cell.</param>
            <param name="status">The status.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.SetMask(System.Int32,System.Int16)">
            <summary>
            Set the specified cell to the specified mask.
            </summary>
            <param name="cell">The cell.</param>
            <param name="mask">The mask to set.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.System#IEquatable{Sudoku#Concepts#Collections#Grid}#Equals(Sudoku.Concepts.Collections.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetMap()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Collections.Grid.CandidatesMap"/>, <see cref="P:Sudoku.Concepts.Collections.Grid.DigitsMap"/> and <see cref="P:Sudoku.Concepts.Collections.Grid.ValuesMap"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The map of digits.</returns>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.CandidatesMap"/>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.DigitsMap"/>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.ValuesMap"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.GetCells()">
            <summary>
            Called by properties <see cref="P:Sudoku.Concepts.Collections.Grid.EmptyCells"/> and <see cref="P:Sudoku.Concepts.Collections.Grid.BivalueCells"/>.
            </summary>
            <param name="predicate">The predicate.</param>
            <returns>The cells.</returns>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.EmptyCells"/>
            <seealso cref="P:Sudoku.Concepts.Collections.Grid.BivalueCells"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Equals(Sudoku.Concepts.Collections.Grid@,Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To determine whether two sudoku grid is totally same.
            </summary>
            <param name="left">The left one.</param>
            <param name="right">The right one.</param>
            <returns>The <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Parse(System.ReadOnlySpan{System.Char})">
            <summary>
            <para>Parses a string value and converts to this type.</para>
            <para>
            If you want to parse a PM grid, we recommend you use the method
            <see cref="M:Sudoku.Concepts.Collections.Grid.Parse(System.String,Sudoku.Concepts.Parsing.GridParsingOption)"/> instead of this method.
            </para>
            </summary>
            <param name="str">The string.</param>
            <returns>The result instance had converted.</returns>
            <seealso cref="M:Sudoku.Concepts.Collections.Grid.Parse(System.String,Sudoku.Concepts.Parsing.GridParsingOption)"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Parse(System.Char*)">
            <summary>
            Parses a pointer that points to a string value and converts to this type.
            </summary>
            <param name="ptrStr">The pointer that points to string.</param>
            <returns>The result instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the only argument is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Parse(System.String,System.Boolean)">
            <summary>
            <para>
            Parses a string value and converts to this type.
            </para>
            <para>
            If you want to parse a PM grid, you should decide the mode to parse.
            If you use compatible mode to parse, all single values will be treated as
            given values; otherwise, recommended mode, which uses '<c><![CDATA[<d>]]></c>'
            or '<c>*d*</c>' to represent a value be a given or modifiable one. The decision
            will be indicated and passed by the second parameter <paramref name="compatibleFirst"/>.
            </para>
            </summary>
            <param name="str">The string.</param>
            <param name="compatibleFirst">
            Indicates whether the parsing operation should use compatible mode to check PM grid.
            </param>
            <returns>The result instance had converted.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.Parse(System.String,Sudoku.Concepts.Parsing.GridParsingOption)">
            <summary>
            Parses a string value and converts to this type, using a specified grid parsing type.
            </summary>
            <param name="str">The string.</param>
            <param name="gridParsingOption">The grid parsing type.</param>
            <returns>The result instance had converted.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.TryParse(System.String,Sudoku.Concepts.Collections.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.TryParse(System.String,Sudoku.Concepts.Parsing.GridParsingOption,Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Try to parse a string and converts to this type, and returns a
            <see cref="T:System.Boolean"/> value indicating the result of the conversion.
            </summary>
            <param name="str">The string.</param>
            <param name="option">The grid parsing type.</param>
            <param name="result">
            The result parsed. If the conversion is failed,
            this argument will be <see cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <seealso cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskToStatus(System.Int16)">
            <summary>
            To get the cell status through a mask.
            </summary>
            <param name="mask">The mask.</param>
            <returns>The cell status.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.op_Equality(Sudoku.Concepts.Collections.Grid@,Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Collections.Grid"/>s are same.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.op_Inequality(Sudoku.Concepts.Collections.Grid@,Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Collections.Grid"/>s aren't same.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.System#IEqualityOperators{Sudoku#Concepts#Collections#Grid,Sudoku#Concepts#Collections#Grid}#op_Equality(Sudoku.Concepts.Collections.Grid,Sudoku.Concepts.Collections.Grid)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.System#IEqualityOperators{Sudoku#Concepts#Collections#Grid,Sudoku#Concepts#Collections#Grid}#op_Inequality(Sudoku.Concepts.Collections.Grid,Sudoku.Concepts.Collections.Grid)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator">
            <summary>
            Defines the default enumerator that iterates the <see cref="T:Sudoku.Concepts.Collections.Grid"/>
            through the masks in the current <see cref="T:Sudoku.Concepts.Collections.Grid"/> instance.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator._start">
            <summary>
            The pointer to the start value.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator._currentPointer">
            <summary>
            The current pointer.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator._currentIndex">
            <summary>
            The current index.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.#ctor(System.Int16*)">
            <summary>
            Initializes an instance with the specified pointer to an array to iterate.
            </summary>
            <param name="arr">The pointer to an array.</param>
            <remarks>
            Note here we should point at the one-unit-lengthed memory before the array start.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>If the enumerator was successfully advanced to the next element.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>If the enumerator has passed the end of the collection.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element
            in the collection.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Grid.MaskCollectionEnumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Collections.GridTransformations">
            <summary>
            Provides methods for <see cref="T:Sudoku.Concepts.Collections.Grid"/> instances on transformations.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Collections.Grid"/>
        </member>
        <member name="F:Sudoku.Concepts.Collections.GridTransformations.ClockwiseTable">
            <summary>
            The table of clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.GridTransformations.CounterclockwiseTable">
            <summary>
            The table of counter-clockwise rotation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.GridTransformations.PiRotateTable">
            <summary>
            The table of pi-rotation.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.MirrorLeftRight(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Mirror left-right the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.MirrorTopBottom(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Mirror top-bottom the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.MirrorDiagonal(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Mirror diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.Transpose(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Transpose the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.MirrorAntidiagonal(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Mirror anti-diagonal the grid.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.RotateClockwise(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Rotate the grid clockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.RotateCounterclockwise(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Rotate the grid counterclockwise.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.RotatePi(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Rotate the grid <c><see cref="F:System.Math.PI"/></c> degrees.
            </summary>
            <param name="this">The grid.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.GridTransformations.SwapTwoRegions(Sudoku.Concepts.Collections.Grid@,System.Int32,System.Int32)">
            <summary>
            Swap to regions.
            </summary>
            <param name="this">The grid.</param>
            <param name="region1">The region 1.</param>
            <param name="region2">The region 2.</param>
            <returns>The result.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when two specified region argument is not in valid range (0..27)
            or two regions are not in same region type.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Handlers.ConclusionCollection">
            <summary>
            Provides a collection that contains the conclusions.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Handlers.ConclusionCollection._collection">
            <summary>
            The internal collection.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.#ctor(Sudoku.Concepts.Solving.Conclusion[])">
            <summary>
            Initializes an instance with the specified collection.
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.Cells">
            <summary>
            Indicates all cells used in this conclusions list.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.Digits">
            <summary>
            Indicates all digits used in this conclusions list, represented as a mask.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.Equals(Sudoku.Concepts.Collections.Handlers.ConclusionCollection)">
            <summary>
            Determine whether the two collections are equal.
            </summary>
            <param name="other">The collection to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.ToString(System.Boolean,System.String)">
            <summary>
            Converts the current instance to <see cref="T:System.String"/> with the specified separator.
            </summary>
            <param name="shouldSort">Indicates whether the specified collection should be sorted first.</param>
            <param name="separator">The separator.</param>
            <returns>The string result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.ConclusionCollection.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Handlers.DigitCollection">
            <summary>
            Indicates a collection that contains the several digits.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Handlers.DigitCollection._mask">
            <summary>
            Indicates the inner mask.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.#ctor(System.Int16)">
            <summary>
            Initializes the collection using a mask.
            </summary>
            <param name="mask">The mask.</param>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Handlers.DigitCollection.Count">
            <summary>
            Get the number of digits in the collection.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.Contains(System.Int32)">
            <summary>
            Indicates whether the specified collection contains the digit.
            </summary>
            <param name="digit">The digit.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.ToSimpleString">
            <summary>
            Returns a string that represents the current object without the specified format string.
            </summary>
            <returns>The string result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.ToString(System.String)">
            <summary>
            Returns a string that represents the current object with the specified format string.
            </summary>
            <param name="format">The format. If available, the parameter can be <see langword="null"/>.</param>
            <returns>The string result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.GetEnumerator">
            <summary>
            Get the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.op_OnesComplement(Sudoku.Concepts.Collections.Handlers.DigitCollection)">
            <summary>
            Make all <see langword="true"/> bits to be set <see langword="false"/>,
            and make all <see langword="false"/> bits to be set <see langword="true"/>.
            </summary>
            <param name="collection">The instance to negate.</param>
            <returns>The negative result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.op_Subtraction(Sudoku.Concepts.Collections.Handlers.DigitCollection,Sudoku.Concepts.Collections.Handlers.DigitCollection)">
            <summary>
            Apply the subtraction with <paramref name="left"/> as the subtrahend,
            and <paramref name="right"/> as the subtractor.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.op_BitwiseAnd(Sudoku.Concepts.Collections.Handlers.DigitCollection,Sudoku.Concepts.Collections.Handlers.DigitCollection)">
            <summary>
            Apply the intersection from two <see cref="T:Sudoku.Concepts.Collections.Handlers.DigitCollection"/>s.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.op_BitwiseOr(Sudoku.Concepts.Collections.Handlers.DigitCollection,Sudoku.Concepts.Collections.Handlers.DigitCollection)">
            <summary>
            Apply the union of two <see cref="T:Sudoku.Concepts.Collections.Handlers.DigitCollection"/>s.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.op_ExclusiveOr(Sudoku.Concepts.Collections.Handlers.DigitCollection,Sudoku.Concepts.Collections.Handlers.DigitCollection)">
            <summary>
            Apply the exclusive union of two <see cref="T:Sudoku.Concepts.Collections.Handlers.DigitCollection"/>s.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>The result collection.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.DigitCollection.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Handlers.RegionCollection">
            <summary>
            Indicates a region collection.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.#ctor(System.Int32)">
            <summary>
            Initializes an empty collection and add one region into the list.
            </summary>
            <param name="region">The region.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.#ctor(System.ReadOnlySpan{System.Int32}@)">
            <summary>
            Initializes an instance with the specified regions.
            </summary>
            <param name="regions">The regions.</param>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Initializes an instance with the specified regions.
            </summary>
            <param name="regions">The regions.</param>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Handlers.RegionCollection.Count">
            <summary>
            Indicates the number of regions that contain in this collection.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Handlers.RegionCollection.Mask">
            <summary>
            Indicates the mask used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Collections.Handlers.RegionCollection.Item(System.Int32)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> value indicating whether the bit of the corresponding specified region
            is set <see langword="true"/>.
            </summary>
            <param name="region">The region.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.Equals(Sudoku.Concepts.Collections.Handlers.RegionCollection)">
            <summary>
            Determine whether the two collections are equal.
            </summary>
            <param name="other">The collection to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.ToSimpleString">
            <summary>
            To string but only output the labels ('r', 'c' or 'b').
            </summary>
            <returns>The labels.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.GetEnumerator">
            <summary>
            Gets the enumerator of the instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.GetLabel(System.Int32)">
            <summary>
            Get the label of each region.
            </summary>
            <param name="index">The index.</param>
            <returns>The label.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Handlers.RegionCollection.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Serialization.CandidatesConverter">
            <summary>
            Defines a serialization converter to convert the <see cref="T:Sudoku.Concepts.Collections.Candidates"/>
            to a JSON <see cref="T:System.String"/> or vice versa.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Serialization.CandidatesConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Serialization.CandidatesConverter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Collections.Candidates,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Serialization.CellsConverter">
            <summary>
            Defines a serialization converter to convert the <see cref="T:Sudoku.Concepts.Collections.Cells"/>
            to a JSON <see cref="T:System.String"/> or vice versa.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Serialization.CellsConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Serialization.CellsConverter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Collections.Cells,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Collections.Serialization.GridConverter">
            <summary>
            Defines a serialization converter to convert the <see cref="T:Sudoku.Concepts.Collections.Grid"/>
            to a JSON <see cref="T:System.String"/> or vice versa.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Collections.Serialization.GridConverter.PropertyName">
            <summary>
            The property name.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Serialization.GridConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Collections.Serialization.GridConverter.Write(System.Text.Json.Utf8JsonWriter,Sudoku.Concepts.Collections.Grid,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.ConjugatePair">
            <summary>
            Encapsulates a conjugate pair.
            </summary>
            <remarks>
            <b>Conjugate pair</b> is a candidate pair (two candidates),
            these two candidates is in the same region where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="From">Indicates the cell that is the start cell.</param>
            <param name="To">Indicates the cell that is end cell.</param>
            <param name="Digit">Indicates the digit used.</param>
            <param name="Map">Indicates the pair of maps used.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConjugatePair.#ctor(System.Int32,System.Int32,System.Int32,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Encapsulates a conjugate pair.
            </summary>
            <remarks>
            <b>Conjugate pair</b> is a candidate pair (two candidates),
            these two candidates is in the same region where all cells has only
            two position can fill this candidate.
            </remarks>
            <param name="From">Indicates the cell that is the start cell.</param>
            <param name="To">Indicates the cell that is end cell.</param>
            <param name="Digit">Indicates the digit used.</param>
            <param name="Map">Indicates the pair of maps used.</param>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.From">
            <summary>Indicates the cell that is the start cell.</summary>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.To">
            <summary>Indicates the cell that is end cell.</summary>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.Digit">
            <summary>Indicates the digit used.</summary>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.Map">
            <summary>Indicates the pair of maps used.</summary>
        </member>
        <member name="F:Sudoku.Concepts.ConjugatePair.Default">
            <summary>
            <inheritdoc cref="P:System.IDefaultable`1.Default"/>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.ConjugatePair.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.ConjugatePair"/> instance with from and to cell offset and a digit.
            </summary>
            <param name="from">The from cell.</param>
            <param name="to">The to cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="M:Sudoku.Concepts.ConjugatePair.#ctor(Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.ConjugatePair"/> instance with the map and the digit.
            The map should contains two cells, the first one is the start one, and the second one is the end one.
            </summary>
            <param name="map">The map.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.Line">
            <summary>
            Indicates the line that two cells lie in.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.Regions">
            <summary>
            Indicates the region that two cells lie in.
            </summary>
            <remarks><inheritdoc cref="P:Sudoku.Concepts.Collections.Cells.CoveredRegions"/></remarks>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.System#IDefaultable{Sudoku#Concepts#ConjugatePair}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ConjugatePair.System#IDefaultable{Sudoku#Concepts#ConjugatePair}#Default">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ConjugatePair.Equals(Sudoku.Concepts.ConjugatePair@)">
            <summary>
            Determine whether the two conjugate pairs are same.
            </summary>
            <param name="other">The other instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ConjugatePair.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.ConjugatePair.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Concepts.Enumerators.BitSubsetsGenerator">
            <summary>
            Encapsulates a bit combination generator.
            </summary>
            <remarks>
            You can use this struct like this:
            <code><![CDATA[
            foreach (short mask in new BitSubsetsGenerator(9, 3))
            {
                // Do something to use the mask.
            }
            ]]></code>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Enumerators.BitSubsetsGenerator._enumerator">
            <summary>
            The inner enumerator.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes an instance with the specified number of bits
            and <see langword="true"/> bits.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator">
            <summary>
            Indicates the enumerator of the current instance.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator._mask">
            <summary>
            The mask.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator._isLast">
            <summary>
            Indicates whether that the value is the last one.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes an instance with the specified number of bits
            and <see langword="true"/> bits.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="P:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator.Current">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Enumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Enumerators.BitSubsetsGenerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.GridFormatter">
            <summary>
            Provides a formatter that gathers the main information for a <see cref="T:Sudoku.Concepts.Collections.Grid"/> instance,
            and convert it to a <see cref="T:System.String"/> value as the result.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormatter._flags">
            <summary>
            Indicates the inner mask that stores the flags.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.#ctor(System.Boolean)">
            <summary>
            Initializes an instance with a <see cref="T:System.Boolean"/> value
            indicating multi-line.
            </summary>
            <param name="multiline">
            The multi-line identifier. If the value is <see langword="true"/>, the output will
            be multi-line.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.#ctor(System.Int16)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Formatting.GridFormatter"/> instance using the specified mask storing all possible flags.
            </summary>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.#ctor(System.Char,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initialize an instance with the specified information.
            </summary>
            <param name="placeholder">The placeholder.</param>
            <param name="multiline">Indicates whether the formatter will use multiple lines mode.</param>
            <param name="withModifiables">Indicates whether the formatter will output modifiables.</param>
            <param name="withCandidates">
            Indicates whether the formatter will output candidates list.
            </param>
            <param name="treatValueAsGiven">
            Indicates whether the formatter will treat values as givens always.
            </param>
            <param name="subtleGridLines">
            Indicates whether the formatter will process outline corner of the multiline grid.
            </param>
            <param name="hodokuCompatible">
            Indicates whether the formatter will use hodoku library mode to output.
            </param>
            <param name="sukaku">Indicates whether the formatter will output as sukaku.</param>
            <param name="excel">Indicates whether the formatter will output as excel.</param>
            <param name="openSudoku">
            Indicates whether the formatter will output as open sudoku format.
            </param>
            <param name="shortenSusser">
            Indicates whether the formatter will shorten the susser format.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="placeholder"/> is not supported.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.Placeholder">
            <summary>
            The place holder.
            </summary>
            <returns>The result placeholder text.</returns>
            <value>The value to assign. The value must be 46 (<c>'.'</c>) or 48 (<c>'0'</c>).</value>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <see langword="value"/> is not supported.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.Multiline">
            <summary>
            Indicates whether the output should be multi-line.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.WithModifiables">
            <summary>
            Indicates the output should be with modifiable values.
            </summary>
            <returns>The output should be with modifiable values.</returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.WithCandidates">
            <summary>
            <para>
            Indicates the output should be with candidates.
            If the output is single line, the candidates will indicate
            the candidates-have-eliminated before the current grid status;
            if the output is multi-line, the candidates will indicate
            the real candidate at the current grid status.
            </para>
            <para>
            If the output is single line, the output will append the candidates
            value at the tail of the string in '<c>:candidate list</c>'. In addition,
            candidates will be represented as 'digit', 'row offset' and
            'column offset' in order.
            </para>
            </summary>
            <returns>The output should be with candidates.</returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.TreatValueAsGiven">
            <summary>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>' instead
            of '<c>*digit*</c>'.
            </summary>
            <returns>The output will treat modifiable values as given ones.</returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.SubtleGridLines">
            <summary>
            Indicates whether need to handle all grid outlines while outputting.
            </summary>
            <returns>
            The <see cref="T:System.Boolean"/> result indicating whether need to handle all grid outlines while outputting.
            </returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.HodokuCompatible">
            <summary>
            Indicates whether the output will be compatible with Hodoku library format.
            </summary>
            <returns>
            The <see cref="T:System.Boolean"/> result indicating whether the output will be compatible
            with Hodoku library format.
            </returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.Sukaku">
            <summary>
            Indicates the output will be sukaku format (all single-valued digit will
            be all treated as candidates).
            </summary>
            <returns>
            The output will be sukaku format (all single-valued digit will
            be all treated as candidates).
            </returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.Excel">
            <summary>
            Indicates the output will be Excel format.
            </summary>
            <returns>The output will be Excel format.</returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.OpenSudoku">
            <summary>
            Indicates whether the current output mode is aiming to open sudoku format.
            </summary>
            <returns>
            The <see cref="T:System.Boolean"/> result indicating whether the current output mode
            is aiming to open sudoku format.
            </returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="P:Sudoku.Concepts.Formatting.GridFormatter.ShortenSusser">
            <summary>
            Indicates whether the current output mode will shorten the susser format.
            </summary>
            <returns>
            The <see cref="T:System.Boolean"/> result indicating whether the current output mode
            will shorten the susser format.
            </returns>
            <value>A <see cref="T:System.Boolean"/> value to set.</value>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToString(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Represents a string value indicating this instance.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToString(Sudoku.Concepts.Collections.Grid@,System.String)">
            <summary>
            Represents a string value indicating this instance, with the specified format string.
            </summary>
            <param name="grid">The grid.</param>
            <param name="format">The string format.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.Create(Sudoku.Concepts.Formatting.GridFormattingOptions)">
            <summary>
            Create a <see cref="T:Sudoku.Concepts.Formatting.GridFormatter"/> according to the specified grid output options.
            </summary>
            <param name="gridOutputOption">The grid output options.</param>
            <returns>The grid formatter.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToExcelString(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To Excel format string.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToOpenSudokuString(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To open sudoku format string.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The string.</returns>
            <exception cref="T:System.FormatException">Throws when the specified grid is invalid.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToHodokuLibraryFormatString(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To string with Hodoku library format compatible string.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToSukakuString(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To string with the sukaku format.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The string.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when the puzzle is an invalid sukaku puzzle (at least one cell is given or modifiable).
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToSingleLineStringCore(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To single line string.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToMultiLineStringCore(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To multi-line string with candidates.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToMultiLineSimpleGridCore(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To multi-line normal grid string without any candidates.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatter.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.GridFormatterFactory">
            <summary>
            Indicates the factory that creates the grid formatter.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Formatting.GridFormatterFactory.Create(System.String)">
            <summary>
            Create a <see cref="T:Sudoku.Concepts.Formatting.GridFormatter"/> according to the specified format.
            </summary>
            <param name="format">The format.</param>
            <returns>The grid formatter.</returns>
            <exception cref="T:System.FormatException">Throws when the format string is invalid.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Formatting.GridFormattingOptions">
            <summary>
            Provides a grid format option.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.None">
            <summary>
            Indicates the default settings (a single-line string text).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.WithModifiers">
            <summary>
            Indicates the output should be with modifiable values.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.WithCandidates">
            <summary>
            <para>
            Indicates the output should be with candidates.
            If the output is single line, the candidates will indicate
            the candidates-have-eliminated before the current grid status;
            if the output is multi-line, the candidates will indicate
            the real candidate at the current grid status.
            </para>
            <para>
            If the output is single line, the output will append the candidates
            value at the tail of the string in '<c>:candidate list</c>'. In addition,
            candidates will be represented as 'digit', 'row offset' and
            'column offset' in order.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.TreatValueAsGiven">
            <summary>
            Indicates the output will treat modifiable values as given ones.
            If the output is single line, the output will remove all plus marks '+'.
            If the output is multi-line, the output will use '<c><![CDATA[<digit>]]></c>'
            instead of '<c>*digit*</c>'.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.SubtleGridLines">
            <summary>
            Indicates whether need to handle all grid outlines while outputting.
            Visit the page
            <i>
            <see href="https://sunnieshine.github.io/Sudoku/types/structs/How-To-Use-Struct-SudokuGrid">
            How to use the structure SudokuGrid
            </see>
            </i>
            for more information.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.HodokuCompatible">
            <summary>
            Indicates whether the output will be compatible with Hodoku library format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.DotPlaceholder">
            <summary>
            Indicates the placeholder must be '.' instead of '0'.
            If the value is <see langword="true"/>, the placeholder will be '.';
            otherwise, '0'.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.Multiline">
            <summary>
            Indicates the output should be multi-line.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.Sukaku">
            <summary>
            Indicates the output will be sukaku format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.Excel">
            <summary>
            Indicates the output will be Excel format.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.OpenSudoku">
            <summary>
            Indicates the open sudoku format.
            </summary>
            <remarks>
            This format will use a triplet to describe a cell. If the cell has already been filled with
            a value, it will be output at the first digit of that triplet. For example,
            the triplet <c>900</c> means the cell is filled with the digit 9. In addition,
            if the cell is empty, the triplet is always <c>001</c>.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Formatting.GridFormattingOptions.Shorten">
            <summary>
            Indicates the shorten susser format.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.GridCreatingOption">
            <summary>
            Indicates the grid creating option.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.None">
            <summary>
            Indicates the option is none.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.GridCreatingOption.MinusOne">
            <summary>
            Indicates each value should minus one before creation.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Inference">
            <summary>
            Defines an inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Strong">
            <summary>
            Indicates the inference is strong inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Weak">
            <summary>
            Indicates the inference is weak inference.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.StrongGeneralized">
            <summary>
            Indicates the inference is strong inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.WeakGeneralized">
            <summary>
            Indicates the inference is weak inference that is generalized.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.ConjuagtePair">
            <summary>
            Indicates the inference is conjugate pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Inference.Default">
            <summary>
            Indicates the inference is the default case that doesn't belong to above.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.InferenceExtensions">
            <summary>
            Provides the extensions methods on <see cref="T:Sudoku.Concepts.Inference"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Inference"/>
        </member>
        <member name="M:Sudoku.Concepts.InferenceExtensions.GetIdentifier(Sudoku.Concepts.Inference)">
            <summary>
            Gets the identifier of the inference.
            </summary>
            <param name="this">The inference.</param>
            <returns>The identifier value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="this"/> is not defined.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Notations.EliminationNotation">
            <summary>
            Encapsulates a set of methods that handles a variety of instances, using Hodoku elimination notation
            to output the <see cref="T:System.String"/> representation, or parse a <see cref="T:System.String"/> value to convert
            it to the suitable-typed instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.EliminationNotation.Notation">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.EliminationNotation.TryParseCandidates(System.String,Sudoku.Concepts.Collections.Candidates@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.EliminationNotation.ToCandidatesString(Sudoku.Concepts.Collections.Candidates@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.EliminationNotation.ToCandidatesString(Sudoku.Concepts.Collections.Candidates@,Sudoku.Concepts.Notations.EliminationNotationOptions@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.EliminationNotation.ParseCandidates(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Notations.EliminationNotationOptions">
            <summary>
            Provides with a type that is used for displaying a cell list, using hodoku elimination notation.
            </summary>
            <param name="DigitFirst">
            <para>Indicates whether the output string will put the digit at first.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="Separator">
            <para>Indicates the separator that is used for the insertion between 2 adjacent candidate elements.</para>
            <para>The default value is <c>" "</c>.</para>
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Notations.EliminationNotationOptions.#ctor(System.Boolean,System.String)">
            <summary>
            Provides with a type that is used for displaying a cell list, using hodoku elimination notation.
            </summary>
            <param name="DigitFirst">
            <para>Indicates whether the output string will put the digit at first.</para>
            <para>The default value is <see langword="true"/>.</para>
            </param>
            <param name="Separator">
            <para>Indicates the separator that is used for the insertion between 2 adjacent candidate elements.</para>
            <para>The default value is <c>" "</c>.</para>
            </param>
        </member>
        <member name="P:Sudoku.Concepts.Notations.EliminationNotationOptions.DigitFirst">
            <summary>
            <para>Indicates whether the output string will put the digit at first.</para>
            <para>The default value is <see langword="true"/>.</para>
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.EliminationNotationOptions.Separator">
            <summary>
            <para>Indicates the separator that is used for the insertion between 2 adjacent candidate elements.</para>
            <para>The default value is <c>" "</c>.</para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Notations.EliminationNotationOptions.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.EliminationNotationOptions.System#IDefaultable{Sudoku#Concepts#Notations#EliminationNotationOptions}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Notations.EliminationNotationOptions.System#IDefaultable{Sudoku#Concepts#Notations#EliminationNotationOptions}#Default">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Notations.ICandidateNotation`2">
            <summary>
            Defines a type that can convert a <see cref="T:Sudoku.Concepts.Collections.Candidates"/> instance into a result <see cref="T:System.String"/>
            representation to describe the candidate collection.
            </summary>
            <typeparam name="TBaseType">The base type that applies the interface.</typeparam>
            <typeparam name="TOptions">The type that is used as the provider for extra options.</typeparam>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICandidateNotation`2.TryParseCandidates(System.String,Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            <para>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.Collections.Candidates"/>
            instance.
            </para>
            <para>
            Different with the method <see cref="M:Sudoku.Concepts.Notations.ICandidateNotation`2.ParseCandidates(System.String)"/>, the method will return a
            <see cref="T:System.Boolean"/> value instead, indicating whether the operation is successful. Therefore,
            the method won't throw <see cref="T:System.FormatException"/>.
            </para>
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <param name="result">
            The <see cref="T:Sudoku.Concepts.Collections.Candidates"/> result. If the return value is <see langword="false"/>,
            this argument will be a discard and cannot be used.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the parsing operation is successful.</returns>
            <seealso cref="M:Sudoku.Concepts.Notations.ICandidateNotation`2.ParseCandidates(System.String)"/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICandidateNotation`2.ToCandidatesString(Sudoku.Concepts.Collections.Candidates@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of candidates.
            </summary>
            <param name="candidates">The candidate list.</param>
            <returns>The <see cref="T:System.String"/> representation describe the candidate list.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICandidateNotation`2.ToCandidatesString(Sudoku.Concepts.Collections.Candidates@,`1@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of candidates.
            </summary>
            <param name="candidates">The candidates list.</param>
            <param name="options">The extra options to control the output style.</param>
            <returns>The <see cref="T:System.String"/> representation describe the candidate list.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICandidateNotation`2.ParseCandidates(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.Collections.Candidates"/>
            instance.
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Collections.Candidates"/> result.</returns>
            <exception cref="T:System.FormatException">
            Throws when the parsing operation is failed due to invalid characters or invalid operation.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Notations.ICellNotation`2">
            <summary>
            Defines a type that can convert a <see cref="T:Sudoku.Concepts.Collections.Cells"/> instance into a result <see cref="T:System.String"/>
            representation to describe the cell collection.
            </summary>
            <typeparam name="TBaseType">The base type that applies the interface.</typeparam>
            <typeparam name="TOptions">The type that is used as the provider for extra options.</typeparam>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICellNotation`2.TryParseCells(System.String,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            <para>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.Collections.Cells"/>
            instance.
            </para>
            <para>
            Different with the method <see cref="M:Sudoku.Concepts.Notations.ICellNotation`2.ParseCells(System.String)"/>, the method will return a
            <see cref="T:System.Boolean"/> value instead, indicating whether the operation is successful. Therefore,
            the method won't throw <see cref="T:System.FormatException"/>.
            </para>
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <param name="result">
            The <see cref="T:Sudoku.Concepts.Collections.Cells"/> result. If the return value is <see langword="false"/>,
            this argument will be a discard and cannot be used.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the parsing operation is successful.</returns>
            <seealso cref="M:Sudoku.Concepts.Notations.ICellNotation`2.ParseCells(System.String)"/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICellNotation`2.ToCellsString(Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of cells.
            </summary>
            <param name="cells">The cell list.</param>
            <returns>The <see cref="T:System.String"/> representation describe the cell list.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICellNotation`2.ToCellsString(Sudoku.Concepts.Collections.Cells@,`1@)">
            <summary>
            Gets the <see cref="T:System.String"/> representation of a list of cells.
            </summary>
            <param name="cells">The cell list.</param>
            <param name="options">The extra options to control the output style.</param>
            <returns>The <see cref="T:System.String"/> representation describe the cell list.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Notations.ICellNotation`2.ParseCells(System.String)">
            <summary>
            Try to parse the specified <see cref="T:System.String"/> value, and convert it into the <see cref="T:Sudoku.Concepts.Collections.Cells"/>
            instance.
            </summary>
            <param name="str">The <see cref="T:System.String"/> value.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Collections.Cells"/> result.</returns>
            <exception cref="T:System.FormatException">
            Throws when the parsing operation is failed due to invalid characters or invalid operation.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Notations.INotationHandler">
            <summary>
            Defines a type that handles using the current notation.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.INotationHandler.Notation">
            <summary>
            Indicates the notation of the current provider type.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Notations.INotationHandlerOptions`1">
            <summary>
            Defines a type that provides the extra options that is used by the <see cref="T:Sudoku.Concepts.Notations.INotationHandler"/> instance.
            </summary>
            <typeparam name="TSelf">The type of the handler.</typeparam>
        </member>
        <member name="T:Sudoku.Concepts.Notations.K9Notation">
            <summary>
            Encapsulates a set of methods that handles a variety of instances, using K9 notation
            to output the <see cref="T:System.String"/> representation, or parse a <see cref="T:System.String"/> value to convert
            it to the suitable-typed instance.
            </summary>
            <remarks>
            <para>
            The <b>K9 notation</b> is a notation to describe a set of cells that uses letters
            A, B, C, D, E, F, G, H and K to describe the row, and uses digits 1 to 9 to describe the column.
            For example, <c>C8</c> means the cell at row 3 and column 8.
            The letter I and J aren't used in this notation because they are confusing with digit 1.
            However, they can also be used in Chinese notations, for example, <c>K8</c> in traditional notation
            is same as <c>I8</c> in Chinese K9 notation rule.
            </para>
            <para>
            For more information about this concept, please visit
            <see href="http://sudopedia.enjoysudoku.com/K9.html">this link</see>.
            </para>
            <para>
            Please note that the type is an <see langword="abstract"/> type,
            which means you cannot instantiate any objects. In addition, the type contains
            a <see langword="private"/> instance constructor, which disallows you deriving any types.
            </para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Notations.K9Notation.Letters">
            <summary>
            Indicates all possible letters that used in the row notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Notations.K9Notation.CellOrCellListRegex">
            <summary>
            Indicates the regular expression for matching a cell or cell-list.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.K9Notation.Notation">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.K9Notation.ToCellsString(Sudoku.Concepts.Collections.Cells@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.K9Notation.ToCellsString(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Notations.K9NotationOptions@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.K9Notation.ParseCells(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.K9Notation.TryParseCells(System.String,Sudoku.Concepts.Collections.Cells@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Notations.K9NotationOptions">
            <summary>
            Provides with a type that is used for displaying a cell list, using K9 notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether the method should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the concept "row 3 column 3" will be displayed
            as <c>C3</c>; otherwise, <c>c3</c>.
            </param>
            <param name="AvoidConfusionOnRowLetters">
            Indicates whether the method should avoid confusion for the letter I and digit 1. For example,
            if <see langword="true"/>, row 9 column 9 will be notated as <c>K9</c>; otherwise, <c>I9</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>C1</c> and <c>D2</c> can be combined to <c>C1|D2</c> if the seperator
            is <c>"|"</c>.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Notations.K9NotationOptions.#ctor(System.Boolean,System.Boolean,System.String)">
            <summary>
            Provides with a type that is used for displaying a cell list, using K9 notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether the method should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the concept "row 3 column 3" will be displayed
            as <c>C3</c>; otherwise, <c>c3</c>.
            </param>
            <param name="AvoidConfusionOnRowLetters">
            Indicates whether the method should avoid confusion for the letter I and digit 1. For example,
            if <see langword="true"/>, row 9 column 9 will be notated as <c>K9</c>; otherwise, <c>I9</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>C1</c> and <c>D2</c> can be combined to <c>C1|D2</c> if the seperator
            is <c>"|"</c>.
            </param>
        </member>
        <member name="P:Sudoku.Concepts.Notations.K9NotationOptions.UpperCasing">
            <summary>
            Indicates whether the method should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the concept "row 3 column 3" will be displayed
            as <c>C3</c>; otherwise, <c>c3</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.K9NotationOptions.AvoidConfusionOnRowLetters">
            <summary>
            Indicates whether the method should avoid confusion for the letter I and digit 1. For example,
            if <see langword="true"/>, row 9 column 9 will be notated as <c>K9</c>; otherwise, <c>I9</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.K9NotationOptions.Separator">
            <summary>
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>C1</c> and <c>D2</c> can be combined to <c>C1|D2</c> if the seperator
            is <c>"|"</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Notations.K9NotationOptions.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.K9NotationOptions.System#IDefaultable{Sudoku#Concepts#Notations#K9NotationOptions}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Notations.K9NotationOptions.System#IDefaultable{Sudoku#Concepts#Notations#K9NotationOptions}#Default">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Notations.Notation">
            <summary>
            Represents a notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Notations.Notation.RxCy">
            <summary>
            Indicates the RxCy notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Notations.Notation.K9">
            <summary>
            Indicates the K9 notation.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Notations.Notation.HodokuElimination">
            <summary>
            Indicates the notation that is used by the program called Hodoku, as the eliminations.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Notations.RxCyNotation">
            <summary>
            Encapsulates a set of methods that handles a variety of instances, using RxCy notation
            to output the <see cref="T:System.String"/> representation, or parse a <see cref="T:System.String"/> value to convert
            it to the suitable-typed instance.
            </summary>
            <remarks>
            <para>
            The <b>RxCy notation</b> is a notation to describe a set of cells that uses letter
            <c>R</c> (or its lower case <c>r</c>) to describe a row label, and uses the other letter
            <c>C</c> (or its lower case <c>c</c>) to describe a column label. For example,
            <c>R4C2</c> means the cell at row 4 and column 2.
            </para>
            <para>
            For more information about this concept, please visit
            <see href="http://sudopedia.enjoysudoku.com/Rncn.html">this link</see>.
            </para>
            <para>
            Please note that the type is an <see langword="abstract"/> type,
            which means you cannot instantiate any objects. In addition, the type contains
            a <see langword="private"/> instance constructor, which disallows you deriving any types.
            </para>
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Notations.RxCyNotation.CellOrCellListRegex">
            <summary>
            Indicates the regular expression for matching a cell or cell-list.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.RxCyNotation.Notation">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.RxCyNotation.TryParseCells(System.String,Sudoku.Concepts.Collections.Cells@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.RxCyNotation.ToCellsString(Sudoku.Concepts.Collections.Cells@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.RxCyNotation.ToCellsString(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Notations.RxCyNotationOptions@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Notations.RxCyNotation.ParseCells(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Notations.RxCyNotationOptions">
            <summary>
            Provides with a type that is used for displaying a cell list, using RxCy notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether we should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the cell at row 3 and column 3 will be displayed
            as <c>R3C3</c>; otherwise, <c>r3c3</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>R3C1</c> and <c>R4C2</c> can be combined to <c>R3C1|R4C2</c> if the seperator
            is <c>"|"</c>.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Notations.RxCyNotationOptions.#ctor(System.Boolean,System.String)">
            <summary>
            Provides with a type that is used for displaying a cell list, using RxCy notation.
            </summary>
            <param name="UpperCasing">
            Indicates whether we should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the cell at row 3 and column 3 will be displayed
            as <c>R3C3</c>; otherwise, <c>r3c3</c>.
            </param>
            <param name="Separator">
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>R3C1</c> and <c>R4C2</c> can be combined to <c>R3C1|R4C2</c> if the seperator
            is <c>"|"</c>.
            </param>
        </member>
        <member name="P:Sudoku.Concepts.Notations.RxCyNotationOptions.UpperCasing">
            <summary>
            Indicates whether we should use upper-casing to handle the result notation of cells.
            For example, if <see langword="true"/>, the cell at row 3 and column 3 will be displayed
            as <c>R3C3</c>; otherwise, <c>r3c3</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.RxCyNotationOptions.Separator">
            <summary>
            Indicates the separator string value that inserts two coordinate elements, to combine them.
            For example, cells <c>R3C1</c> and <c>R4C2</c> can be combined to <c>R3C1|R4C2</c> if the seperator
            is <c>"|"</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Notations.RxCyNotationOptions.Default">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Notations.RxCyNotationOptions.System#IDefaultable{Sudoku#Concepts#Notations#RxCyNotationOptions}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Notations.RxCyNotationOptions.System#IDefaultable{Sudoku#Concepts#Notations#RxCyNotationOptions}#Default">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Parsing.CandidatesParsingOptions">
            <summary>
            Encapsulates an option that is specified to parse the <see cref="T:Sudoku.Concepts.Collections.Candidates"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Collections.Candidates"/>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.CandidatesParsingOptions.ShortForm">
            <summary>
            Indicates the short form, such as <c>312</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.CandidatesParsingOptions.BracketForm">
            <summary>
            Indicates the bracket form, such as <c>{ r1c1, r3c3 }(12)</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.CandidatesParsingOptions.PrepositionalForm">
            <summary>
            Indicates the prepositional form, such as <c>12{ r1c1, r3c3 }</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Parsing.GridParser">
            <summary>
            Encapsulates a grid parser that can parse a string value and convert it
            into a valid <see cref="T:Sudoku.Concepts.Collections.Grid"/> instance as the result.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParser.ParseFunctions">
            <summary>
            The list of all methods to parse.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParser.MultilineParseFunctions">
            <summary>
            The list of all methods to parse multiple-line grid.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.#ctor(System.String)">
            <summary>
            Initializes an instance with parsing data.
            </summary>
            <param name="parsingValue">The string to parse.</param>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes an instance with parsing data and a bool value
            indicating whether the parsing operation should use compatible mode.
            </summary>
            <param name="parsingValue">The string to parse.</param>
            <param name="compatibleFirst">
            Indicates whether the parsing operation should use compatible mode to check
            PM grid. See <see cref="P:Sudoku.Concepts.Parsing.GridParser.CompatibleFirst"/> to learn more.
            </param>
            <seealso cref="P:Sudoku.Concepts.Parsing.GridParser.CompatibleFirst"/>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Initializes an instance with parsing data and a bool value
            indicating whether the parsing operation should use compatible mode.
            </summary>
            <param name="parsingValue">The string to parse.</param>
            <param name="compatibleFirst">
            Indicates whether the parsing operation should use compatible mode to check
            PM grid. See <see cref="P:Sudoku.Concepts.Parsing.GridParser.CompatibleFirst"/> to learn more.
            </param>
            <param name="shortenSusser">Indicates the parser will shorten the susser format result.</param>
            <seealso cref="P:Sudoku.Concepts.Parsing.GridParser.CompatibleFirst"/>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="P:Sudoku.Concepts.Parsing.GridParser.ParsingValue">
            <summary>
            The string value to parse.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Parsing.GridParser.CompatibleFirst">
            <summary>
            Indicates whether the parser will change the execution order of PM grid.
            If the value is <see langword="true"/>, the parser will check compatible one
            first, and then check recommended parsing plan ('<c><![CDATA[<d>]]></c>' and '<c>*d*</c>').
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Parsing.GridParser.ShortenSusserFormat">
            <summary>
            Indicates whether the parser will use shorten mode to parse a susser format grid.
            If the value is <see langword="true"/>, the parser will omit the continuous empty notation
            <c>.</c>s or <c>0</c>s to a <c>*</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.Parse">
            <summary>
            To parse the value.
            </summary>
            <returns>The grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.Parse(Sudoku.Concepts.Parsing.GridParsingOption)">
            <summary>
            To parse the value with a specified grid parsing type.
            </summary>
            <param name="gridParsingOption">A specified parsing type.</param>
            <returns>The grid.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="gridParsingOption"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.OnParsingSimpleMultilineGrid(Sudoku.Concepts.Parsing.GridParser@)">
            <summary>
            Parse the value using multi-line simple grid (without any candidates).
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.OnParsingExcel(Sudoku.Concepts.Parsing.GridParser@)">
            <summary>
            Parse the Excel format.
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.OnParsingOpenSudoku(Sudoku.Concepts.Parsing.GridParser@)">
            <summary>
            Parse the open sudoku format grid.
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.OnParsingPencilMarked(Sudoku.Concepts.Parsing.GridParser@)">
            <summary>
            Parse the PM grid.
            </summary>
            <param name="parser">The parser.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.OnParsingSimpleTable(Sudoku.Concepts.Parsing.GridParser@)">
            <summary>
            Parse the simple table format string (Sudoku explainer format).
            </summary>
            <param name="parser">The parser.</param>
            <returns>The grid.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.OnParsingSusser(Sudoku.Concepts.Parsing.GridParser@,System.Boolean)">
            <summary>
            Parse the susser format string.
            </summary>
            <param name="parser">The parser.</param>
            <param name="shortenSusser">Indicates whether the parser will shorten the susser format.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.OnParsingSukaku(Sudoku.Concepts.Parsing.GridParser@,System.Boolean)">
            <summary>
            Parse the sukaku format string.
            </summary>
            <param name="parser">The parser.</param>
            <param name="compatibleFirst">
            Indicates whether the algorithm uses compatibility mode to check and parse sudoku grid.
            </param>
            <returns>The result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Parsing.GridParser.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="T:Sudoku.Concepts.Parsing.GridParsingOption">
            <summary>
            Represents a grid parsing type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.Susser">
            <summary>
            <para>
            Indicates the susser format, which means all grid values
            will be displayed in one line with empty cell character
            <c>'0'</c> or <c>'.'</c>.
            </para>
            <para>
            For example:
            </para>
            <para>
            1) <c>080630040200085009090000081000300800000020000006001000970000030400850007010094050</c>
            </para>
            <para>
            2) <c>4+80002+306+31000+9004000+4030109+38+24+675+1+75+1+39+8+46+2+2640708+3902090000010000002080+36+20007:713 723 533 633 537 575 176 576 577 579 583 784 586 587 496 997</c>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.ShortenSusser">
            <summary>
            <para>
            Indicates the shorten susser format, which means all grid values
            will be displayed in one line with empty cell character <c>'0'</c> or <c>'.'</c>.
            Different with the option <see cref="F:Sudoku.Concepts.Parsing.GridParsingOption.Susser"/>, this option will continue
            shortening the code. The option will omit the continuous empty cells to a <c>*</c>
            in a single line. For example, the code
            <code>
            080630040200085009090000081000300800000020000006001000970000030400850007010094050
            </code>
            will be displayed as
            <code>
            08063*40,2*85009,09*81,*300800,*2*,006001*,97*30,40085*7,01*94050
            </code>
            via this option. We use the colon <c>,</c> to separate each line of 9 numbers,
            and then omit the most continuous empty cells to a <c>*</c>.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.PencilMarked">
            <summary>
            <para>
            Indicates the pencil marked grid (PM grid), which means all
            grid candidates will be displayed using a table.
            </para>
            <para>
            For example:
            <code><![CDATA[
            +-------------------+-----------------+--------------------+
            | <8>   12459  249  | *6*  <7>   259  | 1245    245   *3*  |
            | 1457  1245   <6>  | 58   125   <3>  | 124578  2458  <9>  |
            | 1579  <3>    279  | <4>  1259  2589 | 12578   *6*   78   |
            +-------------------+-----------------+--------------------+
            | *2*   <7>    *3*  | <1>  <8>   45   | 456     <9>   46   |
            | <6>   458    48   | <2>  59    459  | <3>     *7*   *1*  |
            | 1459  1459   49   | *3*  *6*   <7>  | 458     458   <2>  |
            +-------------------+-----------------+--------------------+
            | <3>   2489   <1>  | 578  25    <6>  | 24789   248   478  |
            | 79    <6>    2789 | 78   <4>   *1*  | 289     *3*   <5>  |
            | 47    248    <5>  | <9>  *3*   28   | 2678    <1>   4678 |
            +-------------------+-----------------+--------------------+
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.Table">
            <summary>
            <para>
            Indicates the table format, which means all grid values
            will be displayed using a table with empty cell character
            <c>'0'</c> or <c>'.'</c>.
            </para>
            <para>
            For example:
            <code><![CDATA[
            .----------.----------.----------.
            |  .  4  6 |  . +1  . |  3 +7 +5 |
            | +3 +8  1 | +5  4  7 | +2 +9 +6 |
            |  .  .  5 |  .  3  . | +1 +4  8 |
            :----------+----------+----------:
            |  8  .  4 |  . +5  . | +7  6  . |
            |  .  9  . |  .  2  . | +8  5 +4 |
            |  .  5  . |  .  .  . |  9  .  3 |
            :----------+----------+----------:
            |  5  .  . |  .  8  . |  6  . +9 |
            | +4  .  8 |  1  9  . |  5  .  . |
            |  .  .  9 |  .  . +5 |  4  8  . |
            '----------'----------'----------'
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.SimpleTable">
            <summary>
            <para>
            Sudoku explainer format (9 characters in a row, and 9 rows).
            </para>
            <para>
            For example:
            <code><![CDATA[
            080630040
            200085009
            090000081
            000300800
            000020000
            006001000
            970000030
            400850007
            010094050
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.Sukaku">
            <summary>
            <para>
            Sukaku sudoku format (only contains the digits and the whitespace).
            </para>
            <para>
            For example:
            <code><![CDATA[
             23456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789  23456789
             23456789 123456789 123456789  23456789  23456789  23456789  23456789  23456789  23456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789 123456789
            123456789  23456789  23456789 123456789 123456789  23456789  23456789  23456789 123456789
             23456789  23456789  23456789  23456789 123456789  23456789 123456789  23456789  23456789
            123456789  23456789  23456789 123456789 123456789  23456789 123456789  23456789 123456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
             23456789 123456789 123456789  23456789  23456789 123456789  23456789 123456789  23456789
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.SukakuSingleLine">
            <summary>
            <para>Sukaku single line format, which uses '0' to be a placeholder.</para>
            <para>
            For example:
            <code><![CDATA[023406789123456700003050780120050789003006009123456009100056089023456080123000789003456789023006700023006700120056780100006789120400780000406789103000080020450000003406089020056709120050080100000700120056780120000709123056000123050080000450089123050709100456089003400780100450009003400009120400009123056709003000700023406000000406009123006000000056709003406700120050009103056089103456709003056009120456009123456780023400000103406709003056789020406700100050009020400000100006789020006789020456780123056080120400700000406789120400080023456789003006080020456789103450709123400009123400080023406700123406709103400080123456009120456789023406709023450080100406080103056009100400009123000789100400709100406780123050700000050080023406009]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.Excel">
            <summary>
            <para>
            Excel sudoku format (only contains the digits and the tab character).
            </para>
            <para>
            For example:
            <code><![CDATA[
            1			7	8	9	4	5	6
            4	5	6	1	2	3	7	8	9
            7	8	9	4	5	6	1	2	
            9	1	2	6		8	3	4	
            3	4	5				6	7	8
            	7	8	3		5	9	1	2
            	9	1	5	6	7	2	3	4
            2	3	4	8	9	1	5	6	7
            5	6	7	2	3	4			1
            ]]></code>
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Parsing.GridParsingOption.OpenSudoku">
            <summary>
            <para>
            Open sudoku format.
            </para>
            <para>
            For example:
            <code><![CDATA[0|0|1|1|0|0|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|0|0|1|9|0|0|8|0|0|0|0|1|0|0|1|0|0|1|0|0|1|7|0|0|2|0|0|0|0|1|0|0|1|0|0|1|0|0|1|7|0|0|0|0|1|3|0|0|0|0|1|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|9|0|0|2|0|0|6|0|0|0|0|1|0|0|1|8|0|0|0|0|1|0|0|1|7|0|0|0|0|1|0|0|1|0|0|1|3|0|0|0|0|1|0|0|1|4|0|0|5|0|0|0|0|1|6|0|0|0|0|1|0|0|1|0|0|1|3|0|0|0|0|1|1|0|0|0|0|1|0|0|1|1|0|0|7|0|0|0|0|1|8|0|0|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|0|0|1|4|0|0|0|0|1|0|0|1|0|0|1|0|0|1|6|0|0|0|0|1|0|0|1|3|0|0|0|0|1|9|0|0|0|0|1|0|0|1|7|0|0]]></code>
            </para>
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Region">
            <summary>
            Defines a region type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Region.Block">
            <summary>
            Indicates the region type is a block.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Region.Row">
            <summary>
            Indicates the region type is a row.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Region.Column">
            <summary>
            Indicates the region type is a column.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.RegionExtensions">
            <summary>
            Provides extension methods on <see cref="T:Sudoku.Concepts.Region"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Region"/>
        </member>
        <member name="M:Sudoku.Concepts.RegionExtensions.CopyRegionInfo(System.Byte,System.Byte*)">
            <inheritdoc cref="M:Sudoku.Concepts.RegionExtensions.CopyRegionInfo(System.Int32,System.Int32*)"/>
        </member>
        <member name="M:Sudoku.Concepts.RegionExtensions.CopyRegionInfo(System.Int32,System.Int32*)">
            <summary>
            Gets the row, column and block value and copies to the specified array that represents by a pointer
            of 3 elements, where the first element stores the block index, second element stores the row index
            and the third element stores the column index.
            </summary>
            <param name="cell">The cell. The available values must be between 0 and 80.</param>
            <param name="ptr">The specified array that represents by a pointer of 3 elements.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="ptr"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.RegionExtensions.ToRegionIndex(System.Byte,Sudoku.Concepts.Region)">
            <summary>
            Get the region index (0..27 for block 1-9, row 1-9 and column 1-9)
            for the specified cell and the region type.
            </summary>
            <param name="cell">The cell. The available values must be between 0 and 80.</param>
            <param name="region">The region type.</param>
            <returns>The region index. The return value must be between 0 and 26.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="region"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.RegionExtensions.ToRegionIndex(System.Int32,Sudoku.Concepts.Region)">
            <inheritdoc cref="M:Sudoku.Concepts.RegionExtensions.ToRegionIndex(System.Byte,Sudoku.Concepts.Region)"/>
        </member>
        <member name="M:Sudoku.Concepts.RegionExtensions.ToRegion(System.Int32)">
            <summary>
            Get the region type for the specified region index.
            </summary>
            <param name="regionIndex">The region index.</param>
            <returns>
            The region type. The possible return values are:
            <list type="table">
            <listheader>
            <term>Range for the region index</term>
            <description>Return value</description>
            </listheader>
            <item>
            <term><paramref name="regionIndex"/> is <![CDATA[>= 0 and < 9]]></term>
            <description><see cref="F:Sudoku.Concepts.Region.Block"/></description>
            </item>
            <item>
            <term><paramref name="regionIndex"/> is <![CDATA[>= 9 and < 18]]></term>
            <description><see cref="F:Sudoku.Concepts.Region.Row"/></description>
            </item>
            <item>
            <term><paramref name="regionIndex"/> is <![CDATA[>= 18 and < 27]]></term>
            <description><see cref="F:Sudoku.Concepts.Region.Column"/></description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Concepts.Solving.AlmostLockedSet">
            <summary>
            Defines a data structure that describes an ALS.
            </summary>
            <remarks>
            An <b>Almost Locked Set</b> is a sudoku concept, which describes a case that
            <c>n</c> cells contains <c>(n + 1)</c> kinds of different digits.
            The special case is a bi-value cell.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Solving.AlmostLockedSet.StrongRelationsCount">
            <summary>
            Indicates an array of the total number of the strong relations in an ALS of the different size.
            The field is only unsed in the property <see cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.StrongLinksMask"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.StrongLinksMask"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.#ctor(System.Int16,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Initializes an <see cref="T:Sudoku.Concepts.Solving.AlmostLockedSet"/> instance
            via the specified digit mask and the map of cells.
            </summary>
            <param name="digitMask">The digit mask.</param>
            <param name="map">The map.</param>
            <param name="possibleEliminationMap">
            Indicates the possible cells that can be as the elimination.
            </param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlmostLockedSet.Region">
            <summary>
            Indicates the region used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlmostLockedSet.IsBivalueCell">
            <summary>
            Indicates whether the ALS only uses a bi-value cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlmostLockedSet.DigitsMask">
            <summary>
            Indicates the mask of digits used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlmostLockedSet.StrongLinksMask">
            <summary>
            Indicates all strong links in this ALS. The result will be represented
            as a <see cref="T:System.Int16"/> mask of 9 bits indicating which bits used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlmostLockedSet.Map">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlmostLockedSet.PossibleEliminationMap">
            <summary>
            Gets the possible cells that can store eliminations for the ALS.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.ContainsDigit(Sudoku.Concepts.Collections.Grid@,System.Int32,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Indicates whether the specified grid contains the digit.
            </summary>
            <param name="grid">The grid.</param>
            <param name="digit">The digit.</param>
            <param name="result">The result.</param>
            <returns>A <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.Equals(Sudoku.Concepts.Solving.AlmostLockedSet)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Solving.AlmostLockedSet"/> instance holds the same
            <see cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.DigitsMask"/> and <see cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.Map"/> property values as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.GetHashCode">
            <inheritdoc/>
            <remarks>
            If you want to determine the equality of two instance, I recommend you
            <b>should</b> use method <see cref="M:Sudoku.Concepts.Solving.AlmostLockedSet.Equals(Sudoku.Concepts.Solving.AlmostLockedSet)"/> instead of this method.
            </remarks>
            <seealso cref="M:Sudoku.Concepts.Solving.AlmostLockedSet.Equals(Sudoku.Concepts.Solving.AlmostLockedSet)"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.Gather(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Gathers all possible <see cref="T:Sudoku.Concepts.Solving.AlmostLockedSet"/>s in the specified grid.
            </summary>
            <param name="grid">The grid.</param>
            <returns>All possible found <see cref="T:Sudoku.Concepts.Solving.AlmostLockedSet"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.op_Equality(Sudoku.Concepts.Solving.AlmostLockedSet,Sudoku.Concepts.Solving.AlmostLockedSet)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Solving.AlmostLockedSet"/>s hold a same <see cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.DigitsMask"/>
            and <see cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.Map"/> property values.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlmostLockedSet.op_Inequality(Sudoku.Concepts.Solving.AlmostLockedSet,Sudoku.Concepts.Solving.AlmostLockedSet)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Solving.AlmostLockedSet"/>s don't hold a same <see cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.DigitsMask"/>
            and <see cref="P:Sudoku.Concepts.Solving.AlmostLockedSet.Map"/> property values.
            </summary>
            <param name="left">The left-side instance to compare.</param>
            <param name="right">The right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Solving.AlternatingInferenceChain">
            <summary>
            Defines an alternating inference chain. The data structure can describe the following techniques:
            <list type="bullet">
            <item>
            Short chains:
            <list type="bullet">
            <item>Irregular Wings</item>
            </list>
            </item>
            <item>
            Normal chains:
            <list type="bullet">
            <item>Discontinuous Nice Loop</item>
            <item>Alternating Inference Chain</item>
            <!--<item>Continuous Nice Loop</item>-->
            </list>
            </item>
            <item>
            Grouped chains (which means the nodes are not limited in sole candidates):
            <list type="bullet">
            <item>Grouped Discontinuous Nice Loop</item>
            <item>Grouped Alternating Inference Chain</item>
            <!--<item>Grouped Continuous Nice Loop</item>-->
            </list>
            </item>
            </list>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlternatingInferenceChain.#ctor(Sudoku.Concepts.Solving.ChainNodes.Node[],System.Boolean)">
            <summary>
            Initializes an <see cref="T:Sudoku.Concepts.Solving.AlternatingInferenceChain"/> instance via the specified nodes
            and the <see cref="T:System.Boolean"/> value indicating whether the chain starts and ends
            with strong inferences.
            </summary>
            <param name="nodes">The nodes used.</param>
            <param name="isStrong">Indicates whether the chain starts and ends with strong inferences.</param>
            <exception cref="T:System.ArgumentException">
            Throws when the length of the argument <paramref name="nodes"/> is less than or equals 3,
            or the first and the last node aren't the same when the arguemnt <paramref name="isStrong"/>
            is <see langword="true"/>.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlternatingInferenceChain.IsStrong">
            <summary>
            Indicates whether the alternating inference chain starts with a strong inference,
            and ends with another strong inference.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlternatingInferenceChain.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlternatingInferenceChain.RealChainNodes">
            <summary>
            <para>Indicates the nodes that represents the main chain node data for the current chain.</para>
            <para>
            The property value will be different if the property <see cref="P:Sudoku.Concepts.Solving.AlternatingInferenceChain.IsStrong"/> is different.
            <list type="table">
            <listheader>
            <term>The value of the property <see cref="P:Sudoku.Concepts.Solving.AlternatingInferenceChain.IsStrong"/></term>
            <description>Description</description>
            </listheader>
            <item>
            <term><see langword="true"/></term>
            <description>All nodes will be returned (i.e. <c>_nodes[..]</c>).</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>
            Returns the sliced array from the nodes being stored in the current instance,
            without the first and the last node (i.e. <c>_nodes[1..^1]</c>).
            </description>
            </item>
            </list>
            </para>
            </summary>
            <seealso cref="P:Sudoku.Concepts.Solving.AlternatingInferenceChain.IsStrong"/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.AlternatingInferenceChain.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlternatingInferenceChain.Equals(Sudoku.Concepts.Solving.Chain)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlternatingInferenceChain.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlternatingInferenceChain.GetConclusions(Sudoku.Concepts.Collections.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlternatingInferenceChain.InitializeFieldNodeStatus(Sudoku.Concepts.Solving.ChainNodes.Node[],System.Boolean)">
            <summary>
            Try to initializes the field <see cref="F:Sudoku.Concepts.Solving.Chain._nodesStatus"/>.
            </summary>
            <param name="nodes">The nodes.</param>
            <param name="startsWithStrong">
            Indicates whether the chain starts and ends with strong inferences.
            </param>
            <returns>The array of type <see cref="T:System.Boolean"/>[].</returns>
            <seealso cref="F:Sudoku.Concepts.Solving.Chain._nodesStatus"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlternatingInferenceChain.GetEliminationsMultipleDigits(Sudoku.Concepts.Collections.Grid@,System.Int32,System.Int32,System.Byte,System.Byte)">
            <summary>
            Try to get eliminations via different digits.
            </summary>
            <param name="grid">The grid as the candidate reference.</param>
            <param name="c1">The only cell in the first node.</param>
            <param name="c2">The only cell in the second node.</param>
            <param name="d1">The digit 1.</param>
            <param name="d2">The digit 2.</param>
            <returns>The conclusions.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.AlternatingInferenceChain.GetEliminationsSingleDigit(Sudoku.Concepts.Collections.Cells@,System.Byte)">
            <summary>
            Try to get eliminations via the digit and the elimination cells.
            </summary>
            <param name="elimMap">The elimination cells.</param>
            <param name="digit">The digit.</param>
            <returns>The conclusions.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Solving.Chain">
            <summary>
            Defines a chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Chain._nodesStatus">
            <summary>
            Indicates the status of those nodes.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Chain._nodes">
            <summary>
            Indicates the nodes that is used in the current chain.
            Generally, the first element and the last element are same.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.#ctor(Sudoku.Concepts.Solving.ChainNodes.Node[],System.Boolean[])">
            <summary>
            Initializes a instance whose type is derived from <see cref="T:Sudoku.Concepts.Solving.Chain"/>,
            using the specified nodes and their own status respectively.
            </summary>
            <param name="nodes">The nodes.</param>
            <param name="nodesStatus">The nodes' status.</param>
            <exception cref="T:System.ArgumentException">
            Throws when the arguments <paramref name="nodes"/> and <paramref name="nodesStatus"/>
            don't hold the same number of elements.
            </exception>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Chain.Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Chain.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.Equals(Sudoku.Concepts.Solving.Chain)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.GetConclusions(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Gets the conclusions of the current chain.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The conclusions of the current chain.</returns>
            <remarks>
            <para><b>TODO</b>: Append extra eliminations that requires the extended elimination rules.</para>
            <para>
            e.g.
            <code>
            a. 25 | d. 28
            b. 25 | e. 38
            c. 3+ | f. 5+
            </code>
            Chain: <c>a(5) == d(8) -- e(8 == 3) => b != 5</c>, where the cell <c>c</c> and <c>f</c>
            are filled with modifiable values.
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.ToRawArray">
            <summary>
            Creates an array that stores the values with each element of a pair, where:
            <list type="table">
            <item>
            <term>The first tuple element</term>
            <description>The node itself.</description>
            </item>
            <item>
            <term>The second tuple element</term>
            <description>The status of the current node, indicating whether the node is on currently.</description>
            </item>
            </list>
            </summary>
            <returns>An array that stores the values with each element of a pair.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.op_Equality(Sudoku.Concepts.Solving.Chain,Sudoku.Concepts.Solving.Chain)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Concepts.Solving.Chain"/>s are same.
            </summary>
            <param name="left">The left instance to be compared.</param>
            <param name="right">The right instance to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating the result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Chain.op_Inequality(Sudoku.Concepts.Solving.Chain,Sudoku.Concepts.Solving.Chain)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Concepts.Solving.Chain"/>s are not same.
            </summary>
            <param name="left">The left instance to be compared.</param>
            <param name="right">The right instance to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating the result.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ChainNodes.AlmostLockedSetNode">
            <summary>
            Defines a chain node that provides with the data for an almost locked set.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.AlmostLockedSetNode.Shifting">
            <summary>
            Indicates the shifting bits that each cell stores in the <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._other"/> mask.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._other"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.AlmostLockedSetNode.#ctor(System.Byte,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Initializes an <see cref="T:Sudoku.Concepts.Solving.ChainNodes.AlmostLockedSetNode"/> instance via the digit used
            and the cells used.
            </summary>
            <param name="digit">The digit used.</param>
            <param name="cells">The cells used.</param>
            <param name="extraCells">
            Indicates the extra cells that the current ALS used, but the current digit doesn't used.
            </param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.AlmostLockedSetNode.FullCells">
            <summary>
            Indicates the whole ALS map.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.AlmostLockedSetNode.ToSimpleString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.AlmostLockedSetNode.InitOtherMask(Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Gets the part of the other mask value that represents the extra cells used.
            </summary>
            <param name="extraCells">The extra cells used.</param>
            <returns>The mask of type <see cref="T:System.Int64"/>.</returns>
            <exception cref="T:System.ArgumentException">
            Throws when the number of elements in the argument <paramref name="extraCells"/>
            is greater than 8.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ChainNodes.LockedCandidatesNode">
            <summary>
            Defines a chain node that provides with the data for a locked candidates.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.LockedCandidatesNode.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.LockedCandidatesNode"/> instance via the digit used,
            and two cells used.
            </summary>
            <param name="digit">The digit used.</param>
            <param name="cell1">The cell 1.</param>
            <param name="cell2">The cell 2.</param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.LockedCandidatesNode.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.LockedCandidatesNode"/> instance via the digit used,
            and three cells used.
            </summary>
            <param name="digit">The digit used.</param>
            <param name="cell1">The cell 1.</param>
            <param name="cell2">The cell 2.</param>
            <param name="cell3">The cell 3.</param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.LockedCandidatesNode.#ctor(System.Byte,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.LockedCandidatesNode"/> instance via the digit used and cells used.
            </summary>
            <param name="digit">The digit used.</param>
            <param name="cells">The cells used.</param>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ChainNodes.Node">
            <summary>
            Defines a chain node.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.Node.PreservedBitsCount">
            <summary>
            Indicates the number of bits that is preserved by the bit mask field <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._other"/>.
            </summary>
            <seealso cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._other"/>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.Node._higher">
            <summary>
            Indicates the bits used. <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._higher"/> and <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._lower"/>
            store the basic data of the cells used.
            </summary>
            <remarks>
            Please note that the lower 7 bits in the field <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._other"/> are reserved ones,
            which represents the basic data for the digit used, and the type of the node.
            You cannot modify them.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.Node._lower">
            <summary>
            Indicates the bits used. <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._higher"/> and <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._lower"/>
            store the basic data of the cells used.
            </summary>
            <remarks>
            Please note that the lower 7 bits in the field <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._other"/> are reserved ones,
            which represents the basic data for the digit used, and the type of the node.
            You cannot modify them.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.Node._other">
            <summary>
            Indicates the bits used. <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._higher"/> and <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._lower"/>
            store the basic data of the cells used.
            </summary>
            <remarks>
            Please note that the lower 7 bits in the field <see cref="F:Sudoku.Concepts.Solving.ChainNodes.Node._other"/> are reserved ones,
            which represents the basic data for the digit used, and the type of the node.
            You cannot modify them.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.#ctor(Sudoku.Concepts.Solving.ChainNodes.NodeType,System.Byte,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.Node"/> instance via the basic data.
            </summary>
            <param name="nodeType">The node type.</param>
            <param name="digit">The digit used.</param>
            <param name="cells">The cells used.</param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.#ctor(Sudoku.Concepts.Solving.ChainNodes.NodeType,System.Byte,Sudoku.Concepts.Collections.Cells@,System.Int64)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.Node"/> instance via the basic data.
            </summary>
            <param name="nodeType">The node type.</param>
            <param name="digit">The digit used.</param>
            <param name="cells">The cells used.</param>
            <param name="otherMask">
            The other mask. Here the mask provided must preserve the lower 7 bits zeroed
            because they are reserved one.
            </param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.#ctor(System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.Node"/> instance via the basic data.
            </summary>
            <param name="higher">The higher 64 bits.</param>
            <param name="lower">The lower 64 bits.</param>
            <param name="other">The other 64 bits.</param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.Node.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.Node.IsGroupedNode">
            <summary>
            Indicates whether the current node is a grouped node, which means it uses more than 1 cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.Node.Cells">
            <summary>
            Indicates the cells used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.Node.Type">
            <summary>
            Indicates the type of the node.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.Equals(Sudoku.Concepts.Solving.ChainNodes.Node)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.ToSimpleString">
            <summary>
            Gets the simplified string value that only displays the important information.
            </summary>
            <returns>The string value.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.op_Equality(Sudoku.Concepts.Solving.ChainNodes.Node,Sudoku.Concepts.Solving.ChainNodes.Node)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Concepts.Solving.ChainNodes.Node"/>s are same.
            </summary>
            <param name="left">Indicates the left-side instance to compare.</param>
            <param name="right">Indicates the right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.Node.op_Inequality(Sudoku.Concepts.Solving.ChainNodes.Node,Sudoku.Concepts.Solving.ChainNodes.Node)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Concepts.Solving.ChainNodes.Node"/>s are not totally same.
            </summary>
            <param name="left">Indicates the left-side instance to compare.</param>
            <param name="right">Indicates the right-side instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ChainNodes.NodeType">
            <summary>
            Defines a node type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.NodeType.Sole">
            <summary>
            Indicates the node type is a sole candidate.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.NodeType.LockedCandidates">
            <summary>
            Indicates the node type is a locked candidates.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.NodeType.AlmostLockedSets">
            <summary>
            Indicates the node type is an almost locked sets.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ChainNodes.NodeTypeNameAttribute">
            <summary>
            Defines an attribute that can be applied to a field in the type <see cref="T:Sudoku.Concepts.Solving.ChainNodes.NodeType"/>,
            to tell the runtime that the name is bound with the field, in order to display in the console or UI.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Solving.ChainNodes.NodeType"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.NodeTypeNameAttribute.#ctor(System.String)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.NodeTypeNameAttribute"/> instance via the name.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.NodeTypeNameAttribute.Name">
            <summary>
            Indicates the name.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes">
            <summary>
            Defines a node type that provides with the choices for the chain node types.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.None">
            <summary>
            Indicates the searcher doesn't search for any extended-typed nodes.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.SoleDigit">
            <summary>
            Indicates the searcher can search on sole digit in the same region.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.SoleCell">
            <summary>
            Indicates the searcher can search on candidates in a same cell.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.LockedCandidates">
            <summary>
            Indicates the searcher can search for locked candidate nodes.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.LockedSet">
            <summary>
            Indicates the searcher can search for locked set nodes.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.HiddenSet">
            <summary>
            Indicates the searcher can search for hidden set nodes.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.UniqueRectangle">
            <summary>
            Indicates the searcher can search for almost rectangle nodes.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ChainNodes.SearcherNodeTypes.Kraken">
            <summary>
            Indicates the searcher can search for kraken fish nodes.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ChainNodes.SoleCandidateNode">
            <summary>
            Provides with the node that stores a sole candidate.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ChainNodes.SoleCandidateNode.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Solving.ChainNodes.SoleCandidateNode"/> instance via the candidate and its current status.
            </summary>
            <param name="cell">Indicates the cell used.</param>
            <param name="digit">Indicates the digit used.</param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.SoleCandidateNode.Cell">
            <summary>
            Indicates the cell used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ChainNodes.SoleCandidateNode.Candidate">
            <summary>
            Indicates the candidate used.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.Conclusion">
            <summary>
            Encapsulates a conclusion representation while solving in logic.
            </summary>
            <param name="Mask">
            Indicates the mask that holds the information for the cell, digit and the conclusion type.
            The bits distribution is like:
            <code><![CDATA[
            16       8       0
             |-------|-------|
             |     |---------|
            16    10         0
                   |   used  |
            ]]></code>
            </param>
            <remarks>
            Two <see cref="T:Sudoku.Concepts.Solving.Conclusion"/>s can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.Solving.ConclusionType.Elimination"/> as the type), the instance
            will be greater; if those two hold same conclusion type, but one of those two holds
            the global index of the candidate position is greater, it is greater.
            </remarks>
            <seealso cref="F:Sudoku.Concepts.Solving.ConclusionType.Elimination"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.#ctor(System.Int32)">
            <summary>
            Encapsulates a conclusion representation while solving in logic.
            </summary>
            <param name="Mask">
            Indicates the mask that holds the information for the cell, digit and the conclusion type.
            The bits distribution is like:
            <code><![CDATA[
            16       8       0
             |-------|-------|
             |     |---------|
            16    10         0
                   |   used  |
            ]]></code>
            </param>
            <remarks>
            Two <see cref="T:Sudoku.Concepts.Solving.Conclusion"/>s can be compared with each other. If one of those two is an elimination
            (i.e. holds the value <see cref="F:Sudoku.Concepts.Solving.ConclusionType.Elimination"/> as the type), the instance
            will be greater; if those two hold same conclusion type, but one of those two holds
            the global index of the candidate position is greater, it is greater.
            </remarks>
            <seealso cref="F:Sudoku.Concepts.Solving.ConclusionType.Elimination"/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Conclusion.Mask">
            <summary>
            Indicates the mask that holds the information for the cell, digit and the conclusion type.
            The bits distribution is like:
            <code><![CDATA[
            16       8       0
             |-------|-------|
             |     |---------|
            16    10         0
                   |   used  |
            ]]></code>
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Conclusion.Default">
            <summary>
            <inheritdoc cref="P:System.IDefaultable`1.Default"/>
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.#ctor(Sudoku.Concepts.Solving.ConclusionType,System.Int32)">
            <summary>
            Initializes an instance with a conclusion type and a candidate offset.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="candidate">The candidate offset.</param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.#ctor(Sudoku.Concepts.Solving.ConclusionType,System.Int32,System.Int32)">
            <summary>
            Initializes the <see cref="T:Sudoku.Concepts.Solving.Conclusion"/> instance via the specified cell, digit and the conclusion type.
            </summary>
            <param name="type">The conclusion type.</param>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Conclusion.Cell">
            <summary>
            Indicates the cell.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Conclusion.Digit">
            <summary>
            Indicates the digit.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Conclusion.Candidate">
            <summary>
            Indicates the candidate.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Conclusion.ConclusionType">
            <summary>
            The conclusion type to control the action of applying.
            If the type is <see cref="F:Sudoku.Concepts.Solving.ConclusionType.Assignment"/>,
            this conclusion will be set value (Set a digit into a cell);
            otherwise, a candidate will be removed.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Conclusion.System#IDefaultable{Sudoku#Concepts#Solving#Conclusion}#IsDefault">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.Conclusion.System#IDefaultable{Sudoku#Concepts#Solving#Conclusion}#Default">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.Deconstruct(Sudoku.Concepts.Solving.ConclusionType@,System.Int32@)">
            <summary>
            Deconstruct the instance into multiple values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.Deconstruct(Sudoku.Concepts.Solving.ConclusionType@,System.Int32@,System.Int32@)">
            <summary>
            Deconstruct the instance into multiple values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.ApplyTo(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            Put this instance into the specified grid.
            </summary>
            <param name="grid">The grid.</param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.Equals(Sudoku.Concepts.Solving.Conclusion)">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.CompareTo(Sudoku.Concepts.Solving.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.System#IComparable#CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.ToConclusions(Sudoku.Concepts.Collections.Cells@,System.Int32,Sudoku.Concepts.Solving.ConclusionType)">
            <summary>
            Gets the conclusion list whose inner value is from the specified cells,
            the specified digit used and the specified conclusion type.
            </summary>
            <param name="cells">The cells that the conclusions are used.</param>
            <param name="digit">The digit used.</param>
            <param name="type">The type of the conclusion.</param>
            <returns>An array of type <see cref="T:Sudoku.Concepts.Solving.Conclusion"/>.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.op_LessThan(Sudoku.Concepts.Solving.Conclusion,Sudoku.Concepts.Solving.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.op_LessThanOrEqual(Sudoku.Concepts.Solving.Conclusion,Sudoku.Concepts.Solving.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.op_GreaterThan(Sudoku.Concepts.Solving.Conclusion,Sudoku.Concepts.Solving.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.Conclusion.op_GreaterThanOrEqual(Sudoku.Concepts.Solving.Conclusion,Sudoku.Concepts.Solving.Conclusion)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ConclusionType">
            <summary>
            Provides a conclusion type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ConclusionType.Assignment">
            <summary>
            Indicates the conclusion is a value filling into a cell.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.ConclusionType.Elimination">
            <summary>
            Indicates the conclusion is a candidate being remove from a cell.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ConclusionTypeExtensions">
            <summary>
            Provides extension methods on <see cref="T:Sudoku.Concepts.Solving.ConclusionType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Solving.ConclusionType"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ConclusionTypeExtensions.GetNotation(Sudoku.Concepts.Solving.ConclusionType)">
            <summary>
            Gets the notation of the conclusion type.
            </summary>
            <param name="this">The conclusion type.</param>
            <returns>The notation of the conclusion type.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument is not <see cref="F:Sudoku.Concepts.Solving.ConclusionType.Assignment"/>
            or <see cref="F:Sudoku.Concepts.Solving.ConclusionType.Elimination"/>.
            </exception>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ExocetPattern">
            <summary>
            <para>
            Indicates an exocet pattern. The pattern will be like:
            <code><![CDATA[
            .-------.-------.-------.
            | B B E | E . . | E . . |
            | . . E | Q . . | R . . |
            | . . E | Q . . | R . . |
            :-------+-------+-------:
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            :-------+-------+-------:
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            '-------'-------'-------'
            ]]></code>
            Where:
            <list type="table">
            <item><term>B</term><description>Base Cells.</description></item>
            <item><term>Q</term><description>1st Object Pair (Target cells pair 1).</description></item>
            <item><term>R</term><description>2nd Object Pair (Target cells pair 2).</description></item>
            <item><term>S</term><description>Cross-line Cells.</description></item>
            <item><term>E</term><description>Escape Cells.</description></item>
            </list>
            </para>
            <para>
            In the data structure, all letters will be used as the same one in this exemplar.
            In addition, if senior exocet, one of two target cells will lie in cross-line cells,
            and the lines of two target cells lying on can't contain any base digits.
            </para>
            </summary>
            <param name="Base1">Indicates the first base cell.</param>
            <param name="Base2">Indicates the second base cell.</param>
            <param name="TargetQ1">Indicates the first target cell in the Q part.</param>
            <param name="TargetQ2">Indicates the second target cell in the Q part.</param>
            <param name="TargetR1">Indicates the first target cell in the R part.</param>
            <param name="TargetR2">Indicates the second target cell in the R part.</param>
            <param name="MirrorQ1">Indicates the first mirror cell in the Q part.</param>
            <param name="MirrorQ2">Indicates the second mirror cell in the Q part.</param>
            <param name="MirrorR1">Indicates the first mirror cell in the R part.</param>
            <param name="MirrorR2">Indicates the second mirror cell in the R part.</param>
            <param name="CrossLine">Indicates the cross-line cells.</param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ExocetPattern.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            <para>
            Indicates an exocet pattern. The pattern will be like:
            <code><![CDATA[
            .-------.-------.-------.
            | B B E | E . . | E . . |
            | . . E | Q . . | R . . |
            | . . E | Q . . | R . . |
            :-------+-------+-------:
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            :-------+-------+-------:
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            | . . S | S . . | S . . |
            '-------'-------'-------'
            ]]></code>
            Where:
            <list type="table">
            <item><term>B</term><description>Base Cells.</description></item>
            <item><term>Q</term><description>1st Object Pair (Target cells pair 1).</description></item>
            <item><term>R</term><description>2nd Object Pair (Target cells pair 2).</description></item>
            <item><term>S</term><description>Cross-line Cells.</description></item>
            <item><term>E</term><description>Escape Cells.</description></item>
            </list>
            </para>
            <para>
            In the data structure, all letters will be used as the same one in this exemplar.
            In addition, if senior exocet, one of two target cells will lie in cross-line cells,
            and the lines of two target cells lying on can't contain any base digits.
            </para>
            </summary>
            <param name="Base1">Indicates the first base cell.</param>
            <param name="Base2">Indicates the second base cell.</param>
            <param name="TargetQ1">Indicates the first target cell in the Q part.</param>
            <param name="TargetQ2">Indicates the second target cell in the Q part.</param>
            <param name="TargetR1">Indicates the first target cell in the R part.</param>
            <param name="TargetR2">Indicates the second target cell in the R part.</param>
            <param name="MirrorQ1">Indicates the first mirror cell in the Q part.</param>
            <param name="MirrorQ2">Indicates the second mirror cell in the Q part.</param>
            <param name="MirrorR1">Indicates the first mirror cell in the R part.</param>
            <param name="MirrorR2">Indicates the second mirror cell in the R part.</param>
            <param name="CrossLine">Indicates the cross-line cells.</param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.Base1">
            <summary>Indicates the first base cell.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.Base2">
            <summary>Indicates the second base cell.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.TargetQ1">
            <summary>Indicates the first target cell in the Q part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.TargetQ2">
            <summary>Indicates the second target cell in the Q part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.TargetR1">
            <summary>Indicates the first target cell in the R part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.TargetR2">
            <summary>Indicates the second target cell in the R part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.CrossLine">
            <summary>Indicates the cross-line cells.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.MirrorQ1">
            <summary>Indicates the first mirror cell in the Q part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.MirrorQ2">
            <summary>Indicates the second mirror cell in the Q part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.MirrorR1">
            <summary>Indicates the first mirror cell in the R part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.MirrorR2">
            <summary>Indicates the second mirror cell in the R part.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.Map">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.MapWithMirrors">
            <summary>
            Indicates the full map, with mirror cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.BaseCellsMap">
            <summary>
            Indicates the base cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ExocetPattern.TargetCellsMap">
            <summary>
            Indicates the target cells.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ExocetPattern.Equals(Sudoku.Concepts.Solving.ExocetPattern@)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Solving.ExocetPattern"/> instance holds the same cell maps
            as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ExocetPattern.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.ExocetPattern.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Concepts.Solving.ITechniquePattern`1">
            <summary>
            Defines a pattern that is a technique.
            </summary>
            <typeparam name="TSelf">The type of the technique pattern.</typeparam>
        </member>
        <member name="P:Sudoku.Concepts.Solving.ITechniquePattern`1.Map">
            <summary>
            Indicates the whole map of cells that the technique used.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.QiuDeadlyPattern">
            <summary>
            Defines a pattern that is a Qiu's deadly pattern technique structure in theory. The sketch is like:
            <code><![CDATA[
            .-------.-------.-------.
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | P P . | . . . | . . . |
            :-------+-------+-------:
            | S S B | B B B | B B B |
            | S S B | B B B | B B B |
            | . . . | . . . | . . . |
            :-------+-------+-------:
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            Where:
            <list type="table">
            <item><term>P</term><description>Pair Cells.</description></item>
            <item><term>S</term><description>Square Cells.</description></item>
            <item><term>B</term><description>Base-line Cells.</description></item>
            </list>
            </summary>
            <param name="Square">The square cells that is <c>S</c> in that sketch.</param>
            <param name="BaseLine">The base-line cells that is <c>B</c> in that sketch.</param>
            <param name="Pair">The pair cells that is <c>P</c> in that sketch.</param>
        </member>
        <member name="M:Sudoku.Concepts.Solving.QiuDeadlyPattern.#ctor(Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Defines a pattern that is a Qiu's deadly pattern technique structure in theory. The sketch is like:
            <code><![CDATA[
            .-------.-------.-------.
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | P P . | . . . | . . . |
            :-------+-------+-------:
            | S S B | B B B | B B B |
            | S S B | B B B | B B B |
            | . . . | . . . | . . . |
            :-------+-------+-------:
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            Where:
            <list type="table">
            <item><term>P</term><description>Pair Cells.</description></item>
            <item><term>S</term><description>Square Cells.</description></item>
            <item><term>B</term><description>Base-line Cells.</description></item>
            </list>
            </summary>
            <param name="Square">The square cells that is <c>S</c> in that sketch.</param>
            <param name="BaseLine">The base-line cells that is <c>B</c> in that sketch.</param>
            <param name="Pair">The pair cells that is <c>P</c> in that sketch.</param>
        </member>
        <member name="P:Sudoku.Concepts.Solving.QiuDeadlyPattern.Square">
            <summary>The square cells that is <c>S</c> in that sketch.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.QiuDeadlyPattern.BaseLine">
            <summary>The base-line cells that is <c>B</c> in that sketch.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.QiuDeadlyPattern.Pair">
            <summary>The pair cells that is <c>P</c> in that sketch.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.QiuDeadlyPattern.Map">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.QiuDeadlyPattern.Equals(Sudoku.Concepts.Solving.QiuDeadlyPattern@)">
            <summary>
            Determine whether the specified <see cref="T:Sudoku.Concepts.Solving.QiuDeadlyPattern"/> instance holds the same
            cell maps as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Solving.QiuDeadlyPattern.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.QiuDeadlyPattern.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Concepts.Solving.Technique">
            <summary>
            Represents a technique instance, which is used for comparison.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.None">
            <summary>
            The placeholder of this enumeration type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FullHouse">
            <summary>
            Indicates the full house.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.LastDigit">
            <summary>
            Indicates the last digit.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenSingleBlock">
            <summary>
            Indicates the hidden single (in block).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenSingleRow">
            <summary>
            Indicates the hidden single (in row).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenSingleColumn">
            <summary>
            Indicates the hidden single (in column).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NakedSingle">
            <summary>
            Indicates the naked single.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Pointing">
            <summary>
            Indicates the pointing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Claiming">
            <summary>
            Indicates the claiming.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AlmostLockedPair">
            <summary>
            Indicates the almost locked pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AlmostLockedTriple">
            <summary>
            Indicates the almost locked triple.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AlmostLockedQuadruple">
            <summary>
            Indicates the almost locked quadruple.
            The technique may not be useful because it'll be replaced with Sue de Coq.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NakedPair">
            <summary>
            Indicates the naked pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NakedPairPlus">
            <summary>
            Indicates the naked pair plus (naked pair (+)).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.LockedPair">
            <summary>
            Indicates the locked pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenPair">
            <summary>
            Indicates the hidden pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NakedTriple">
            <summary>
            Indicates the naked triple.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NakedTriplePlus">
            <summary>
            Indicates the naked triple plus (naked triple (+)).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.LockedTriple">
            <summary>
            Indicates the locked triple.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenTriple">
            <summary>
            Indicates the hidden triple.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NakedQuadruple">
            <summary>
            Indicates the naked quadruple.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NakedQuadruplePlus">
            <summary>
            Indicates the naked quadruple plus (naked quadruple (+)).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenQuadruple">
            <summary>
            Indicates the hidden quadruple.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.XWing">
            <summary>
            Indicates the X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedXWing">
            <summary>
            Indicates the finned X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiXWing">
            <summary>
            Indicates the sashimi X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedXWing">
            <summary>
            Indicates the siamese finned X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiXWing">
            <summary>
            Indicates the siamese sashimi X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FrankenXWing">
            <summary>
            Indicates the franken X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedFrankenXWing">
            <summary>
            Indicates the finned franken X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiFrankenXWing">
            <summary>
            Indicates the sashimi franken X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedFrankenXWing">
            <summary>
            Indicates the siamese finned franken X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiFrankenXWing">
            <summary>
            Indicates the siamese sashimi franken X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MutantXWing">
            <summary>
            Indicates the mutant X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedMutantXWing">
            <summary>
            Indicates the finned mutant X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiMutantXWing">
            <summary>
            Indicates the sashimi mutant X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedMutantXWing">
            <summary>
            Indicates the siamese finned mutant X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiMutantXWing">
            <summary>
            Indicates the siamese sashimi mutant X-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Swordfish">
            <summary>
            Indicates the swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedSwordfish">
            <summary>
            Indicates the finned swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiSwordfish">
            <summary>
            Indicates the sashimi swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedSwordfish">
            <summary>
            Indicates the siamese finned swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiSwordfish">
            <summary>
            Indicates the siamese sashimi swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FrankenSwordfish">
            <summary>
            Indicates the swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedFrankenSwordfish">
            <summary>
            Indicates the finned franken swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiFrankenSwordfish">
            <summary>
            Indicates the sashimi franken swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedFrankenSwordfish">
            <summary>
            Indicates the siamese finned franken swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiFrankenSwordfish">
            <summary>
            Indicates the siamese sashimi franken swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MutantSwordfish">
            <summary>
            Indicates the mutant swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedMutantSwordfish">
            <summary>
            Indicates the finned mutant swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiMutantSwordfish">
            <summary>
            Indicates the sashimi mutant swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedMutantSwordfish">
            <summary>
            Indicates the siamese finned mutant swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiMutantSwordfish">
            <summary>
            Indicates the siamese sashimi mutant swordfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Jellyfish">
            <summary>
            Indicates the jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedJellyfish">
            <summary>
            Indicates the finned jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiJellyfish">
            <summary>
            Indicates the sashimi jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedJellyfish">
            <summary>
            Indicates the siamese finned jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiJellyfish">
            <summary>
            Indicates the siamese sashimi jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FrankenJellyfish">
            <summary>
            Indicates the franken jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedFrankenJellyfish">
            <summary>
            Indicates the finned franken jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiFrankenJellyfish">
            <summary>
            Indicates the sashimi franken jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedFrankenJellyfish">
            <summary>
            Indicates the siamese finned franken jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiFrankenJellyfish">
            <summary>
            Indicates the siamese sashimi franken jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MutantJellyfish">
            <summary>
            Indicates the mutant jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedMutantJellyfish">
            <summary>
            Indicates the finned mutant jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiMutantJellyfish">
            <summary>
            Indicates the sashimi mutant jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedMutantJellyfish">
            <summary>
            Indicates the siamese finned mutant jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiMutantJellyfish">
            <summary>
            Indicates the siamese sashimi mutant jellyfish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Squirmbag">
            <summary>
            Indicates the squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedSquirmbag">
            <summary>
            Indicates the finned squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiSquirmbag">
            <summary>
            Indicates the sashimi squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedSquirmbag">
            <summary>
            Indicates the siamese finned squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiSquirmbag">
            <summary>
            Indicates the siamese sashimi squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FrankenSquirmbag">
            <summary>
            Indicates the franken squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedFrankenSquirmbag">
            <summary>
            Indicates the finned franken squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiFrankenSquirmbag">
            <summary>
            Indicates the sashimi franken squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedFrankenSquirmbag">
            <summary>
            Indicates the siamese finned franken squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiFrankenSquirmbag">
            <summary>
            Indicates the siamese sashimi franken squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MutantSquirmbag">
            <summary>
            Indicates the mutant squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedMutantSquirmbag">
            <summary>
            Indicates the finned mutant squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiMutantSquirmbag">
            <summary>
            Indicates the sashimi mutant squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedMutantSquirmbag">
            <summary>
            Indicates the siamese finned mutant squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiMutantSquirmbag">
            <summary>
            Indicates the siamese sashimi mutant squirmbag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Whale">
            <summary>
            Indicates the whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedWhale">
            <summary>
            Indicates the finned whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiWhale">
            <summary>
            Indicates the sashimi whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedWhale">
            <summary>
            Indicates the siamese finned whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiWhale">
            <summary>
            Indicates the siamese sashimi whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FrankenWhale">
            <summary>
            Indicates the franken whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedFrankenWhale">
            <summary>
            Indicates the finned franken whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiFrankenWhale">
            <summary>
            Indicates the sashimi franken whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedFrankenWhale">
            <summary>
            Indicates the siamese finned franken whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiFrankenWhale">
            <summary>
            Indicates the siamese sashimi franken whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MutantWhale">
            <summary>
            Indicates the mutant whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedMutantWhale">
            <summary>
            Indicates the finned mutant whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiMutantWhale">
            <summary>
            Indicates the sashimi mutant whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedMutantWhale">
            <summary>
            Indicates the siamese finned mutant whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiMutantWhale">
            <summary>
            Indicates the siamese sashimi mutant whale.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Leviathan">
            <summary>
            Indicates the leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedLeviathan">
            <summary>
            Indicates the finned leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiLeviathan">
            <summary>
            Indicates the sashimi leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedLeviathan">
            <summary>
            Indicates the siamese finned leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiLeviathan">
            <summary>
            Indicates the siamese sashimi leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FrankenLeviathan">
            <summary>
            Indicates the franken leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedFrankenLeviathan">
            <summary>
            Indicates the finned franken leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiFrankenLeviathan">
            <summary>
            Indicates the sashimi franken leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedFrankenLeviathan">
            <summary>
            Indicates the siamese finned franken leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiFrankenLeviathan">
            <summary>
            Indicates the siamese sashimi franken leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MutantLeviathan">
            <summary>
            Indicates the mutant leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FinnedMutantLeviathan">
            <summary>
            Indicates the finned mutant leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SashimiMutantLeviathan">
            <summary>
            Indicates the sashimi mutant leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseFinnedMutantLeviathan">
            <summary>
            Indicates the siamese finned mutant leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSashimiMutantLeviathan">
            <summary>
            Indicates the siamese sashimi mutant leviathan.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.XyWing">
            <summary>
            Indicates the XY-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.XyzWing">
            <summary>
            Indicates the XYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.WxyzWing">
            <summary>
            Indicates the WXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.VwxyzWing">
            <summary>
            Indicates the VWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UvwxyzWing">
            <summary>
            Indicates the UVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.TuvwxyzWing">
            <summary>
            Indicates the TUVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.StuvwxyzWing">
            <summary>
            Indicates the STUVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.RstuvwxyzWing">
            <summary>
            Indicates the RSTUVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.IncompleteWxyzWing">
            <summary>
            Indicates the incomplete WXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.IncompleteVwxyzWing">
            <summary>
            Indicates the incomplete VWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.IncompleteUvwxyzWing">
            <summary>
            Indicates the incomplete UVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.IncompleteTuvwxyzWing">
            <summary>
            Indicates the incomplete TUVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.IncompleteStuvwxyzWing">
            <summary>
            Indicates the incomplete STUVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.IncompleteRstuvwxyzWing">
            <summary>
            Indicates the incomplete RSTUVWXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.WWing">
            <summary>
            Indicates the W-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MWing">
            <summary>
            Indicates the M-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.LocalWing">
            <summary>
            Indicates the local wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SplitWing">
            <summary>
            Indicates the split wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HybridWing">
            <summary>
            Indicates the hybrid wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedXyWing">
            <summary>
            Indicates the grouped XY-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedWWing">
            <summary>
            Indicates the grouped W-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedMWing">
            <summary>
            Indicates the grouped M-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedLocalWing">
            <summary>
            Indicates the grouped local wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedSplitWing">
            <summary>
            Indicates the grouped split wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedHybridWing">
            <summary>
            Indicates the grouped hybrid wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleType1">
            <summary>
            Indicates the unique rectangle type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleType2">
            <summary>
            Indicates the unique rectangle type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleType3">
            <summary>
            Indicates the unique rectangle type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleType4">
            <summary>
            Indicates the unique rectangle type 4.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleType5">
            <summary>
            Indicates the unique rectangle type 5.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleType6">
            <summary>
            Indicates the unique rectangle type 6.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenUniqueRectangle">
            <summary>
            Indicates the hidden unique rectangle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle2D">
            <summary>
            Indicates the unique rectangle + 2D.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle2B1">
            <summary>
            Indicates the unique rectangle + 2B / 1SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle2D1">
            <summary>
            Indicates the unique rectangle + 2D / 1SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle3X">
            <summary>
            Indicates the unique rectangle + 3X.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle3X1L">
            <summary>
            Indicates the unique rectangle + 3x / 1SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle3X1U">
            <summary>
            Indicates the unique rectangle + 3X / 1SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle3X2">
            <summary>
            Indicates the unique rectangle + 3X / 2SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle3N2">
            <summary>
            Indicates the unique rectangle + 3N / 2SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle3U2">
            <summary>
            Indicates the unique rectangle + 3U / 2SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle3E2">
            <summary>
            Indicates the unique rectangle + 3E / 2SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle4X1L">
            <summary>
            Indicates the unique rectangle + 4x / 1SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle4X1U">
            <summary>
            Indicates the unique rectangle + 4X / 1SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle4X2L">
            <summary>
            Indicates the unique rectangle + 4x / 2SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle4X2U">
            <summary>
            Indicates the unique rectangle + 4X / 2SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle4X3">
            <summary>
            Indicates the unique rectangle + 4X / 3SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangle4C3">
            <summary>
            Indicates the unique rectangle + 4C / 3SL.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleXyWing">
            <summary>
            Indicates the unique rectangle-XY-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleXyzWing">
            <summary>
            Indicates the unique rectangle-XYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleWxyzWing">
            <summary>
            Indicates the unique rectangle-WXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleSueDeCoq">
            <summary>
            Indicates the unique rectangle sue de coq.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleUnknownCovering">
            <summary>
            Indicates the unique rectangle unknown covering.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueRectangleBrokenWing">
            <summary>
            Indicates the unique rectangle guardian.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleType1">
            <summary>
            Indicates the avoidable rectangle type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleType2">
            <summary>
            Indicates the avoidable rectangle type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleType3">
            <summary>
            Indicates the avoidable rectangle type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleType5">
            <summary>
            Indicates the avoidable rectangle type 5.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.HiddenAvoidableRectangle">
            <summary>
            Indicates the hidden avoidable rectangle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangle2D">
            <summary>
            Indicates the avoidable rectangle + 2D.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangle3X">
            <summary>
            Indicates the avoidable rectangle + 3X.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleXyWing">
            <summary>
            Indicates the avoidable rectangle XY-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleXyzWing">
            <summary>
            Indicates the avoidable rectangle XYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleWxyzWing">
            <summary>
            Indicates the avoidable rectangle WXYZ-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleSueDeCoq">
            <summary>
            Indicates the avoidable rectangle sue de coq.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleBrokenWing">
            <summary>
            Indicates the avoidable rectangle guardian.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleHiddenSingleBlock">
            <summary>
            Indicates the avoidable rectangle hidden single in block.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleHiddenSingleRow">
            <summary>
            Indicates the avoidable rectangle hidden single in row.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AvoidableRectangleHiddenSingleColumn">
            <summary>
            Indicates the avoidable rectangle hidden single in column.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueLoopType1">
            <summary>
            Indicates the unique loop type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueLoopType2">
            <summary>
            Indicates the unique loop type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueLoopType3">
            <summary>
            Indicates the unique loop type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueLoopType4">
            <summary>
            Indicates the unique loop type 4.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ExtendedRectangleType1">
            <summary>
            Indicates the extended rectangle type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ExtendedRectangleType2">
            <summary>
            Indicates the extended rectangle type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ExtendedRectangleType3">
            <summary>
            Indicates the extended rectangle type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ExtendedRectangleType4">
            <summary>
            Indicates the extended rectangle type 4.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGraveType1">
            <summary>
            Indicates the bi-value universal grave type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGraveType2">
            <summary>
            Indicates the bi-value universal grave type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGraveType3">
            <summary>
            Indicates the bi-value universal grave type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGraveType4">
            <summary>
            Indicates the bi-value universal grave type 4.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGravePlusN">
            <summary>
            Indicates the bi-value universal grave + n.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGravePlusNForcingChains">
            <summary>
            Indicates the bi-value universal grave + n with forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGraveXzRule">
            <summary>
            Indicates the bi-value universal grave XZ rule.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueUniversalGraveXyWing">
            <summary>
            Indicates the bi-value universal grave XY-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniquePolygonType1">
            <summary>
            Indicates the unique polygon type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniquePolygonType2">
            <summary>
            Indicates the unique polygon type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniquePolygonType3">
            <summary>
            Indicates the unique polygon type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniquePolygonType4">
            <summary>
            Indicates the unique polygon type 4.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.QiuDeadlyPatternType1">
            <summary>
            Indicates the Qiu's deadly pattern type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.QiuDeadlyPatternType2">
            <summary>
            Indicates the Qiu's deadly pattern type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.QiuDeadlyPatternType3">
            <summary>
            Indicates the Qiu's deadly pattern type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.QiuDeadlyPatternType4">
            <summary>
            Indicates the Qiu's deadly pattern type 4.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.LockedQiuDeadlyPattern">
            <summary>
            Indicates the locked Qiu's deadly pattern.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueSquareType1">
            <summary>
            Indicates the unique square type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueSquareType2">
            <summary>
            Indicates the unique square type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueSquareType3">
            <summary>
            Indicates the unique square type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.UniqueSquareType4">
            <summary>
            Indicates the unique square type 4.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SueDeCoq">
            <summary>
            Indicates the sue de coq.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SueDeCoqIsolated">
            <summary>
            Indicates the sue de coq with isolated digit.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SueDeCoq3Dimension">
            <summary>
            Indicates the 3-dimensional sue de coq.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SueDeCoqCannibalism">
            <summary>
            Indicates the sue de coq cannibalism.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.Skyscraper">
            <summary>
            Indicates the skyscraper.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.TwoStringKite">
            <summary>
            Indicates the two-string kite.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.TurbotFish">
            <summary>
            Indicates the turbot fish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.EmptyRectangle">
            <summary>
            Indicates the empty rectangle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BrokenWing">
            <summary>
            Indicates the broken wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueOddagonType1">
            <summary>
            Indicates the bi-value oddagon type 1.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueOddagonType2">
            <summary>
            Indicates the bi-value oddagon type 2.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BivalueOddagonType3">
            <summary>
            Indicates the bi-value oddagon type 3.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedBivalueOddagon">
            <summary>
            Indicates the grouped bi-value oddagon.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.XChain">
            <summary>
            Indicates the X-Chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.YChain">
            <summary>
            Indicates the Y-Chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.FishyCycle">
            <summary>
            Indicates the fishy cycle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.XyChain">
            <summary>
            Indicates the XY-Chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.XyCycle">
            <summary>
            Indicates the XY-Cycle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.XyXChain">
            <summary>
            Indicates the XY-X-Chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.PurpleCow">
            <summary>
            Indicates the purple cow.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DiscontinuousNiceLoop">
            <summary>
            Indicates the discontinuous nice loop.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ContinuousNiceLoop">
            <summary>
            Indicates the continuous nice loop.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AlternatingInferenceChain">
            <summary>
            Indicates the alternating inference chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedXChain">
            <summary>
            Indicates the grouped X-Chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedFishyCycle">
            <summary>
            Indicates the grouped fishy cycle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedXyChain">
            <summary>
            Indicates the grouped XY-Chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedXyCycle">
            <summary>
            Indicates the grouped XY-Cycle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedXyXChain">
            <summary>
            Indicates the grouped XY-X-Chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedPurpleCow">
            <summary>
            Indicates the grouped purple cow.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedDiscontinuousNiceLoop">
            <summary>
            Indicates the grouped discontinuous nice loop.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedContinuousNiceLoop">
            <summary>
            Indicates the grouped continuous nice loop.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GroupedAlternatingInferenceChain">
            <summary>
            Indicates the grouped alternating inference chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.NishioForcingChains">
            <summary>
            Indicates the nishio forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.RegionForcingChains">
            <summary>
            Indicates the region forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.CellForcingChains">
            <summary>
            Indicates the cell forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DynamicRegionForcingChains">
            <summary>
            Indicates the dynamic region forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DynamicCellForcingChains">
            <summary>
            Indicates the dynamic cell forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DynamicContradictionForcingChains">
            <summary>
            Indicates the dynamic contradiction forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DynamicDoubleForcingChains">
            <summary>
            Indicates the dynamic double forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DynamicForcingChains">
            <summary>
            Indicates the dynamic forcing chains.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.EmptyRectangleIntersectionPair">
            <summary>
            Indicates the empty rectangle intersection pair.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ExtendedSubsetPrinciple">
            <summary>
            Indicates the extended subset principle.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SinglyLinkedAlmostLockedSetsXzRule">
            <summary>
            Indicates the singly linked ALS-XZ.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DoublyLinkedAlmostLockedSetsXzRule">
            <summary>
            Indicates the doubly linked ALS-XZ.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AlmostLockedSetsXyWing">
            <summary>
            Indicates the ALS-XY-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.AlmostLockedSetsWWing">
            <summary>
            Indicates the ALS-W-Wing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DeathBlossom">
            <summary>
            Indicates the death blossom.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.GurthSymmetricalPlacement">
            <summary>
            Indicates the Gurth's symmetrical placement.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ExtendedGurthSymmetricalPlacement">
            <summary>
            Indicates the extended Gurth's symmetrical placement.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.JuniorExocet">
            <summary>
            Indicates the junior exocet.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SeniorExocet">
            <summary>
            Indicates the senior exocet.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.ComplexSeniorExocet">
            <summary>
            Indicates the complex senior exocet.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseJuniorExocet">
            <summary>
            Indicates the siamese junior exocet.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.SiameseSeniorExocet">
            <summary>
            Indicates the siamese senior exocet.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.DominoLoop">
            <summary>
            Indicates the domino loop.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.MultisectorLockedSets">
            <summary>
            Indicates the multi-sector locked sets.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.PatternOverlay">
            <summary>
            Indicates the pattern overlay method.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.TemplateSet">
            <summary>
            Indicates the template set.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.TemplateDelete">
            <summary>
            Indicates the template delete.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BowmanBingo">
            <summary>
            Indicates the bowman's bingo.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.Technique.BruteForce">
            <summary>
            Indicates the brute force.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.TechniqueGroup">
            <summary>
            Indicates a technique group.
            </summary>
            <remarks>
            Different with <see cref="T:Sudoku.Concepts.Solving.TechniqueTags"/>, this enumeration type contains
            the real technique group that the technique belongs to. In addition, the value
            of this type may effect the displaying of the analysis result.
            </remarks>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.None">
            <summary>
            Indicates the technique doesn't belong to any group.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.Single">
            <summary>
            Indicates the singles technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.LockedCandidates">
            <summary>
            Indicates the locked candidates (LC) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.Subset">
            <summary>
            Indicates the subset technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.NormalFish">
            <summary>
            Indicates the normal fish technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.ComplexFish">
            <summary>
            Indicates the complex fish technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.Wing">
            <summary>
            Indicates the wing technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.EmptyRectangle">
            <summary>
            Indicates the empty rectangle technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.SingleDigitPattern">
            <summary>
            Indicates the single digit pattern (SDP) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.EmptyRectangleIntersectionPair">
            <summary>
            Indicates the empty rectangle intersection pair (ERIP) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.AlmostLockedCandidates">
            <summary>
            Indicates the almost locked candidates (ALC) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.AlternatingInferenceChain">
            <summary>
            Indicates the alternating inference chain (AIC) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.ForcingChains">
            <summary>
            Indicates the forcing chains (FC) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.UniqueRectangle">
            <summary>
            Indicates the unique rectangle (UR) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.UniqueRectanglePlus">
            <summary>
            Indicates the unique rectangle plus (UR+) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.UniqueLoop">
            <summary>
            Indicates the unique loop (UL) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.ExtendedRectangle">
            <summary>
            Indicates the extended rectangle (XR) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.BivalueUniversalGrave">
            <summary>
            Indicates the bi-value universal grave (BUG) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.ReverseBivalueUniversalGrave">
            <summary>
            Indicates the reverse bi-value universal grave (Reverse BUG) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.DeadlyPattern">
            <summary>
            Indicates the deadly pattern technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.BivalueOddagon">
            <summary>
            Indicates the bi-value oddagon technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.SueDeCoq">
            <summary>
            Indicates the sue de coq (SdC) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.BrokenWing">
            <summary>
            Indicates the broken wing technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.AlmostLockedSetsChainingLike">
            <summary>
            Indicates the ALS chaining-like (ALS-XZ, ALS-XY-Wing, ALS-W-Wing) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.DominoLoop">
            <summary>
            Indicates the SK-Loop technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.MultisectorLockedSets">
            <summary>
            Indicates the multi-sector locked sets (MSLS) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.Exocet">
            <summary>
            Indicates the exocet technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.Symmetry">
            <summary>
            Indicates the symmetry technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.RankTheory">
            <summary>
            Indicates the technique checked and searched relies on the rank theory.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.BowmanBingo">
            <summary>
            Indicates the bowman bingo technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.PatternOverlay">
            <summary>
            Indicates the pattern overlay method (POM) technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.Templating">
            <summary>
            Indicates the templating technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueGroup.BruteForce">
            <summary>
            Indicates the brute force (BF) technique.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.TechniqueTags">
            <summary>
            Provides a series of tags to mark on a technique.
            </summary>
            <remarks>
            For example, a <see cref="F:Sudoku.Concepts.Solving.Technique.DeathBlossom"/> can be categorized
            as both <see cref="F:Sudoku.Concepts.Solving.TechniqueTags.Als"/> and <see cref="F:Sudoku.Concepts.Solving.TechniqueTags.LongChaining"/>.
            </remarks>
            <seealso cref="F:Sudoku.Concepts.Solving.TechniqueTags.Als"/>
            <seealso cref="F:Sudoku.Concepts.Solving.TechniqueTags.LongChaining"/>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.None">
            <summary>
            Indicates none of flags that the technique belongs to.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Singles">
            <summary>
            Indicates the singles technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Intersections">
            <summary>
            Indicates the intersection technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Subsets">
            <summary>
            Indicates the subset technique. Please note that all ALS techniques shouldn't be with this flag.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Fishes">
            <summary>
            Indicates the fish technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Wings">
            <summary>
            Indicates the wing technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.SingleDigitPattern">
            <summary>
            Indicates the single digit pattern technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.ShortChaining">
            <summary>
            Indicates the short chain.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.LongChaining">
            <summary>
            Indicates the long chain, which includes normal AICs, forcing chains
            and other chaining-like techniques, such as Bowman's Bingo.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.ForcingChains">
            <summary>
            Indicates the forcing chains technique, such as Bowman's Bingo, Region Forcing Chains and so on.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.DeadlyPattern">
            <summary>
            Indicates the deadly pattern technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Als">
            <summary>
            Indicates the ALS technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Msls">
            <summary>
            Indicates the MSLS technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Exocet">
            <summary>
            Indicates the exocet technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.RankTheory">
            <summary>
            Indicates the technique checked and searched relies on the rank theory.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.Symmetry">
            <summary>
            Indicates the symmetry technique.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Solving.TechniqueTags.LastResort">
            <summary>
            Indicates the last resort technique.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Solving.UniquePolygonPattern">
            <summary>
            Defines a pattern that is a unique polygon technique structure in theory. The sketch is like:
            <code><![CDATA[
            .-------.-------.-------.
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            :-------+-------+-------:
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | . . . | . . . | P P . |
            :-------+-------+-------:
            | . . . | . . Q | S S . |
            | . . . | . . Q | S(S). |
            | . . . | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            Where:
            <list type="table">
            <item><term>P</term><description>The first group of cells.</description></item>
            <item><term>Q</term><description>The second group of cells.</description></item>
            <item>
            <term>S</term>
            <description>
            The square cells of size 3 or 4. The cell with the bracket (r8c8 in the picture)
            is optional.
            </description>
            </item>
            </list>
            </summary>
            <param name="Mask">The mask that forms a structure.</param>
            <remarks>
            <para>
            This <see cref="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Mask"/> is of type <see cref="T:System.Int64"/>,
            where the distribution of each bit is as follows:
            <code><![CDATA[
            0      7     14     21     28     35     42     49     56
                                                            
            |-------|-------|-------|-------|-------|-------|-------|-------|
                                                                    
            0       8      16      24      32      40      48      56      64
            ]]></code>
            where the bit <c>[0..56]</c> is for 8 cells, the last 7 bits determine the pattern is a
            heptagon or a octagon. If the value is 127 (not available), the pattern will be a heptagon.
            </para>
            <para>
            Due to the rendering engine, you have to check this file rather than the tip window.
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Solving.UniquePolygonPattern.#ctor(System.Int64)">
            <summary>
            Defines a pattern that is a unique polygon technique structure in theory. The sketch is like:
            <code><![CDATA[
            .-------.-------.-------.
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            :-------+-------+-------:
            | . . . | . . . | . . . |
            | . . . | . . . | . . . |
            | . . . | . . . | P P . |
            :-------+-------+-------:
            | . . . | . . Q | S S . |
            | . . . | . . Q | S(S). |
            | . . . | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            Where:
            <list type="table">
            <item><term>P</term><description>The first group of cells.</description></item>
            <item><term>Q</term><description>The second group of cells.</description></item>
            <item>
            <term>S</term>
            <description>
            The square cells of size 3 or 4. The cell with the bracket (r8c8 in the picture)
            is optional.
            </description>
            </item>
            </list>
            </summary>
            <param name="Mask">The mask that forms a structure.</param>
            <remarks>
            <para>
            This <see cref="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Mask"/> is of type <see cref="T:System.Int64"/>,
            where the distribution of each bit is as follows:
            <code><![CDATA[
            0      7     14     21     28     35     42     49     56
                                                            
            |-------|-------|-------|-------|-------|-------|-------|-------|
                                                                    
            0       8      16      24      32      40      48      56      64
            ]]></code>
            where the bit <c>[0..56]</c> is for 8 cells, the last 7 bits determine the pattern is a
            heptagon or a octagon. If the value is 127 (not available), the pattern will be a heptagon.
            </para>
            <para>
            Due to the rendering engine, you have to check this file rather than the tip window.
            </para>
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Mask">
            <summary>The mask that forms a structure.</summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.IsHeptagon">
            <summary>
            Indicates whether the specified pattern is a heptagon.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Pair1Map">
            <summary>
            Indicates the map of pair 1 cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Pair2Map">
            <summary>
            Indicates the map of pair 2 cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.CenterCellsMap">
            <summary>
            The map of other three (or four) cells.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Map">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Pair1">
            <summary>
            Indicates the pair 1.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.Pair2">
            <summary>
            Indicates the pair 2.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Solving.UniquePolygonPattern.CenterCells">
            <summary>
            Indicates the other three (or four) cells.
            </summary>
            <remarks>
            <b>If and only if</b> the fourth value in the returned quadruple is available.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Solving.UniquePolygonPattern.Deconstruct(System.ValueTuple{System.Int32,System.Int32}@,System.ValueTuple{System.Int32,System.Int32}@,System.ValueTuple{System.Int32,System.Int32,System.Int32,System.Int32}@)">
            <summary>
            Deconstruct the instance to multiple values.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Solving.UniquePolygonPattern.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Solving.UniquePolygonPattern.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Concepts.SymmetryType">
            <summary>
            Define a symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.None">
            <summary>
            Indicates none of symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.Central">
            <summary>
            Indicates the central symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.Diagonal">
            <summary>
            Indicates the diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.AntiDiagonal">
            <summary>
            Indicates the anti-diagonal symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.XAxis">
            <summary>
            Indicates the x-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.YAxis">
            <summary>
            Indicates the y-axis symmetry type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.AxisBoth">
            <summary>
            Indicates both X-axis and Y-axis symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.DiagonalBoth">
            <summary>
            Indicates both diagonal and anti-diagonal symmetry types.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.SymmetryType.All">
            <summary>
            Indicates all symmetry types should be satisfied.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.SymmetryTypeExtensions">
            <summary>
            Provides extension methods for <see cref="T:Sudoku.Concepts.SymmetryType"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.SymmetryType"/>
        </member>
        <member name="M:Sudoku.Concepts.SymmetryTypeExtensions.GetName(Sudoku.Concepts.SymmetryType)">
            <summary>
            Get the name of the current symmetry type.
            </summary>
            <param name="this">The type.</param>
            <returns>The name.</returns>
        </member>
        <member name="T:Sudoku.Solving.Collections.ExocetEliminatedReason">
            <summary>
            Encapsulates a type that represents the reason why the exocet eliminations can be removed.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.Basic">
            <summary>
            Indicates the elimination is the basic elimination (Target eliminations).
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.TargetInference">
            <summary>
            Indicates the target inference eliminations (that is eliminated via mirror cells).
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.Mirror">
            <summary>
            Indicates the mirror eliminations.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.BiBiPattern">
            <summary>
            Indicates the bi-bi pattern.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.TargetPair">
            <summary>
            Indicates the target pair eliminations.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.GeneralizedSwordfish">
            <summary>
            Indicates the generalized swordfish eliminations.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.TrueBase">
            <summary>
            Indicates the true base eliminations.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.Collections.ExocetEliminatedReason.CompatibilityTest">
            <summary>
            Indicates the compatibility test eliminations.
            </summary>
        </member>
        <member name="T:Sudoku.Solving.BacktrackingSolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using backtracking algorithm.
            </summary>
            <remarks>
            <para>
            Please note that the solve has no optimization on solving sudokus, sometimes the puzzle will be
            extremely slowly to be solved although it is not very hard. One of the examples described above
            is this:
            <code>
            ..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9
            </code>
            The solver will spend about 4.5 min on solving this puzzle.
            </para>
            <para>
            For more information, please visit <see href="http://www.matrix67.com/blog/archives/725">this link</see>.
            </para>
            </remarks>
        </member>
        <member name="M:Sudoku.Solving.BacktrackingSolver.Solve(Sudoku.Concepts.Collections.Grid@,Sudoku.Concepts.Collections.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Solving.BitwiseSolver">
            <summary>
            Indicates the solver that is able to solve a sudoku puzzle, and then get the solution of that sudoku.
            </summary>
            <remarks>
            The reason why the type name contains the word <i>bitwise</i> is that the solver uses the bitwise algorithm
            to handle a sudoku grid, which is efficient.
            </remarks>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.BufferLength">
            <summary>
            The buffer length of a solution puzzle.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.BitSet27">
            <summary>
            All pencil marks set - 27 bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver._stack">
            <summary>
            Stack to store current and previous states.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver._singleApplied">
            <summary>
            Nasty global flag telling if <see cref="M:Sudoku.Solving.BitwiseSolver.ApplySingleOrEmptyCells"/> found anything.
            </summary>
            <seealso cref="M:Sudoku.Solving.BitwiseSolver.ApplySingleOrEmptyCells"/>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver._solution">
            <summary>
            Pointer to where to store the first solution. This value can be <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver._numSolutions">
            <summary>
            The number of solutions found so far.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver._limitSolutions">
            <summary>
            The max number of solution we're looking for.
            </summary>
            <remarks>
            For the consideration on the performance, I have refused to use auto-implemented property instead.
            </remarks>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver._g">
            <summary>
            Pointer to the currently active slot.
            </summary>
        </member>
        <member name="P:Sudoku.Solving.BitwiseSolver.LimitSolutions">
            <summary>
            Indicates the number of solutions found.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.Solve(Sudoku.Concepts.Collections.Grid@,Sudoku.Concepts.Collections.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.Solve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The pointer to the puzzle.</param>
            <param name="solution">The solution. <see langword="null"/> if you don't want to use the value.</param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="puzzle"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.Solve(System.String,System.Char*,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The puzzle.</param>
            <param name="solution">The solution. <see langword="null"/> if you don't want to use the value.</param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.Solve(System.String,System.String@,System.Int32)">
            <summary>
            The inner solver.
            </summary>
            <param name="puzzle">The puzzle.</param>
            <param name="solution">
            The solution. The value keeps <see langword="null"/> if you doesn't want to use this result.
            </param>
            <param name="limit">The limit.</param>
            <returns>The number of all solutions.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.CheckValidity(System.Char*,System.Boolean)">
            <summary>
            Same as <see cref="M:Sudoku.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <param name="clearFirst">
            Indicates whether the memory will be released before solving or validating.
            The default value is <see langword="true"/>.
            </param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="grid"/> is <see langword="null"/>.
            </exception>
            <seealso cref="M:Sudoku.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.CheckValidity(System.String)">
            <summary>
            Same as <see cref="M:Sudoku.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>, but doesn't contain
            any <see langword="out"/> parameters.
            </summary>
            <param name="grid">The grid.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
            <seealso cref="M:Sudoku.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)"/>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.CheckValidity(System.String,System.String@)">
            <summary>
            Check the validity of the puzzle.
            </summary>
            <param name="grid">The grid.</param>
            <param name="solutionIfUnique">The solution if the puzzle is unique.</param>
            <returns>The <see cref="T:System.Boolean"/> result. <see langword="true"/> for unique solution.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.Solve(Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To solve the puzzle, and get the solution.
            </summary>
            <param name="puzzle">The puzzle to solve.</param>
            <returns>The solution. If failed to solve, <see cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>.</returns>
            <seealso cref="F:Sudoku.Concepts.Collections.Grid.Undefined"/>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.SetSolvedDigit(System.Int32,System.Int32)">
            <summary>
            Set a cell as solved - used in <see cref="M:Sudoku.Solving.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.EliminateDigit(System.Int32,System.Int32)">
            <summary>
            Eliminate a digit - used in <see cref="M:Sudoku.Solving.BitwiseSolver.InitSudoku(System.Char*)"/>.
            </summary>
            <param name="cell">The cell.</param>
            <param name="digit">The digit.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.SetSolvedMask(System.Int32,System.UInt32)">
            <summary>
            Set a cell as solved - used in various guess routines.
            </summary>
            <param name="band">The band.</param>
            <param name="mask">The mask.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.InitSudoku(System.Char*)">
            <summary>
            Setup everything and load the puzzle.
            </summary>
            <param name="puzzle">The pointer that points to a puzzle buffer.</param>
            <returns>The <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.Update">
            <summary>
            Core of fast processing.
            </summary>
            <returns>The <see cref="T:System.Boolean"/> value.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.ApplySingleOrEmptyCells">
            <summary>
            Find singles, bi-value cells, and impossible cells.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.InternalSolve(System.Char*,System.Char*,System.Int32)">
            <summary>
            The internal solving method.
            </summary>
            <param name="puzzle">The pointer to the puzzle string.</param>
            <param name="solutionPtr">The pointer to the solution string.</param>
            <param name="limit">The limitation for the number of all final solutions.</param>
            <returns>The number of solutions found.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.ExtractSolution(System.Char*)">
            <summary>
            Extract solution as a string.
            </summary>
            <param name="solution">
            The solution pointer. <b>The buffer should be at least <see cref="F:Sudoku.Solving.BitwiseSolver.BufferLength"/>
            of value of length.</b>
            </param>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.GuessBiValueInCell">
            <summary>
            Try both options for cells with exactly two pencil marks.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.GuessFirstCell">
            <summary>
            Guess all possibilities in first unsolved cell.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.Guess">
            <summary>
            Either already solved, or guess and recurse.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.FullUpdate">
            <summary>
            Get as far as possible without guessing.
            </summary>
            <returns>An <see cref="T:System.Byte"/> result.</returns>
        </member>
        <member name="M:Sudoku.Solving.BitwiseSolver.BitPos(System.UInt32)">
            <summary>
            Get the bit position.
            </summary>
            <param name="map">The map.</param>
            <returns>The position.</returns>
        </member>
        <member name="T:Sudoku.Solving.BitwiseSolver.State">
            <summary>
            To describe a state for a current grid using binary values.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.State.Bands">
            <summary>
            Pencil marks in bands by digit.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.State.PrevBands">
            <summary>
            Value of bands last time it was calculated.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.State.UnsolvedCells">
            <summary>
            Bit vector of unsolved cells.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.State.UnsolvedRows">
            <summary>
            Bit vector of unsolved rows - three bits per band.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.State.Pairs">
            <summary>
            Bit vector of cells with exactly two pencil marks.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.TblComplexMask">
            <summary>
            To keep mini rows still valid.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.TblMaskSingle">
            <summary>
            Kill in other blocks locked column/box.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.TblShrinkSingle">
            <summary>
            Keep only rows with single.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.TblRowUniq">
            <remarks>
            1 is row not defined in block mode <c>1</c> to <c>111</c>.
            </remarks>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.TblColumnSingle">
            <summary>
            Single in column applied to shrunk block.
            </summary>
        </member>
        <member name="F:Sudoku.Solving.BitwiseSolver.TblRowMask">
            <summary>
            Rows where single found: <c>000</c> to <c>111</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Solving.ISimpleSolver">
            <summary>
            Defines a simple solver.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.ISimpleSolver.Solve(Sudoku.Concepts.Collections.Grid@,Sudoku.Concepts.Collections.Grid@)">
            <summary>
            To solve the specified grid.
            </summary>
            <param name="grid">The grid to be solved.</param>
            <param name="result">
            <para>The result of the grid.</para>
            <para>
            Please note that if the return value is not <see langword="true"/>,
            the value should be a discard and should not be used, because the argument
            keeps a memory-randomized value currently.
            </para>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>? value indicating whether the grid can be solved, i.e. has a unique solution.
            Please note that the method will return three possible values:
            <list type="table">
            <item>
            <term><see langword="true"/></term>
            <description>The puzzle has a unique solution.</description>
            </item>
            <item>
            <term><see langword="false"/></term>
            <description>The puzzle has multiple solutions.</description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>The puzzle has no solution.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:Sudoku.Solving.LinqSolver">
            <summary>
            Defines a solver that can solve a sudoku puzzle, using LINQ.
            </summary>
        </member>
        <member name="M:Sudoku.Solving.LinqSolver.Solve(Sudoku.Concepts.Collections.Grid@,Sudoku.Concepts.Collections.Grid@)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Diagnostics.FileCounter">
            <summary>
            Encapsulates a file counter.
            </summary>
        </member>
        <member name="M:Sudoku.Diagnostics.FileCounter.#ctor(System.String)">
            <summary>
            Initializes an instance with the specified root directory.
            </summary>
            <param name="root">The directory.</param>
        </member>
        <member name="M:Sudoku.Diagnostics.FileCounter.#ctor(System.String,System.String)">
            <summary>
            Initializes an instance with the specified root directory,
            and the filter pattern. The pattern is specified as a file extension,
            such as <c>"cs"</c>.
            </summary>
            <param name="root">The root.</param>
            <param name="extension">
            The file extension. This parameter can be <see langword="null"/>. If
            so, the counter will sum up all files with all extensions.
            </param>
        </member>
        <member name="M:Sudoku.Diagnostics.FileCounter.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes an instance with the specified root directory,
            the file extension and a <see cref="T:System.Boolean"/> value indicating whether
            the counter will record the codes in directories <c>bin</c> and <c>obj</c>.
            </summary>
            <param name="root">The root.</param>
            <param name="extension">
            The file extension. This parameter can be <see langword="null"/>. If
            so, the counter will sum up all files with all extensions.
            </param>
            <param name="withBinOrObjDirectory">
            Indicates whether the counter will record the codes in directories
            <c>bin</c> and <c>obj</c>.
            </param>
        </member>
        <member name="M:Sudoku.Diagnostics.FileCounter.#ctor(System.String,System.String,System.Boolean,System.Collections.Generic.IList{System.String})">
            <summary>
            Initializes an instance with the specified root, extension, a <see cref="T:System.Boolean"/> value
            indicating whether the counter will searcher for bin or obj directory, and a file list.
            </summary>
            <param name="root">The root.</param>
            <param name="extension">The file extension.</param>
            <param name="withBinOrObjDirectory">
            A <see cref="T:System.Boolean"/> value indicating whether the counter will search for bin or obj directory.
            </param>
            <param name="fileList">A file list.</param>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounter.Root">
            <summary>
            The root directory.
            </summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounter.Pattern">
            <summary>
            The pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounter.WithBinOrObjDirectory">
            <summary>
            Indicates whether the searcher will find directories <c>bin</c> or <c>obj</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounter.FileList">
            <summary>
            The file list.
            </summary>
        </member>
        <member name="M:Sudoku.Diagnostics.FileCounter.CountUp">
            <summary>
            Count up for all files in the specified root directory, and return the result.
            </summary>
            <returns>The result information.</returns>
        </member>
        <member name="T:Sudoku.Diagnostics.FileCounterResult">
            <summary>
            Encapsulates a result after <see cref="T:Sudoku.Diagnostics.FileCounter"/>.
            </summary>
            <param name="ResultLines">The number of lines found.</param>
            <param name="FilesCount">The number of files found.</param>
            <param name="CharactersCount">The number of characters found.</param>
            <param name="Bytes">All bytes.</param>
            <param name="Elapsed">The elapsed time during searching.</param>
            <param name="FileList">
            The list of files. This property won't be output. If you want to use this property,
            please write this property explicitly.
            </param>
            <seealso cref="T:Sudoku.Diagnostics.FileCounter"/>
        </member>
        <member name="M:Sudoku.Diagnostics.FileCounterResult.#ctor(System.Int32,System.Int32,System.Int64,System.Int64,System.TimeSpan@,System.Collections.Generic.IList{System.String})">
            <summary>
            Encapsulates a result after <see cref="T:Sudoku.Diagnostics.FileCounter"/>.
            </summary>
            <param name="ResultLines">The number of lines found.</param>
            <param name="FilesCount">The number of files found.</param>
            <param name="CharactersCount">The number of characters found.</param>
            <param name="Bytes">All bytes.</param>
            <param name="Elapsed">The elapsed time during searching.</param>
            <param name="FileList">
            The list of files. This property won't be output. If you want to use this property,
            please write this property explicitly.
            </param>
            <seealso cref="T:Sudoku.Diagnostics.FileCounter"/>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounterResult.ResultLines">
            <summary>The number of lines found.</summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounterResult.FilesCount">
            <summary>The number of files found.</summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounterResult.CharactersCount">
            <summary>The number of characters found.</summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounterResult.Bytes">
            <summary>All bytes.</summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounterResult.Elapsed">
            <summary>The elapsed time during searching.</summary>
        </member>
        <member name="P:Sudoku.Diagnostics.FileCounterResult.FileList">
            <summary>
            The list of files. This property won't be output. If you want to use this property,
            please write this property explicitly.
            </summary>
        </member>
        <member name="M:Sudoku.Diagnostics.FileCounterResult.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Diagnostics.SizeUnit">
            <summary>
            Indicates a unit for a file size.
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.Byte">
            <summary>
            Indicates the size is of bytes.
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.Kilobyte">
            <summary>
            Indicates the size is of kilobytes (KB).
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.Megabyte">
            <summary>
            Indicates the size is of megabytes (MB).
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.Gigabyte">
            <summary>
            Indicates the size is of gigabytes (GB).
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.Terabyte">
            <summary>
            Indicates the size is of terabytes (TB).
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.IKilobyte">
            <summary>
            Indicates the size is of KiB.
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.IMegabyte">
            <summary>
            Indicates the size is of MiB.
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.IGigabyte">
            <summary>
            Indicates the size is of GiB.
            </summary>
        </member>
        <member name="F:Sudoku.Diagnostics.SizeUnit.ITerabyte">
            <summary>
            Indicates the size is of TiB.
            </summary>
        </member>
        <member name="T:Sudoku.Diagnostics.SizeUnitConverter">
            <summary>
            Encapsulates a size unit converter.
            </summary>
        </member>
        <member name="M:Sudoku.Diagnostics.SizeUnitConverter.ConvertTo(System.Int64,Sudoku.Diagnostics.SizeUnit)">
            <summary>
            To convert the size into the specified unit.
            </summary>
            <param name="bytes">The bytes.</param>
            <param name="sizeUnit">The size unit.</param>
            <returns>The value of the specified size unit.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="sizeUnit"/> is invalid.
            </exception>
        </member>
        <member name="M:Sudoku.Diagnostics.SizeUnitConverter.Convert(System.Int64,Sudoku.Diagnostics.SizeUnit@)">
            <summary>
            To convert the size into the appropriate size unit.
            </summary>
            <param name="bytes">The bytes.</param>
            <param name="unit">The unit.</param>
            <returns>The value of the specified size unit.</returns>
        </member>
        <member name="T:Sudoku.Presentation.Identifier">
            <summary>
            Defines an identifier that can differ colors.
            </summary>
        </member>
        <member name="F:Sudoku.Presentation.Identifier._colorRawValue">
            <summary>
            Indicates the raw value of the color.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.#ctor">
            <summary>
            Initializes an <see cref="T:Sudoku.Presentation.Identifier"/> instance.
            </summary>
            <exception cref="T:System.NotSupportedException">Always throws.</exception>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.#ctor(System.Int32)">
            <summary>
            Initializes an <see cref="T:Sudoku.Presentation.Identifier"/> instance via the ID value.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes an <see cref="T:Sudoku.Presentation.Identifier"/> instance via the color value.
            </summary>
            <param name="a">The alpha value.</param>
            <param name="r">The red value.</param>
            <param name="g">The green value.</param>
            <param name="b">The blue value.</param>
        </member>
        <member name="P:Sudoku.Presentation.Identifier.UseId">
            <summary>
            Indicates whether the user uses the ID value.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.Identifier.A">
            <summary>
            Indicates the alpha value.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the current instance uses ID.</exception>
        </member>
        <member name="P:Sudoku.Presentation.Identifier.R">
            <summary>
            Indicates the red value.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the current instance uses ID.</exception>
        </member>
        <member name="P:Sudoku.Presentation.Identifier.G">
            <summary>
            Indicates the green value.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the current instance uses ID.</exception>
        </member>
        <member name="P:Sudoku.Presentation.Identifier.B">
            <summary>
            Indicates the blue value.
            </summary>
            <exception cref="T:System.InvalidOperationException">Throws when the current instance uses ID.</exception>
        </member>
        <member name="P:Sudoku.Presentation.Identifier.Id">
            <summary>
            Indicates the ID value used.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.Equals(Sudoku.Presentation.Identifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.GetColor``1(System.Converter{Sudoku.Presentation.Identifier,``0})">
            <summary>
            Try to cast the current identifier instance into the result color value.
            </summary>
            <typeparam name="TColor">The type of the color.</typeparam>
            <param name="converter">The converter method.</param>
            <returns>The result color.</returns>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.FromId(System.Int32)">
            <summary>
            Creates an <see cref="T:Sudoku.Presentation.Identifier"/> instance via the specified ID value.
            </summary>
            <param name="id">The ID value.</param>
            <returns>The result <see cref="T:Sudoku.Presentation.Identifier"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.FromColor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates an <see cref="T:Sudoku.Presentation.Identifier"/> instance via the color value.
            </summary>
            <param name="r">The red value.</param>
            <param name="g">The green value.</param>
            <param name="b">The blue value.</param>
            <returns>The result <see cref="T:Sudoku.Presentation.Identifier"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.FromColor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates an <see cref="T:Sudoku.Presentation.Identifier"/> instance via the color value.
            </summary>
            <param name="a">The alpha value.</param>
            <param name="r">The red value.</param>
            <param name="g">The green value.</param>
            <param name="b">The blue value.</param>
            <returns>The result <see cref="T:Sudoku.Presentation.Identifier"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Equality(Sudoku.Presentation.Identifier,Sudoku.Presentation.Identifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Inequality(Sudoku.Presentation.Identifier,Sudoku.Presentation.Identifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Explicit(Sudoku.Presentation.Identifier)~System.Int32">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Presentation.Identifier"/> to <see cref="T:System.Int32"/> indicating the ID value.
            </summary>
            <param name="identifier">The <see cref="T:Sudoku.Presentation.Identifier"/> instance.</param>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Explicit(Sudoku.Presentation.Identifier)~System.ValueTuple{System.Byte,System.Byte,System.Byte}">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Presentation.Identifier"/> to (<see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>,
            <see cref="T:System.Byte"/>).
            </summary>
            <param name="identifier">The <see cref="T:Sudoku.Presentation.Identifier"/> instance.</param>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Explicit(Sudoku.Presentation.Identifier)~System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte}">
            <summary>
            Explicit cast from <see cref="T:Sudoku.Presentation.Identifier"/> to (<see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>,
            <see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>).
            </summary>
            <param name="identifier">The <see cref="T:Sudoku.Presentation.Identifier"/> instance.</param>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Implicit(System.ValueTuple{System.Byte,System.Byte,System.Byte,System.Byte})~Sudoku.Presentation.Identifier">
            <summary>
            Implicit cast from (<see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>)
            to <see cref="T:Sudoku.Presentation.Identifier"/>.
            </summary>
            <param name="colorQuadruple">
            The quadruple of element types <see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>
            and <see cref="T:System.Byte"/>.
            </param>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Implicit(System.ValueTuple{System.Byte,System.Byte,System.Byte})~Sudoku.Presentation.Identifier">
            <summary>
            Implicit cast from (<see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>, <see cref="T:System.Byte"/>)
            to <see cref="T:Sudoku.Presentation.Identifier"/>.
            </summary>
            <param name="colorTriple">
            The quadruple of element types <see cref="T:System.Byte"/>, <see cref="T:System.Byte"/> and <see cref="T:System.Byte"/>.
            </param>
        </member>
        <member name="M:Sudoku.Presentation.Identifier.op_Implicit(System.Int32)~Sudoku.Presentation.Identifier">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/> indicating the ID value to <see cref="T:Sudoku.Presentation.Identifier"/>.
            </summary>
            <param name="id">The ID value.</param>
        </member>
        <member name="T:Sudoku.Presentation.LockedTarget">
            <summary>
            Defines the data structure that stores a set of cells and a digit, indicating the information
            about the locked candidate node.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.#ctor(System.Int32,Sudoku.Concepts.Collections.Cells@)">
            <summary>
            Initializes a <see cref="T:Sudoku.Presentation.LockedTarget"/> instance via the specified cells and the specified digit used.
            </summary>
            <param name="digit">Indicates the digit used.</param>
            <param name="cells">Indicates the cells used.</param>
        </member>
        <member name="P:Sudoku.Presentation.LockedTarget.IsSole">
            <summary>
            Indicates whether the number of cells is 1.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.LockedTarget.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.LockedTarget.Cells">
            <summary>
            Indicates the cells used.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.Equals(Sudoku.Presentation.LockedTarget@)">
            <inheritdoc cref="M:System.IEquatable`1.Equals(`0)"/>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.System#IEquatable{Sudoku#Presentation#LockedTarget}#Equals(Sudoku.Presentation.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.op_Equality(Sudoku.Presentation.LockedTarget@,Sudoku.Presentation.LockedTarget@)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Presentation.LockedTarget"/> instances are considered equal.
            </summary>
            <param name="left">The first element to be compared.</param>
            <param name="right">The second element to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.op_Inequality(Sudoku.Presentation.LockedTarget@,Sudoku.Presentation.LockedTarget@)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Presentation.LockedTarget"/> instances are not considered equal.
            </summary>
            <param name="left">The first element to be compared.</param>
            <param name="right">The second element to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.System#IEqualityOperators{Sudoku#Presentation#LockedTarget,Sudoku#Presentation#LockedTarget}#op_Equality(Sudoku.Presentation.LockedTarget,Sudoku.Presentation.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.LockedTarget.System#IEqualityOperators{Sudoku#Presentation#LockedTarget,Sudoku#Presentation#LockedTarget}#op_Inequality(Sudoku.Presentation.LockedTarget,Sudoku.Presentation.LockedTarget)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Presentation.Nodes.CandidateViewNode">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CandidateViewNode.#ctor(Sudoku.Presentation.Identifier,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Presentation.Nodes.CandidateViewNode"/> instance via the identifier and the highlight candidate.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="candidate">The candidate.</param>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.CandidateViewNode.Candidate">
            <summary>
            Indicates the candidate highlighted.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CandidateViewNode.Equals(Sudoku.Presentation.Nodes.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CandidateViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CandidateViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CandidateViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Presentation.Nodes.CellViewNode">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CellViewNode.#ctor(Sudoku.Presentation.Identifier,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Presentation.Nodes.CellViewNode"/> instance via the identifier and the highlight cell.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="cell">The cell.</param>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.CellViewNode.Cell">
            <summary>
            Indicates the cell highlighted.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CellViewNode.Equals(Sudoku.Presentation.Nodes.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CellViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CellViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CellViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Presentation.Nodes.CrosshatchViewNode">
            <summary>
            Defines a view node that highlights for a crosshatch.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CrosshatchViewNode.#ctor(Sudoku.Presentation.Identifier,Sudoku.Concepts.Collections.Cells@,Sudoku.Concepts.Collections.Cells@,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Presentation.Nodes.CrosshatchViewNode"/> instance via the specified identifier,
            start point, end point cells and the digit used.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="startPoint">The start point of the crosshatch.</param>
            <param name="endPoint">The end point of the crosshatch.</param>
            <param name="digit">The digit used.</param>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.CrosshatchViewNode.Digit">
            <summary>
            Indicates the digit used.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.CrosshatchViewNode.Start">
            <summary>
            Indicates the start point cells.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.CrosshatchViewNode.End">
            <summary>
            Indicates the end point cells.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CrosshatchViewNode.Equals(Sudoku.Presentation.Nodes.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CrosshatchViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CrosshatchViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.CrosshatchViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Presentation.Nodes.LinkViewNode">
            <summary>
            Defines a view node that highlights for a link.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.LinkViewNode.#ctor(Sudoku.Presentation.Identifier,Sudoku.Presentation.LockedTarget@,Sudoku.Presentation.LockedTarget@,Sudoku.Concepts.Inference)">
            <summary>
            Initializes a <see cref="T:Sudoku.Presentation.Nodes.LinkViewNode"/> instance via the specified identifier,
            the specified start and end point, and the inference type.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="startPoint">The start point of the link.</param>
            <param name="endPoint">The end point of the link.</param>
            <param name="inference">The inference type.</param>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.LinkViewNode.Start">
            <summary>
            Indicates the start point.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.LinkViewNode.End">
            <summary>
            Indicates the end point.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.LinkViewNode.Inference">
            <summary>
            Indicates the inference type.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.LinkViewNode.Equals(Sudoku.Presentation.Nodes.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.LinkViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.LinkViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.LinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Presentation.Nodes.RegionViewNode">
            <summary>
            Defines a view node that highlights for a region.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.RegionViewNode.#ctor(Sudoku.Presentation.Identifier,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Presentation.Nodes.RegionViewNode"/> instance via the identifier and the highlight region.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="region">The region.</param>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.RegionViewNode.Region">
            <summary>
            Indicates the region highlighted.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.RegionViewNode.Equals(Sudoku.Presentation.Nodes.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.RegionViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.RegionViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.RegionViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Presentation.Nodes.UnknownViewNode">
            <summary>
            Defines a view node that highlights for a unknown.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.UnknownViewNode.#ctor(Sudoku.Presentation.Identifier,System.Int32,System.Byte,System.Int16)">
            <summary>
            Initializes an <see cref="T:Sudoku.Presentation.Nodes.UnknownViewNode"/> instance via the specified identifier,
            the cell used, the unknown value character and the mask representing the digits used.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="cell">The cell used.</param>
            <param name="unknownValueChar">The character that represents the range of the unknown.</param>
            <param name="digitsMask">The mask representing digits used.</param>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.UnknownViewNode.Cell">
            <summary>
            Indicates the cell used.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.UnknownViewNode.UnknownValueChar">
            <summary>
            Indicates the character that represents the unknown range.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.UnknownViewNode.DigitsMask">
            <summary>
            Indicates the digits used.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.UnknownViewNode.Equals(Sudoku.Presentation.Nodes.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.UnknownViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.UnknownViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.UnknownViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Presentation.Nodes.ViewNode">
            <summary>
            Defines a view node.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.#ctor(Sudoku.Presentation.Identifier)">
            <summary>
            Assigns the <see cref="T:Sudoku.Presentation.Identifier"/> instance as the basic information.
            </summary>
            <param name="identifier">The <see cref="T:Sudoku.Presentation.Identifier"/> instance.</param>
        </member>
        <member name="P:Sudoku.Presentation.Nodes.ViewNode.Identifier">
            <summary>
            Indicates the identifier used.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.Equals(Sudoku.Presentation.Nodes.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.Clone">
            <summary>
            Creates a new instance whose inner data is totally same as the current instance.
            </summary>
            <returns>The result <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/> as the copy.</returns>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.op_Equality(Sudoku.Presentation.Nodes.ViewNode,Sudoku.Presentation.Nodes.ViewNode)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/>s are same type, and hold a same value.
            </summary>
            <param name="left">The first instance to be compared.</param>
            <param name="right">The second instance to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Presentation.Nodes.ViewNode.op_Inequality(Sudoku.Presentation.Nodes.ViewNode,Sudoku.Presentation.Nodes.ViewNode)">
            <summary>
            Determines whether two <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/>s are not same type, or not totally hold a same value.
            </summary>
            <param name="left">The first instance to be compared.</param>
            <param name="right">The second instance to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:Sudoku.Presentation.View">
            <summary>
            Provides with a data structure that displays a view for basic information.
            </summary>
        </member>
        <member name="F:Sudoku.Presentation.View._nodes">
            <summary>
            Indicates the inner dictionary.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.View.#ctor">
            <summary>
            Creates an empty <see cref="T:Sudoku.Presentation.View"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Presentation.View.#ctor(System.Collections.Generic.List{Sudoku.Presentation.Nodes.ViewNode})">
            <summary>
            Initializes a <see cref="T:Sudoku.Presentation.View"/> instance via the specified list as the raw value.
            </summary>
            <param name="nodes">The list as the raw value.</param>
        </member>
        <member name="P:Sudoku.Presentation.View.Count">
            <summary>
            Indicates the number of elements stored in the current collection.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.View.Empty">
            <summary>
            Indicates the empty instance.
            </summary>
        </member>
        <member name="P:Sudoku.Presentation.View.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/> at the specified position.
            </summary>
            <param name="index">The index.</param>
            <returns>The <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Presentation.View.Add(Sudoku.Presentation.Nodes.ViewNode)">
            <summary>
            Adds the specified <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/> into the collection.
            </summary>
            <param name="node">The <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/> instance.</param>
        </member>
        <member name="M:Sudoku.Presentation.View.AddRange(System.Collections.Generic.IEnumerable{Sudoku.Presentation.Nodes.ViewNode})">
            <summary>
            Adds a serial of elements into the collection.
            </summary>
            <param name="nodes">The <see cref="T:Sudoku.Presentation.Nodes.ViewNode"/> instances to be added.</param>
        </member>
        <member name="M:Sudoku.Presentation.View.Contains(Sudoku.Presentation.Nodes.ViewNode)">
            <summary>
            Determines whether an element is in the current collection.
            </summary>
            <param name="node">The node.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Presentation.View.Clone">
            <inheritdoc cref="M:System.ICloneable.Clone"/>
        </member>
        <member name="M:Sudoku.Presentation.View.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:Sudoku.Presentation.View.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.View.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.View.System#Collections#Generic#IEnumerable{Sudoku#Presentation#Nodes#ViewNode}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Presentation.View.op_Addition(Sudoku.Presentation.View,Sudoku.Presentation.Nodes.ViewNode)">
            <summary>
            Adds a new node into the collection.
            </summary>
            <param name="originalView">The original view.</param>
            <param name="newNode">The new item to be added.</param>
            <returns>The reference that is same as the argument <paramref name="originalView"/>.</returns>
            <remarks>
            Please note that the operator is mutable one, which means the appending operation
            is based on the argument <paramref name="originalView"/>.
            </remarks>
        </member>
        <member name="M:Sudoku.Presentation.View.op_Addition(Sudoku.Presentation.View,System.Collections.Generic.IEnumerable{Sudoku.Presentation.Nodes.ViewNode})">
            <summary>
            Adds a serial of view nodes into the collection.
            </summary>
            <param name="originalView">The original view.</param>
            <param name="highlightedItems">The highlighted items.</param>
            <returns>The reference that is same as the argument <paramref name="originalView"/>.</returns>
            <remarks>
            Please note that the operator is mutable one, which means the appending operation
            is based on the argument <paramref name="originalView"/>.
            </remarks>
        </member>
        <member name="T:Sudoku.Runtime.AnalysisServices.AlgorithmAttribute">
            <summary>
            Defines an attribute that modifies a type of a <see langword="class"/> or a <see langword="struct"/>,
            indicating the type having been modified this attribute is reserved for the developers used for studying.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.AnalysisServices.AlgorithmAttribute.#ctor(System.String)">
            <summary>
            Initializes an <see cref="T:Sudoku.Runtime.AnalysisServices.AlgorithmAttribute"/> instance via the specified algorithm name.
            </summary>
            <param name="algorithmName">The name of the algorithm.</param>
        </member>
        <member name="P:Sudoku.Runtime.AnalysisServices.AlgorithmAttribute.AlgorithmName">
            <summary>
            Indicates the name of the algorithm.
            </summary>
        </member>
        <member name="P:Sudoku.Runtime.AnalysisServices.AlgorithmAttribute.UriLink">
            <summary>
            Indicates the URI link for the introduction about the algorithm.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.AnalysisServices.CommonReadOnlies">
            <summary>
            Represents a type holding some common read-only fields used by runtime or compiling-time.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.InvalidFirstSet">
            <summary>
            Indicates the invalid first set value
            after called <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/> and <see cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>.
            </summary>
            <remarks>
            For more details you want to learn about, please visit
            <see href="https://github.com/dotnet/runtime/blob/a67d5680186ead0c9afdab7e004389c979d5fc1f/src/libraries/System.Private.CoreLib/src/System/Numerics/BitOperations.cs#L467">this link</see>
            to get the inner code.
            </remarks>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.Int32)"/>
            <seealso cref="M:System.Numerics.BitOperations.TrailingZeroCount(System.UInt32)"/>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.UniqueSquareTemplatesCount">
            <summary>
            Indicates the total number of unique square patterns.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.QiuDeadlyPatternTemplatesCount">
            <summary>
            Indicates the total number of Qiu's deadly patterns.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.ExocetTemplatesCount">
            <summary>
            Indicates the total number of exocet patterns.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.BdpTemplatesSize3Count">
            <summary>
            Indicates the total number of Unique Polygon (Heptagon) possible templates of size 3.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.BdpTemplatesSize4Count">
            <summary>
            Indicates the total number of Unique Polygon (Octagon) possible templates of size 4.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.MultisectorLockedSetsTemplatesCount">
            <summary>
            Indicates the total number of multi-sector locked sets possible templates.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.AllRowsMask">
            <summary>
            Indicates the mask that means all rows.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.AllColumnsMask">
            <summary>
            Indicates the mask that means all columns.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.AllRegionsMask">
            <summary>
            Indicates the mask that means all regions.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.RegionFirst">
            <summary>
            Indicates the first cell offset for each region.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.UniqueRectanglePatterns">
            <summary>
            The table of all <b>Unique Rectangle</b> cells.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.Peers">
            <summary>
            <para>Indicates a table for each cell's peers.</para>
            </summary>
            <example>
            '<c>Peers[0]</c>': the array of peers for the cell 0 (row 1 column 1).
            </example>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.RegionCells">
            <summary>
            <para>
            The map of all cell offsets in its specified region.
            The indices is between 0 and 26, where:
            <list type="table">
            <item>
            <term><c>0..9</c></term>
            <description>Block 1 to 9.</description>
            </item>
            <item>
            <term><c>9..18</c></term>
            <description>Row 1 to 9.</description>
            </item>
            <item>
            <term><c>18..27</c></term>
            <description>Column 1 to 9.</description>
            </item>
            </list>
            </para>
            </summary>
            <example>
            '<c>RegionTable[0]</c>': all cell offsets in the region 0 (block 1).
            </example>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.SubsetNames">
            <summary>
            <para>The names of all subsets by their sizes.</para>
            <para>
            For example, if you want to get the name of the size 3, the code will be
            <code><![CDATA[string name = SubsetNames[3];]]></code>
            Here the digit <c>3</c> is the size you want to get.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.FishNames">
            <summary>
            The names of all fishes by their sizes.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.RegularWingNames">
            <summary>
            <para>The names of all regular wings by their sizes.</para>
            <para>
            For example, if you want to get the name of the size 3, the code will be
            <code><![CDATA[string name = RegularWingNames[3];]]></code>
            Here the digit <c>3</c> is the size you want to get.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.RegionMaps">
            <summary>
            Indicates all grid maps that a grid contains.
            </summary>
            <example>
            '<c>RegionMaps[0]</c>': The map containing all cells in the block 1.
            </example>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.PeerMaps">
            <summary>
            Indicates the peer maps using <see cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.Peers"/> table.
            </summary>
            <seealso cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.Peers"/>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.Regions">
            <summary>
            Indicates the possible region types to iterate.
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.IntersectionMaps">
            <summary>
            <para>
            Indicates all maps that forms the each intersection. The pattern will be like:
            <code><![CDATA[
            .-------.-------.-------.
            | C C C | A A A | A A A |
            | B B B | . . . | . . . |
            | B B B | . . . | . . . |
            '-------'-------'-------'
            ]]></code>
            </para>
            <para>
            In addition, in this data structure, a <b>CoverSet</b> is a block and a <b>BaseSet</b> is a line.
            </para>
            </summary>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.IntersectionBlockTable">
            <summary>
            <para>The table of all blocks to iterate for each blocks.</para>
            <para>
            This field is only used for providing the data for another field <see cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.IntersectionMaps"/>.
            </para>
            </summary>
            <seealso cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.IntersectionMaps"/>
        </member>
        <member name="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.Combinatorials">
            <summary>
            Indicates the combinatorial numbers from <c>C(1, 1)</c> to <c>C(30, 30)</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.#cctor">
            <static-constructor>
		<summary>
			<para>
				Indicates the <see langword="static" /> constructor of the current type.
			</para>
			<para>
				This constructor will initialize some <see langword="static readonly" /> data members
				of this type that can't use a simple expression to describe the initial value.
			</para>
		</summary>
	</static-constructor>
        </member>
        <member name="T:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.ValueTupleComparer">
            <summary>
            The inner comparer of <see cref="T:System.ValueTuple`2"/> used for
            the field <see cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.IntersectionMaps"/>.
            </summary>
            <seealso cref="F:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.IntersectionMaps"/>
        </member>
        <member name="M:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.ValueTupleComparer.Equals(System.ValueTuple{System.Byte,System.Byte},System.ValueTuple{System.Byte,System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Runtime.AnalysisServices.CommonReadOnlies.ValueTupleComparer.GetHashCode(System.ValueTuple{System.Byte,System.Byte})">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Runtime.Reflection.EnumFieldNameAttribute">
            <summary>
            Defines the name of a field in an enumeration type.
            </summary>
        </member>
        <member name="M:Sudoku.Runtime.Reflection.EnumFieldNameAttribute.#ctor(System.String)">
            <summary>
            Initializes an <see cref="T:Sudoku.Runtime.Reflection.EnumFieldNameAttribute"/> instance via the specified name.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Sudoku.Runtime.Reflection.EnumFieldNameAttribute.Name">
            <summary>
            Indicates the name of the field.
            </summary>
        </member>
        <member name="T:Sudoku.Runtime.Reflection.FormatItemAttribute">
            <summary>
            Marks on a property to tell the user the property is only used for the formatting.
            </summary>
        </member>
    </members>
</doc>

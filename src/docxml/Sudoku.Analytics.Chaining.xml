<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Analytics.Chaining</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Analytics.Chaining.ChainingDriver">
            <summary>
            Provides a driver module on chaining.
            </summary>
        </member>
        <member name="M:Sudoku.Analytics.Chaining.ChainingDriver.CollectChainPatterns(Sudoku.Concepts.Grid@,System.ReadOnlySpan{Sudoku.Analytics.Chaining.ChainingRule})">
            <summary>
            Collect all <see cref="T:Sudoku.Concepts.ChainPattern"/> instances appears in a grid.
            </summary>
            <param name="grid">The grid.</param>
            <param name="rules">
            Indicates the rule instances that will create strong and weak links by their own represented concept.
            </param>
            <returns>All possible <see cref="T:Sudoku.Concepts.ChainPattern"/> instances.</returns>
        </member>
        <member name="T:Sudoku.Analytics.Chaining.LocalComparer">
            <summary>
            The file-local comparer generator, lazily initialized.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.Chaining.LocalComparer._chainPatternComparer">
            <summary>
            Indicates the backing field of chain pattern comparer instance.
            </summary>
        </member>
        <member name="F:Sudoku.Analytics.Chaining.LocalComparer._nodeComparer">
            <summary>
            Indicates the backing field of node map comparer instance.
            </summary>
        </member>
        <member name="P:Sudoku.Analytics.Chaining.LocalComparer.GetChainPatternComparer">
            <summary>
            Creates an instance of type <see cref="T:System.Collections.Generic.EqualityComparer`1"/> of <see cref="T:Sudoku.Concepts.ChainPattern"/> on equality comparison
            in order to filter duplicate chains.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.EqualityComparer`1"/> instance.</returns>
        </member>
        <member name="P:Sudoku.Analytics.Chaining.LocalComparer.GetNodeMapComparer">
            <summary>
            Creates an instance of type <see cref="T:System.Collections.Generic.EqualityComparer`1"/> of <see cref="T:Sudoku.Concepts.Node"/> on equality comparison
            in order to filter duplicate nodes on its containing map, guaranteeing same nodes won't be traversed multiple times.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.EqualityComparer`1"/> instance.</returns>
        </member>
        <member name="T:Sudoku.Analytics.Chaining.ChainingRule">
            <summary>
            Represents a rule that make inferences (strong or weak) between two <see cref="T:Sudoku.Concepts.Node"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Node"/>
        </member>
        <member name="M:Sudoku.Analytics.Chaining.ChainingRule.CollectStrongLinks(Sudoku.Concepts.Grid@,Sudoku.Concepts.LinkDictionary)">
            <summary>
            Collects for strong links appeared in argument <paramref name="grid"/>
            and insert all found values into argument <paramref name="linkDictionary"/>.
            </summary>
            <param name="grid">The grid to be checked.</param>
            <param name="linkDictionary">The collection of strong links, grouped by its node.</param>
            <remarks>
            Consider adding values from both entries if a link is found.
            The method call <see cref="M:Sudoku.Concepts.LinkDictionary.AddEntry(Sudoku.Concepts.Node,Sudoku.Concepts.Node)"/> is helpful.
            </remarks>
            <seealso cref="M:Sudoku.Concepts.LinkDictionary.AddEntry(Sudoku.Concepts.Node,Sudoku.Concepts.Node)"/>
        </member>
        <member name="M:Sudoku.Analytics.Chaining.ChainingRule.CollectWeakLinks(Sudoku.Concepts.Grid@,Sudoku.Concepts.LinkDictionary)">
            <summary>
            Collects for weak links appeared in argument <paramref name="grid"/>
            and insert all found values into argument <paramref name="linkDictionary"/>.
            </summary>
            <param name="grid">The grid to be checked.</param>
            <param name="linkDictionary">The collection of weak links, grouped by its node.</param>
            <remarks>
            <inheritdoc cref="M:Sudoku.Analytics.Chaining.ChainingRule.CollectStrongLinks(Sudoku.Concepts.Grid@,Sudoku.Concepts.LinkDictionary)" path="/remarks"/>
            </remarks>
            <seealso cref="M:Sudoku.Concepts.LinkDictionary.AddEntry(Sudoku.Concepts.Node,Sudoku.Concepts.Node)"/>
        </member>
        <member name="T:Sudoku.Analytics.Chaining.XChainingRule">
            <summary>
            Represents a chaining rule on X rule (i.e. <see cref="F:Sudoku.Concepts.LinkType.SingleDigit"/>).
            </summary>
            <seealso cref="F:Sudoku.Concepts.LinkType.SingleDigit"/>
        </member>
        <member name="M:Sudoku.Analytics.Chaining.XChainingRule.CollectStrongLinks(Sudoku.Concepts.Grid@,Sudoku.Concepts.LinkDictionary)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Chaining.XChainingRule.CollectWeakLinks(Sudoku.Concepts.Grid@,Sudoku.Concepts.LinkDictionary)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Analytics.Chaining.YChainingRule">
            <summary>
            Represents a chaining rule on Y rule (i.e. <see cref="F:Sudoku.Concepts.LinkType.SingleCell"/>).
            </summary>
            <seealso cref="F:Sudoku.Concepts.LinkType.SingleCell"/>
        </member>
        <member name="M:Sudoku.Analytics.Chaining.YChainingRule.CollectStrongLinks(Sudoku.Concepts.Grid@,Sudoku.Concepts.LinkDictionary)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Analytics.Chaining.YChainingRule.CollectWeakLinks(Sudoku.Concepts.Grid@,Sudoku.Concepts.LinkDictionary)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Concepts.Chain">
            <summary>
            Represents a chain or a loop.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Chain.#ctor(Sudoku.Concepts.Node)">
            <summary>
            Represents a chain or a loop.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Chain._weakStart">
            <summary>
            Indicates whether the chain starts with weak link.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Chain.IsGrouped">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.SatisfyXRule">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.IsWoodsWing">
            <summary>
            Indicates whether the chain is formed a W-Wing.
            </summary>
            <remarks>
            A valid pattern of W-Wing is <c><![CDATA[(x=y)-y=y-(y=x)]]></c>, symmetric.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Chain.IsMedusaWing">
            <summary>
            Indicates whether the chain is formed a M-Wing.
            </summary>
            <remarks>
            A valid pattern of M-Wing is <c><![CDATA[(x=y)-y=(y-x)=x]]></c>, asymmetric.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Chain.IsSplitWing">
            <summary>
            Indicates whether the chain is formed a S-Wing.
            </summary>
            <remarks>
            A valid pattern of S-Wing is <c><![CDATA[x=x-(x=y)-y=y]]></c>, symmetric.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Chain.IsLocalWing">
            <summary>
            Indicates whether the chain is formed a L-Wing.
            </summary>
            <remarks>
            A valid pattern of L-Wing is <c><![CDATA[x=(x-y)=(y-z)=z]]></c>, asymmetric.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Chain.IsHybridWing">
            <summary>
            Indicates whether the chain is formed a H-Wing.
            </summary>
            <remarks>
            A valid pattern of H-Wing is <c><![CDATA[(x=y)-(y=z)-z=z]]></c>, asymmetric.
            </remarks>
        </member>
        <member name="P:Sudoku.Concepts.Chain.ContainsOverlappedNodes">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.Length">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.Complexity">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.Links">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.First">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.Last">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Chain.SplitMask">
            <summary>
            Split mask for 6 nodes.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Chain.Span">
            <summary>
            Create a <see cref="T:System.ReadOnlySpan`1"/> instance that holds valid <see cref="T:Sudoku.Concepts.Node"/> instances to be used in a chain.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Chain.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.Reverse">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.Equals(Sudoku.Concepts.Chain)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.Equals(Sudoku.Concepts.Chain,Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <inheritdoc cref="M:Sudoku.Concepts.ChainPattern.Equals(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)"/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.Equals(Sudoku.Concepts.ChainPattern)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.Equals(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.GetHashCode(Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.CompareTo(Sudoku.Concepts.Chain)">
            <summary>
            Determine which <see cref="T:Sudoku.Concepts.Chain"/> instance is greater.
            </summary>
            <param name="other">The other instance to be compared.</param>
            <returns>An <see cref="T:System.Int32"/> result.</returns>
            <remarks>
            Order rule:
            <list type="number">
            <item>If <paramref name="other"/> is <see langword="null"/>, <see langword="this"/> is greater, return 1.</item>
            <item>
            If <paramref name="other"/> is not <see langword="null"/>, checks on length:
            <list type="number">
            <item>
            If length is not same, return 1 when <see langword="this"/> is longer
            or -1 when <paramref name="other"/> is longer.
            </item>
            <item>
            Determine whether one of two has "self constraint" (i.e. false -> true confliction).
            <list type="number">
            <item>If so, it will be treated as "less than" the other one.</item>
            <item>
            Otherwise, determine the chain nodes used one by one. If a node is greater, the chain will be greater;
            otherwise, they are same, 0 will be returned.
            </item>
            </list>
            </item>
            </list>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Chain.CompareTo(Sudoku.Concepts.ChainPattern)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.CompareTo(Sudoku.Concepts.Chain,Sudoku.Concepts.NodeComparison)">
            <inheritdoc cref="M:Sudoku.Concepts.Chain.CompareTo(Sudoku.Concepts.Chain)"/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.GetConclusions(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Chain.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Concepts.ChainPattern">
            <summary>
            Represents a type that describes for a chain or a loop.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ChainPattern.Inferences">
            <summary>
            Indicates the possible inferences to be used.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ChainPattern._nodes">
            <summary>
            Indicates the nodes to be initialized.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.#ctor(Sudoku.Concepts.Node,System.Boolean)">
            <summary>
            Initializes <see cref="T:Sudoku.Concepts.ChainPattern"/> data.
            </summary>
            <param name="lastNode">The last node.</param>
            <param name="isLoop">Indicates whether is for loop initialization.</param>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.IsGrouped">
            <summary>
            Indicates whether the chain pattern uses grouped logic.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.SatisfyXRule">
            <summary>
            Indicates whether the pattern only uses same digits.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.SatisfyYRule">
            <summary>
            Indicates whether the pattern only uses cell strong links.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.ContainsOverlappedNodes">
            <summary>
            Indicates whether at least one node in the whole pattern overlaps with a node.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.Length">
            <summary>
            Indicates the length of the pattern.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.Complexity">
            <summary>
            Indicates the complexity of the pattern.
            The value is different with <see cref="P:Sudoku.Concepts.ChainPattern.Length"/> on a chain starting and ending with itself, both are by strong links.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.Links">
            <summary>
            Indicates the links used.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.First">
            <summary>
            Indicates the head node.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.Last">
            <summary>
            Indicates the tail node.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.System#Collections#Generic#IReadOnlyCollection{Sudoku#Concepts#Node}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.ChainPattern.Item(System.Int32)">
            <summary>
            Gets a <see cref="T:Sudoku.Concepts.Node"/> instance at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The <see cref="T:Sudoku.Concepts.Node"/> instance.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Throws when the argument <paramref name="index"/> is out of range.</exception>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.Reverse">
            <summary>
            Try to reverse the pattern, making all nodes negated its direction connected.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.Equals(Sudoku.Concepts.ChainPattern)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.Equals(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Chain"/> or <see cref="T:Sudoku.Concepts.Loop"/> instances are same, by using the specified comparison rule.
            </summary>
            <param name="other">The other instance to be compared.</param>
            <param name="nodeComparison">The comparison rule on nodes.</param>
            <param name="patternComparison">The comparison rule on the whole chain.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="patternComparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
            <remarks>
            This method directly calls <see cref="M:Sudoku.Concepts.ChainPattern.GetHashCode(Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)"/>
            with values <see cref="F:Sudoku.Concepts.NodeComparison.IgnoreIsOn"/> and <see cref="F:Sudoku.Concepts.ChainPatternComparison.Undirected"/>.
            </remarks>
            <seealso cref="M:Sudoku.Concepts.ChainPattern.GetHashCode(Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)"/>
            <seealso cref="F:Sudoku.Concepts.NodeComparison.IgnoreIsOn"/>
            <seealso cref="F:Sudoku.Concepts.ChainPatternComparison.Undirected"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.GetHashCode(Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <summary>
            Computes hash code based on the current instance.
            </summary>
            <param name="nodeComparison">The node comparison.</param>
            <param name="patternComparison">The pattern comparison.</param>
            <returns>An <see cref="T:System.Int32"/> as the result.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="patternComparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.FindIndex(System.Predicate{Sudoku.Concepts.Node})">
            <summary>
            Try to find a node satisfying the specified condition, and return its index. If none found, -1 will be returned.
            </summary>
            <param name="predicate">The condition that a node should satisfy.</param>
            <returns>The index of the node satisfied the condition.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.FindLastIndex(System.Predicate{Sudoku.Concepts.Node})">
            <summary>
            Try to find a node satisfying the specified condition from end, and return its index. If none found, -1 will be returned.
            </summary>
            <param name="predicate">The condition that a node should satisfy.</param>
            <returns>The index of the node satisfied the condition.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.CompareTo(Sudoku.Concepts.ChainPattern)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.Slice(System.Int32,System.Int32)">
            <summary>
            Slices the collection with the specified start node and its length.
            </summary>
            <param name="start">The start index.</param>
            <param name="length">The number of <see cref="T:Sudoku.Concepts.Node"/> instances to slice.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:Sudoku.Concepts.Node"/> instances returned.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.GetConclusions(Sudoku.Concepts.Grid@)">
            <summary>
            Try to get a <see cref="T:Sudoku.Concepts.ConclusionSet"/> instance that contains all conclusions created by using the current chain.
            </summary>
            <param name="grid">The grid to be checked.</param>
            <returns>A <see cref="T:Sudoku.Concepts.ConclusionSet"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.System#Collections#Generic#IEnumerable{Sudoku#Concepts#Node}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.GetConclusions(Sudoku.Concepts.Grid@,Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <summary>
            Try to get all possible conclusions via the specified grid and two <see cref="T:Sudoku.Concepts.Node"/> instances.
            </summary>
            <param name="grid">The grid.</param>
            <param name="node1">The first node.</param>
            <param name="node2">The second node.</param>
            <returns>A sequence of <see cref="T:Sudoku.Concepts.Conclusion"/> instances.</returns>
            <seealso cref="T:Sudoku.Concepts.Conclusion"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.op_Equality(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.ChainPattern)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.op_Inequality(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.ChainPattern)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.op_GreaterThan(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.ChainPattern)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.op_LessThan(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.ChainPattern)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.op_GreaterThanOrEqual(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.ChainPattern)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.ChainPattern.op_LessThanOrEqual(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.ChainPattern)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.ChainPatternComparison">
            <summary>
            Provides with a comparison rule on <see cref="T:Sudoku.Concepts.ChainPattern"/> instances (i.e. <see cref="T:Sudoku.Concepts.Chain"/> or <see cref="T:Sudoku.Concepts.Loop"/>).
            </summary>
            <seealso cref="T:Sudoku.Concepts.ChainPattern"/>
            <seealso cref="T:Sudoku.Concepts.Chain"/>
            <seealso cref="T:Sudoku.Concepts.Loop"/>
        </member>
        <member name="F:Sudoku.Concepts.ChainPatternComparison.Undirected">
            <summary>
            Indicates the comparison will ignore direction on chains.
            For example, <c>A == B -- C == D</c> is equal to <c>D == C -- B == A</c>.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.ChainPatternComparison.Directed">
            <summary>
            Indicates the comparison will also check on direction.
            For example, <c>A == B -- C == D</c> is not equal to <c>D == C -- B == A</c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Link">
            <summary>
            <para>Represents a link that describes a relation between two <see cref="T:Sudoku.Concepts.Node"/> instances.</para>
            <para><b>
            Please note that two <see cref="T:Sudoku.Concepts.Link"/> instances will be considered as equal
            only if they holds same node values, regardless of what link type two <see cref="T:Sudoku.Concepts.Link"/> instances use.
            </b></para>
            </summary>
            <param name="firstNode">Indicates the first node to be used.</param>
            <param name="secondNode">Indicates the second node to be used.</param>
            <param name="isStrong">Indicates whether the link type is a strong link or not.</param>
            <seealso cref="T:Sudoku.Concepts.Node"/>
        </member>
        <member name="M:Sudoku.Concepts.Link.#ctor(Sudoku.Concepts.Node,Sudoku.Concepts.Node,System.Boolean)">
            <summary>
            <para>Represents a link that describes a relation between two <see cref="T:Sudoku.Concepts.Node"/> instances.</para>
            <para><b>
            Please note that two <see cref="T:Sudoku.Concepts.Link"/> instances will be considered as equal
            only if they holds same node values, regardless of what link type two <see cref="T:Sudoku.Concepts.Link"/> instances use.
            </b></para>
            </summary>
            <param name="firstNode">Indicates the first node to be used.</param>
            <param name="secondNode">Indicates the second node to be used.</param>
            <param name="isStrong">Indicates whether the link type is a strong link or not.</param>
            <seealso cref="T:Sudoku.Concepts.Node"/>
        </member>
        <member name="M:Sudoku.Concepts.Link.Equals(Sudoku.Concepts.Link)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Link.Equals(Sudoku.Concepts.Link,Sudoku.Concepts.LinkComparison)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Link"/> are considered equal on the specified comparison rule.
            </summary>
            <param name="other">The other object to be compared.</param>
            <param name="comparison">The comparison rule to be used.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="comparison"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Link.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Link.GetHashCode(Sudoku.Concepts.LinkComparison)">
            <summary>
            Serves as hash code functions, with consideration on the specified comparison rule.
            </summary>
            <param name="comparison">The comparison rule.</param>
            <returns>An <see cref="T:System.Int32"/> indicating the hash code.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the argument <paramref name="comparison"/> is not defined.</exception>
        </member>
        <member name="M:Sudoku.Concepts.Link.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Link.FirstNode">
            <summary>
            The generated property declaration for parameter <c>firstNode</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Link.SecondNode">
            <summary>
            The generated property declaration for parameter <c>secondNode</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Link.IsStrong">
            <summary>
            The generated property declaration for parameter <c>isStrong</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Link.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Link.op_Equality(Sudoku.Concepts.Link,Sudoku.Concepts.Link)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Link.op_Inequality(Sudoku.Concepts.Link,Sudoku.Concepts.Link)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.LinkComparison">
            <summary>
            Represents a comparison rule to be used on comparing with two <see cref="T:Sudoku.Concepts.Link"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Link"/>
        </member>
        <member name="F:Sudoku.Concepts.LinkComparison.Undirected">
            <summary>
            Indicates the comparing rule is undirected, which means two <see cref="T:Sudoku.Concepts.Link"/> instances will be compared,
            without any direction checking; i.e. <c><![CDATA[node1 -> node2]]></c> is equal to <c><![CDATA[node2 -> node1]]></c>.
            This is the default option on comparing.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkComparison.Directed">
            <summary>
            Indicates the comparing rule is directed, which means two <see cref="T:Sudoku.Concepts.Link"/> instances will be compared,
            with considerations on direction; i.e. <c><![CDATA[node1 -> node2]]></c> is not equal to <c><![CDATA[node2 -> node1]]></c>.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.LinkDictionary">
            <summary>
            Represents a list of <see cref="T:Sudoku.Concepts.Node"/> relations on strong or weak links.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Node"/>
        </member>
        <member name="M:Sudoku.Concepts.LinkDictionary.AddEntry(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <summary>
            Add a link to the current collection with both entries on nodes of the link used.
            </summary>
            <param name="node1">Indicates the first node to be added.</param>
            <param name="node2">Indicates the second node to be added.</param>
        </member>
        <member name="T:Sudoku.Concepts.LinkType">
            <summary>
            Represents a link type.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.Unknown">
            <summary>
            Indicates the placeholder of the enumeration. The value can be represented in cases "None" or "Unknown".
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.SingleDigit">
            <summary>
            Indicates the link type is a single digit (X rule).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.SingleCell">
            <summary>
            Indicates the link type is a single cell (Y rule).
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.LockedCandidates">
            <summary>
            Indicates the link type is a locked candidates.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.AlmostLockedSet">
            <summary>
            Indicates the link type is an almost locked set.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.AlmostHiddenSet">
            <summary>
            Indicates the link type is an almost hidden set.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.KrakenNormalFish">
            <summary>
            Indicates the link type is a kraken normal fish.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.LinkType.AlmostUniqueRectangle">
            <summary>
            Indicates the link type is an almost unique rectangle.
            </summary>
        </member>
        <member name="T:Sudoku.Concepts.Loop">
            <summary>
            Represents a loop.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Loop.#ctor(Sudoku.Concepts.Node)">
            <summary>
            Represents a loop.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Loop.IsGrouped">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Loop.Length">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Loop.Complexity">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Loop.Links">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Loop.First">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Loop.Last">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Concepts.Loop.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.Reverse">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.Equals(Sudoku.Concepts.Loop)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.Equals(Sudoku.Concepts.Loop,Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <summary>
            Determine whether two <see cref="T:Sudoku.Concepts.Loop"/> instances are same, by using the specified comparison rule.
            </summary>
            <param name="other">The other instance to be compared.</param>
            <param name="nodeComparison">The comparison rule on nodes.</param>
            <param name="chainComparison">The comparison rule on the whole chain.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="chainComparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Loop.Equals(Sudoku.Concepts.ChainPattern)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.Equals(Sudoku.Concepts.ChainPattern,Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.GetHashCode(Sudoku.Concepts.NodeComparison,Sudoku.Concepts.ChainPatternComparison)">
            <summary>
            Creates a hash code based on the current instance.
            </summary>
            <param name="nodeComparison">The node comparison.</param>
            <param name="patternComparison">The pattern comparison.</param>
            <returns>An <see cref="T:System.Int32"/> as the result.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="patternComparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Loop.CompareTo(Sudoku.Concepts.Loop)">
            <summary>
            Determine which <see cref="T:Sudoku.Concepts.Loop"/> instance is greater.
            </summary>
            <param name="other">The other instance to be compared.</param>
            <returns>An <see cref="T:System.Int32"/> result.</returns>
            <remarks>
            Order rule:
            <list type="number">
            <item>If <paramref name="other"/> is <see langword="null"/>, <see langword="this"/> is greater, return 1.</item>
            <item>
            If <paramref name="other"/> is not <see langword="null"/>, checks on length:
            <list type="number">
            <item>
            If length is not same, return 1 when <see langword="this"/> is longer
            or -1 when <paramref name="other"/> is longer.
            </item>
            <item>
            Determines the loop nodes used one by one. If a node is greater, the chain will be greater;
            otherwise, they are same, 0 will be returned.
            <b>
            This operation will adjust the checking node index on the other loop <paramref name="other"/>.
            Two loops with same nodes will be considered as equal no matter what order they will be.
            For example, <c><![CDATA[A == B -- C == D -- A]]></c> is equal to <c><![CDATA[C == D -- A == B -- C]]></c>.
            </b>
            </item>
            </list>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Loop.CompareTo(Sudoku.Concepts.Loop,Sudoku.Concepts.NodeComparison)">
            <inheritdoc cref="M:Sudoku.Concepts.Loop.CompareTo(Sudoku.Concepts.Loop)"/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.CompareTo(Sudoku.Concepts.ChainPattern)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.Slice(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.GetConclusions(Sudoku.Concepts.Grid@)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Loop.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Concepts.Node">
            <summary>
            Represents a chain node.
            </summary>
            <param name="map">Indicates the backing map.</param>
            <param name="isOn">Indicates whether the node is on.</param>
        </member>
        <member name="M:Sudoku.Concepts.Node.#ctor(Sudoku.Concepts.CandidateMap@,System.Boolean)">
            <summary>
            Represents a chain node.
            </summary>
            <param name="map">Indicates the backing map.</param>
            <param name="isOn">Indicates whether the node is on.</param>
        </member>
        <member name="F:Sudoku.Concepts.Node.MapFormatString">
            <summary>
            Indicates the map format string.
            </summary>
        </member>
        <member name="F:Sudoku.Concepts.Node.IsOnFormatString">
            <summary>
            Indicates the property <see cref="P:Sudoku.Concepts.Node.IsOn"/> format string.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Node.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Node"/> instance via the specified candidate.
            </summary>
            <param name="candidate">A candidate.</param>
            <param name="isOn">Indicates whether the node is on.</param>
        </member>
        <member name="M:Sudoku.Concepts.Node.#ctor(Sudoku.Concepts.LockedTarget@,System.Boolean)">
            <summary>
            Initializes a <see cref="T:Sudoku.Concepts.Node"/> instance via the specified <see cref="T:Sudoku.Concepts.LockedTarget"/> instance.
            </summary>
            <param name="lockedTarget">A <see cref="T:Sudoku.Concepts.LockedTarget"/> instance.</param>
            <param name="isOn">Indicates whether the node is on.</param>
        </member>
        <member name="M:Sudoku.Concepts.Node.#ctor(Sudoku.Concepts.Node)">
            <summary>
            Copies and creates a <see cref="T:Sudoku.Concepts.Node"/> instance from argument <paramref name="base"/>.
            </summary>
            <param name="base">The data provider.</param>
        </member>
        <member name="M:Sudoku.Concepts.Node.#ctor(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <summary>
            Copies and creates a <see cref="T:Sudoku.Concepts.Node"/> instance from argument <paramref name="base"/>,
            and appends its parent node.
            </summary>
            <param name="base">The data provider.</param>
            <param name="parent">The parent node.</param>
        </member>
        <member name="M:Sudoku.Concepts.Node.#ctor(Sudoku.Concepts.Node,System.Boolean)">
            <summary>
            Copies and creates a <see cref="T:Sudoku.Concepts.Node"/> instance from argument <paramref name="base"/>,
            and appends its parent node, and modify <see cref="P:Sudoku.Concepts.Node.IsOn"/> property value.
            </summary>
            <param name="base">The data provider.</param>
            <param name="isOn">Indicates whether the node is on.</param>
        </member>
        <member name="P:Sudoku.Concepts.Node.IsGroupedNode">
            <summary>
            Indicates whether the node is a grouped node.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Node.Map">
            <summary>
            Indicates the map of candidates the node uses.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Node.AncestorsLength">
            <summary>
            Indicates the length of ancestors.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Node.Parent">
            <summary>
            Indicates the parent node. The value doesn't participate in equality comparison.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Node.IsOnPropertyValue">
            <summary>
            The backing comparing value on <see cref="P:Sudoku.Concepts.Node.IsOn"/> property.
            </summary>
            <seealso cref="P:Sudoku.Concepts.Node.IsOn"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.Equals(Sudoku.Concepts.Node)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Node.Equals(Sudoku.Concepts.Node,Sudoku.Concepts.NodeComparison)">
            <summary>
            Compares with two <see cref="T:Sudoku.Concepts.Node"/> instances, based on the specified comparison rule.
            </summary>
            <param name="other">The other instance to be compared.</param>
            <param name="comparison">The comparison rule.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="comparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Node.IsAncestorOf(Sudoku.Concepts.Node)">
            <summary>
            Determines whether the current node is an ancestor of the specified node. 
            </summary>
            <param name="childNode">The node to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Concepts.Node.GetHashCode(Sudoku.Concepts.NodeComparison)">
            <summary>
            Calculates the hash code on the current instance.
            </summary>
            <param name="comparison">The comparison rule.</param>
            <returns>An <see cref="T:System.Int32"/> value as the result.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="comparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Node.CompareTo(Sudoku.Concepts.Node)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Node.CompareTo(Sudoku.Concepts.Node,Sudoku.Concepts.NodeComparison)">
            <inheritdoc cref="M:Sudoku.Concepts.Node.CompareTo(Sudoku.Concepts.Node)"/>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Throws when the argument <paramref name="comparison"/> is not defined.
            </exception>
        </member>
        <member name="M:Sudoku.Concepts.Node.ToString``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Concepts.Node.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
            <remarks>
            Format description:
            <list type="table">
            <listheader>
            <term>Format character</term>
            <description>Description</description>
            </listheader>
            <item>
            <term><c>m</c></term>
            <description>The map text. For example, <c>r1c23(4)</c></description>
            </item>
            <item>
            <term><c>S</c> and <c>s</c></term>
            <description>
            The <see cref="P:Sudoku.Concepts.Node.IsOn"/> property value (<see langword="true"/> or <see langword="false"/>).
            If the character <c>s</c> is upper-cased, the result text will be upper-cased on initial letter.
            </description>
            </item>
            </list>
            For example, format value <c>"m: S"</c> will be replaced with value <c>"r1c23(4): True"</c>.
            </remarks>
        </member>
        <member name="M:Sudoku.Concepts.Node.op_OnesComplement(Sudoku.Concepts.Node)">
            <summary>
            Negates the node with <see cref="P:Sudoku.Concepts.Node.IsOn"/> property value.
            </summary>
            <param name="value">The current node.</param>
            <returns>The node negated.</returns>
        </member>
        <member name="F:Sudoku.Concepts.Node._map">
            <summary>
            The generated field declaration for parameter <c>map</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Concepts.Node.IsOn">
            <summary>
            The generated property declaration for parameter <c>isOn</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Concepts.Node.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.op_Equality(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.op_Inequality(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.op_GreaterThan(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.op_LessThan(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.op_GreaterThanOrEqual(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Concepts.Node.op_LessThanOrEqual(Sudoku.Concepts.Node,Sudoku.Concepts.Node)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Concepts.NodeComparison">
            <summary>
            Represents a comparison rule on <see cref="T:Sudoku.Concepts.Node"/> instances.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Node"/>
        </member>
        <member name="F:Sudoku.Concepts.NodeComparison.IncludeIsOn">
            <summary>
            Indicates the comparison rule checks on <see cref="P:Sudoku.Concepts.Node.IsOn"/> property.
            </summary>
            <seealso cref="P:Sudoku.Concepts.Node.IsOn"/>
        </member>
        <member name="F:Sudoku.Concepts.NodeComparison.IgnoreIsOn">
            <summary>
            Indicates the comparison rule ignores for <see cref="P:Sudoku.Concepts.Node.IsOn"/> property, and only checks on <see cref="P:Sudoku.Concepts.Node.Map"/>.
            </summary>
            <seealso cref="P:Sudoku.Concepts.Node.IsOn"/>
            <seealso cref="P:Sudoku.Concepts.Node.Map"/>
        </member>
    </members>
</doc>

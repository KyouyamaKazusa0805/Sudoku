<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SystemExtensions</name>
    </assembly>
    <members>
        <member name="T:System.Algorithm.Combinatorial">
            <summary>
            Extracts the type that includes the methods that operates with combinatorial values.
            </summary>
        </member>
        <member name="F:System.Algorithm.Combinatorial.PascalTriangle">
            <summary>
            Indicates the <see href="https://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal's Triangle</see>
            (in Chinese: Yang Hui's Triangle), i.e. the combinatorial numbers from <c>C(1, 1)</c> to <c>C(30, 30)</c>.
            </summary>
            <remarks>
            Formula: <latex><![CDATA[
            C(n,k) = \frac{n!}{k!(n-k)!}
            ]]></latex>
            </remarks>
        </member>
        <member name="M:System.Algorithm.Combinatorial.GetSubsets``1(``0[],System.Int32)">
            <summary>
            Get all subsets from the specified number of the values to take.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array.</param>
            <param name="count">The number of elements you want to take.</param>
            <returns>
            The subsets of the list.
            For example, if the input array is <c>[1, 2, 3]</c> and the argument <paramref name="count"/> is 2, the result will be
            <code>
            [[1, 2], [1, 3], [2, 3]]
            </code>
            3 cases.
            </returns>
        </member>
        <member name="M:System.Algorithm.Combinatorial.GetExtractedCombinations``1(``0[][])">
            <summary>
            Get all combinations that each sub-array only choose one.
            </summary>
            <param name="this">The jigsaw array.</param>
            <returns>
            All combinations that each sub-array choose one.
            For example, if one array is <c>[[1, 2, 3], [1, 3], [1, 4, 7, 10]]</c>, the final combinations will be
            <code><![CDATA[
            [
                [1, 1, 1], [1, 1, 4], [1, 1, 7], [1, 1, 10],
                [1, 3, 1], [1, 3, 4], [1, 3, 7], [1, 3, 10],
                [2, 1, 1], [2, 1, 4], [2, 1, 7], [2, 1, 10],
                [2, 3, 1], [2, 3, 4], [2, 3, 7], [2, 3, 10],
                [3, 1, 1], [3, 1, 4], [3, 1, 7], [3, 1, 10],
                [3, 3, 1], [3, 3, 4], [3, 3, 7], [3, 3, 10]
            ]
            ]]></code>
            24 cases.
            </returns>
        </member>
        <member name="T:System.Algorithm.Sequences">
            <summary>
            Defines some sequences that has been recorded in the
            <see href="https://oeis.org/">On-Line Encyclopedia of Integer Sequences</see>.
            </summary>
            <seealso href="https://oeis.org/">On-Line Encyclopedia of Integer Sequences</seealso>
            <shared-comments>
            <para>The index of the sequence. The index is 0-based.</para>
            <para>The index of the sequence. The index is 1-based.</para>
            </shared-comments>
        </member>
        <member name="M:System.Algorithm.Sequences.A000217(System.Int32)">
            <summary>
            Gets the value at the specified index in the sequence <see href="https://oeis.org/A000217">A000217</see>
            (0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ..).
            </summary>
            <param name="index"><inheritdoc cref="T:System.Algorithm.Sequences" path="//shared-comments/para[1]"/></param>
            <returns>The result value at the specified index.</returns>
        </member>
        <member name="M:System.Algorithm.Sequences.A002024(System.Int32)">
            <summary>
            Gets the value at the specified index in the sequence <see href="https://oeis.org/A002024">A002024</see>
            (1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, ..).
            </summary>
            <param name="index"><inheritdoc cref="T:System.Algorithm.Sequences" path="//shared-comments/para[2]"/></param>
            <returns>The result value at the specified index.</returns>
        </member>
        <member name="M:System.Algorithm.Sequences.A004526(System.Int32)">
            <summary>
            Gets the value at the specified index in the sequence <see href="https://oeis.org/A004526">A004526</see>
            (0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, ..).
            </summary>
            <param name="index"><inheritdoc cref="T:System.Algorithm.Sequences" path="//shared-comments/para[1]"/></param>
            <returns>The result value at the specified index.</returns>
        </member>
        <member name="M:System.Algorithm.Sequences.A057353(System.Int32)">
            <summary>
            Gets the value at the specified index in the sequence <see href="https://oeis.org/A057353">A057353</see>
            (0, 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 9, ..).
            </summary>
            <param name="index"><inheritdoc cref="T:System.Algorithm.Sequences" path="//shared-comments/para[1]"/></param>
            <returns>The result value at the specified index.</returns>
        </member>
        <member name="T:System.Algorithm.SimdOperations">
            <summary>
            Encapsulates a list of methods to handle with bits, using SIMD.
            </summary>
            <seealso href="https://learn.microsoft.com/en-us/dotnet/standard/simd">Microsoft Learn - SIMD</seealso>
            <seealso href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">Wikipedia - SIMD</seealso>
        </member>
        <member name="M:System.Algorithm.SimdOperations.IterateBits(System.Int64*,System.Int32,System.Int32*)">
            <summary>
            Iterates all possible set bits in the target array.
            </summary>
            <param name="array">The array specified as a pointer that points to an array or other collection, of <see cref="T:System.Int64"/> integers.</param>
            <param name="length">The length of the argument <paramref name="array"/>.</param>
            <param name="outBuffer">The set bit indices specified as a buffer.</param>
            <returns>Returns the number of set bit indices. This return value is used with argument <paramref name="outBuffer"/>.</returns>
            <seealso href="https://lemire.me/blog/2018/03/08/iterating-over-set-bits-quickly-simd-edition/">
            Iterating over set bits quickly (SIMD edition)
            </seealso>
        </member>
        <member name="T:System.Algorithm.Constants">
            <target name="class" when="constant">
				<summary>
					Provides with constants and read-only values used by code in the current file.
				</summary>
			</target>
        </member>
        <member name="F:System.Algorithm.Constants.LengthTable">
            <summary>
            The length table. Indicates how many bits are set in the specified integer.
            </summary>
        </member>
        <member name="F:System.Algorithm.Constants.BitPosTable">
            <summary>
            The bit position table. In other words, <c>BitPosTable[n]</c> means the n-th integer's (i.e. <c>n</c>'s) set bit positions
            represented as indices.
            </summary>
        </member>
        <member name="T:System.CommonMethods">
            <summary>
            Represents a set of methods to be used as method groups.
            </summary>
        </member>
        <member name="M:System.CommonMethods.DoNothing">
            <summary>
            Do nothing. This method is equivalent to lambda expression <c>static () => {}</c>.
            </summary>
        </member>
        <member name="M:System.CommonMethods.True``1(``0)">
            <summary>
            Makes the variable <paramref name="value"/> be an equivalent <see cref="T:System.Boolean"/> value.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="value">The value to be checked.</param>
            <returns>The logical conversion result.</returns>
            <remarks>
            This method does not use casting to make the target <typeparamref name="T"/> value to be converted into a <see cref="T:System.Boolean"/> value.
            If the type <typeparamref name="T"/> has implemented <see cref="T:System.ILogicalOperators`1"/>, C# language will allow this type
            using <see cref="T:System.Boolean"/>-like operators <see langword="operator"/> <![CDATA[&&]]> and <see langword="operator"/> ||
            to determine multiple <typeparamref name="T"/> values are <see langword="true"/> or <see langword="false"/> via the specified way
            to be checked. This is just like C programming language rule - allowing any implicit casts from an integer to a boolean value like:
            <code><![CDATA[
            if (integer) // integer != 0 in C and op_True(integer) in C#
            {
                // ...
            }
            ]]></code>
            The backing implementation is like the following code in C#:
            <code><![CDATA[
            struct Int32
            {
                public static bool operator true(int value) => value != 0;
                public sttaic bool operator false(int value) => value == 0;
            }
            ]]></code>
            </remarks>
        </member>
        <member name="M:System.CommonMethods.True``1(``0@)">
            <inheritdoc cref="M:System.CommonMethods.True``1(``0)"/>
        </member>
        <member name="M:System.CommonMethods.False``1(``0)">
            <summary>
            Makes the variable <paramref name="value"/> be an equivalent <see cref="T:System.Boolean"/> value, and negate it.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="value">The value to be checked.</param>
            <returns>The logical conversion result.</returns>
            <remarks>
            <inheritdoc cref="M:System.CommonMethods.True``1(``0)" path="/remarks"/>
            </remarks>
        </member>
        <member name="M:System.CommonMethods.False``1(``0@)">
            <inheritdoc cref="M:System.CommonMethods.False``1(``0)"/>
        </member>
        <member name="M:System.CommonMethods.BitMerger``1(``0,``0)">
            <summary>
            Merges two integers by bits. This method will be used by LINQ method
            <see cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>.
            </summary>
            <typeparam name="T">The type of the value. The value must be an integer type, and supports for shifting operators.</typeparam>
            <param name="interim">The interim value.</param>
            <param name="next">The next value to be merged by its bits.</param>
            <returns>The final value merged.</returns>
            <seealso cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>
        </member>
        <member name="M:System.CommonMethods.EnumFlagMerger``1(``0,``0)">
            <summary>
            Merges two flags of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the enumeration.</typeparam>
            <param name="left">The first instance to be merged.</param>
            <param name="right">The second instance to be merged.</param>
            <returns>A merged result.</returns>
        </member>
        <member name="M:System.CommonMethods.Self``1(``0)">
            <summary>
            Returns the argument <paramref name="value"/>.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <param name="value">The value.</param>
            <returns>The value itself.</returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntax">
            <summary>
            Represents a list of <see cref="T:System.String"/> constants being used by <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/>.
            </summary>
            <remarks>
            In fact such fields are totally same as ones in attribute type <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/>,
            but I don't like to reference them using attribute full name.
            </remarks>
            <seealso cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntax.Json">
            <summary>
            The syntax identifier for strings containing JavaScript Object Notation (JSON).
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntax.Regex">
            <summary>
            The syntax identifier for strings containing regular expressions.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntax.Uri">
            <summary>
            The syntax identifier for strings containing URIs.
            </summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntax.Xml">
            <summary>
            The syntax identifier for strings containing XML.
            </summary>
        </member>
        <member name="T:System.ArrayExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Array"/>, especially for one-dimensional array.
            </summary>
            <seealso cref="T:System.Array"/>
        </member>
        <member name="M:System.ArrayExtensions.ForEachRef``1(``0[],System.ActionRef{``0})">
            <summary>
            Same as for-each method <see cref="M:System.Array.ForEach``1(``0[],System.Action{``0})"/>, but iterating on references to corresponding elements.
            </summary>
            <typeparam name="T">The type of each element in this array.</typeparam>
            <param name="this">The array.</param>
            <param name="callback">The callback method to handle for each reference to each element.</param>
            <seealso cref="M:System.Array.ForEach``1(``0[],System.Action{``0})"/>
        </member>
        <member name="M:System.ArrayExtensions.ForEachRefUnsafe``1(``0[],)">
            <inheritdoc cref="M:System.ArrayExtensions.ForEachRef``1(``0[],System.ActionRef{``0})"/>
        </member>
        <member name="M:System.ArrayExtensions.InitializeArray``1(``0[],System.ArrayInitializer{``0})">
            <summary>
            Initializes an array, using the specified method to initialize each element.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="array">The array.</param>
            <param name="initializer">The initializer callback method.</param>
        </member>
        <member name="M:System.ArrayExtensions.SortUnsafe``1(``0[],)">
            <summary>
            Sort the specified array by quick sort.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array.</param>
            <param name="comparer">The method to compare two elements.</param>
        </member>
        <member name="T:System.Reflection.AssemblyExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Reflection.Assembly"/>.
            </summary>
            <seealso cref="T:System.Reflection.Assembly"/>
        </member>
        <member name="M:System.Reflection.AssemblyExtensions.GetDerivedTypes(System.Reflection.Assembly,System.Type)">
            <summary>
            Gets all possible types derived from an <see langword="interface"/> type,
            or a base <see langword="class"/> type, in the specified assembly.
            </summary>
            <param name="this">The assembly to be checked.</param>
            <param name="baseType">The type as the base type.</param>
            <returns>All possible derived types.</returns>
        </member>
        <member name="M:System.Reflection.AssemblyExtensions.GetDerivedTypes``1(System.Reflection.Assembly)">
            <inheritdoc cref="M:System.Reflection.AssemblyExtensions.GetDerivedTypes(System.Reflection.Assembly,System.Type)"/>
            <typeparam name="TBase">The type as the base type.</typeparam>
            <param name="this"><inheritdoc/></param>
            <returns><inheritdoc/></returns>
        </member>
        <member name="T:System.Reflection.CustomAttributeProviderExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Reflection.ICustomAttributeProvider"/>.
            </summary>
            <seealso cref="T:System.Reflection.ICustomAttributeProvider"/>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetGenericAttributeTypeArguments``1(``0,System.Type)">
            <summary>
            Gets the type arguments of the specified attribute type applied to the specified property.
            </summary>
            <typeparam name="T">The type of custom attribute provider.</typeparam>
            <param name="this">The instance.</param>
            <param name="genericAttributeType">The generic attribute type.</param>
            <returns>The types of the generic type arguments.</returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetCustomGenericAttribute``1(``0,System.Type)">
            <summary>
            <inheritdoc cref="M:System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type)" path="/summary"/>
            </summary>
            <typeparam name="T">The type of custom attribute provider.</typeparam>
            <param name="this">The instance.</param>
            <param name="genericAttributeType">The generic attribute type.</param>
            <returns>
            <inheritdoc cref="M:System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type)" path="/returns"/>
            </returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetCustomGenericAttributes``1(``0,System.Type)">
            <summary>
            <inheritdoc cref="M:System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type)" path="/summary"/>
            </summary>
            <typeparam name="T">The type of custom attribute provider.</typeparam>
            <param name="this">The instance.</param>
            <param name="genericAttributeType">The generic attribute type.</param>
            <returns>
            <inheritdoc cref="M:System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type)" path="/returns"/>
            </returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.IndexOfBacktick(System.String)">
            <summary>
            Get the index of the text of the back tick.
            </summary>
            <param name="this">The string text.</param>
            <returns>The index of the backtick in the string.</returns>
        </member>
        <member name="M:System.Reflection.CustomAttributeProviderExtensions.GetAttributesCore``1(``0)">
            <summary>
            Get custom attributes.
            </summary>
            <typeparam name="T">The type of the provider.</typeparam>
            <param name="this">The custom attribute provider.</param>
            <returns>The attributes.</returns>
        </member>
        <member name="T:System.Reflection.MemberInfoExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Reflection.MemberInfo"/> instances.
            </summary>
            <seealso cref="T:System.Reflection.MemberInfo"/>
        </member>
        <member name="M:System.Reflection.MemberInfoExtensions.GetInitMethod(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            When overridden in a derived class, returns the <see langword="init"/> accessor for this property.
            </summary>
            <param name="this">The property.</param>
            <param name="nonPublic">
            Indicates whether the accessor should be returned if it is non-public.
            <see langword="true"/> if a non-public accessor is to be returned; otherwise, <see langword="false"/>.
            </param>
            <returns>
            This property's <see langword="init"/> method, or <see langword="null"/>, as shown in the following table.
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Condition</description>
            </listheader>
            <item>
            <term>The <see langword="init"/> method for this property</term>
            <description>
            The <see langword="init"/> accessor is public, or <paramref name="nonPublic"/> is <see langword="true"/>
            and the <see langword="init"/> accessor is non-public.
            </description>
            </item>
            <item>
            <term><see langword="null"/></term>
            <description>
            <paramref name="nonPublic"/> is <see langword="true"/>, but the property is read-only,
            or <paramref name="nonPublic"/> is <see langword="false"/> and the <see langword="init"/> accessor is non-public,
            or there is no <see langword="init"/> accessor.
            </description>
            </item>
            </list>
            </returns>
        </member>
        <member name="T:System.Reflection.TypeExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Type"/>.
            </summary>
            <seealso cref="T:System.Type"/>
        </member>
        <member name="M:System.Reflection.TypeExtensions.IsGenericAssignableTo(System.Type,System.Type)">
            <summary>
            Determines whether the current type can be assigned to a variable of the specified
            <paramref name="targetType"/>, although it is with generic parameters.
            </summary>
            <param name="this">The current type.</param>
            <param name="targetType">The type to compare with the current type.</param>
            <returns>Returns <see langword="true"/> if the target type is matched, without generic constraints.</returns>
            <seealso href="https://stackoverflow.com/questions/74616/how-to-detect-if-type-is-another-generic-type/1075059#1075059">
            Question: How to detect if type is another generic type
            </seealso>
        </member>
        <member name="M:System.Reflection.TypeExtensions.HasParameterlessConstructor(System.Type)">
            <summary>
            Determines whether the type has a parameterless constructor.
            </summary>
            <param name="type">The type.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:System.Collections.BitArrayExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <seealso cref="T:System.Collections.BitArray"/>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetCardinality(System.Collections.BitArray)">
            <summary>
            Get the cardinality of the specified <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <param name="this">The array.</param>
            <returns>The total number of bits set <see langword="true"/>.</returns>
        </member>
        <member name="T:System.Collections.ObjectModel.CollectionExtensions">
            <summary>
            Provides with extension methos on <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
            </summary>
            <seealso cref="T:System.Collections.ObjectModel.Collection`1"/>
        </member>
        <member name="M:System.Collections.ObjectModel.CollectionExtensions.Insert``1(System.Collections.ObjectModel.Collection{``0},System.Index,``0)">
            <inheritdoc cref="M:System.Collections.ObjectModel.Collection`1.Insert(System.Int32,`0)"/>
            <param name="this">The current collection.</param>
            <param name="index"/>
            <param name="item"/>
        </member>
        <member name="T:System.Collections.ObjectModel.ObservableCollectionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.
            </summary>
            <seealso cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionExtensions.FindIndex``1(System.Collections.ObjectModel.ObservableCollection{``0},System.Func{``0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.
            </summary>
            <typeparam name="T"><inheritdoc cref="T:System.Collections.Generic.List`1" path="/typeparam[@name='T']"/></typeparam>
            <param name="this">The current collection.</param>
            <param name="match"><inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" path="/param[@name='match']"/></param>
            <returns><inheritdoc cref="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" path="/returns"/></returns>
        </member>
        <member name="M:System.Collections.ObjectModel.ObservableCollectionExtensions.FindLastIndex``1(System.Collections.ObjectModel.ObservableCollection{``0},System.Func{``0,System.Boolean})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/>.
            </summary>
            <typeparam name="T"><inheritdoc cref="T:System.Collections.Generic.List`1" path="/typeparam[@name='T']"/></typeparam>
            <param name="this">The current collection.</param>
            <param name="match"><inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" path="/param[@name='match']"/></param>
            <returns><inheritdoc cref="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" path="/returns"/></returns>
        </member>
        <member name="T:System.Collections.Generic.ListExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.Remove``1(System.Collections.Generic.List{``0})">
            <summary>
            Removes the last element stored in the current <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list to be modified.</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.RemoveAt``1(System.Collections.Generic.List{``0},System.Index)">
            <inheritdoc cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)"/>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.SequenceEqual``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the elements by using <see cref="M:System.IEquatable`1.Equals(`0)"/> for their type.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">A <see cref="T:System.Collections.Generic.List`1"/> to compare to <paramref name="other"/>.</param>
            <param name="other">A <see cref="T:System.Collections.Generic.List`1"/> to compare to <paramref name="this"/>.</param>
            <returns>
            <see langword="true"/> if the two source sequences are of equal length and their correpsonding elements are equal according
            to <see cref="M:System.IEquatable`1.Equals(`0)"/> for their type; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.AsSpan``1(System.Collections.Generic.List{``0})">
            <inheritdoc cref="M:System.Runtime.InteropServices.CollectionsMarshal.AsSpan``1(System.Collections.Generic.List{``0})"/>
            <param name="this">The instance to be transformed.</param>
        </member>
        <member name="M:System.Collections.Generic.ListExtensions.AsReadOnlySpan``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets a <see cref="T:System.ReadOnlySpan`1"/> view over the data in a list. Items should not be added or removed from the <see cref="T:System.Collections.Generic.List`1"/>
            while the <see cref="T:System.ReadOnlySpan`1"/> is in use.
            </summary>
            <param name="this">The instance to be transformed.</param>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> instance over the <see cref="T:System.Collections.Generic.List`1"/>.</returns>
        </member>
        <member name="T:System.Collections.Generic.StackExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.Generic.Stack`1"/> instances.
            </summary>
            <seealso cref="T:System.Collections.Generic.Stack`1"/>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.Reverse``1(System.Collections.Generic.Stack{``0})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" path="/summary"/>
            </summary>
            <param name="this"><inheritdoc cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" path="/param[@name='source']"/></param>
            <returns><inheritdoc cref="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" path="/returns"/></returns>
        </member>
        <member name="T:System.DelegateExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Delegate"/>.
            </summary>
            <seealso cref="T:System.Delegate"/>
        </member>
        <member name="M:System.DelegateExtensions.GetInvocations``1(``0)">
            <summary>
            Returns the invocation list of the delegate.
            </summary>
            <typeparam name="T">The type of the delegate.</typeparam>
            <param name="this">The instance.</param>
            <returns>An array of delegates representing the invocation list of the current delegate.</returns>
        </member>
        <member name="T:System.DoubleExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Double"/>.
            </summary>
            <seealso cref="T:System.Double"/>
        </member>
        <member name="M:System.DoubleExtensions.NearlyEquals(System.Double,System.Double)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.DoubleExtensions.NearlyEquals(System.Double,System.Double,System.Double)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            If the differ of two values to compare is lower than the specified epsilon value,
            the method will return <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value to compare.</param>
            <param name="epsilon">The epsilon value (the minimal differ).</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.EnumExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Enum"/>.
            </summary>
            <seealso cref="T:System.Enum"/>
        </member>
        <member name="M:System.EnumExtensions.IsFlag``1(``0)">
            <summary>
            Checks whether the current enumeration field is a flag.
            </summary>
            <typeparam name="T">The type of the current field.</typeparam>
            <param name="this">The current field to check.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.EnumExtensions.GetAllFlags``1(``0)">
            <summary>
            To get all possible flags from a specified enumeration instance.
            </summary>
            <typeparam name="T">The type of that enumeration.</typeparam>
            <param name="this">The field.</param>
            <returns>
            All flags. If the enumeration field doesn't contain any flags, the return value will be <see langword="null"/>.
            </returns>
        </member>
        <member name="M:System.EnumExtensions.GetEnumerator``1(``0)">
            <summary>
            Get all possible flags that the current enumeration field set.
            </summary>
            <typeparam name="T">The type of the enumeration.</typeparam>
            <param name="this">The current enumeration type instance.</param>
            <returns>All flags.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the type isn't applied the attribute <see cref="T:System.FlagsAttribute"/>.
            </exception>
        </member>
        <member name="T:System.IO.File2">
            <summary>
            Extends <see cref="T:System.IO.File"/>.
            </summary>
            <seealso cref="T:System.IO.File"/>
        </member>
        <member name="F:System.IO.File2.InvalidCharacters">
            <summary>
            The field for invalid path characters as a file name.
            </summary>
        </member>
        <member name="M:System.IO.File2.IsValidFileName(System.String)">
            <summary>
            Determines whether the specified file name is valid.
            </summary>
            <param name="fileName">The file name to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.IO.StreamReaderExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <seealso cref="T:System.IO.StreamReader"/>
        </member>
        <member name="M:System.IO.StreamReaderExtensions.EndsWithNewLine(System.IO.StreamReader)">
            <summary>
            Determines whether a file ends with new line character.
            </summary>
            <param name="this">The <see cref="T:System.IO.StreamReader"/> instance.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
            <remarks><i>
            This method only supports for Windows now. For other OS platforms, this method cannot determine the end line characters
            because I have already forgotten them...
            </i></remarks>
        </member>
        <member name="T:System.Text.Json.JsonSerializerOptionsExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.JsonSerializerOptions"/>.
            </summary>
            <seealso cref="T:System.Text.Json.JsonSerializerOptions"/>
        </member>
        <member name="M:System.Text.Json.JsonSerializerOptionsExtensions.GetConverter``2(System.Text.Json.JsonSerializerOptions)">
            <summary>
            Returns the converter that supports the given type, or the <typeparamref name="TConverter"/>
            will be used when the property <see cref="P:System.Text.Json.JsonSerializerOptions.Converters"/>
            doesn't contain any valid converters.
            </summary>
            <typeparam name="T">The type to get converter.</typeparam>
            <typeparam name="TConverter">
            The type that is the converter type to convert the instance of type <typeparamref name="T"/>.
            </typeparam>
            <param name="this">The options to check the existence of the converter.</param>
            <returns>
            The converter that supports the given type, or the <typeparamref name="TConverter"/>
            will be used when the property <see cref="P:System.Text.Json.JsonSerializerOptions.Converters"/>
            doesn't contain any valid converters.
            </returns>
            <seealso cref="P:System.Text.Json.JsonSerializerOptions.Converters"/>
        </member>
        <member name="T:System.Text.Json.Utf8JsonReaderExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.Utf8JsonReader"/>.
            </summary>
            <seealso cref="T:System.Text.Json.Utf8JsonReader"/>
        </member>
        <member name="M:System.Text.Json.Utf8JsonReaderExtensions.GetNestedObject``1(System.Text.Json.Utf8JsonReader@,System.Text.Json.JsonSerializerOptions)">
            <summary>
            To read as a nested object in the JSON string stream.
            </summary>
            <typeparam name="T">The type of the instance to be deserialized.</typeparam>
            <param name="this">The <see cref="T:System.Text.Json.Utf8JsonReader"/> instance.</param>
            <param name="options">The options.</param>
        </member>
        <member name="T:System.Text.Json.Utf8JsonWriterExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.Json.Utf8JsonWriter"/>.
            </summary>
            <seealso cref="T:System.Text.Json.Utf8JsonWriter"/>
        </member>
        <member name="M:System.Text.Json.Utf8JsonWriterExtensions.WriteNestedObject``1(System.Text.Json.Utf8JsonWriter,``0,System.Text.Json.JsonSerializerOptions)">
            <summary>
            To write an object as nested one in the JSON string stream.
            </summary>
            <typeparam name="T">The type of the instance to be serialized.</typeparam>
            <param name="this">The <see cref="T:System.Text.Json.Utf8JsonWriter"/> instance.</param>
            <param name="instance">The instance to be serialized.</param>
            <param name="options">The options.</param>
        </member>
        <member name="M:System.Text.Json.Utf8JsonWriterExtensions.WriteArray``1(System.Text.Json.Utf8JsonWriter,``0[],System.Text.Json.JsonSerializerOptions)">
            <summary>
            To write an array of element type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The <see cref="T:System.Text.Json.Utf8JsonWriter"/> instance.</param>
            <param name="array">The array.</param>
            <param name="options">The options.</param>
        </member>
        <member name="M:System.Text.Json.Utf8JsonWriterExtensions.WriteStringValue(System.Text.Json.Utf8JsonWriter,System.Text.StringHandler@)">
            <summary>
            Writes a string text value specified as a <see cref="T:System.Text.StringHandler"/> instance as an element
            of a JSON array.
            </summary>
            <param name="this">The <see cref="T:System.Text.Json.Utf8JsonWriter"/> instance.</param>
            <param name="handler">The string handler.</param>
        </member>
        <member name="T:System.Text.Json.CommonSerializerOptions">
            <summary>
            Provides a list of <see cref="T:System.Text.Json.JsonSerializerOptions"/> instances that is used on default cases.
            </summary>
        </member>
        <member name="F:System.Text.Json.CommonSerializerOptions.PascalCasing">
            <summary>
            Creates a default option instance with:
            <list type="bullet">
            <item><see cref="P:System.Text.Json.JsonSerializerOptions.WriteIndented"/> is <see langword="true"/></item>
            <item><see cref="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties"/> is <see langword="true"/></item>
            <item>
            <see cref="P:System.Text.Json.JsonSerializerOptions.Encoder"/> is <see cref="P:System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping"/>
            </item>
            <item><see cref="P:System.Text.Json.JsonSerializerOptions.ReadCommentHandling"/> is <see cref="F:System.Text.Json.JsonCommentHandling.Skip"/></item>
            <item><see cref="P:System.Text.Json.JsonSerializerOptions.UnmappedMemberHandling"/> is <see cref="F:System.Text.Json.Serialization.JsonUnmappedMemberHandling.Disallow"/></item>
            </list>
            </summary>
        </member>
        <member name="T:System.Text.Json.PascalCaseJsonNamingPolicy">
            <summary>
            Defines the pascal casing JSON naming policy.
            </summary>
            <remarks>
            This type cannot be initialized; instead, you can use the property <see cref="P:System.Text.Json.PascalCaseJsonNamingPolicy.PascalCase"/> to get the instance.
            </remarks>
            <seealso cref="P:System.Text.Json.PascalCaseJsonNamingPolicy.PascalCase"/>
        </member>
        <member name="P:System.Text.Json.PascalCaseJsonNamingPolicy.PascalCase">
            <summary>
            Gets the naming policy for pascal-casing.
            </summary>
            <returns>The naming policy for pascal-casing.</returns>
        </member>
        <member name="M:System.Text.Json.PascalCaseJsonNamingPolicy.ConvertName(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:System.Text.StringBuilderExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <seealso cref="T:System.Text.StringBuilder"/>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.RemoveFrom(System.Text.StringBuilder,System.Int32)">
            <summary>
            Remove all characters behind the character whose index is specified.
            </summary>
            <param name="this">The instance to remove characters.</param>
            <param name="startIndex">The start index.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.RemoveFrom(System.Text.StringBuilder,System.Index)">
            <summary>
            Remove all characters behind the character whose index is specified.
            </summary>
            <param name="this">The instance to remove characters.</param>
            <param name="startIndex">The start index.</param>
            <returns>The reference of the current instance.</returns>
        </member>
        <member name="T:System.Text.RegularExpressions.MatchCollectionEnumerable">
            <summary>
            Provides LINQ-based extension methods on <see cref="T:System.Text.RegularExpressions.MatchCollection"/>.
            </summary>
            <seealso cref="T:System.Text.RegularExpressions.MatchCollection"/>
        </member>
        <member name="M:System.Text.RegularExpressions.MatchCollectionEnumerable.Select``1(System.Text.RegularExpressions.MatchCollection,System.Func{System.Text.RegularExpressions.Match,``0})">
            <inheritdoc cref="M:System.Linq.ReadOnlySpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0">
            <summary>Custom <see cref="T:System.Text.RegularExpressions.Regex"/>-derived type for the NullLinesOrHeaderSpacesPattern method.</summary>
        </member>
        <member name="F:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0.Instance">
            <summary>Cached, thread-safe singleton instance.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0.#ctor">
            <summary>Initializes the instance.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0.RunnerFactory">
            <summary>Provides a factory for creating <see cref="T:System.Text.RegularExpressions.RegexRunner"/> instances to be used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0.RunnerFactory.CreateInstance">
            <summary>Creates an instance of a <see cref="T:System.Text.RegularExpressions.RegexRunner"/> used by methods on <see cref="T:System.Text.RegularExpressions.Regex"/>.</summary>
        </member>
        <member name="T:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0.RunnerFactory.Runner">
            <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0.RunnerFactory.Runner.Scan(System.ReadOnlySpan{System.Char})">
            <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
        </member>
        <member name="M:System.Text.RegularExpressions.Generated.NullLinesOrHeaderSpacesPattern_0.RunnerFactory.Runner.TryMatchAtCurrentPosition(System.ReadOnlySpan{System.Char})">
            <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
            <param name="inputSpan">The text being scanned by the regular expression.</param>
            <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
        </member>
        <member name="T:System.Text.StringHandler">
            <summary>
            <para>
            Provides a handler used on two cases:
            <list type="bullet">
            <item>By the language compiler to process interpolated strings into <see cref="T:System.String"/> instances.</item>
            <item>
            As a <see cref="T:System.String"/> builder to append and concatenate multiple <see cref="T:System.String"/>s to a whole one.
            </item>
            </list>
            </para>
            <para>
            Different with <see cref="T:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler"/>, this type won't contain
            any formatters to construct any custom format operations, i.e. using <see cref="T:System.IFormatProvider"/>.
            </para>
            </summary>
            <remarks>
            You can use this type like this:
            <code><![CDATA[
            scoped var sb = new StringHandler(initialCapacity: 100);
            sb.Append("Hello");
            sb.Append(',');
            sb.Append("World");
            sb.Append('!');
            
            Console.WriteLine(sb.ToStringAndClear());
            ]]></code>
            </remarks>
            <seealso cref="T:System.Runtime.CompilerServices.DefaultInterpolatedStringHandler"/>
            <seealso cref="T:System.IFormatProvider"/>
        </member>
        <member name="F:System.Text.StringHandler.GuessedLengthPerHole">
            <summary>
            Expected average length of formatted data used for an individual interpolation expression result.
            </summary>
            <remarks>
            <para>
            This is inherited from <see cref="M:System.String.Format(System.String,System.Object[])"/>,
            and could be changed based on further data.
            </para>
            <para>
            <see cref="M:System.String.Format(System.String,System.Object[])"/> actually uses <c>format.Length + args.Length * 8</c>,
            but <c>format.Length</c> includes the format items themselves, e.g. <c>"{0}"</c>,
            and since it's rare to have double-digit numbers of items, we bump the 8 up to 11 to account
            for the three extra characters in <c>"{d}"</c>, since the compiler-provided base length won't include
            the equivalent character count.
            </para>
            <para><i>The original value implemented by .NET foundation is 11, but I change it to 8.</i></para>
            </remarks>
            <seealso cref="M:System.String.Format(System.String,System.Object[])"/>
        </member>
        <member name="F:System.Text.StringHandler.MinimumArrayPoolLength">
            <summary>
            Minimum size array to rent from the pool.
            </summary>
            <remarks>
            Same as stack-allocation size used today by <see cref="M:System.String.Format(System.String,System.Object[])"/>.
            </remarks>
            <seealso cref="M:System.String.Format(System.String,System.Object[])"/>
        </member>
        <member name="F:System.Text.StringHandler._arrayToReturnToPool">
            <summary>
            Array rented from the array pool and used to back <see cref="F:System.Text.StringHandler._chars"/>.
            </summary>
        </member>
        <member name="F:System.Text.StringHandler._chars">
            <summary>
            The span to write into.
            </summary>
        </member>
        <member name="M:System.Text.StringHandler.#ctor">
            <summary>
            Creates a handler used to translate an interpolated string into a <see cref="T:System.String" />,
            with the default-sized buffer 256.
            </summary>
            <remarks>
            <target name="constructor">
				<i>
					The feature "Custom parameterless struct constructor" makes the parameterless struct constructor
					different with <c>default(T)</c>. If you has defined a parameterless struct constructor,
					<c>new T()</c> is no longer with the same meaning as <c>default(T)</c>.
				</i>
			</target>
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.#ctor(System.Int32)">
            <summary>
            Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.
            </summary>
            <param name="initialCapacity">The number of constant characters as the default memory to initialize.</param>
        </member>
        <member name="M:System.Text.StringHandler.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.
            </summary>
            <param name="literalLength">
            The number of constant characters outside of interpolation expressions in the interpolated string.
            </param>
            <param name="holeCount">The number of interpolation expressions in the interpolated string.</param>
            <remarks>
            This is intended to be called only by compiler-generated code.
            Arguments aren't validated as they'd otherwise be for members intended to be used directly.
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.#ctor(System.Int32,System.Int32,System.Span{System.Char})">
            <summary>
            Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>.
            </summary>
            <param name="literalLength">
            The number of constant characters outside of interpolation expressions in the interpolated string.
            </param>
            <param name="holeCount">The number of interpolation expressions in the interpolated string.</param>
            <param name="initialBuffer">
            A buffer temporarily transferred to the handler for use as part of its formatting.
            Contents may be overwritten.
            </param>
            <remarks>
            This is intended to be called only by compiler-generated code.
            Arguments are not validated as they'd otherwise be for members intended to be used directly.
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.#ctor(System.String)">
            <summary>
            Creates a handler used to translate an interpolated string into a <see cref="T:System.String"/>
            that is initialized by a string value.
            </summary>
            <param name="initialString">The initialized string.</param>
        </member>
        <member name="P:System.Text.StringHandler.Length">
            <summary>
            Position at which to write the next character.
            </summary>
        </member>
        <member name="P:System.Text.StringHandler.Text">
            <summary>
            Gets a span of the written characters thus far.
            </summary>
        </member>
        <member name="P:System.Text.StringHandler.Item(System.Int32)">
            <summary>
            Gets the reference of a character at the specified index.
            </summary>
            <param name="index">The index.</param>
            <returns>The reference of the character.</returns>
            <remarks>
            <target name="indexer-return">
				<i>
					This indexer returns a value by <see langword="ref" />,
					which means you can use the return value to re-assign a new value, as the same behavior
					as the <see langword="set" /> accessor, therefore the indexer does not contain the setter.
				</i>
			</target>
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.CopyTo(System.Text.StringHandler@)">
            <summary>
            Copies the current collection into the specified collection.
            </summary>
            <param name="handler">The collection.</param>
        </member>
        <member name="M:System.Text.StringHandler.Equals(System.Text.StringHandler)">
            <summary>
            Determine whether the specified <see cref="T:System.Text.StringHandler"/> instance hold a same character set
            as the current instance.
            </summary>
            <param name="other">The instance to compare.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Text.StringHandler.GetPinnableReference">
            <target name="method">
				<summary>
					Returns a reference as the fixed position of the current instance.
					For example, the return value will be the pointer value that points to the zero-indexed
					place in an array.
				</summary>
				<returns>A reference as the fixed position of the current instance.</returns>
				<remarks>
					Beginning with C# 7, we can customize the return value type of a <see langword="fixed" /> variable
					if we implement a parameterless method called <c>GetPinnableReference</c>, returning by
					<see langword="ref" /> or <see langword="ref readonly" />. For example, if we hold a fixed buffer
					of element type:
					<code>
<![CDATA[
class ExampleType
{
    private fixed short _maskList[100];

    public ref readonly short GetPinnableReference() => ref _maskList[0];
}
]]>
					</code>
					We can use <see langword="fixed" /> statement to define a variable of type <see langword="short" />*
					as the left-value.
					<code>
<![CDATA[
var instance = new ExampleType();
fixed (short* ptr = instance)
{
    // Operation here.
}
]]>
					</code>
				</remarks>
			</target>
        </member>
        <member name="M:System.Text.StringHandler.GetPinnableReference(System.Boolean)">
            <summary>
            Get a pinnable reference to the builder.
            </summary>
            <param name="withTerminate">
            Ensures that the builder has a null character after <see cref="P:System.Text.StringHandler.Length"/>.
            </param>
            <seealso cref="P:System.Text.StringHandler.Length"/>
        </member>
        <member name="M:System.Text.StringHandler.ToString">
            <inheritdoc/>
        </member>
        <member name="M:System.Text.StringHandler.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="M:System.Text.StringHandler.AppendLiteral(System.String)">
            <summary>
            Writes the specified string to the handler.
            </summary>
            <param name="value">The string to write.</param>
            <remarks>
            <para>
            <see cref="M:System.Text.StringHandler.AppendLiteral(System.String)"/> is expected to always be called by compiler-generated code
            with a literal string. By inlining it, the method body is exposed to the constant length of that literal,
            allowing the JIT to prune away the irrelevant cases.
            This effectively enables multiple implementations of <see cref="M:System.Text.StringHandler.AppendLiteral(System.String)"/>,
            special-cased on and optimized for the literal's length.
            </para>
            <para>
            We special-case lengths 1 and 2 because they're very common, e.g.
            <list type="number">
            <item><c>' '</c>, <c>'.'</c>, <c>'-'</c>, <c>'\t'</c>, etc.</item>
            <item><c>", "</c>, <c>"0x"</c>, <c>"=>"</c>, <c>": "</c>, etc.</item>
            </list>
            but we refrain from adding more because, in the rare case where <see cref="M:System.Text.StringHandler.AppendLiteral(System.String)"/>
            is called with a non-literal, there is a lot of code here to be inlined.
            </para>
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.Object,System.Int32,System.String)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted(System.Object,System.Int32,System.String)"/>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.Char)">
            <summary>
            Append a character at the tail of the collection.
            </summary>
            <param name="c">The character.</param>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.Char,System.Int32)">
            <summary>
            Append a serial of same characters into the collection.
            </summary>
            <param name="c">The character.</param>
            <param name="count">The number of the character you want to append.</param>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.Char*,System.Int32)">
            <summary>
            Append a string that is represented as a <see cref="T:System.Char"/>*.
            </summary>
            <param name="value">The string.</param>
            <param name="length">The length of the string.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="value"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.String)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted(System.String)"/>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.String,System.Int32,System.String)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted(System.String,System.Int32,System.String)"/>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.ReadOnlySpan{System.Char})">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})"/>
        </member>
        <member name="M:System.Text.StringHandler.Append(System.ReadOnlySpan{System.Char},System.Int32,System.String)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted(System.ReadOnlySpan{System.Char},System.Int32,System.String)"/>
        </member>
        <member name="M:System.Text.StringHandler.Append``1(``0)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted``1(``0)"/>
        </member>
        <member name="M:System.Text.StringHandler.Append``1(``0,System.Int32)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted``1(``0,System.Int32)"/>
        </member>
        <member name="M:System.Text.StringHandler.Append``1(``0,System.String)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted``1(``0,System.String)"/>
        </member>
        <member name="M:System.Text.StringHandler.Append``1(``0,System.Int32,System.String)">
            <inheritdoc cref="M:System.Text.StringHandler.AppendFormatted``1(``0,System.Int32,System.String)"/>
        </member>
        <member name="M:System.Text.StringHandler.AppendLine">
            <summary>
            Append a new line string <see cref="P:System.Environment.NewLine"/>.
            </summary>
            <seealso cref="P:System.Environment.NewLine"/>
        </member>
        <member name="M:System.Text.StringHandler.AppendCharacters(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Append a serial of characters at the tail of the collection.
            </summary>
            <param name="chars">The serial of characters.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendRange``1(System.ReadOnlySpan{``0})">
            <inheritdoc cref="M:System.Text.StringHandler.AppendRange``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:System.Text.StringHandler.AppendRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Append a serial of strings from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendRange``1(System.Collections.Generic.IEnumerable{``0},)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the function pointer as this argument.
            </param>
        </member>
        <member name="M:System.Text.StringHandler.AppendRange``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the delegate instance as this argument.
            </param>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithSeparator``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Append a serial of strings from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="separator">The separator to append when an element is finished to append.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithSeparator``1(System.Collections.Generic.IEnumerable{``0},,System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the function pointer as this argument.
            </param>
            <param name="separator">The separator to append when an element is finished to append.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithSeparator``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the delegate instance as this argument.
            </param>
            <param name="separator">The separator to append when an element is finished to append.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0*,System.Int32,,System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements that is represented as a pointer.</param>
            <param name="length">The length of the list.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the delegate instance as this argument.
            </param>
            <param name="separator">The separator to append when an element is finished to append.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="list"/> or <paramref name="converter"/>
            is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0*,System.Int32,System.Func{``0,System.String},System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements that is represented as a pointer.</param>
            <param name="length">The length of the list.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the delegate instance as this argument.
            </param>
            <param name="separator">The separator to append when an element is finished to append.</param>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="list"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0@,System.Int32,,System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements that is represented as a pointer.</param>
            <param name="length">The length of the list.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the delegate instance as this argument.
            </param>
            <param name="separator">The separator to append when an element is finished to append.</param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="list"/> is <see langword="null"/>.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="converter"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0@,System.Int32,System.Text.StringHandlerRefAppender{``0},System.String)">
            <summary>
            Append a serial of strings converted from a serial of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list of elements that is represented as a pointer.</param>
            <param name="length">The length of the list.</param>
            <param name="converter">
            The converter that allows the instance to convert into the <see cref="T:System.String"/> representation,
            whose the rule is defined as a method specified as the delegate instance as this argument.
            </param>
            <param name="separator">The separator to append when an element is finished to append.</param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="list"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Text.StringHandler.AppendRangeWithLines``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Append a series of elements into the current collection.
            In addition, new line characters will be inserted after each element.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="list">The list.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendLargeObjectFormatted``1(``0@)">
            <summary>
            Writes the specified large-object value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.AppendLargeObjectFormatted``1(``0@,System.String)">
            <summary>
            Writes the specified large-object value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.AppendLargeObjectFormatted``1(``0@,System.Int32)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.AppendLargeObjectFormatted``1(``0@,System.Int32,System.String)">
            <summary>
            Writes the specified large-object value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted(System.Object,System.Int32,System.String)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
            <remarks>
            This overload is expected to be used rarely, only if either:
            <list type="bullet">
            <item>
            a) something strongly typed as <see cref="T:System.Object"/> is formatted with both an alignment and a format.
            </item>
            <item>
            b) the compiler is unable to target type to <c>T</c>.
            </item>
            </list>
            It exists purely to help make cases from (b) compile. Just delegate to the <c>T</c>-based implementation.
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted(System.String)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted(System.String,System.Int32,System.String)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
            <remarks>
            Format is meaningless for strings and doesn't make sense for someone to specify.
            We have the overload simply to disambiguate between <c><![CDATA[ReadOnlySpan<char>]]></c>
            and <see cref="T:System.Object"/>, just in case someone does specify a format,
            as <see cref="T:System.String"/> is implicitly convertible to both.
            Just delegate to the <c>T</c>-based implementation.
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})">
            <summary>
            Writes the specified character span to the handler.
            </summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted(System.ReadOnlySpan{System.Char},System.Int32,System.String)">
            <summary>
            Writes the specified string of chars to the handler.
            </summary>
            <param name="value">The span to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
            <param name="format">The format string.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted(System.Text.StringHandler)">
            <summary>
            Writes the specified interpolated string into the handler.
            </summary>
            <param name="handler">The handler that creates the interpolated string as this argument.</param>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted``1(``0)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted``1(``0,System.String)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted``1(``0,System.Int32)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormatted``1(``0,System.Int32,System.String)">
            <summary>
            Writes the specified value to the handler.
            </summary>
            <param name="value">The value to write.</param>
            <param name="format">The format string.</param>
            <param name="alignment">
            Minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
            <typeparam name="T">The type of the value to write.</typeparam>
        </member>
        <member name="M:System.Text.StringHandler.Reverse">
            <summary>
            Reverse the instance. For example, if the handler holds a string <c>"Hello"</c>,
            after called this method, the string will be <c>"olleH"</c>.
            </summary>
        </member>
        <member name="M:System.Text.StringHandler.Insert(System.Int32,System.Char,System.Int32)">
            <summary>
            Inserts a new character into the collection at the specified index.
            </summary>
            <param name="index">The index.</param>
            <param name="value">The character you want to insert into the collection.</param>
            <param name="count">The number.</param>
        </member>
        <member name="M:System.Text.StringHandler.Insert(System.Int32,System.String)">
            <summary>
            Inserts a new string into the collection at the specified index.
            </summary>
            <param name="index">The index you want to insert.</param>
            <param name="s">The string you want to insert.</param>
        </member>
        <member name="M:System.Text.StringHandler.Remove(System.Int32,System.Int32)">
            <summary>
            Remove a serial of characters from the specified index, with the specified length.
            </summary>
            <param name="startIndex">The start index.</param>
            <param name="length">The length you want to remove.</param>
            <remarks>
            This method will be costly (move a lot of elements), so you shouldn't call this method usually.
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.RemoveFromEnd(System.Int32)">
            <summary>
            Removes the specified number of characters from the end of the collection.
            </summary>
            <param name="length">The number of characters you want to remove.</param>
            <remarks>
            This method can be used for removing the last separator in a whole string, split by separators.
            For example:
            <code><![CDATA[
            const string separator = ", "; // Defines a separator.
            
            scoped var sb = new StringHandler(); // Creates a string concatenator.
            foreach (var element in list)
            {
                sb.Append(element); // Append the element.
                sb.Append(separator); // Append the separator.
            }
            
            // Use the method 'RemoveFromEnd' to remove the last separator.
            sb.RemoveFromEnd(separator.Length);
            
            // Get the final string value and release the temporarily allocated memory.
            return sb.ToStringAndClear();
            ]]></code>
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.ToStringAndClear">
            <summary>
            Gets the built <see cref="T:System.String"/> and clears the handler.
            </summary>
            <returns>The built string.</returns>
            <remarks>
            This releases any resources used by the handler. The method should be invoked only
            once and as the last thing performed on the handler. Subsequent use is erroneous, ill-defined,
            and may destabilize the process, as may using any other copies of the handler after
            <see cref="M:System.Text.StringHandler.ToStringAndClear"/> is called on any one of them.
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.Dispose">
            <summary>
            To dispose the object, releasing the memory allocated temporarily.
            </summary>
        </member>
        <member name="M:System.Text.StringHandler.AppendStringDirect(System.String)">
            <summary>
            Writes the specified string to the handler.
            </summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Text.StringHandler.Clear">
            <summary>
            Clears the handler, returning any rented array to the pool.
            </summary>
        </member>
        <member name="M:System.Text.StringHandler.AppendFormattedSlow(System.String)">
            <summary>Writes the specified value to the handler.</summary>
            <param name="value">The value to write.</param>
            <remarks>
            Slow path to handle a custom formatter, potentially null value,
            or a string that doesn't fit in the current buffer.
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.AppendOrInsertAlignmentIfNeeded(System.Int32,System.Int32)">
            <summary>
            Handles adding any padding required for aligning a formatted value in an interpolation expression.
            </summary>
            <param name="startingPos">The position at which the written value started.</param>
            <param name="alignment">
            Non-zero minimum number of characters that should be written for this value.
            If the value is negative, it indicates left-aligned and the required minimum is the absolute value.
            </param>
        </member>
        <member name="M:System.Text.StringHandler.EnsureCapacityForAdditionalChars(System.Int32)">
            <summary>
            Ensures <see cref="F:System.Text.StringHandler._chars"/> has the capacity to store <paramref name="additionalChars"/>
            beyond <see cref="P:System.Text.StringHandler.Length"/>.
            </summary>
        </member>
        <member name="M:System.Text.StringHandler.GrowThenCopyString(System.String)">
            <summary>
            Fallback for fast path in <see cref="M:System.Text.StringHandler.AppendStringDirect(System.String)"/>
            when there's not enough space in the destination.
            </summary>
            <param name="value">The string to write.</param>
        </member>
        <member name="M:System.Text.StringHandler.GrowThenCopySpan(System.ReadOnlySpan{System.Char})">
            <summary>
            Fallback for <see cref="M:System.Text.StringHandler.AppendFormatted(System.ReadOnlySpan{System.Char})"/> for when not enough space exists
            in the current buffer.
            </summary>
            <param name="value">The span to write.</param>
        </member>
        <member name="M:System.Text.StringHandler.Grow(System.Int32)">
            <summary>
            Grows <see cref="F:System.Text.StringHandler._chars"/> to have the capacity to store at least <paramref name="additionalChars"/>
            beyond <see cref="P:System.Text.StringHandler.Length"/>.
            </summary>
            <remarks>
            This method is called when the remaining space <c>_chars.Length - _pos</c> is
            insufficient to store a specific number of additional characters.
            Thus, we need to grow to at least that new total. <see cref="M:System.Text.StringHandler.GrowCore(System.UInt32)"/>
            will handle growing by more than that if possible.
            </remarks>
            <seealso cref="M:System.Text.StringHandler.GrowCore(System.UInt32)"/>
        </member>
        <member name="M:System.Text.StringHandler.Grow">
            <summary>
            Grows the size of <see cref="F:System.Text.StringHandler._chars"/>.
            </summary>
            <remarks>
            This method is called when the remaining space in <c>_chars</c> isn't sufficient to continue
            the operation. Thus, we need at least one character beyond <c>_chars.Length</c>.
            <see cref="M:System.Text.StringHandler.GrowCore(System.UInt32)"/> will handle growing by more than that if possible.
            </remarks>
            <seealso cref="M:System.Text.StringHandler.GrowCore(System.UInt32)"/>
        </member>
        <member name="M:System.Text.StringHandler.GrowCore(System.UInt32)">
            <summary>
            Grow the size of <see cref="F:System.Text.StringHandler._chars"/> to at least the specified <paramref name="requiredMinCapacity"/>.
            </summary>
            <param name="requiredMinCapacity">The required minimum capacity.</param>
            <remarks>
            <para>Design notes:</para>
            <para>
            We want the max of how much space we actually required and doubling our capacity (without going
            beyond the max allowed length). We also want to avoid asking for small arrays,
            to reduce the number of times we need to grow, and since we're working with unsigned integers
            that could technically overflow if someone tried to, for example, append a huge string
            to a huge string, we also clamp to <see cref="F:System.Int32.MaxValue"/>. Even if the array creation
            fails in such a case, we may later fail in <see cref="M:System.Text.StringHandler.ToStringAndClear"/>.
            </para>
            </remarks>
        </member>
        <member name="M:System.Text.StringHandler.Equals(System.Text.StringHandler,System.Text.StringHandler)">
            <summary>
            Determines whether two instances has same values with the other instance.
            </summary>
            <param name="left">The left instance.</param>
            <param name="right">The right instance.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Text.StringHandler.ElementToStringConverter``1(``0)">
            <summary>
            Provides with the default way to convert the specified instance of type <see cref="T:System.Int16"/>
            into a <see cref="T:System.String"/> value.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <param name="this">The instance.</param>
            <returns>The <see cref="T:System.String"/> value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the argument <paramref name="this"/> return <see langword="null"/>
            as the <c>ToString</c> method result.
            </exception>
            <remarks>
            You can put this method as the argument into the method invocation
            <see cref="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0*,System.Int32,System.Func{``0,System.String},System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0*,System.Int32,System.Func{``0,System.String},System.String)"/>
        </member>
        <member name="M:System.Text.StringHandler.ElementToStringConverter``1(``0@)">
            <summary>
            Provides with the default way to convert the specified instance of type <see cref="T:System.Int16"/>
            into a <see cref="T:System.String"/> value.
            </summary>
            <typeparam name="T">The type of the argument.</typeparam>
            <param name="this">The instance.</param>
            <returns>The <see cref="T:System.String"/> value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the argument <paramref name="this"/> return <see langword="null"/>
            as the <c>ToString</c> method result.
            </exception>
            <remarks>
            You can put this method as the argument into the method invocation
            <see cref="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0@,System.Int32,System.Text.StringHandlerRefAppender{``0},System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.StringHandler.AppendRangeWithSeparatorRef``1(``0@,System.Int32,System.Text.StringHandlerRefAppender{``0},System.String)"/>
        </member>
        <member name="T:System.Text.StringHandler.Enumerator">
            <summary>
            Encapsulates the enumerator of this collection.
            </summary>
        </member>
        <member name="F:System.Text.StringHandler.Enumerator._length">
            <summary>
            Indicates the length.
            </summary>
        </member>
        <member name="F:System.Text.StringHandler.Enumerator._index">
            <summary>
            Indicates whether 
            </summary>
        </member>
        <member name="F:System.Text.StringHandler.Enumerator._ptr">
            <summary>
            Indicates the pointer that points to the current character.
            </summary>
        </member>
        <member name="M:System.Text.StringHandler.Enumerator.#ctor(System.Text.StringHandler)">
            <summary>
            Initializes an instance with the specified character list specified as a <see cref="T:System.Span`1"/>.
            </summary>
            <param name="chars">The characters.</param>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the field <see cref="F:System.Text.StringHandler._chars"/> in argument <paramref name="chars"/>
            is a <see langword="null"/> reference after having been invoked <see cref="M:System.Span`1.GetPinnableReference"/>.
            </exception>
            <seealso cref="T:System.Span`1"/>
            <seealso cref="M:System.Span`1.GetPinnableReference"/>
        </member>
        <member name="P:System.Text.StringHandler.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.Text.StringHandler.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Text.StringHandler.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Text.StringHandler.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Text.StringHandler.op_Equality(System.Text.StringHandler,System.Text.StringHandler)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:System.Text.StringHandler.op_Inequality(System.Text.StringHandler,System.Text.StringHandler)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:System.Text.StringHandlerRefAppender`1">
            <summary>
            Defines an appender method that converts a <typeparamref name="T"/> instance into a <see cref="T:System.String"/> result.
            </summary>
            <typeparam name="T">The type of each element in a collection, specified as a read-only reference.</typeparam>
            <param name="refFirstElement">A reference that reference to the collection.</param>
            <returns>The converted string result.</returns>
        </member>
        <member name="T:System.MathExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Math"/>.
            </summary>
            <seealso cref="T:System.Math"/>
        </member>
        <member name="M:System.MathExtensions.Min(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the minimal one of three values.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <param name="c">The third value.</param>
            <returns>Which is the minimal value.</returns>
        </member>
        <member name="M:System.MathExtensions.Max(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the maximum one of three values.
            </summary>
            <param name="a">The first value.</param>
            <param name="b">The second value.</param>
            <param name="c">The third value.</param>
            <returns>Which is the maximum value.</returns>
        </member>
        <member name="T:System.MemoryExtensions2">
            <summary>
            Extends from type <see cref="T:System.MemoryExtensions"/>.
            </summary>
            <seealso cref="T:System.MemoryExtensions"/>
        </member>
        <member name="M:System.MemoryExtensions2.AsReadOnlySpan``1(``0[])">
            <inheritdoc cref="M:System.MemoryExtensions.AsSpan``1(``0[])"/>
        </member>
        <member name="T:System.ReadOnlyMemoryExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="M:System.ReadOnlyMemoryExtensions.ElementAt``1(System.ReadOnlyMemory{``0},System.Int32)">
            <summary>
            Fetch the element at the specified index inside a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The <see cref="T:System.ReadOnlyMemory`1"/> instance.</param>
            <param name="index">The desired index.</param>
            <returns>The reference to the element at the specified index.</returns>
        </member>
        <member name="M:System.ReadOnlyMemoryExtensions.ElementAt``1(System.ReadOnlyMemory{``0},System.Index)">
            <inheritdoc cref="M:System.ReadOnlyMemoryExtensions.ElementAt``1(System.ReadOnlyMemory{``0},System.Int32)"/>
        </member>
        <member name="M:System.ReadOnlyMemoryExtensions.GetEnumerator``1(System.ReadOnlyMemory{``0})">
            <summary>
            Creates a <see cref="T:System.ReadOnlyMemoryEnumerator`1"/> instance that can be consumed by a <see langword="foreach"/> loop.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The sequence of <see cref="T:System.ReadOnlyMemory`1"/> instance.</param>
            <returns>A <see cref="T:System.ReadOnlyMemoryEnumerator`1"/> instance.</returns>
        </member>
        <member name="T:System.ReadOnlySpanExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Span`1"/> and <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <seealso cref="T:System.Span`1"/>
            <seealso cref="T:System.ReadOnlySpan`1"/>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.ForEach``1(System.Span{``0},System.ActionRef{``0})">
            <summary>
            Performs the specified action on each element of the <see cref="T:System.Span`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the span.</typeparam>
            <param name="this">The current collection.</param>
            <param name="action">The <see cref="T:System.ActionRef`1"/> delegate to perform on each element of the <see cref="T:System.Span`1"/>.</param>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.ForEach``1(System.ReadOnlySpan{``0},System.ActionRefReadOnly{``0})">
            <summary>
            Performs the specified action on each element of the <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the span.</typeparam>
            <param name="this">The current collection.</param>
            <param name="action">
            The <see cref="T:System.ActionRefReadOnly`1"/> delegate to perform on each element of the <see cref="T:System.ReadOnlySpan`1"/>.
            </param>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.RandomSelectOne``1(System.ReadOnlySpan{``0},System.Random)">
            <summary>
            Select an element from the specified list of elements.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The collection.</param>
            <param name="random">The randomizer.</param>
            <returns>The chosen element.</returns>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.EnumerateReversely``1(System.ReadOnlySpan{``0})">
            <summary>
            Iterates on each element, in reverse order.
            </summary>
            <typeparam name="T">The type of each element in the sequence.</typeparam>
            <param name="this">The sequence to be iterated.</param>
            <returns>An enumerator type that iterates on each element.</returns>
        </member>
        <member name="M:System.ReadOnlySpanExtensions.EnumeratePairly``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a <see cref="T:System.PairEnumerator`1"/> instance that iterates on each element of pair elements.
            </summary>
            <typeparam name="T">The type of the array elements.</typeparam>
            <param name="this">The array.</param>
            <returns>An enumerable collection.</returns>
        </member>
        <member name="T:System.SingleExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Single"/>.
            </summary>
            <seealso cref="T:System.Single"/>
        </member>
        <member name="M:System.SingleExtensions.NearlyEquals(System.Single,System.Single)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.SingleExtensions.NearlyEquals(System.Single,System.Single,System.Single)">
            <summary>
            Indicates whether the specified value is nearly equals to the current value.
            If the differ of two values to compare is lower than the specified epsilon value,
            the method will return <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="other">The other value to compare.</param>
            <param name="epsilon">The epsilon value (the minimal differ).</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="T:System.StringExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.String"/>.
            </summary>
            <seealso cref="T:System.String"/>
        </member>
        <member name="F:System.StringExtensions.MatchingTimeSpan">
            <summary>
            Indicates the time span that is used for matching.
            </summary>
        </member>
        <member name="F:System.StringExtensions.InvalidOperation">
            <summary>
            Indicates the exception that will be thrown when a certain regular expression is invalid.
            </summary>
        </member>
        <member name="M:System.StringExtensions.SatisfyPattern(System.String,System.String)">
            <summary>
            Check whether the specified string instance is satisfied
            the specified regular expression pattern or not.
            </summary>
            <param name="this">The value to check.</param>
            <param name="pattern">
            The regular expression pattern. If the value is <see langword="null"/>,
            the return value is always <see langword="false"/>.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.StringExtensions.IsMatch(System.String,System.String)">
            <summary>
            Check whether the specified string instance can match the value
            using the specified regular expression pattern or not.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating that.</returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)"/>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.StringExtensions.Ref(System.String)">
            <summary>
            Try to get the reference to the first character from a string, and immutable by default.
            </summary>
            <param name="this">The string.</param>
            <returns>A read-only reference that points to the first character of the specified string.</returns>
        </member>
        <member name="M:System.StringExtensions.MutableRef(System.String)">
            <summary>
            Try to get the reference to the first character of a string.
            </summary>
            <param name="this">The string.</param>
            <returns>The reference to the first element.</returns>
        </member>
        <member name="M:System.StringExtensions.RemoveAll(System.String,System.Char)">
            <summary>
            Removes all specified characters.
            </summary>
            <param name="this">The string value.</param>
            <param name="character">The character to be removed from the base string.</param>
            <returns>The result string value after removal.</returns>
        </member>
        <member name="M:System.StringExtensions.Match(System.String,System.String)">
            <summary>
            Searches the specified input string for the first occurrence of
            the specified regular expression pattern.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>
            The value after matching. If failed to match,
            the value will be <see langword="null"/>.
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)"/>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.StringExtensions.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Searches the input string for the first occurrence of the specified regular
            expression, using the specified matching options.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <param name="regexOption">The matching options.</param>
            <returns>
            The matched string value. If failed to match,
            the value will be <see langword="null"/>.
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>
        </member>
        <member name="M:System.StringExtensions.ExpandCharacters(System.String)">
            <summary>
            Gets a new <see cref="T:System.String"/>[] result, with each element (a <see cref="T:System.String"/> with a single character)
            from the specified <see cref="T:System.String"/>.
            </summary>
            <param name="this">The current <see cref="T:System.String"/> instance.</param>
            <returns>An array of <see cref="T:System.String"/> elements.</returns>
        </member>
        <member name="M:System.StringExtensions.CutOfLength(System.String,System.Int32)">
            <summary>
            Cut the array to multiple part, making them are all of length <paramref name="length"/>.
            </summary>
            <param name="this">The string text.</param>
            <param name="length">The desired length.</param>
            <returns>A list of <see cref="T:System.String"/> values.</returns>
        </member>
        <member name="M:System.StringExtensions.MatchAll(System.String,System.String)">
            <summary>
            Searches the specified input string for all occurrences of a
            specified regular expression pattern.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>
            The result after matching. If failed to match,
            the returning array will be an empty string array (has no elements).
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)"/>
        </member>
        <member name="M:System.StringExtensions.MatchAll(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Searches the specified input string for all occurrences of a
            specified regular expression pattern, using the specified matching
            options.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <param name="regexOption">The matching options.</param>
            <returns>
            The result after matching. If failed to match,
            the returning array will be an empty string array (has no elements).
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>
        </member>
        <member name="M:System.StringExtensions.SplitBy(System.String,System.Char[])">
            <inheritdoc cref="M:System.String.Split(System.Char[],System.StringSplitOptions)"/>
            <param name="this">The array itself.</param>
            <param name="separator">The separator characters.</param>
        </member>
        <member name="M:System.StringExtensions.RemoveLineEndings(System.String)">
            <summary>
            Remove all new-line sequences in the current string.
            </summary>
            <param name="this">The current string.</param>
            <returns>
            A string whose contents match the current string, but with all new-line sequences replaced with <see cref="F:System.String.Empty"/>.
            </returns>
        </member>
        <member name="M:System.StringExtensions.Reserve(System.String,System.String)">
            <summary>
            Reserve all characters that satisfy the specified pattern.
            </summary>
            <param name="this">The string.</param>
            <param name="reservePattern">
            The pattern that reserved characters satisfied. All supported patterns are:
            <list type="table">
            <item>
            <term><c>@"\d"</c></term>
            <description>To match a digit.</description>
            </item>
            <item>
            <term><c>@"\t"</c></term>
            <description>To match a tab.</description>
            </item>
            <item>
            <term><c>@"\w"</c></term>
            <description>To match a letter, digit or underscore character <c>'_'</c>.</description>
            </item>
            </list>
            </param>
            <returns>The result string.</returns>
            <remarks>
            For example, if code is <c>"Hello, world!".Reserve(@"\w")</c>, the return value
            will only contain the letters, digits or the underscore character '<c>_</c>'
            (i.e. <c>"Helloworld"</c> as the result of this example).
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Throws when the <paramref name="reservePattern"/> is invalid.
            All possible patterns are shown in the tip for the parameter <paramref name="reservePattern"/>.
            </exception>
        </member>
        <member name="M:System.StringExtensions.IsRegexPattern(System.String)">
            <summary>
            To check if the current string value is a valid regular
            expression pattern or not.
            </summary>
            <param name="this">The value to check.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating that.</returns>
        </member>
        <member name="M:System.StringExtensions.NullLinesOrHeaderSpacesPattern">
            <remarks>
            Pattern:<br/>
            <code>(^\\s*|(?&lt;=\\r\\n)\\s+)</code><br/>
            Options:<br/>
            <code>RegexOptions.Compiled</code><br/>
            Explanation:<br/>
            <code>
             1st capture group.<br/>
                 Match with 2 alternative expressions, atomically.<br/>
                     Match a sequence of expressions.<br/>
                         Match if at the beginning of the string.<br/>
                         Match a whitespace character atomically any number of times.<br/>
                     Match a sequence of expressions.<br/>
                         Zero-width positive lookbehind.<br/>
                             Match the string "\r\n" right-to-left.<br/>
                         Match a whitespace character atomically at least once.<br/>
            </code>
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Runtime.CompilerServices.ITuple"/>.
            </summary>
            <seealso cref="T:System.Runtime.CompilerServices.ITuple"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleExtensions.ToArray(System.Runtime.CompilerServices.ITuple)">
            <summary>
            Converts the <see cref="T:System.Runtime.CompilerServices.ITuple"/> instance into an array of objects.
            </summary>
            <param name="this">The instance.</param>
            <returns>The array of elements.</returns>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleExtensions.GetEnumerator(System.Runtime.CompilerServices.ITuple)">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterceptsLocationAttribute">
            <summary>
            <para>
            Interceptors are an experimental compiler feature planned to ship in .NET 8 (with support for C# only).
            The feature may be subject to breaking changes or removal in a future release.
            </para>
            <para>
            An interceptor is a method which can declaratively substitute a call to an interceptable method with a call to itself at compile time.
            This substitution occurs by having the interceptor declare the source locations of the calls that it intercepts.
            This provides a limited facility to change the semantics of existing code by adding new code to a compilation (e.g. in a source generator).
            </para>
            </summary>
            <param name="filePath">The required file path.</param>
            <param name="line">The line.</param>
            <param name="character">The character position.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterceptsLocationAttribute.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            <para>
            Interceptors are an experimental compiler feature planned to ship in .NET 8 (with support for C# only).
            The feature may be subject to breaking changes or removal in a future release.
            </para>
            <para>
            An interceptor is a method which can declaratively substitute a call to an interceptable method with a call to itself at compile time.
            This substitution occurs by having the interceptor declare the source locations of the calls that it intercepts.
            This provides a limited facility to change the semantics of existing code by adding new code to a compilation (e.g. in a source generator).
            </para>
            </summary>
            <param name="filePath">The required file path.</param>
            <param name="line">The line.</param>
            <param name="character">The character position.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterceptsLocationAttribute.FilePath">
            <summary>
            The generated property declaration for parameter <c>filePath</c>.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterceptsLocationAttribute.Line">
            <summary>
            The generated property declaration for parameter <c>line</c>.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterceptsLocationAttribute.Character">
            <summary>
            The generated property declaration for parameter <c>character</c>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleEnumerator">
            <summary>
            Represents for an enumerator that iterates on each elements stored in a <see cref="T:System.Runtime.CompilerServices.ITuple"/>.
            </summary>
            <param name="tuple">A tuple instance.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator.#ctor(System.Runtime.CompilerServices.ITuple)">
            <summary>
            Represents for an enumerator that iterates on each elements stored in a <see cref="T:System.Runtime.CompilerServices.ITuple"/>.
            </summary>
            <param name="tuple">A tuple instance.</param>
        </member>
        <member name="F:System.Runtime.CompilerServices.TupleEnumerator._index">
            <summary>
            The current index.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:System.Runtime.CompilerServices.TupleEnumerator._tuple">
            <summary>
            The generated field declaration for parameter <c>tuple</c>.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleEnumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.Runtime.Versioning.PlatformNames">
            <summary>
            Represents platform names.
            </summary>
        </member>
        <member name="F:System.Runtime.Versioning.PlatformNames.Windows">
            <summary>
            Indicates the Windows system.
            </summary>
        </member>
        <member name="T:System.Utf8StringExtensions">
            <summary>
            Provides with extension methods on <see cref="T:System.Utf8String"/>.
            </summary>
            <remarks>
            This type is lazy-implemented: all methods uses corresponding methods of <see cref="T:System.String"/> as implementation.
            </remarks>
            <seealso cref="T:System.Utf8String"/>
        </member>
        <member name="M:System.Utf8StringExtensions.SatisfyPattern(System.Utf8String,System.Utf8String)">
            <summary>
            Check whether the specified string instance is satisfied
            the specified regular expression pattern or not.
            </summary>
            <param name="this">The value to check.</param>
            <param name="pattern">
            The regular expression pattern. If the value is <see langword="null"/>,
            the return value is always <see langword="false"/>.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.Utf8StringExtensions.IsMatch(System.Utf8String,System.Utf8String)">
            <summary>
            Check whether the specified string instance can match the value
            using the specified regular expression pattern or not.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating that.</returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)"/>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.Utf8StringExtensions.Match(System.Utf8String,System.Utf8String)">
            <summary>
            Searches the specified input string for the first occurrence of
            the specified regular expression pattern.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>
            The value after matching. If failed to match,
            the value will be <see langword="null"/>.
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)"/>.
            </remarks>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)"/>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
        </member>
        <member name="M:System.Utf8StringExtensions.Match(System.Utf8String,System.Utf8String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Searches the input string for the first occurrence of the specified regular
            expression, using the specified matching options.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <param name="regexOption">The matching options.</param>
            <returns>
            The matched string value. If failed to match,
            the value will be <see langword="null"/>.
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>
        </member>
        <member name="M:System.Utf8StringExtensions.MatchAll(System.Utf8String,System.Utf8String)">
            <summary>
            Searches the specified input string for all occurrences of a
            specified regular expression pattern.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <returns>
            The result after matching. If failed to match,
            the returning array will be an empty string array (has no elements).
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)"/>
        </member>
        <member name="M:System.Utf8StringExtensions.MatchAll(System.Utf8String,System.Utf8String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Searches the specified input string for all occurrences of a
            specified regular expression pattern, using the specified matching
            options.
            </summary>
            <param name="this">The value to match.</param>
            <param name="pattern">The regular expression pattern.</param>
            <param name="regexOption">The matching options.</param>
            <returns>
            The result after matching. If failed to match,
            the returning array will be an empty string array (has no elements).
            </returns>
            <remarks>
            This method is a syntactic sugar of the calling
            method <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Throws when the specified <paramref name="pattern"/> is not a valid regular
            expression pattern.
            </exception>
            <seealso cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)"/>
        </member>
        <member name="M:System.Utf8StringExtensions.IsRegexPattern(System.Utf8String)">
            <summary>
            To check if the current string value is a valid regular
            expression pattern or not.
            </summary>
            <param name="this">The value to check.</param>
            <returns>A <see cref="T:System.Boolean"/> indicating that.</returns>
        </member>
        <member name="T:System.ValueTupleExtensions">
            <summary>
            Represents with extension methods for value tuple type set.
            </summary>
        </member>
        <member name="M:System.ValueTupleExtensions.GetEnumerator``1(System.ValueTuple{``0,``0})">
            <summary>
            Gets an <see cref="T:System.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`2"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type that two instances defined in pair are.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.ValueTupleExtensions.GetEnumerator``1(System.ValueTuple{``0,``0,``0})">
            <summary>
            Gets an <see cref="T:System.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`3"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type that two instances defined in pair are.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.ValueTupleExtensions.GetEnumerator``1(System.ValueTuple{``0,``0,``0,``0})">
            <summary>
            Gets an <see cref="T:System.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`4"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type that two instances defined in pair are.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.ValueTupleExtensions.GetEnumerator``1(System.ValueTuple{``0,``0,``0,``0,``0})">
            <summary>
            Gets an <see cref="T:System.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`5"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type that two instances defined in pair are.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.ValueTupleExtensions.GetEnumerator``1(System.ValueTuple{``0,``0,``0,``0,``0,``0})">
            <summary>
            Gets an <see cref="T:System.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`6"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type that two instances defined in pair are.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.ValueTupleExtensions.GetEnumerator``1(System.ValueTuple{``0,``0,``0,``0,``0,``0,``0})">
            <summary>
            Gets an <see cref="T:System.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`7"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type that two instances defined in pair are.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="M:System.ValueTupleExtensions.GetEnumerator``2(System.ValueTuple{``0,``0,``0,``0,``0,``0,``0,``1})">
            <summary>
            Gets an <see cref="T:System.ValueTupleEnumerator`1"/> instance that can iterate for a pair of values
            via a value tuple <see cref="T:System.ValueTuple`8"/> of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type that two instances defined in pair are.</typeparam>
            <typeparam name="TRest">The type that encapsulates a list of rest elements.</typeparam>
            <param name="this">The instance to be iterated.</param>
            <returns>An enumerator instance.</returns>
        </member>
        <member name="T:System.Linq.ArrayEnumerable">
            <summary>
            Provides with the LINQ-related methods on type <see cref="T:System.Array"/>, especially for the one-dimensional array.
            </summary>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Cast``1(System.Object[])">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.OfType``1(System.Object[])">
            <summary>
            Filters the array, removing elements not of type <typeparamref name="TResult"/>.
            </summary>
            <typeparam name="TResult">The type of the target elements.</typeparam>
            <param name="this">The array to be filtered.</param>
            <returns>A list of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
            Totals up the number of elements that satisfy the specified condition.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array.</param>
            <param name="predicate">The condition.</param>
            <returns>The number of elements satisfying the specified condition.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.FuncRefReadOnly{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Sum``1(``0[])">
            <summary>
            Sum all elements up and return the result.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array that contains a list of elements to be calculated.</param>
            <returns>A <typeparamref name="T"/> instance as the result.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Select``2(``0[],System.Func{``0,``1})">
            <returns>
            An array of <typeparamref name="TResult"/> instances being the result of invoking the transform function on each element of <paramref name="source"/>.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.SelectMany``3(``0[],System.Func{``0,``1[]},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence of a collection, flattens the resulting sequence into one sequence,
            and invokes a result selector function on each element therein.
            </summary>
            <returns>
            A same type of collection whose elements are the result of invoking the one-to-many transform function
            <paramref name="collectionSelector"/> on each element of <paramref name="source"/> and then mapping each of those sequence elements
            and their corresponding source element to a result element.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Where``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="this">An array of <typeparamref name="T"/> instances to filter.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            An array of <typeparamref name="T"/> instances that contains elements from the input sequence that satisfy the condition.
            </returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Sum``2(``0[],System.Func{``0,``1})">
            <summary>
            Computes the sum of the sequence of <typeparamref name="TInterim"/> values that are obtained by invoking a transform function
            on each element of the input sequence.
            </summary>
            <typeparam name="T">The type of element of <paramref name="source"/>.</typeparam>
            <typeparam name="TInterim">The type of interim variables.</typeparam>
            <inheritdoc cref="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Min``2(``0[],System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the minimum <typeparamref name="TInterim"/> value.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="this"/>.</typeparam>
            <typeparam name="TInterim">The type of projected values after the transform function invoked.</typeparam>
            <param name="this">A sequence of values to determine the minimum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The value of type <typeparamref name="TInterim"/> that corresponds to the minimum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Max``2(``0[],System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a sequence and returns the maximum <typeparamref name="TInterim"/> value.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="this"/>.</typeparam>
            <typeparam name="TInterim">The type of projected values after the transform function invoked.</typeparam>
            <param name="this">A sequence of values to determine the maximum value of.</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>The value of type <typeparamref name="TInterim"/> that corresponds to the maximum value in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Aggregate``1(``0[],System.Func{``0,``0,``0})">
            <param name="this">An array of <typeparamref name="TSource"/> elementsto aggregate over.</param>
            <param name="func">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" path="/param[@name='func']"/>
            </param>
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.SortBy``2(``0[],System.Func{``0,``1})">
            <summary>
            Sort the specified array using the specified key selector.
            </summary>
            <typeparam name="T">The type of each element in the array.</typeparam>
            <typeparam name="TKey">The type of the selected key to be compared.</typeparam>
            <param name="this">The array.</param>
            <param name="keySelector">The function that fetches for a key to be compared.</param>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Zip``2(``0[],``1[])">
            <inheritdoc cref="M:System.Linq.Enumerable.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.SequenceEquals``1(``0[],``0[])">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.SequenceEquals``1(``0[],``0[],System.Func{``0,``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.SequenceEquals``1(``0[],``0[],System.Func{``0,``0,System.Boolean})">
            <summary>
            Compares elements from two arrays one by one respetively.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array to be compared.</param>
            <param name="other">The other array to be compared.</param>
            <param name="equalityComparer">
            A method that compares two <typeparamref name="T"/> elements, and returns a <see cref="T:System.Boolean"/> result
            indicating whether two elements are considered equal.
            </param>
            <returns>A <see cref="T:System.Boolean"/> result indicating whether two arrays are considered equal.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.Distinct``1(``0[])">
            <summary>
            Filters duplicate items from an array.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The array to be filtered.</param>
            <returns>A new array of elements that doesn't contain any duplicate items.</returns>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.DistinctBy``2(``0[],System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ArrayEnumerable.DistinctBy``2(``0[],System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.DistinctBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})"/>
        </member>
        <member name="T:System.Linq.ArrayListEnumerable">
            <summary>
            Provides with extension methods on <see cref="T:System.Collections.ArrayList"/>.
            </summary>
            <seealso cref="T:System.Collections.ArrayList"/>
        </member>
        <member name="M:System.Linq.ArrayListEnumerable.Cast``1(System.Collections.ArrayList)">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="M:System.Linq.ArrayListEnumerable.Select``1(System.Collections.ArrayList,System.Func{System.Object,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="T:System.Linq.Enumerable2">
            <summary>
            The extension for <see cref="T:System.Linq.Enumerable"/>.
            </summary>
            <seealso cref="T:System.Linq.Enumerable"/>
        </member>
        <member name="M:System.Linq.Enumerable2.None(System.Collections.IEnumerable)">
            <summary>
            Determines whether an <see cref="T:System.Collections.IEnumerable"/> collection has no elements in it.
            </summary>
            <param name="this">The element.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Linq.Enumerable2.None``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether an <see cref="T:System.Collections.Generic.IEnumerable`1"/> collection has no elements in it.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The element.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Linq.Enumerable2.HasOnlyOneElement``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check whether the specified list has only one element.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="this">The list.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="T:System.Linq.EnumFlagsEnumerable">
            <summary>
            Provides with some extension methods for enumeration types.
            </summary>
        </member>
        <member name="M:System.Linq.EnumFlagsEnumerable.Select``2(``0,System.Func{``0,``1})">
            <summary>
            Try to get all <typeparamref name="T"/> elements as flags stored in argument <paramref name="this"/>,
            and convert them into an array of <typeparamref name="TResult"/> instances via specified argument <paramref name="selector"/>,
            then return the array.
            </summary>
            <typeparam name="T">The type of the enumeration.</typeparam>
            <typeparam name="TResult">The type of the result elements.</typeparam>
            <param name="this">The enumeration type field.</param>
            <param name="selector">The selector that can convert the enumeration field into the target-typed instance.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the enumeration type is not marked <see cref="T:System.FlagsAttribute"/>.
            </exception>
        </member>
        <member name="T:System.Linq.ListEnumerable">
            <summary>
            Represents with LINQ methods for <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.Count``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.Count``1(``0[],System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.Where``1(System.Collections.Generic.List{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.Select``2(System.Collections.Generic.List{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ListEnumerable.SelectMany``3(System.Collections.Generic.List{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <inheritdoc cref="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})"/>
        </member>
        <member name="T:System.Linq.ReadOnlyMemoryEnumerable">
            <summary>
            Represents a list of methods that are LINQ methods operating with <see cref="T:System.ReadOnlyMemory`1"/> instances.
            </summary>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="M:System.Linq.ReadOnlyMemoryEnumerable.Select``2(System.ReadOnlyMemory{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.ReadOnlySpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ReadOnlyMemoryEnumerable.Where``1(System.ReadOnlyMemory{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.ReadOnlySpanEnumerable.Where``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="T:System.Linq.ReadOnlySpanEnumerable">
            <summary>
            Provides LINQ-based extension methods on <see cref="T:System.ReadOnlySpan`1"/>.
            </summary>
            <seealso cref="T:System.ReadOnlySpan`1"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Min``2(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,``1})">
            <inheritdoc cref="M:System.Linq.ReadOnlySpanEnumerable.MinBy``2(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.MinBy``2(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,``1})">
            <summary>
            Returns the minimum value in a generic sequence according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="this">A sequence of values to determine the minimum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>The value with the minimum key in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Max``2(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,``1})">
            <inheritdoc cref="M:System.Linq.ReadOnlySpanEnumerable.MaxBy``2(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.MaxBy``2(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,``1})">
            <summary>
            Returns the maximum value in a generic sequence according to a specified key selector function.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of key to compare elements by.</typeparam>
            <param name="this">A sequence of values to determine the maximum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>The value with the maximum key in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Sum``2(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,``1})">
            <summary>
            Totals up all elements, and return the result of the sum by the specified property calculated from each element.
            </summary>
            <typeparam name="TSource">The type of the elements of source.</typeparam>
            <typeparam name="TKey">The type of key to add up.</typeparam>
            <param name="this">A sequence of values to determine the sum value of.</param>
            <param name="keySelector">A function to extract the key for each element.</param>
            <returns>The value with the sum key in the sequence.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Count``1(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,System.Boolean})">
            <summary>
            Totals up how many elements stored in the specified sequence satisfy the specified condition.
            </summary>
            <typeparam name="TSource">The type of each element.</typeparam>
            <param name="this">A sequence of values to be determined.</param>
            <param name="condition">The condition.</param>
            <returns>The number of elements satisfying the specified condition.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Any``1(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,System.Boolean})">
            <summary>
            Checks whether at least one element are satisfied the specified condition.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list of elements to be checked.</param>
            <param name="match">The <see cref="T:System.FuncRefReadOnly`2"/> that defines the conditions of the elements to search for.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.All``1(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,System.Boolean})">
            <summary>
            Checks whether all elements are satisfied the specified condition.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="this">The list of elements to be checked.</param>
            <param name="match">The <see cref="T:System.FuncRefReadOnly`2"/> that defines the conditions of the elements to search for.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.AllAre``2(System.ReadOnlySpan{``0})">
            <summary>
            Determines whether all elements are of type <typeparamref name="TDerived"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <typeparam name="TDerived">The derived type to be checked.</typeparam>
            <param name="this">A list of elements to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.FindAll``1(System.ReadOnlySpan{``0},System.FuncRefReadOnly{``0,System.Boolean})">
            <summary>
            Retrieves all the elements that match the conditions defined by the specified predicate.
            </summary>
            <typeparam name="T">The type of the elements of the span.</typeparam>
            <param name="this">The span to search.</param>
            <param name="match">The <see cref="T:System.FuncRefReadOnly`2"/> that defines the conditions of the elements to search for.</param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> containing all the elements that match the conditions defined
            by the specified predicate, if found; otherwise, an empty <see cref="T:System.ReadOnlySpan`1"/>.
            </returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Select``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <summary>
            Projects each element in the current instance into the target-typed span of element type <typeparamref name="TResult"/>,
            using the specified function to convert.
            </summary>
            <typeparam name="T">The type of each elements in the span.</typeparam>
            <typeparam name="TResult">The type of target value.</typeparam>
            <param name="this">The source elements.</param>
            <param name="selector">The selector.</param>
            <returns>An array of <typeparamref name="TResult"/> elements.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.SelectMany``3(System.ReadOnlySpan{``0},System.Func{``0,``1[]},System.Func{``0,``1,``2})">
            <inheritdoc cref="M:System.Linq.ArrayEnumerable.SelectMany``3(``0[],System.Func{``0,``1[]},System.Func{``0,``1,``2})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Where``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" path="/summary"/>
            </summary>
            <param name="this">A <see cref="T:System.ReadOnlySpan`1"/> to filter.</param>
            <param name="predicate">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" path="/param[@name='predicate']"/>
            </param>
            <returns>A <typeparamref name="T"/>[] that contains elements form the input sequence that satisfy the condition.</returns>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.OrderBy``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.First``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.FirstOrDefault``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <inheritdoc cref="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Aggregate``1(System.ReadOnlySpan{``0},System.Func{``0,``0,``0})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.Aggregate``2(System.ReadOnlySpan{``0},``1,System.Func{``1,``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})"/>
        </member>
        <member name="M:System.Linq.ReadOnlySpanEnumerable.GetSubsets``1(System.ReadOnlySpan{``0},System.Int32)">
            <summary>
            Get all subsets from the specified number of the values to take.
            </summary>
            <param name="this">The array.</param>
            <param name="count">The number of elements you want to take.</param>
            <returns>All subsets.</returns>
        </member>
        <member name="T:System.Linq.StringEnumerable">
            <summary>
            Provides with LINQ methods on a <see cref="T:System.String"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.StringEnumerable.Select``1(System.String,System.Func{System.Char,``0})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/summary"/>
            </summary>
            <param name="this">The string instance.</param>
            <param name="selector">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" path="/param[@name='selector']"/>
            </param>
            <returns>
            A <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="TResult"/> whose elements are the result of invoking the transfrom function
            on each element of <paramref name="this"/>.
            </returns>
        </member>
        <member name="M:System.Linq.StringEnumerable.Where(System.String,System.Func{System.Char,System.Boolean})">
            <summary>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" path="/summary"/>
            </summary>
            <param name="this">The string instance.</param>
            <param name="predicate">
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" path="/param[@name='selector']"/>
            </param>
            <returns>
            A new <see cref="T:System.String"/> instance that contains characters from the input sequence that satisfy the condition.
            </returns>
        </member>
        <member name="T:System.Linq.TupleEnumerable">
            <summary>
            Provides with LINQ methods for <see cref="T:System.Runtime.CompilerServices.ITuple"/> instances.
            </summary>
            <seealso cref="T:System.Runtime.CompilerServices.ITuple"/>
        </member>
        <member name="M:System.Linq.TupleEnumerable.Cast``1(System.Runtime.CompilerServices.ITuple)">
            <inheritdoc cref="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)"/>
        </member>
        <member name="M:System.Linq.TupleEnumerable.Select``2(System.Runtime.CompilerServices.ITuple,System.Func{``0,``1})">
            <inheritdoc cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="T:System.ModuleInitializer">
            <target name="type">
				<summary>
					<para>
						Provides with the type that contains a module initializer method, called automatically by the CLR
						(Common Language Runtime) to initialize some values.
					</para>
					<para>
						<i>
							The type is called by the compiler and the CLR (Common Language Runtime),
							which means you cannot use any members in this type manually.
						</i>
					</para>
				</summary>
			</target>
        </member>
        <member name="M:System.ModuleInitializer.Initialize">
            <target name="method">
				<summary>
					Called by the runtime automatically while booting on this solution to initialize the values,
					data members or any other things that can or should be initialized here.
				</summary>
				<remarks>
					The concept <b>module</b> is different with <b>assembly</b>.
					The solution can contain multiple assemblies, while each assembly can contain multiple modules.
					However, due to the design of Visual Studio project file system, each assembly will only contain
					one module by default.
				</remarks>
			</target>
        </member>
        <member name="T:System.Numerics.BitOperationsExtensions">
            <summary>
            Provides extension methods on <see cref="T:System.Numerics.BitOperations"/>.
            </summary>
            <seealso cref="T:System.Numerics.BitOperations"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)">
            <summary>
            Find all offsets of set bits of the binary representation of a specified value.
            </summary>
            <param name="this">The value.</param>
            <returns>All offsets.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Byte)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Int16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UInt16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UInt32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.Int64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UInt64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.IntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.UIntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetAllSets(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)">
            <summary>
            <para>Get an enumerator to iterate on each bits of the specified integer value.</para>
            <para>This method will allow you to use <see langword="foreach"/> loop to iterate on all indices of set bits.</para>
            </summary>
            <param name="this">The value.</param>
            <returns>All indices of set bits.</returns>
            <remarks>
            This method allows you using <see langword="foreach"/> loop to iterate this value:
            <code><![CDATA[
            foreach (var bit in 17)
            {
                // Do something...
            }
            ]]></code>
            </remarks>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Byte)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Int16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UInt16)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UInt32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.Int64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UInt64)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.IntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.UIntPtr)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetEnumerator(System.SByte)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)">
            <summary>
            Find an index of the binary representation of a value after the specified index whose bit is set <see langword="true"/>.
            </summary>
            <param name="this">The value.</param>
            <param name="index">The index.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Int16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Int64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.GetNextSet(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)">
            <summary>
            <para>Reverse all bits in a specified value.</para>
            <para>Note that the value is passed by <b>reference</b> though the method is an extension method, and returns nothing.</para>
            </summary>
            <param name="this">The value.</param>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Int16@)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Int32@)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Int64@)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.ReverseBits(System.Byte@)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.SByte,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)">
            <summary>
            Get an <see cref="T:System.Int32"/> value, indicating that the absolute position of all set bits with the specified set bit order.
            </summary>
            <param name="this">The value.</param>
            <param name="order">The number of the order of set bits.</param>
            <returns>The position.</returns>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Int16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.Int64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.IntPtr,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SetAt(System.UIntPtr,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)">
            <summary>
            Skip the specified number of set bits and iterate on the integer with other set bits.
            </summary>
            <param name="this">The integer to iterate.</param>
            <param name="setBitPosCount">Indicates how many set bits you want to skip to iterate.</param>
            <returns>The byte value that only contains the other set bits.</returns>
            <remarks>
            For example:
            <code><![CDATA[
            byte value = 0b00010111;
            foreach (int bitPos in value.SkipSetBit(2))
            {
                yield return bitPos + 1;
            }
            ]]></code>
            You will get 3 and 5, because all set bit positions are 0, 1, 2 and 4, and we have skipped
            two of them, so the result set bit positions to iterate on are only 2 and 4.
            </remarks>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Int16,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Int64,System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SkipSetBit(System.Byte,System.Int32)"/>
        </member>
        <member name="T:System.Numerics.Bits">
            <summary>
            Represents a list of methods that operates with bits.
            </summary>
        </member>
        <member name="M:System.Numerics.Bits.EnumerateOf(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:System.Numerics.MaskCombinationsGenerator"/> instance that can generate a list of <see cref="T:System.Int64"/>
            values that are all possibilities of combinations of integer values containing specified number of bits,
            and the specified number of bits set 1.
            </summary>
            <param name="bitCount">Indicates how many bits should be enumerated.</param>
            <param name="oneCount">Indicates how many bits set one contained in the value.</param>
            <returns>A <see cref="T:System.Numerics.MaskCombinationsGenerator"/> instance.</returns>
        </member>
        <member name="T:System.Numerics.MaskCombinationsGenerator">
            <summary>
            Represents a combination generator that iterations each combination of bits for the specified number of bits, and how many 1's in it.
            </summary>
            <param name="bitCount">Indicates the number of bits.</param>
            <param name="oneCount">Indicates the number of bits set <see langword="true"/>.</param>
        </member>
        <member name="M:System.Numerics.MaskCombinationsGenerator.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents a combination generator that iterations each combination of bits for the specified number of bits, and how many 1's in it.
            </summary>
            <param name="bitCount">Indicates the number of bits.</param>
            <param name="oneCount">Indicates the number of bits set <see langword="true"/>.</param>
        </member>
        <member name="M:System.Numerics.MaskCombinationsGenerator.GetEnumerator">
            <summary>
            Gets the enumerator of the current instance in order to use <see langword="foreach"/> loop.
            </summary>
            <returns>The enumerator instance.</returns>
        </member>
        <member name="F:System.Numerics.MaskCombinationsGenerator._bitCount">
            <summary>
            The generated field declaration for parameter <c>bitCount</c>.
            </summary>
        </member>
        <member name="F:System.Numerics.MaskCombinationsGenerator._oneCount">
            <summary>
            The generated field declaration for parameter <c>oneCount</c>.
            </summary>
        </member>
        <member name="M:System.Numerics.MaskCombinationsGenerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.MaskCombinationsGenerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.MaskCombinationsGenerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.Numerics.Int32Enumerator">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.Int32"/> or <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The value to be iterated.</param>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.#ctor(System.UInt32)">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.Int32"/> or <see cref="T:System.UInt32"/> value.
            </summary>
            <param name="value">The value to be iterated.</param>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.PopulationCount">
            <summary>
            Indicates the population count of the value.
            </summary>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.Bits">
            <summary>
            Indicates the bits set.
            </summary>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.Int32Enumerator.Item(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt32,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Int32Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:System.Numerics.Int32Enumerator._value">
            <summary>
            The generated field declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="T:System.Numerics.Int64Enumerator">
            <summary>
            Represents an enumerator that iterates a <see cref="T:System.Int64"/> or <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The value to be iterated.</param>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.#ctor(System.UInt64)">
            <summary>
            Represents an enumerator that iterates a <see cref="T:System.Int64"/> or <see cref="T:System.UInt64"/> value.
            </summary>
            <param name="value">The value to be iterated.</param>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.PopulationCount">
            <summary>
            Indicates the population count of the value.
            </summary>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.Bits">
            <summary>
            Indicates the bits set.
            </summary>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.Int64Enumerator.Item(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt32,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.Int64Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:System.Numerics.Int64Enumerator._value">
            <summary>
            The generated field declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="T:System.Numerics.MaskCombinationEnumerator">
            <summary>
            Indicates the enumerator of the current instance.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="M:System.Numerics.MaskCombinationEnumerator.#ctor(System.Int32,System.Int32)">
            <summary>
            Indicates the enumerator of the current instance.
            </summary>
            <param name="bitCount">The number of bits.</param>
            <param name="oneCount">The number of <see langword="true"/> bits.</param>
        </member>
        <member name="F:System.Numerics.MaskCombinationEnumerator._mask">
            <summary>
            The mask.
            </summary>
        </member>
        <member name="F:System.Numerics.MaskCombinationEnumerator._isLast">
            <summary>
            Indicates whether that the value is the last one.
            </summary>
        </member>
        <member name="P:System.Numerics.MaskCombinationEnumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.Numerics.MaskCombinationEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.Numerics.MaskCombinationEnumerator.HasNext">
            <summary>
            Changes the state of the fields, and check whether the bit has another available possibility to be iterated.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Numerics.MaskCombinationEnumerator.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Numerics.MaskCombinationEnumerator.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Numerics.MaskCombinationEnumerator.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.Numerics.NativeIntEnumerator">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.IntPtr"/> or <see cref="T:System.UIntPtr"/> value.
            </summary>
            <param name="value">The value to be iterated.</param>
        </member>
        <member name="M:System.Numerics.NativeIntEnumerator.#ctor(System.UIntPtr)">
            <summary>
            Represents an enumerator that iterates an <see cref="T:System.IntPtr"/> or <see cref="T:System.UIntPtr"/> value.
            </summary>
            <param name="value">The value to be iterated.</param>
        </member>
        <member name="P:System.Numerics.NativeIntEnumerator.PopulationCount">
            <summary>
            Indicates the population count of the value.
            </summary>
        </member>
        <member name="P:System.Numerics.NativeIntEnumerator.Bits">
            <summary>
            Indicates the bits set.
            </summary>
        </member>
        <member name="P:System.Numerics.NativeIntEnumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="P:System.Numerics.NativeIntEnumerator.Item(System.Int32)">
            <inheritdoc cref="M:System.Numerics.BitOperationsExtensions.SetAt(System.UInt32,System.Int32)"/>
        </member>
        <member name="M:System.Numerics.NativeIntEnumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:System.Numerics.NativeIntEnumerator._value">
            <summary>
            The generated field declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="T:System.Ref">
            <summary>
            Represents a list of methods that can check for the concept "References" defined in C#.
            </summary>
        </member>
        <member name="M:System.Ref.Swap``1(``0@,``0@)">
            <summary>
            Swaps for two elements.
            </summary>
            <typeparam name="T">The type of both two arguments.</typeparam>
            <param name="left">The first element to be swapped.</param>
            <param name="right">The second element to be swapped.</param>
        </member>
        <member name="M:System.Ref.AsByteRef``1(``0@)">
            <summary>
            Simply invokes the method <see cref="M:System.Runtime.CompilerServices.Unsafe.As``2(``0@)"/>, but with target generic type being fixed type <see cref="T:System.Byte"/>.
            </summary>
            <typeparam name="T">The base type that is converted from.</typeparam>
            <param name="ref">
            The reference to the value. Generally speaking the value should be a <see langword="ref readonly"/> parameter, but C# disallows it,
            using <see langword="ref readonly"/> as a combined parameter modifier.
            </param>
        </member>
        <member name="M:System.Ref.AsReadOnlyByteRef``1(``0@)">
            <inheritdoc cref="M:System.Ref.AsByteRef``1(``0@)"/>
        </member>
        <member name="M:System.Ref.IsNullReference``1(``0@)">
            <summary>
            Determines whether the current reference points to <see langword="null"/>.
            </summary>
            <typeparam name="T">The type of the referenced element.</typeparam>
            <param name="reference">The reference to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Ref.MemoryLocationAreSame``1(``0@,``0@)">
            <summary>
            Check whether two references point to a same memory location.
            </summary>
            <typeparam name="T">The type of both two arguments.</typeparam>
            <param name="left">The first element to be checked.</param>
            <param name="right">The second element to be checked.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.Ref.MakeNullReference``1">
            <summary>
            Returns a reference that points to <see langword="null"/>.
            </summary>
            <typeparam name="T">
            The type of the element the reference points to if this reference were not <see langword="null"/>.
            </typeparam>
            <returns>A read-only reference that points to <see langword="null"/>.</returns>
        </member>
        <member name="M:System.Ref.AsMutableRef``1(``0@)">
            <summary>
            Re-interpret the read-only reference to non-read-only reference.
            </summary>
            <typeparam name="T">The type of the referenced item.</typeparam>
            <param name="ref">The read-only reference.</param>
            <returns>The non-read-only reference.</returns>
        </member>
        <member name="M:System.Ref.Slice``1(``0@,System.Int32,System.Int32)">
            <summary>
            Get the new array from the reference to the block memory start position, with the specified start index.
            </summary>
            <typeparam name="T">The type of the pointed element.</typeparam>
            <param name="memorySpan">The reference to the block memory start position.</param>
            <param name="start">The start index that you want to pick from.</param>
            <param name="count">The length of the array that the reference points to.</param>
            <returns>The array of elements.</returns>
            <exception cref="T:System.ArgumentNullRefException">
            Throws when the argument <paramref name="memorySpan"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.Ref.ThrowIfNullRef``1(``0@,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentNullRefException" /> if the argument points to <see langword="null" />.
            </summary>
            <typeparam name="T">The type of the referenced element.</typeparam>
            <param name="reference">
            <para>The reference to the target element, or maybe a <see langword="null" /> reference.</para>
            <para><i>
            Please note that the argument requires a <see langword="ref" /> modifier, but it does not modify the referenced value
            of the argument. It is nearly equal to <see langword="in" /> modifier.
            However, the method will invoke <see cref="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)" />,
            where the only argument is passed by <see langword="ref" />.
            Therefore, here the current method argument requires a modifier <see langword="ref" /> instead of <see langword="in" />.
            </i></para>
            </param>
            <param name="paramName">
            <para>The parameter name.</para>
            <feature name="caller-argument-expression">
			<para>
				<b>The value of the argument will be automatically produced by the compiler and passed into here. You may not assign this argument.</b>
			</para>
		</feature>
            </param>
            <exception cref="T:System.ArgumentNullRefException">Throws if the argument is a <see langword="null" /> reference.</exception>
        </member>
        <member name="T:System.Resources.MissingResourceManagerException">
            <summary>
            Represents an exception that will be thrown if resource manager is missing.
            </summary>
            <param name="assembly"><inheritdoc/></param>
        </member>
        <member name="M:System.Resources.MissingResourceManagerException.#ctor(System.Reflection.Assembly)">
            <summary>
            Represents an exception that will be thrown if resource manager is missing.
            </summary>
            <param name="assembly"><inheritdoc/></param>
        </member>
        <member name="P:System.Resources.MissingResourceManagerException.Message">
            <inheritdoc/>
        </member>
        <member name="P:System.Resources.MissingResourceManagerException.Data">
            <inheritdoc/>
        </member>
        <member name="T:System.Resources.ResourceDictionary">
            <summary>
            Represents a easy way to fetch resource values using the specified key and culture information.
            </summary>
        </member>
        <member name="F:System.Resources.ResourceDictionary.DefaultBindingFlags">
            <summary>
            Indicates the resource manager reflection binding flags.
            </summary>
        </member>
        <member name="F:System.Resources.ResourceDictionary.DefaultCulture">
            <summary>
            Indicates the default culture.
            </summary>
        </member>
        <member name="F:System.Resources.ResourceDictionary.ResourceManagers">
            <summary>
            The internal resource managers.
            </summary>
        </member>
        <member name="M:System.Resources.ResourceDictionary.RegisterResourceManager``1">
            <summary>
            Register a new resource manager for the current assembly calling this method.
            </summary>
            <typeparam name="TResourceManagerProvider">
            <para>The type of the resource manager provider.</para>
            <para>
            This type should point to a generated type, bound with your resource dictionary manifest file (*.resx), named like the file name of it.
            For example, if you create a resource dictionary manifest file called <c>Resource.resx</c>, a generated type will be named <c>Resource</c>.
            You should pass in this type (<c>Resource</c> here) as type argument to this method.
            </para>
            </typeparam>
            <exception cref="T:System.Resources.MissingResourceManagerException">Throws when the current calling assembly doesn't contain any resource manager.</exception>
        </member>
        <member name="M:System.Resources.ResourceDictionary.ExceptionMessage(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get error information (used by exception message, <see cref="P:System.Exception.Message"/> property) values,
            or throw a <see cref="T:System.Resources.ResourceNotFoundException"/> if resource is not found.
            </summary>
            <inheritdoc cref="M:System.Resources.ResourceDictionary.TryGet(System.String,System.String@,System.Globalization.CultureInfo,System.Reflection.Assembly)"/>
            <exception cref="T:System.Resources.ResourceNotFoundException">Throws when the specified resource is not found.</exception>
        </member>
        <member name="M:System.Resources.ResourceDictionary.Get(System.String,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get resource via the key, or throw a <see cref="T:System.Resources.ResourceNotFoundException"/> if resource is not found.
            </summary>
            <inheritdoc cref="M:System.Resources.ResourceDictionary.TryGet(System.String,System.String@,System.Globalization.CultureInfo,System.Reflection.Assembly)"/>
            <exception cref="T:System.Resources.ResourceNotFoundException">Throws when the specified resource is not found.</exception>
        </member>
        <member name="M:System.Resources.ResourceDictionary.TryGet(System.String,System.String@,System.Globalization.CultureInfo,System.Reflection.Assembly)">
            <summary>
            Try to get resource via the key, or return <see langword="null"/> if failed.
            </summary>
            <param name="resourceKey">The resource key.</param>
            <param name="resource">Indicates the target resource.</param>
            <param name="culture">The culture.</param>
            <param name="assembly">The assembly storing the resource dictionaries.</param>
            <returns>The result string result.</returns>
            <exception cref="T:System.Resources.MissingResourceManagerException">Throws when the resource manager object is missing.</exception>
        </member>
        <member name="T:System.Resources.ResourceException">
            <summary>
            Represents an exception type that relates to resource dictionary.
            </summary>
            <param name="assembly">Indicates the target assembly.</param>
        </member>
        <member name="M:System.Resources.ResourceException.#ctor(System.Reflection.Assembly)">
            <summary>
            Represents an exception type that relates to resource dictionary.
            </summary>
            <param name="assembly">Indicates the target assembly.</param>
        </member>
        <member name="P:System.Resources.ResourceException.Message">
            <inheritdoc/>
        </member>
        <member name="P:System.Resources.ResourceException.Data">
            <inheritdoc/>
        </member>
        <member name="F:System.Resources.ResourceException._assembly">
            <summary>
            The generated field declaration for parameter <c>assembly</c>.
            </summary>
        </member>
        <member name="T:System.Resources.ResourceNotFoundException">
            <summary>
            Indicates an exception that will be thrown if target resource is not found.
            </summary>
            <param name="assembly"><inheritdoc/></param>
            <param name="resourceKey">The resource key.</param>
            <param name="culture">The culture information.</param>
        </member>
        <member name="M:System.Resources.ResourceNotFoundException.#ctor(System.Reflection.Assembly,System.String,System.Globalization.CultureInfo)">
            <summary>
            Indicates an exception that will be thrown if target resource is not found.
            </summary>
            <param name="assembly"><inheritdoc/></param>
            <param name="resourceKey">The resource key.</param>
            <param name="culture">The culture information.</param>
        </member>
        <member name="F:System.Resources.ResourceNotFoundException.CultureNotSpecifiedDefaultText">
            <summary>
            The "unspecified" text.
            </summary>
        </member>
        <member name="P:System.Resources.ResourceNotFoundException.Message">
            <inheritdoc/>
        </member>
        <member name="P:System.Resources.ResourceNotFoundException.Data">
            <inheritdoc/>
        </member>
        <member name="F:System.Resources.ResourceNotFoundException._resourceKey">
            <summary>
            The generated field declaration for parameter <c>resourceKey</c>.
            </summary>
        </member>
        <member name="F:System.Resources.ResourceNotFoundException._culture">
            <summary>
            The generated field declaration for parameter <c>culture</c>.
            </summary>
        </member>
        <member name="T:System.Resources.SystemExtensionsResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_ArgCannotBeNull">
            <summary>
              Looks up a localized string similar to The argument cannot return null..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_CharacterNotUtf8">
            <summary>
              Looks up a localized string similar to Cannot operate because the argument is not a UTF-8 formatted character..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_FormatInvalid">
            <summary>
              Looks up a localized string similar to The specified format is invalid..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_MemberNotSupported">
            <summary>
              Looks up a localized string similar to This member does not supported..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_NoSuchElementSatisfyingCondition">
            <summary>
              Looks up a localized string similar to The collection does not contain any possible element satisfying the specified condition..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_SpecifiedValueMustBeEven">
            <summary>
              Looks up a localized string similar to The argument must be of an even length..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_UnderlyingTypeNotSupported">
            <summary>
              Looks up a localized string similar to The target enumeration type has a wrong underlying numeric type. All possible underlying types for an enumeration type must be of size 1, 2, 4 or 8 bits..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.ErrorInfo_ValueStopwatchTypeIsUninitialized">
            <summary>
              Looks up a localized string similar to An uninitialized, or &apos;default(ValueStopwatch)&apos;, ValueStopwatch cannot be used for getting elapsed time..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.Message_MissingResourceManagerException">
            <summary>
              Looks up a localized string similar to Assembly &apos;{0}&apos; is lack of invocation &apos;{1}.{2}&apos;..
            </summary>
        </member>
        <member name="P:System.Resources.SystemExtensionsResources.Message_ResourceNotFoundException">
            <summary>
              Looks up a localized string similar to Specified resource not found.
             * Resource key: &apos;{0}&apos;,
             * Assembly: &apos;{1}&apos;,
             * Culture: &apos;{2}&apos;.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.Accessibility">
            <summary>
            Defines a kind of accessibility being defined in C#.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.None">
            <summary>
            Indicates the accessibility is invalid and not defined in this type.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.File">
            <summary>
            Indicates the accessibility is <see langword="file"/>-local, which means it can be accessed only in a whole file.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.Private">
            <summary>
            Indicates the accessibility is <see langword="private"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.Protected">
            <summary>
            Indicates the accessibility is <see langword="protected"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.PrivateProtected">
            <summary>
            Indicates the accessibility is <see langword="private protected"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.Internal">
            <summary>
            Indicates the accessibility is <see langword="internal"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.ProtectedInternal">
            <summary>
            Indicates the accessibility is <see langword="protected internal"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.Accessibility.Public">
            <summary>
            Indicates the accessibility is <see langword="public"/>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.ComparisonOperatorsAttribute">
            <summary>
            Represents an attribute type that allows source generators generating for comparison operators if the specified types marked this attribute.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.DuckTypingAttribute">
            <summary>
            Represents an attribute type that can be used as a duck-typing implementation by source generators.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.EqualityOperatorsAttribute">
            <summary>
            Represents an attribute type that allows source generators generating for equality operators if the specified types marked this attribute.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
        </member>
        <member name="M:System.SourceGeneration.EqualityOperatorsAttribute.#ctor(System.SourceGeneration.EqualityOperatorsBehavior)">
            <summary>
            Represents an attribute type that allows source generators generating for equality operators if the specified types marked this attribute.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
        </member>
        <member name="P:System.SourceGeneration.EqualityOperatorsAttribute.NullabilityPrefer">
            <summary>
            Indicates an extra option to tell source generators which case of nullability should be preferred.
            By default, not null for value types and including null for reference types.
            </summary>
        </member>
        <member name="P:System.SourceGeneration.EqualityOperatorsAttribute.Behavior">
            <summary>
            The generated property declaration for parameter <c>behavior</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.EqualityOperatorsBehavior">
            <summary>
            Defines a behavior by source generator on generating <see langword="operator"/> <c>==</c> and <see langword="operator"/> <c>!=</c>
            overloading operators.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.EqualityOperatorsBehavior.Intelligent">
            <summary>
            Indicates the source generator will choose a suitable way to implement equality operators.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.EqualityOperatorsBehavior.MakeVirtual">
            <summary>
            Indicates the operators will be made to be <see langword="virtual"/>.
            This option can only be used for interfaces implementing operators.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.EqualityOperatorsBehavior.MakeAbstract">
            <summary>
            Indicates the operators will be made to be <see langword="abstract"/>.
            This option can only be used for interfaces implementing operators.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.EqualsAttribute">
            <summary>
            Represents an attribute type that allows source generators controlling behaviors on generating <see cref="M:System.Object.Equals(System.Object)"/> method.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.SourceGeneration.EqualsAttribute.#ctor(System.SourceGeneration.EqualsBehavior)">
            <summary>
            Represents an attribute type that allows source generators controlling behaviors on generating <see cref="M:System.Object.Equals(System.Object)"/> method.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="P:System.SourceGeneration.EqualsAttribute.Behavior">
            <summary>
            The generated property declaration for parameter <c>behavior</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.EqualsBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.Equals(System.Object)"/> overridden methods.
            </summary>
            <seealso cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="F:System.SourceGeneration.EqualsBehavior.Intelligent">
            <summary>
            Indicates the source generator will automatically adopt a case for an overridden unit.
            <list type="bullet">
            <item>For <see langword="ref struct"/>s, return <see langword="false"/> because there is implicitly box and unbox operation</item>
            <item>For <see langword="class"/>es, use <see langword="as"/> casting and call overloaded <c>Equals</c> method</item>
            <item>For <see langword="struct"/>s, use <see langword="is"/> casting and call overloaded <c>Equals</c> method</item>
            </list>
            </summary>
        </member>
        <member name="F:System.SourceGeneration.EqualsBehavior.ThrowNotSupportedException">
            <summary>
            Indicates the method always throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.EqualsBehavior.MakeAbstract">
            <summary>
            Indicates the method will be made <see langword="abstract"/>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.ExplicitInterfaceImplAttribute">
            <summary>
            Represents an attribute type that tells source generator that the current method marked this attribute type should implement an interface
            type specified as argument <paramref name="interfaceType"/>. This type can also be consumed by operators.
            </summary>
            <param name="interfaceType">
            Indicates the interface type. The type should be specified via <see langword="typeof"/> expression.
            If the target interface type is a generic type, you can just specify its open-typed reference.
            For example, if you want to explicitly implement <see cref="M:System.IEquatable`1.Equals(`0)"/>,
            just pass value <c><![CDATA[typeof(IEquatable<>)]]></c>.
            </param>
            <remarks><b>
            Please note that if a type implements multiple same interfaces without type parameters
            (e.g. <c><![CDATA[I<A>]]></c> and <c><![CDATA[I<B>]]></c>), the target source generator won't work.
            </b></remarks>
        </member>
        <member name="M:System.SourceGeneration.ExplicitInterfaceImplAttribute.#ctor(System.Type)">
            <summary>
            Represents an attribute type that tells source generator that the current method marked this attribute type should implement an interface
            type specified as argument <paramref name="interfaceType"/>. This type can also be consumed by operators.
            </summary>
            <param name="interfaceType">
            Indicates the interface type. The type should be specified via <see langword="typeof"/> expression.
            If the target interface type is a generic type, you can just specify its open-typed reference.
            For example, if you want to explicitly implement <see cref="M:System.IEquatable`1.Equals(`0)"/>,
            just pass value <c><![CDATA[typeof(IEquatable<>)]]></c>.
            </param>
            <remarks><b>
            Please note that if a type implements multiple same interfaces without type parameters
            (e.g. <c><![CDATA[I<A>]]></c> and <c><![CDATA[I<B>]]></c>), the target source generator won't work.
            </b></remarks>
        </member>
        <member name="P:System.SourceGeneration.ExplicitInterfaceImplAttribute.InterfaceType">
            <summary>
            The generated property declaration for parameter <c>interfaceType</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.GetHashCodeAttribute">
            <summary>
            Represents an attribute type that allows source generators controlling behaviors on generating <see cref="M:System.Object.GetHashCode"/> method.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.SourceGeneration.GetHashCodeAttribute.#ctor(System.SourceGeneration.GetHashCodeBehavior)">
            <summary>
            Represents an attribute type that allows source generators controlling behaviors on generating <see cref="M:System.Object.GetHashCode"/> method.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="P:System.SourceGeneration.GetHashCodeAttribute.Behavior">
            <summary>
            The generated property declaration for parameter <c>behavior</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.GetHashCodeBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.GetHashCode"/> overridden methods.
            </summary>
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="F:System.SourceGeneration.GetHashCodeBehavior.Intelligent">
            <summary>
            Indicates the source generator will adopt an intelligent way to generate hashing expression.
            If none of all data members in a type marked <see cref="T:System.SourceGeneration.HashCodeMemberAttribute"/>, a <see cref="T:System.NotSupportedException"/>
            will be thrown; if one member is marked and its type can be directly converted into an <see cref="T:System.Int32"/>, then use itself;
            otherwise, call <see cref="M:System.HashCode.Combine``1(``0)"/> method set or use <see cref="M:System.HashCode.Add``1(``0)"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.GetHashCodeBehavior.ThrowNotSupportedException">
            <summary>
            Indicates throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.GetHashCodeBehavior.MakeAbstract">
            <summary>
            Indicates the method will be made <see langword="abstract"/>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.HashCodeMemberAttribute">
            <summary>
            Indicates the marked member will participate hashing operation.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.ImplicitFieldAttribute">
            <summary>
            Indicates the source generator should generate its backing field without compiler controlling.
            </summary>
            <remarks>
            You can use this attribute to create a field:
            <code><![CDATA[
            [ImplicitField]
            public int Property
            {
                get => _property;
                set => _property ??= value;
            }
            ]]></code>
            You may not write code to create field <c>_property</c>. This attribute will make source generators generate it.
            </remarks>
        </member>
        <member name="P:System.SourceGeneration.ImplicitFieldAttribute.RequiredReadOnlyModifier">
            <summary>
            Indicates whether the generated field automatically appends a <see langword="readonly"/> modifier.
            The value is <see langword="true"/> by default.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.InlineArrayFieldAttribute`1">
            <summary>
            Represents an attribute type that will be used by source generator,
            telling the target source generator that the type must contain a fixed-sized buffer type,
            with specified length and a generated field to visit it.
            </summary>
            <typeparam name="T">The type of the fixed-sized buffer element.</typeparam>
            <param name="fieldName">Indicates the target field name.</param>
            <param name="length">Indicates the length of the fixed-sized buffer type.</param>
        </member>
        <member name="M:System.SourceGeneration.InlineArrayFieldAttribute`1.#ctor(System.String,System.Int32)">
            <summary>
            Represents an attribute type that will be used by source generator,
            telling the target source generator that the type must contain a fixed-sized buffer type,
            with specified length and a generated field to visit it.
            </summary>
            <typeparam name="T">The type of the fixed-sized buffer element.</typeparam>
            <param name="fieldName">Indicates the target field name.</param>
            <param name="length">Indicates the length of the fixed-sized buffer type.</param>
        </member>
        <member name="P:System.SourceGeneration.InlineArrayFieldAttribute`1.FieldName">
            <summary>
            The generated property declaration for parameter <c>fieldName</c>.
            </summary>
        </member>
        <member name="P:System.SourceGeneration.InlineArrayFieldAttribute`1.Length">
            <summary>
            The generated property declaration for parameter <c>length</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.LargeStructureAttribute">
            <summary>
            Represents an attribute that can tell source generators the type is a large structure,
            meaning the source generators will always append <see langword="scoped ref readonly"/> onto target-typed parameters
            if the containing member isn't an operator, or append <see langword="scoped in"/> if the containing member is an operator.
            </summary>
            <remarks>
            Please note that the type can be also consumed by interfaces. Such cases mean the target structure types implemented is a large structure.
            However, if the interface types having marked this attribute have been implemented by class types, it'll be meaningless.
            </remarks>
        </member>
        <member name="T:System.SourceGeneration.MemberKinds">
            <summary>
            Indicates a data member kind.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.MemberKinds.Field">
            <summary>
            Indicates the member kind is field.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.MemberKinds.Property">
            <summary>
            Indicates the member kind is property.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.NullabilityPrefer">
            <summary>
            Represents an enumeration type that tells source generators which case of nullability should be preferred.
            By default, <see langword="not null"/> for value types and including <see langword="null"/> for reference types.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.NullabilityPrefer.Default">
            <summary>
            Indicates the preferring is default.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.NullabilityPrefer.NotNull">
            <summary>
            Indicates the source generator will prefer <see langword="not null"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.NullabilityPrefer.IncludeNull">
            <summary>
            Indicates the source generator will prefer including <see langword="null"/>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.PatternOverriddenAttribute">
            <summary>
            Represents a base type that provides base properties used by derived attribute types.s
            </summary>
        </member>
        <member name="P:System.SourceGeneration.PatternOverriddenAttribute.OtherModifiers">
            <summary>
            <para>
            Indicates the other modifiers should be modified. For example, if the method should be <see langword="sealed"/>
            in a <see langword="class"/> type, assign <c>"Sealed"</c> or <c>"sealed"</c> to this property. Casing are ignored.
            Multiple modifiers should be separated by whitespaces.
            </para>
            <para>By default, this property is <see langword="null"/>.</para>
            </summary>
            <remarks>
            Please note, sometimes some extra keywords will be automatically added into signature without manually assigning them to this property.
            For example, in a non-<see langword="readonly struct"/>, due to the implementation not caring
            about its <see langword="readonly"/>-ability, a <see langword="readonly"/> modifier will be implicitly added.
            </remarks>
        </member>
        <member name="T:System.SourceGeneration.PrimaryConstructorParameterAttribute">
            <summary>
            Indicates the attribute type that can be marked for a parameter, indicating the parameter is a <see langword="record"/>-like one,
            telling the source generator that it should generate a property that references this parameter.
            </summary>
            <param name="memberKind">
            Indicates the member kind to be generated. You can reference the target value via type <see cref="T:System.SourceGeneration.MemberKinds"/>.
            </param>
            <remarks>
            <para>
            Begin with C# 12, we can define primary constructors for non-<see langword="record"/> types.
            However, the parameter defined will be expanded as a real parameter in its containing constructor.
            The compiler won't create a binding field or property. We should define it manually. This attribute will solve this problem.
            </para>
            <para>
            The original way to declare a type with primary constructor is like:
            <code><![CDATA[
            public readonly struct Color(byte a, byte r, byte g, byte b)
            {
                public byte A { get; } = a;
                public byte R { get; } = r;
                public byte G { get; } = g;
                public byte B { get; } = b;
            }
            ]]></code>
            </para>
            <para>
            Via this attribute type, we can simplify the code:
            <code><![CDATA[
            public readonly partial struct Color(
                [PrimaryConstructorParameter] byte a,
                [PrimaryConstructorParameter] byte r,
                [PrimaryConstructorParameter] byte g,
                [PrimaryConstructorParameter] byte b
            );
            ]]></code>
            Such code is equivalent to the original one.
            </para>
            <para>If you want to learn more information about this attribute type, please visit the metadata of the type.</para>
            </remarks>
        </member>
        <member name="M:System.SourceGeneration.PrimaryConstructorParameterAttribute.#ctor(System.String)">
            <summary>
            Indicates the attribute type that can be marked for a parameter, indicating the parameter is a <see langword="record"/>-like one,
            telling the source generator that it should generate a property that references this parameter.
            </summary>
            <param name="memberKind">
            Indicates the member kind to be generated. You can reference the target value via type <see cref="T:System.SourceGeneration.MemberKinds"/>.
            </param>
            <remarks>
            <para>
            Begin with C# 12, we can define primary constructors for non-<see langword="record"/> types.
            However, the parameter defined will be expanded as a real parameter in its containing constructor.
            The compiler won't create a binding field or property. We should define it manually. This attribute will solve this problem.
            </para>
            <para>
            The original way to declare a type with primary constructor is like:
            <code><![CDATA[
            public readonly struct Color(byte a, byte r, byte g, byte b)
            {
                public byte A { get; } = a;
                public byte R { get; } = r;
                public byte G { get; } = g;
                public byte B { get; } = b;
            }
            ]]></code>
            </para>
            <para>
            Via this attribute type, we can simplify the code:
            <code><![CDATA[
            public readonly partial struct Color(
                [PrimaryConstructorParameter] byte a,
                [PrimaryConstructorParameter] byte r,
                [PrimaryConstructorParameter] byte g,
                [PrimaryConstructorParameter] byte b
            );
            ]]></code>
            Such code is equivalent to the original one.
            </para>
            <para>If you want to learn more information about this attribute type, please visit the metadata of the type.</para>
            </remarks>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.IsImplicitlyReadOnly">
            <summary>
            Indicates whether the generated field or property is implicitly read-only.
            If the property is <see langword="true"/>, the generated data member (auto-impl'ed propertys or fields) will be modified
            by keyword <see langword="readonly"/> if all following conditions are true:
            <list type="number">
            <item>
            The type is a <see langword="struct"/>, <see langword="record struct"/>,
            <see langword="implicit extension"/> (will be included in future C# version)
            or <see langword="explicit extension"/> (will be included in future C# version)
            </item>
            <item>The type is not marked with keyword <see langword="readonly"/></item>
            </list>
            However, sometimes we should use non-<see langword="readonly"/> <see langword="struct"/> member as fields or auto-impl'ed properties,
            but we cannot modify it. By setting the property with <see langword="false"/> value,
            to avoid the source generator marking the generated member as <see langword="readonly"/>.
            </summary>
            <remarks>This property is <see langword="true"/> by default.</remarks>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.SetterExpression">
            <summary>
            <para>Indicates the extra setter expression. The expression is same declaration as auto-implemented properties.</para>
            <para>
            For example, if the property is declared as <c>public object? Property { get; private set; }</c>,
            the setter expression will be "<c>private set</c>". By default, this value will be <see langword="null"/>,
            which means the target property does not contain a setter.
            </para>
            </summary>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.NamingRule">
            <summary>
            Indicates the naming rule of the generated member name.
            </summary>
            <remarks>
            <para>
            The syntax of this property can be described as two parts:
            <list type="number">
            <item>
            A verbatim symbol <c>@</c> ("At" symbol, may contain an extra character <c><![CDATA[<]]></c> or <c><![CDATA[>]]></c>:
            <c><![CDATA[<@]]></c> or <c><![CDATA[>@]]></c>)
            </item>
            <item>Characters used in a valid identifier</item>
            </list>
            </para>
            <para>
            For example, if you want to set a generated property is named like <c>xxxTargetProperty</c>
            where the <c>xxx</c> is the name of the generated property, you can set this property as value <c>"@TargetProperty"</c>.
            Then the generated property will be like:
            <code><![CDATA[
            public int ParameterTargetProperty { get; } = parameter;
            ]]></code>
            </para>
            <para>
            Also, you can set the first character as lower or upper case via symbols <c><![CDATA[<]]></c> and <c><![CDATA[>]]></c>.
            If this property is <c><![CDATA["_<@"]]></c>, the generated member will be like:
            <code><![CDATA[
            private int _parameter = parameter;
            ]]></code>
            where <c><![CDATA["<@"]]></c> means the generated member name will use lower case for its first character.
            </para>
            <para>
            By default, the naming rule is <c><![CDATA["_<@"]]></c> for fields, and <c><![CDATA[">@"]]></c> for properties.
            </para>
            </remarks>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.MembersNotNull">
            <summary>
            Indicates the member names becoming not <see langword="null"/>
            when this generated member is <see langword="true"/> or <see langword="false"/>.
            </summary>
            <remarks>
            The syntax of this property can be described as two parts:
            <list type="number">
            <item>Boolean value literal</item>
            <item>Member or parameter names</item>
            </list>
            The complete expression is <c>"(1): (2)"</c>. For example: <c>"<see langword="false"/>: property1, property2"</c>.
            The generated member will be:
            <code><![CDATA[
            [MemberNotNullWhen(false, nameof(Property1), nameof(Property2))]
            public bool Parameter { get; } = parameter;
            ]]></code>
            where <c>property1</c> and <c>property2</c> are supposed to be two parameters marked this attribute.
            </remarks>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.GeneratedMemberName">
            <summary>
            Indicates the name of the generated member.
            </summary>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.Accessibility">
            <summary>
            Indicates the accessibility of the generated member.
            </summary>
            <remarks>
            <para>
            This property controls the case when you want to customize the accessibility of generated member.
            For example, the value is <c>"private"</c> or <c>"Private"</c>, the generated member will automatically insert the accessibility modifier
            into property declaration:
            <code><![CDATA[
            private int Parameter { get; } = parameter;
            ]]></code>
            </para>
            <para>By default, the accessibility is <see langword="private"/> for fields and <see langword="public"/> for properties.</para>
            </remarks>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.RefKind">
            <summary>
            Indicates the <see langword="ref"/> kind of the generated member.
            </summary>
            <remarks>
            <para>
            This property controls the case when you want to customize the reference kind of return value of the field or property.
            For example, the value is <c>"ref readonly"</c>, the generated member will automatically insert the <see langword="ref"/> modifiers
            into declaration:
            <code><![CDATA[
            private ref readonly int _parameter = ref parameter;
            ]]></code>
            </para>
            <para>
            By default, the <see langword="ref"/> kind should be suitable with parameter's declaration.
            If the parameter is defined without any <see langword="ref"/> modifiers:
            <list type="bullet">
            <item><see langword="ref"/></item>
            <item><see langword="ref readonly"/> (Supported in C# 12)</item>
            <item><see langword="in"/></item>
            <item><see langword="scoped ref"/></item>
            <item><see langword="scoped ref readonly"/> (Supported in C# 12)</item>
            <item><see langword="scoped in"/></item>
            <item><see langword="ref scoped"/> (Not supported in C# 12)</item>
            <item><see langword="ref readonly scoped"/> (Not supported in C# 12)</item>
            <item><see langword="in scoped"/> (Not supported in C# 12)</item>
            </list>
            the generated member will automatically include a <see langword="ref"/> modifier if the modifiers don't include <see langword="scoped"/>;
            otherwise, no <see langword="ref"/> modifiers.
            If you want to set <see langword="ref readonly"/>, you should manually set this property with value <c>"ref readonly"</c> value.
            </para>
            </remarks>
        </member>
        <member name="P:System.SourceGeneration.PrimaryConstructorParameterAttribute.MemberKind">
            <summary>
            The generated property declaration for parameter <c>memberKind</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.StringMemberAttribute">
            <summary>
            Indicates the marked member will participate to-string operation.
            </summary>
            <param name="displayName">
            Indicates the display name of the field or property to be changed.
            By default the value is <see langword="null"/>, which means no conversion will be existing here.
            </param>
        </member>
        <member name="M:System.SourceGeneration.StringMemberAttribute.#ctor(System.String)">
            <summary>
            Indicates the marked member will participate to-string operation.
            </summary>
            <param name="displayName">
            Indicates the display name of the field or property to be changed.
            By default the value is <see langword="null"/>, which means no conversion will be existing here.
            </param>
        </member>
        <member name="P:System.SourceGeneration.StringMemberAttribute.DisplayName">
            <summary>
            The generated property declaration for parameter <c>displayName</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.ToStringAttribute">
            <summary>
            Represents an attribute type that allows source generators controlling behaviors on generating <see cref="M:System.Object.ToString"/> method.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.SourceGeneration.ToStringAttribute.#ctor(System.SourceGeneration.ToStringBehavior)">
            <summary>
            Represents an attribute type that allows source generators controlling behaviors on generating <see cref="M:System.Object.ToString"/> method.
            </summary>
            <param name="behavior">Represents a kind of behavior on generated expression on comparing equality for instances.</param>
            <seealso cref="M:System.Object.ToString"/>
        </member>
        <member name="P:System.SourceGeneration.ToStringAttribute.Behavior">
            <summary>
            The generated property declaration for parameter <c>behavior</c>.
            </summary>
        </member>
        <member name="T:System.SourceGeneration.ToStringBehavior">
            <summary>
            Defines a behavior by source generator on generating <see cref="M:System.Object.GetHashCode"/> overridden methods.
            </summary>
            <seealso cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="F:System.SourceGeneration.ToStringBehavior.Intelligent">
            <summary>
            Indicates the source generator will automatically determine which expression to be output.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.ToStringBehavior.CallOverload">
            <summary>
            Indicates the source generator will generate an expression
            to call overload <see cref="M:System.ISimpleFormattable.ToString(System.String)"/> method.
            </summary>
            <seealso cref="M:System.ISimpleFormattable.ToString(System.String)"/>
        </member>
        <member name="F:System.SourceGeneration.ToStringBehavior.Specified">
            <summary>
            Indicates the source generator will generate an expression
            to output a string whose value is directly from a property or field result.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.ToStringBehavior.RecordLike">
            <summary>
            Indicates the source generator will generate an expression
            like a <see langword="record"/> or <see langword="record struct"/> default output.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.ToStringBehavior.ThrowNotSupportedException">
            <summary>
            Indicates throws <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="F:System.SourceGeneration.ToStringBehavior.MakeAbstract">
            <summary>
            Indicates the method will be made <see langword="abstract"/>.
            </summary>
        </member>
        <member name="T:System.ArrayInitializer`1">
            <summary>
            Represents a method that initializes for an element of type <typeparamref name="T"/>?,
            and be <typeparamref name="T"/> after the method invoked.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="value">The value to be initialized.</param>
        </member>
        <member name="T:System.CompareHandler`1">
            <summary>
            Represents a handler that checks the value comparison of two <typeparamref name="T"/> values.
            </summary>
            <typeparam name="T">The type of values to be compared.</typeparam>
            <param name="left">The left value to be compared.</param>
            <param name="right">The right value to be compared.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the result.</returns>
        </member>
        <member name="T:System.EqualsHandler`1">
            <summary>
            The specialized equality comparing handler.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="left">The left value to be compared.</param>
            <param name="right">The right value to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating the result.</returns>
        </member>
        <member name="T:System.GetHashCodeFunc`1">
            <inheritdoc cref="T:System.GetHashCodeHandler`1"/>
        </member>
        <member name="T:System.GetHashCodeHandler`1">
            <summary>
            The specialized get hash code handler.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="obj">The object to be calculated.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating the result.</returns>
        </member>
        <member name="T:System.ComplexValueTupleEnumerator`2">
            <summary>
            Defines a complex value tuple enumerator.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <typeparam name="TRest">The type that encapsulate for a list of rest elements.</typeparam>
            <param name="tuple">The tuple.</param>
        </member>
        <member name="M:System.ComplexValueTupleEnumerator`2.#ctor(System.ValueTuple{`0,`0,`0,`0,`0,`0,`0,`1})">
            <summary>
            Defines a complex value tuple enumerator.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <typeparam name="TRest">The type that encapsulate for a list of rest elements.</typeparam>
            <param name="tuple">The tuple.</param>
        </member>
        <member name="F:System.ComplexValueTupleEnumerator`2._values">
            <summary>
            Indicates the internal values to be iterated.
            </summary>
        </member>
        <member name="F:System.ComplexValueTupleEnumerator`2._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.ComplexValueTupleEnumerator`2.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:System.ComplexValueTupleEnumerator`2.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.ComplexValueTupleEnumerator`2.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.ComplexValueTupleEnumerator`2.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.ComplexValueTupleEnumerator`2.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.EnumFlagsEnumerator`1">
            <summary>
            Defines an enumerator that iterates the possible fields of an enumeration type.
            </summary>
            <typeparam name="T">
            The type of the enumeration type, that is marked the attribute <see cref="T:System.FlagsAttribute"/>.
            </typeparam>
            <param name="baseField">Indicates the base field.</param>
        </member>
        <member name="M:System.EnumFlagsEnumerator`1.#ctor(`0)">
            <summary>
            Defines an enumerator that iterates the possible fields of an enumeration type.
            </summary>
            <typeparam name="T">
            The type of the enumeration type, that is marked the attribute <see cref="T:System.FlagsAttribute"/>.
            </typeparam>
            <param name="baseField">Indicates the base field.</param>
        </member>
        <member name="F:System.EnumFlagsEnumerator`1._fields">
            <summary>
            Indicates the fields of the type to iterate.
            </summary>
        </member>
        <member name="F:System.EnumFlagsEnumerator`1._index">
            <summary>
            Indicates the current index being iterated.
            </summary>
        </member>
        <member name="P:System.EnumFlagsEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="P:System.EnumFlagsEnumerator`1.SizeOfT">
            <summary>
            Indicates the size of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:System.EnumFlagsEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:System.EnumFlagsEnumerator`1._baseField">
            <summary>
            The generated field declaration for parameter <c>baseField</c>.
            </summary>
        </member>
        <member name="M:System.EnumFlagsEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.EnumFlagsEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.EnumFlagsEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.PairEnumerator`1">
            <summary>
            Represents an enumerator that can iterate on elements, adjacent-pairly combined.
            </summary>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <param name="sequence">The sequence value.</param>
        </member>
        <member name="M:System.PairEnumerator`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Represents an enumerator that can iterate on elements, adjacent-pairly combined.
            </summary>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <param name="sequence">The sequence value.</param>
        </member>
        <member name="F:System.PairEnumerator`1._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.PairEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.PairEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.PairEnumerator`1.GetEnumerator">
            <inheritdoc cref="M:System.ReverseEnumerator`1.GetEnumerator"/>
        </member>
        <member name="M:System.PairEnumerator`1.Cast``2">
            <summary>
            Creates a <see cref="T:System.PairEnumeratorCasted`3"/> instance that supports down-casting
            for paired elements.
            </summary>
            <typeparam name="TFirst">
            <inheritdoc cref="T:System.PairEnumeratorCasted`3" path="/typeparam[@name='TFirst']"/>
            </typeparam>
            <typeparam name="TSecond">
            <inheritdoc cref="T:System.PairEnumeratorCasted`3" path="/typeparam[@name='TSecond']"/>
            </typeparam>
            <returns>A <see cref="T:System.PairEnumeratorCasted`3"/> instance.</returns>
        </member>
        <member name="F:System.PairEnumerator`1._sequence">
            <summary>
            The generated field declaration for parameter <c>sequence</c>.
            </summary>
        </member>
        <member name="M:System.PairEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.PairEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.PairEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.PairEnumeratorCasted`3">
            <inheritdoc cref="T:System.PairEnumerator`1"/>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <typeparam name="TFirst">The type of the first element in a pair.</typeparam>
            <typeparam name="TSecond">The type of the second element in a pair.</typeparam>
        </member>
        <member name="M:System.PairEnumeratorCasted`3.#ctor(System.ReadOnlySpan{`0})">
            <inheritdoc cref="T:System.PairEnumerator`1"/>
            <typeparam name="T">The type of each element to be iterated.</typeparam>
            <typeparam name="TFirst">The type of the first element in a pair.</typeparam>
            <typeparam name="TSecond">The type of the second element in a pair.</typeparam>
        </member>
        <member name="F:System.PairEnumeratorCasted`3._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.PairEnumeratorCasted`3.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.PairEnumeratorCasted`3.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.PairEnumeratorCasted`3.GetEnumerator">
            <inheritdoc cref="M:System.ReverseEnumerator`1.GetEnumerator"/>
        </member>
        <member name="F:System.PairEnumeratorCasted`3._sequence">
            <summary>
            The generated field declaration for parameter <c>sequence</c>.
            </summary>
        </member>
        <member name="M:System.PairEnumeratorCasted`3.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.PairEnumeratorCasted`3.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.PairEnumeratorCasted`3.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.ReadOnlyMemoryEnumerator`1">
            <summary>
            Represents an enumerator that iterates on each element of type <typeparamref name="T"/> inside a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="M:System.ReadOnlyMemoryEnumerator`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Represents an enumerator that iterates on each element of type <typeparamref name="T"/> inside a <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <seealso cref="T:System.ReadOnlyMemory`1"/>
        </member>
        <member name="F:System.ReadOnlyMemoryEnumerator`1._span">
            <summary>
            Indicates the span to the memory.
            </summary>
        </member>
        <member name="F:System.ReadOnlyMemoryEnumerator`1._index">
            <summary>
            Indicates the index that is currently iterated.
            </summary>
        </member>
        <member name="P:System.ReadOnlyMemoryEnumerator`1.Current">
            <summary>
            Indicates the current instance.
            </summary>
        </member>
        <member name="M:System.ReadOnlyMemoryEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.ReadOnlyMemoryEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.ReadOnlyMemoryEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.ReadOnlyMemoryEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.ReverseEnumerator`1">
            <summary>
            Represents a reverse enumerator.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="sequence">The internal sequence to be iterated.</param>
        </member>
        <member name="M:System.ReverseEnumerator`1.#ctor(System.ReadOnlySpan{`0})">
            <summary>
            Represents a reverse enumerator.
            </summary>
            <typeparam name="T">The type of the element.</typeparam>
            <param name="sequence">The internal sequence to be iterated.</param>
        </member>
        <member name="F:System.ReverseEnumerator`1._index">
            <summary>
            Indicates the current index.
            </summary>
        </member>
        <member name="P:System.ReverseEnumerator`1.Length">
            <summary>
            Indicates the length to the sequence.
            </summary>
        </member>
        <member name="P:System.ReverseEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.ReverseEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.ReverseEnumerator`1.GetEnumerator">
            <summary>
            Provides the basic iteration rule that iterates on each element using the current enumerator.
            </summary>
            <returns>The current enumerator.</returns>
        </member>
        <member name="F:System.ReverseEnumerator`1._sequence">
            <summary>
            The generated field declaration for parameter <c>sequence</c>.
            </summary>
        </member>
        <member name="M:System.ReverseEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.ReverseEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.ReverseEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.ValueTupleEnumerator`1">
            <summary>
            Provides with a mechanism to iterate a value tuple instance of a uniform type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The uniform type of a pair of instances.</typeparam>
        </member>
        <member name="F:System.ValueTupleEnumerator`1._limit">
            <summary>
            Indicates the maximum number of values to be iterated.
            </summary>
        </member>
        <member name="F:System.ValueTupleEnumerator`1._innerTuple">
            <summary>
            Indicates the internal tuple.
            </summary>
        </member>
        <member name="F:System.ValueTupleEnumerator`1._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0})">
            <summary>
            Initializes a <see cref="T:System.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <param name="pair">A pair instance to be iterated.</param>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0})">
            <summary>
            Initializes a <see cref="T:System.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <param name="triple">A triple instance to be iterated.</param>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0})">
            <summary>
            Initializes a <see cref="T:System.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <param name="quadruple">A quadruple instance to be iterated.</param>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0,`0})">
            <summary>
            Initializes a <see cref="T:System.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <param name="quintuple">A quintuple instance to be iterated.</param>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0,`0,`0})">
            <summary>
            Initializes a <see cref="T:System.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <param name="sextuple">A sextuple instance to be iterated.</param>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.#ctor(System.ValueTuple{`0,`0,`0,`0,`0,`0,`0})">
            <summary>
            Initializes a <see cref="T:System.ValueTupleEnumerator`1"/> instance via a <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <param name="septuple">A septuple instance to be iterated.</param>
        </member>
        <member name="P:System.ValueTupleEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.ValueTupleEnumerator`1.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:System.ArgumentNullRefException">
            <inheritdoc/>
            <param name="paramName">The parameter name.</param>
        </member>
        <member name="M:System.ArgumentNullRefException.#ctor(System.String)">
            <inheritdoc/>
            <param name="paramName">The parameter name.</param>
        </member>
        <member name="T:System.INullRef`1">
            <summary>
            Represents a type that supports a property returning a <see langword="null"/> reference.
            </summary>
            <typeparam name="TSelf">The type of itself.</typeparam>
        </member>
        <member name="P:System.INullRef`1.NullRef">
            <summary>
            Represents the default reference of this type.
            </summary>
        </member>
        <member name="T:System.ISimpleFormattable">
            <summary>
            Defines a type that supports <c>ToString(<see langword="string"/>?)</c>.
            </summary>
            <seealso cref="M:System.ISimpleFormattable.ToString(System.String)"/>
        </member>
        <member name="M:System.ISimpleFormattable.ToString(System.String)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <param name="format">The format to use, or <see langword="null"/> to use the default format.</param>
            <returns>The value of the current instance in the specified format.</returns>
            <exception cref="T:System.FormatException">Throws when the format is invalid.</exception>
        </member>
        <member name="M:System.ISimpleFormattable.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:System.ISimpleParsable`1">
            <summary>
            Defines an instance that allows the <see cref="T:System.String"/> value
            to be parsed to the target type <typeparamref name="TSelf"/>.
            </summary>
            <remarks>
            Different with type <see cref="T:System.IParsable`1"/>, this type is not necessary to convert
            instances into <see cref="T:System.IFormatProvider"/>.
            </remarks>
            <typeparam name="TSelf">The type of the target result.</typeparam>
            <seealso cref="T:System.IParsable`1"/>
            <seealso cref="T:System.IFormatProvider"/>
        </member>
        <member name="M:System.ISimpleParsable`1.Parse(System.String)">
            <summary>
            Parse the specified string text, and get the same-meaning instance
            of type <typeparamref name="TSelf"/>.
            </summary>
            <param name="str">The string to parse. The value cannot be <see langword="null"/>.</param>
            <returns>The result parsed.</returns>
            <exception cref="T:System.FormatException">Throws when failed to parse.</exception>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="str"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.ISimpleParsable`1.TryParse(System.String,`0@)">
            <summary>
            Try to parse the specified string text, and get the same-meaning instance
            of type <typeparamref name="TSelf"/>.
            </summary>
            <param name="str">The string to parse. The value cannot be <see langword="null"/>.</param>
            <param name="result">
            The result parsed. If failed to parse, the value will keep the <see langword="default"/> value,
            i.e. <see langword="default"/>(<typeparamref name="TSelf"/>).
            </param>
            <returns>
            A <see cref="T:System.Boolean"/> result indicating whether the operation is successful to execute.
            </returns>
        </member>
        <member name="M:System.ISimpleParsable`1.System#IParsable{TSelf}#TryParse(System.String,System.IFormatProvider,`0@)">
            <inheritdoc/>
        </member>
        <member name="M:System.ISimpleParsable`1.System#IParsable{TSelf}#Parse(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:System.ILogicalOperators`1">
            <summary>
            Defines a mechanism for computing the logical relation between two instances of type <typeparamref name="TSelf"/>.
            </summary>
            <typeparam name="TSelf">The implementation.</typeparam>
        </member>
        <member name="M:System.ILogicalOperators`1.op_True(`0)">
            <summary>
            Determine whether the specified object is determined <see langword="true"/>.
            </summary>
            <param name="value">The value to be determined.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.ILogicalOperators`1.op_False(`0)">
            <summary>
            Determine whether the specified object is determined <see langword="false"/>.
            </summary>
            <param name="value">The value to be determined.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.ILogicalOperators`1.op_LogicalNot(`0)">
            <summary>
            Negates the current instance, and makes the result to be negated one.
            </summary>
            <param name="value">The value.</param>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.ILogicalOperators`1.op_BitwiseAnd(`0,`0)">
            <summary>
            Equivalent to <c><![CDATA[false(left) ? left : false(left & right)]]></c>.
            </summary>
            <param name="left">The left-side value.</param>
            <param name="right">The right-side value.</param>
            <returns>A instance of type <typeparamref name="TSelf"/>, as the result value.</returns>
        </member>
        <member name="M:System.ILogicalOperators`1.op_BitwiseOr(`0,`0)">
            <summary>
            Equivalent to <c><![CDATA[true(left) ? left : true(left | right)]]></c>.
            </summary>
            <param name="left">The left-side value.</param>
            <param name="right">The right-side value.</param>
            <returns><inheritdoc cref="M:System.ILogicalOperators`1.op_BitwiseAnd(`0,`0)" path="/returns"/></returns>
        </member>
        <member name="M:System.ILogicalOperators`1.op_ExclusiveOr(`0,`0)">
            <summary>
            Equivalent to <c><![CDATA[left & ~right | ~left & right]]></c>.
            </summary>
            <param name="left">The left-side value.</param>
            <param name="right">The right-side value.</param>
            <returns><inheritdoc cref="M:System.ILogicalOperators`1.op_BitwiseAnd(`0,`0)" path="/returns"/></returns>
        </member>
        <member name="T:System.ChunkNode`1">
            <summary>
            Represents a chunk node. The type will be used by <see cref="T:System.ReadOnlyChunk`1"/> instances.
            </summary>
            <typeparam name="T">The type of each values.</typeparam>
            <seealso cref="T:System.ReadOnlyChunk`1"/>
        </member>
        <member name="F:System.ChunkNode`1.Empty">
            <summary>
            Represents an empty instance.
            </summary>
        </member>
        <member name="M:System.ChunkNode`1.#ctor(`0)">
            <summary>
            Initializes a <see cref="T:System.ChunkNode`1"/> instance via the specified value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.ChunkNode`1.#ctor(`0[])">
            <summary>
            Initializes a <see cref="T:System.ChunkNode`1"/> instance via the array.
            </summary>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.ChunkNode`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Initializes a <see cref="T:System.ChunkNode`1"/> instance via the list.
            </summary>
            <param name="list">The list.</param>
        </member>
        <member name="P:System.ChunkNode`1.ValueRef">
            <summary>
            Indicates the pointer that points to the values.
            The value can be used if <see cref="P:System.ChunkNode`1.Type"/> is not <see cref="F:System.ChunkNodeType.Value"/>.
            </summary>
        </member>
        <member name="P:System.ChunkNode`1.Length">
            <summary>
            Indicates the sequence length of the chunk.
            By default, the value is 1 if <see cref="P:System.ChunkNode`1.Type"/> is <see cref="F:System.ChunkNodeType.Value"/>.
            </summary>
            <seealso cref="P:System.ChunkNode`1.Type"/>
        </member>
        <member name="P:System.ChunkNode`1.Type">
            <summary>
            Indicates the type of the chunk.
            </summary>
        </member>
        <member name="P:System.ChunkNode`1.Value">
            <summary>
            Indicates the value. The value can be used if <see cref="P:System.ChunkNode`1.Type"/> is <see cref="F:System.ChunkNodeType.Value"/>.
            </summary>
        </member>
        <member name="P:System.ChunkNode`1.IsSingleValue">
            <summary>
            Indicates whether the node represents for a single value.
            </summary>
        </member>
        <member name="P:System.ChunkNode`1.Item(System.Int32)">
            <summary>
            Gets the value at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>The reference to the element at the specified index.</returns>
            <exception cref="T:System.NotSupportedException">Throws when the property is <see cref="F:System.ChunkNodeType.Value"/>.</exception>
        </member>
        <member name="M:System.ChunkNode`1.ReferenceEquals(System.ChunkNode{`0}@)">
            <summary>
            Compares the reference of the internal collection value from two values,
            and return a value indicating whether they reference to a same memory location.
            </summary>
            <param name="other">The other value to be compared.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:System.ChunkNode`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.ChunkNode`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.ChunkNode`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.ChunkNode`1.op_Explicit(System.ChunkNode{`0}@)~`0[]">
            <summary>
            Explict cast from <see cref="T:System.ChunkNode`1"/> to <typeparamref name="T"/>[].
            </summary>
            <param name="value">The value.</param>
            <exception cref="T:System.InvalidCastException">Throws when the value is not an array.</exception>
        </member>
        <member name="M:System.ChunkNode`1.op_Explicit(System.ChunkNode{`0}@)~System.Collections.Generic.List{`0}">
            <summary>
            Explict cast from <see cref="T:System.ChunkNode`1"/> to <typeparamref name="T"/>[].
            </summary>
            <param name="value">The value.</param>
            <exception cref="T:System.InvalidCastException">Throws when the value is not a list.</exception>
        </member>
        <member name="M:System.ChunkNode`1.op_Implicit(`0[])~System.ChunkNode{`0}">
            <summary>
            Implicit cast from <typeparamref name="T"/>[] to a <see cref="T:System.ChunkNode`1"/>.
            </summary>
            <param name="array">The array.</param>
        </member>
        <member name="M:System.ChunkNode`1.op_Implicit(System.Collections.Generic.List{`0})~System.ChunkNode{`0}">
            <summary>
            Implicit cast from <see cref="T:System.Collections.Generic.List`1"/> of <typeparamref name="T"/> to a <see cref="T:System.ChunkNode`1"/>.
            </summary>
            <param name="list">The list.</param>
        </member>
        <member name="T:System.ChunkNode`1.Enumerator">
            <summary>
            Indicates the enumerator of current type.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:System.ChunkNode`1.Enumerator.#ctor(System.ChunkNode{`0}@)">
            <summary>
            Indicates the enumerator of current type.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="F:System.ChunkNode`1.Enumerator._values">
            <summary>
            Indicates the values.
            </summary>
        </member>
        <member name="F:System.ChunkNode`1.Enumerator._index">
            <summary>
            Indicates the index.
            </summary>
        </member>
        <member name="P:System.ChunkNode`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.ChunkNode`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="M:System.ChunkNode`1.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.ChunkNode`1.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:System.ChunkNodeBuilder">
            <summary>
            Internal builder type for creating <see cref="T:System.ChunkNode`1"/>.
            </summary>
            <seealso cref="T:System.ChunkNode`1"/>
        </member>
        <member name="M:System.ChunkNodeBuilder.Create``1(System.ReadOnlySpan{``0})">
            <summary>
            The create method.
            </summary>
            <typeparam name="T">The type of the value.</typeparam>
            <param name="values">The values.</param>
            <returns>A <see cref="T:System.ChunkNode`1"/> instance.</returns>
        </member>
        <member name="T:System.ChunkNodeType">
            <summary>
            Represents a type of a <see cref="T:System.ChunkNode`1"/>.
            </summary>
            <seealso cref="T:System.ChunkNode`1"/>
        </member>
        <member name="F:System.ChunkNodeType.Value">
            <summary>
            Indicates the type is a value.
            </summary>
        </member>
        <member name="F:System.ChunkNodeType.Array">
            <summary>
            Indicates the type is array.
            </summary>
        </member>
        <member name="F:System.ChunkNodeType.List">
            <summary>
            Indicates the type is list.
            </summary>
        </member>
        <member name="T:System.ReadOnlyChunksBuilder">
            <summary>
            Represents the builder that can create <see cref="T:System.ReadOnlyChunk`1"/> instances.
            </summary>
            <seealso cref="T:System.ReadOnlyChunk`1"/>
        </member>
        <member name="M:System.ReadOnlyChunksBuilder.Create``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a <see cref="T:System.ReadOnlyChunk`1"/> instance.
            </summary>
            <typeparam name="T">The type of each element.</typeparam>
            <param name="values">The values.</param>
            <returns>A <see cref="T:System.ReadOnlyChunk`1"/> instance.</returns>
        </member>
        <member name="T:System.ReadOnlyChunk`1">
            <summary>
            Represents a read-only collection of chunks of values of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of each values.</typeparam>
            <param name="chunks">Indicates the internal chunks.</param>
        </member>
        <member name="M:System.ReadOnlyChunk`1.#ctor(System.ChunkNode{`0}[])">
            <summary>
            Represents a read-only collection of chunks of values of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of each values.</typeparam>
            <param name="chunks">Indicates the internal chunks.</param>
        </member>
        <member name="P:System.ReadOnlyChunk`1.Length">
            <summary>
            Indicates the number of elements of type <see cref="T:System.ChunkNode`1"/> stored in this collection.
            </summary>
            <seealso cref="T:System.ChunkNode`1"/>
        </member>
        <member name="P:System.ReadOnlyChunk`1.Span">
            <summary>
            Indicates the span of values.
            </summary>
        </member>
        <member name="P:System.ReadOnlyChunk`1.Item(System.Int32)">
            <summary>
            Gets the value node at the specified index.
            </summary>
            <param name="index">The desired index.</param>
            <returns>A <see cref="T:System.ChunkNode`1"/> instance. You can use explicit cast to fetch the internal value.</returns>
        </member>
        <member name="M:System.ReadOnlyChunk`1.GetPinnableReference">
            <inheritdoc cref="M:System.ReadOnlySpan`1.GetPinnableReference"/>
        </member>
        <member name="M:System.ReadOnlyChunk`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.ReadOnlyChunk`1.AsSpan">
            <summary>
            Expands the collection to a <see cref="T:System.ReadOnlySpan`1"/> of <typeparamref name="T"/> instances.
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> that stores the expanded <typeparamref name="T"/> elements.</returns>
        </member>
        <member name="M:System.ReadOnlyChunk`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.ReadOnlyChunk`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:System.ReadOnlyChunk`1.Enumerator">
            <summary>
            Represents an enumerator type that can iterate on each element of type <typeparamref name="T"/> stored in this collection.
            </summary>
            <param name="this">Indicates the instance of <see langword="this"/>.</param>
            <remarks>
            This enumerator code is generated by compiler. See <see href="http://tinyurl.com/trunks-enumerator">this link</see>.
            </remarks>
        </member>
        <member name="M:System.ReadOnlyChunk`1.Enumerator.#ctor(System.ReadOnlyChunk{`0})">
            <summary>
            Represents an enumerator type that can iterate on each element of type <typeparamref name="T"/> stored in this collection.
            </summary>
            <param name="this">Indicates the instance of <see langword="this"/>.</param>
            <remarks>
            This enumerator code is generated by compiler. See <see href="http://tinyurl.com/trunks-enumerator">this link</see>.
            </remarks>
        </member>
        <member name="F:System.ReadOnlyChunk`1.Enumerator._this">
            <summary>
            Indicates the copied instance.
            </summary>
        </member>
        <member name="F:System.ReadOnlyChunk`1.Enumerator._state">
            <summary>
            Indicates the state of the enumerator. The value can be described which type of the node is currently enumerated.
            </summary>
        </member>
        <member name="F:System.ReadOnlyChunk`1.Enumerator._index">
            <summary>
            Indicates the index of the array iterated.
            </summary>
        </member>
        <member name="F:System.ReadOnlyChunk`1.Enumerator._tempValue">
            <summary>
            Indicates the temporary value.
            </summary>
        </member>
        <member name="F:System.ReadOnlyChunk`1.Enumerator._tempNodeArray">
            <summary>
            Indicates the temporary array of nodes.
            </summary>
        </member>
        <member name="F:System.ReadOnlyChunk`1.Enumerator._tempListEnumerator">
            <summary>
            Indicates the temporary enumerator of <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <seealso cref="T:System.Collections.Generic.List`1.Enumerator"/>
        </member>
        <member name="F:System.ReadOnlyChunk`1.Enumerator._tempValueArray">
            <summary>
            Indicates the value array to be iterated.
            </summary>
        </member>
        <member name="P:System.ReadOnlyChunk`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.IEnumerator.Current"/>
        </member>
        <member name="M:System.ReadOnlyChunk`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="F:System.ReadOnlyChunk`1._chunks">
            <summary>
            The generated field declaration for parameter <c>chunks</c>.
            </summary>
        </member>
        <member name="T:System.SpecializedComparer`1">
            <summary>
            Represents a specialized comparer.
            </summary>
            <typeparam name="T">The type of values to be compared.</typeparam>
            <param name="isUnsafe">Indicates whether the handler methods are unsafe.</param>
        </member>
        <member name="M:System.SpecializedComparer`1.#ctor(System.Boolean)">
            <summary>
            Represents a specialized comparer.
            </summary>
            <typeparam name="T">The type of values to be compared.</typeparam>
            <param name="isUnsafe">Indicates whether the handler methods are unsafe.</param>
        </member>
        <member name="F:System.SpecializedComparer`1._compare">
            <summary>
            The handler for method <see cref="M:System.SpecializedComparer`1.Compare(`0@,`0@)"/>.
            </summary>
        </member>
        <member name="F:System.SpecializedComparer`1._compareUnsafe">
            <inheritdoc cref="F:System.SpecializedComparer`1._compare"/>
        </member>
        <member name="P:System.SpecializedComparer`1.IsUnsafe">
            <summary>
            Indicates whether the comparer uses unsafe logic.
            </summary>
        </member>
        <member name="M:System.SpecializedComparer`1.#ctor(System.CompareHandler{`0})">
            <summary>
            Initializes a <see cref="T:System.SpecializedComparer`1"/> instance.
            </summary>
        </member>
        <member name="M:System.SpecializedComparer`1.#ctor()">
            <summary>
            Initializes a <see cref="T:System.SpecializedComparer`1"/> instance.
            </summary>
        </member>
        <member name="M:System.SpecializedComparer`1.Compare(`0@,`0@)">
            <inheritdoc cref="M:System.IComparable`1.CompareTo(`0)"/>
        </member>
        <member name="M:System.SpecializedComparer`1.System#Collections#Generic#IComparer{T}#Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="T:System.SpecializedEqualityComparer`1">
            <summary>
            Represents a specialized equality comparer.
            </summary>
            <typeparam name="T">The type of values to be compared.</typeparam>
            <param name="isUnsafe">Indicates whether the handler methods are unsafe.</param>
        </member>
        <member name="M:System.SpecializedEqualityComparer`1.#ctor(System.Boolean)">
            <summary>
            Represents a specialized equality comparer.
            </summary>
            <typeparam name="T">The type of values to be compared.</typeparam>
            <param name="isUnsafe">Indicates whether the handler methods are unsafe.</param>
        </member>
        <member name="F:System.SpecializedEqualityComparer`1._equals">
            <summary>
            The handler for method <see cref="M:System.SpecializedEqualityComparer`1.Equals(`0@,`0@)"/>.
            </summary>
        </member>
        <member name="F:System.SpecializedEqualityComparer`1._getHashCode">
            <summary>
            The handler for method <see cref="M:System.SpecializedEqualityComparer`1.GetHashCode(`0@)"/>.
            </summary>
        </member>
        <member name="F:System.SpecializedEqualityComparer`1._equalsUnsafe">
            <inheritdoc cref="F:System.SpecializedEqualityComparer`1._equals"/>
        </member>
        <member name="F:System.SpecializedEqualityComparer`1._getHashCodeUnsafe">
            <inheritdoc cref="F:System.SpecializedEqualityComparer`1._getHashCode"/>
        </member>
        <member name="M:System.SpecializedEqualityComparer`1.#ctor(System.EqualsHandler{`0},System.GetHashCodeHandler{`0})">
            <summary>
            Initializes a <see cref="T:System.SpecializedEqualityComparer`1"/> instance.
            </summary>
        </member>
        <member name="M:System.SpecializedEqualityComparer`1.#ctor(,)">
            <summary>
            Initializes a <see cref="T:System.SpecializedEqualityComparer`1"/> instance.
            </summary>
        </member>
        <member name="P:System.SpecializedEqualityComparer`1.IsUnsafe">
            <summary>
            Indicates whether the comparer uses unsafe logic.
            </summary>
        </member>
        <member name="M:System.SpecializedEqualityComparer`1.Equals(`0@,`0@)">
            <inheritdoc cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)"/>
        </member>
        <member name="M:System.SpecializedEqualityComparer`1.GetHashCode(`0@)">
            <inheritdoc cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/>
        </member>
        <member name="M:System.SpecializedEqualityComparer`1.System#Collections#Generic#IEqualityComparer{T}#Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:System.SpecializedEqualityComparer`1.System#Collections#Generic#IEqualityComparer{T}#GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="T:System.Utf8Char">
            <summary>
            Represents a character as a UTF-8 code unit.
            </summary>
        </member>
        <member name="F:System.Utf8Char.MinValue">
            <summary>
            Indicates the minimum-valued instance of the current type.
            </summary>
        </member>
        <member name="F:System.Utf8Char.MaxValue">
            <summary>
            Indicates the maximum-valued instance of the current type.
            </summary>
        </member>
        <member name="F:System.Utf8Char._char">
            <summary>
            Indicates the inner character.
            </summary>
        </member>
        <member name="M:System.Utf8Char.#ctor(System.Byte)">
            <summary>
            Initializes a <see cref="T:System.Utf8Char"/> instance via the specified <see cref="T:System.Byte"/> value.
            </summary>
            <param name="value">The <see cref="T:System.Byte"/> value.</param>
        </member>
        <member name="P:System.Utf8Char.CharString">
            <summary>
            Indicates the character string.
            </summary>
        </member>
        <member name="P:System.Utf8Char.System#Numerics#IMinMaxValue{System#Utf8Char}#MinValue">
            <inheritdoc/>
        </member>
        <member name="P:System.Utf8Char.System#Numerics#IMinMaxValue{System#Utf8Char}#MaxValue">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.IsDigit">
            <summary>
            Determines whether the current character is a digit.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Utf8Char.IsLetter">
            <summary>
            Determines whether the current character is a letter.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Utf8Char.IsUpper">
            <summary>
            Determines whether the current character is a upper-casing letter.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Utf8Char.IsLower">
            <summary>
            Determines whether the current character is a lower-casing letter.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Utf8Char.IsLetterOrDigit">
            <summary>
            Determines whether a character is a letter or a digit.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> result.</returns>
        </member>
        <member name="M:System.Utf8Char.Equals(System.Utf8Char)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.CompareTo(System.Utf8Char)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.ToUpper">
            <summary>
            Converts the current character to the upper-casing letter.
            </summary>
            <returns>The result character.</returns>
        </member>
        <member name="M:System.Utf8Char.ToLower">
            <summary>
            Converts the current character to the lower-casing letter.
            </summary>
            <returns>The result character.</returns>
        </member>
        <member name="M:System.Utf8Char.System#IComparable#CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_Addition(System.Utf8Char,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_CheckedAddition(System.Utf8Char,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_Subtraction(System.Utf8Char,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_CheckedSubtraction(System.Utf8Char,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_Increment(System.Utf8Char)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_CheckedIncrement(System.Utf8Char)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_Decrement(System.Utf8Char)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_CheckedDecrement(System.Utf8Char)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8Char.op_Explicit(System.Char)~System.Utf8Char">
            <summary>
            Explicitly cast from <see cref="T:System.Char"/> instance to <see cref="T:System.Utf8Char"/> instance.
            </summary>
            <param name="utf16Char">The <see cref="T:System.Char"/> instance.</param>
        </member>
        <member name="M:System.Utf8Char.op_CheckedExplicit(System.Char)~System.Utf8Char">
            <summary>
            Explicitly cast from <see cref="T:System.Char"/> instance to <see cref="T:System.Utf8Char"/> instance,
            with range check.
            </summary>
            <param name="utf16Char">The <see cref="T:System.Char"/> instance.</param>
        </member>
        <member name="M:System.Utf8Char.op_Implicit(System.Utf8Char)~System.Byte">
            <summary>
            Implicitly cast from <see cref="T:System.Utf8Char"/> instance to <see cref="T:System.Byte"/> instance.
            </summary>
            <param name="utf8Char">The <see cref="T:System.Utf8Char"/> instance.</param>
        </member>
        <member name="M:System.Utf8Char.op_Implicit(System.Utf8Char)~System.Char">
            <summary>
            Implicitly cast from <see cref="T:System.Utf8Char"/> instance to <see cref="T:System.Char"/> instance.
            </summary>
            <param name="utf8Char">The <see cref="T:System.Utf8Char"/> instance.</param>
        </member>
        <member name="M:System.Utf8Char.op_Implicit(System.Byte)~System.Utf8Char">
            <summary>
            Implicitly cast from <see cref="T:System.Byte"/> instance to <see cref="T:System.Utf8Char"/> instance.
            </summary>
            <param name="byteValue">The <see cref="T:System.Byte"/> instance.</param>
        </member>
        <member name="M:System.Utf8Char.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Utf8Char.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:System.Utf8Char.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:System.Utf8Char.op_Equality(System.Utf8Char,System.Utf8Char)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:System.Utf8Char.op_Inequality(System.Utf8Char,System.Utf8Char)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:System.Utf8Char.op_GreaterThan(System.Utf8Char,System.Utf8Char)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:System.Utf8Char.op_LessThan(System.Utf8Char,System.Utf8Char)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:System.Utf8Char.op_GreaterThanOrEqual(System.Utf8Char,System.Utf8Char)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:System.Utf8Char.op_LessThanOrEqual(System.Utf8Char,System.Utf8Char)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="T:System.JsonConverter">
            <summary>
            The internal JSON converter type for <see cref="T:System.Utf8Char"/>.
            </summary>
            <seealso cref="T:System.Utf8Char"/>
        </member>
        <member name="M:System.JsonConverter.Read(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:System.JsonConverter.Write(System.Text.Json.Utf8JsonWriter,System.Utf8Char,System.Text.Json.JsonSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:System.Utf8String">
            <summary>
            Represents text as a sequence of UTF-8 code units.
            </summary>
        </member>
        <member name="F:System.Utf8String.Empty">
            <summary>
            Indicates the default instance.
            </summary>
        </member>
        <member name="F:System.Utf8String._value">
            <summary>
            Indicates the inner value.
            </summary>
        </member>
        <member name="M:System.Utf8String.#ctor(System.Utf8Char,System.Int32)">
            <summary>
            Initializes a <see cref="T:System.Utf8String"/> instance via the specified UTF-8 character and the specified
            times of the appearance.
            </summary>
            <param name="c">The character.</param>
            <param name="count">The times of the appearance.</param>
        </member>
        <member name="M:System.Utf8String.#ctor(System.Utf8Char*)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Utf8String"/> struct to the value
            indicated by a specified pointer to an array of UTF-8 characters.
            </summary>
            <param name="value">A pointer to a <see langword="null"/>-terminated array of UTF-8 characters.</param>
        </member>
        <member name="M:System.Utf8String.#ctor(System.Utf8Char[])">
            <summary>
            Initializes a <see cref="T:System.Utf8String"/> instance via the specified array of <see cref="T:System.Utf8Char"/>s
            as the underlying array.
            </summary>
            <param name="underlyingArray">The underlying array.</param>
        </member>
        <member name="M:System.Utf8String.#ctor(System.Byte[])">
            <summary>
            Initializes a <see cref="T:System.Utf8String"/> instance via the specified array of <see cref="T:System.Byte"/>s
            as the underlying values.
            </summary>
            <param name="array">The array of <see cref="T:System.Byte"/>s.</param>
        </member>
        <member name="P:System.Utf8String.Length">
            <inheritdoc/>
        </member>
        <member name="P:System.Utf8String.UnderlyingArray">
            <summary>
            Indicates the underlying array.
            </summary>
        </member>
        <member name="P:System.Utf8String.System#Collections#Generic#IReadOnlyCollection{System#Utf8Char}#Count">
            <inheritdoc/>
        </member>
        <member name="P:System.Utf8String.Item(System.Int32)">
            <summary>
            Gets the reference of a character at the specified index in the current string.
            </summary>
            <param name="index">The index.</param>
            <returns>The reference of the character.</returns>
        </member>
        <member name="P:System.Utf8String.System#Collections#Generic#IReadOnlyList{System#Utf8Char}#Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8String.Equals(System.Utf8String)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8String.Contains(System.Utf8Char)">
            <summary>
            Determines whether the current string contains the specified UTF-8 character.
            </summary>
            <param name="c">The character.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:System.Utf8String.Contains(System.Utf8String)">
            <summary>
            Determines whether the current string contains the specified UTF-8 string.
            </summary>
            <param name="s">The string.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating that.</returns>
        </member>
        <member name="M:System.Utf8String.GetPinnableReference">
            <target name="method">
				<summary>
					Returns a reference as the fixed position of the current instance.
					For example, the return value will be the pointer value that points to the zero-indexed
					place in an array.
				</summary>
				<returns>A reference as the fixed position of the current instance.</returns>
				<remarks>
					Beginning with C# 7, we can customize the return value type of a <see langword="fixed" /> variable
					if we implement a parameterless method called <c>GetPinnableReference</c>, returning by
					<see langword="ref" /> or <see langword="ref readonly" />. For example, if we hold a fixed buffer
					of element type:
					<code>
<![CDATA[
class ExampleType
{
    private fixed short _maskList[100];

    public ref readonly short GetPinnableReference() => ref _maskList[0];
}
]]>
					</code>
					We can use <see langword="fixed" /> statement to define a variable of type <see langword="short" />*
					as the left-value.
					<code>
<![CDATA[
var instance = new ExampleType();
fixed (short* ptr = instance)
{
    // Operation here.
}
]]>
					</code>
				</remarks>
			</target>
        </member>
        <member name="M:System.Utf8String.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8String.CompareTo(System.Utf8String)">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8String.IndexOf(System.Utf8Char)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified UTF-8 character in this string.
            </summary>
            <param name="c">The character.</param>
            <returns>
            The zero-based index position of <paramref name="c"/> if that character is found, or -1 if it is not.
            </returns>
        </member>
        <member name="M:System.Utf8String.IndexOf(System.Utf8String)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified UTF-8 string in this string.
            </summary>
            <param name="s">The character.</param>
            <returns>
            The zero-based index position of <paramref name="s"/> if that character is found, or -1 if it is not.
            </returns>
        </member>
        <member name="M:System.Utf8String.ToString">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8String.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>
        </member>
        <member name="M:System.Utf8String.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8String.System#Collections#Generic#IEnumerable{System#Utf8Char}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:System.Utf8String.Compare(System.Utf8String,System.Utf8String)">
            <summary>
            Compares two values.
            </summary>
            <param name="strA">The first string to be compared.</param>
            <param name="strB">The second string to be compared.</param>
            <returns>An <see cref="T:System.Int32"/> value indicating which one is greater.</returns>
        </member>
        <member name="M:System.Utf8String.op_Addition(System.Utf8String,System.Utf8String)">
            <summary>
            Concatenate two <see cref="T:System.Utf8String"/> instances.
            </summary>
            <param name="left">The left-side instance to be concatenated.</param>
            <param name="right">The right-side instance to be concatenated.</param>
            <returns>The final string.</returns>
        </member>
        <member name="M:System.Utf8String.StringLengthOf(System.Utf8Char*)">
            <summary>
            Get the length of the specified string which is represented by a <see cref="T:System.Utf8Char"/>*.
            </summary>
            <param name="ptr">The pointer.</param>
            <returns>The total length.</returns>
            <exception cref="T:System.ArgumentNullException">
            Throws when the argument <paramref name="ptr"/> is <see langword="null"/>.
            </exception>
            <remarks>
            In C#, this function is unsafe because the implementation of
            <see cref="T:System.Utf8String"/> types between C and C# is totally different.
            In C, <see cref="T:System.Utf8String"/> is like a <see cref="T:System.Utf8Char"/>* or a
            <see cref="T:System.Utf8Char"/>[], they ends with the terminator symbol <c>'\0'</c>.
            However, C# not.
            </remarks>
        </member>
        <member name="M:System.Utf8String.op_Explicit(System.Utf8String)~System.Utf8Char[]">
            <summary>
            Explicitly cast from <see cref="T:System.Utf8String"/> to <see cref="T:System.Utf8Char"/>[].
            </summary>
            <param name="s">The string.</param>
        </member>
        <member name="M:System.Utf8String.op_Explicit(System.String)~System.Utf8String">
            <summary>
            Explicitly cast from <see cref="T:System.String"/> to <see cref="T:System.Utf8String"/> instance.
            </summary>
            <param name="s">The string.</param>
        </member>
        <member name="M:System.Utf8String.op_CheckedExplicit(System.String)~System.Utf8String">
            <summary>
            Explicitly cast from <see cref="T:System.String"/> to <see cref="T:System.Utf8String"/> instance,
            with character range check.
            </summary>
            <param name="s">The string.</param>
            <exception cref="T:System.ArithmeticException">
            Throws when a certain character in the sequence cannot convert to a UTF-8 formatted character.
            </exception>
        </member>
        <member name="M:System.Utf8String.op_Implicit(System.Utf8String)~System.String">
            <summary>
            Implicitly cast from <see cref="T:System.Utf8String"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="s">The string.</param>
        </member>
        <member name="M:System.Utf8String.op_Implicit(System.Utf8Char[])~System.Utf8String">
            <summary>
            Implicitly cast from <see cref="T:System.Utf8Char"/>[]? to <see cref="T:System.Utf8String"/>.
            </summary>
            <param name="underlyingArray">The underlying array.</param>
        </member>
        <member name="M:System.Utf8String.op_Implicit(System.Byte[])~System.Utf8String">
            <summary>
            Implicitly cast from <see cref="T:System.Byte"/>[] to <see cref="T:System.Utf8String"/>.
            </summary>
            <param name="underlyingArray">The underlying array.</param>
        </member>
        <member name="M:System.Utf8String.op_Implicit(System.ReadOnlySpan{System.Byte})~System.Utf8String">
            <summary>
            Implicitly cast from <see cref="T:System.ReadOnlySpan`1"/> of <see cref="T:System.Byte"/> to <see cref="T:System.Utf8String"/>.
            </summary>
            <param name="underlyingArray">The underlying array.</param>
        </member>
        <member name="M:System.Utf8String.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Utf8String.op_Equality(System.Utf8String,System.Utf8String)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:System.Utf8String.op_Inequality(System.Utf8String,System.Utf8String)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="M:System.Utf8String.op_GreaterThan(System.Utf8String,System.Utf8String)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)"/>
        </member>
        <member name="M:System.Utf8String.op_LessThan(System.Utf8String,System.Utf8String)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)"/>
        </member>
        <member name="M:System.Utf8String.op_GreaterThanOrEqual(System.Utf8String,System.Utf8String)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)"/>
        </member>
        <member name="M:System.Utf8String.op_LessThanOrEqual(System.Utf8String,System.Utf8String)">
            <inheritdoc cref="M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)"/>
        </member>
        <member name="T:System.Timers.ValueStopwatch">
            <summary>
            Defines a stopwatch that uses <see langword="struct"/> instead of <see langword="class"/> to optimize the performance.
            </summary>
            <param name="startTimestamp">The timestamp value that is represented as a <see cref="T:System.Int64"/> value.</param>
        </member>
        <member name="M:System.Timers.ValueStopwatch.#ctor(System.Int64)">
            <summary>
            Defines a stopwatch that uses <see langword="struct"/> instead of <see langword="class"/> to optimize the performance.
            </summary>
            <param name="startTimestamp">The timestamp value that is represented as a <see cref="T:System.Int64"/> value.</param>
        </member>
        <member name="F:System.Timers.ValueStopwatch.TimestampToTicks">
            <summary>
            The read-only value that indicates the formula converting from timestamp to ticks.
            </summary>
        </member>
        <member name="P:System.Timers.ValueStopwatch.ElapsedTime">
            <summary>
            Try to get the elapsed time.
            </summary>
            <returns>The elapsed time, specified as a <see cref="T:System.TimeSpan"/> instance.</returns>
            <exception cref="T:System.InvalidOperationException">
            Throws when the current stopwatch is not active at present.
            </exception>
        </member>
        <member name="P:System.Timers.ValueStopwatch.NewInstance">
            <summary>
            Indicates a new instance. Use this property to start a new stopwatch instead of expressions like
            <see langword="new"/> <see cref="T:System.Timers.ValueStopwatch"/>() and <see langword="default"/>(<see cref="T:System.Timers.ValueStopwatch"/>).
            </summary>
        </member>
        <member name="F:System.Timers.ValueStopwatch._startTimestamp">
            <summary>
            The generated field declaration for parameter <c>startTimestamp</c>.
            </summary>
        </member>
        <member name="M:System.Timers.ValueStopwatch.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:System.Timers.ValueStopwatch.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="T:System.ValueComparison">
            <summary>
            Represents a list of methods that creates <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> and <see cref="T:System.Collections.Generic.IComparer`1"/> instances.
            </summary>
            <seealso cref="T:System.Collections.Generic.IEqualityComparer`1"/>
            <seealso cref="T:System.Collections.Generic.IComparer`1"/>
        </member>
        <member name="M:System.ValueComparison.Create``1(System.Func{``0,``0,System.Boolean},System.GetHashCodeFunc{``0})">
            <inheritdoc cref="M:System.ValueComparison.Create``1(System.EqualsHandler{``0},System.GetHashCodeHandler{``0})"/>
        </member>
        <member name="M:System.ValueComparison.Create``1(System.EqualsHandler{``0},System.GetHashCodeHandler{``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> instance via specified methods.
            </summary>
            <typeparam name="T">The type of the value to be compared.</typeparam>
            <param name="equals">The equals method handler.</param>
            <param name="getHashCode">The get hash code method handler.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> value serving as comparing equality rules.</returns>
        </member>
        <member name="M:System.ValueComparison.Create``1(System.Comparison{``0})">
            <inheritdoc cref="M:System.ValueComparison.Create``1(System.CompareHandler{``0})"/>
        </member>
        <member name="M:System.ValueComparison.Create``1(System.CompareHandler{``0})">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IComparer`1"/> instance via specified method.
            </summary>
            <typeparam name="T">The type of the value to be compared.</typeparam>
            <param name="compare">The compare method handler.</param>
            <returns>An <see cref="T:System.Collections.Generic.IComparer`1"/> value serving as comparing rules.</returns>
        </member>
        <member name="M:System.ValueComparison.CreateUnsafe``1(,)">
            <inheritdoc cref="M:System.ValueComparison.Create``1(System.EqualsHandler{``0},System.GetHashCodeHandler{``0})"/>
        </member>
        <member name="M:System.ValueComparison.CreateUnsafe``1(,)">
            <inheritdoc cref="M:System.ValueComparison.Create``1(System.EqualsHandler{``0},System.GetHashCodeHandler{``0})"/>
        </member>
        <member name="M:System.ValueComparison.CreateUnsafe``1()">
            <inheritdoc cref="M:System.ValueComparison.Create``1(System.CompareHandler{``0})"/>
        </member>
        <member name="M:System.ValueComparison.CreateUnsafe``1()">
            <inheritdoc cref="M:System.ValueComparison.Create``1(System.CompareHandler{``0})"/>
        </member>
        <member name="T:System.ActionRef`1">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`1">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`2">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`2">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`2">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`2">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`3">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`3">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`3">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`3">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`4">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`4">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`4">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`4">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`5">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`5">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`5">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`5">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`6">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`6">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`6">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`6">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`7">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`7">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`7">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`7">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`8">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`8">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`8">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`8">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`9">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`9">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`9">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`9">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`10">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`10">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`10">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`10">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`11">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`11">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`11">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`11">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`12">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`12">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`12">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`12">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`13">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`13">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`13">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`13">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`14">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`14">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`14">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`14">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`15">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`15">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`15">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`15">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`16">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`16">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.ActionRef`16">
            <summary>
            Encapsulates a method that returns void but pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.ActionRefReadOnly`16">
            <summary>
            Encapsulates a method that returns void but pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
        <member name="T:System.FuncRef`17">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a reference or a list of references.
            </summary>
        </member>
        <member name="T:System.FuncRefReadOnly`17">
            <summary>
            Encapsulates a method that returns a <typeparamref name="TResult"/> and pass in a read-only reference or a list of read-only references.
            </summary>
        </member>
    </members>
</doc>

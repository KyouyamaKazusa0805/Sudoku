<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Rendering</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Concepts.GridExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Concepts.Grid"/>.
            </summary>
            <seealso cref="T:Sudoku.Concepts.Grid"/>
        </member>
        <member name="M:Sudoku.Concepts.GridExtensions.Apply(Sudoku.Concepts.Grid@,Sudoku.Rendering.IRenderable)">
            <summary>
            <inheritdoc cref="M:Sudoku.Concepts.Grid.Apply(Sudoku.Analytics.Conclusion[])" path="/summary"/>
            </summary>
            <param name="this">The puzzle to be applied.</param>
            <param name="renderable">The renderable instance providing with conclusions to be applied.</param>
        </member>
        <member name="T:Sudoku.Rendering.ViewExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Rendering.View"/>.
            </summary>
            <seealso cref="T:Sudoku.Rendering.View"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewExtensions.UnknownOverlaps(Sudoku.Rendering.View,System.Int32)">
            <summary>
            Determines whether the specified <see cref="T:Sudoku.Rendering.View"/> stores several <see cref="T:Sudoku.Rendering.Nodes.BabaGroupViewNode"/>s,
            and at least one of it overlaps the specified cell.
            </summary>
            <param name="this">The view instance.</param>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether being overlapped.</returns>
        </member>
        <member name="T:Sudoku.Rendering.ColorColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="a">Indicates the color alpha raw values to be assigned.</param>
            <param name="r">Indicates the color red raw values to be assigned.</param>
            <param name="g">Indicates the color green raw values to be assigned.</param>
            <param name="b">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="a">Indicates the color alpha raw values to be assigned.</param>
            <param name="r">Indicates the color red raw values to be assigned.</param>
            <param name="g">Indicates the color green raw values to be assigned.</param>
            <param name="b">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.RawValue">
            <summary>
            Indicates the raw value.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.A">
            <summary>
            The generated property declaration for parameter <c>a</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.R">
            <summary>
            The generated property declaration for parameter <c>r</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.G">
            <summary>
            The generated property declaration for parameter <c>g</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.B">
            <summary>
            The generated property declaration for parameter <c>b</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.ColorIdentifier">
            <summary>
            Represents an identifier that is used for describing target rendering item.
            </summary>
            <completionlist cref="T:Sudoku.Rendering.WellKnownColorIdentifier"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Implicit(System.Int32)~Sudoku.Rendering.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/> to <see cref="T:Sudoku.Rendering.ColorIdentifier"/>.
            </summary>
            <param name="paletteId">The <see cref="T:System.Int32"/> instance indicating the palette ID.</param>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Implicit(Sudoku.Rendering.WellKnownColorIdentifierKind)~Sudoku.Rendering.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:Sudoku.Rendering.WellKnownColorIdentifierKind"/> to <see cref="T:Sudoku.Rendering.ColorIdentifier"/>.
            </summary>
            <param name="kind">The <see cref="T:Sudoku.Rendering.WellKnownColorIdentifierKind"/> instance.</param>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Equality(Sudoku.Rendering.ColorIdentifier,Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Inequality(Sudoku.Rendering.ColorIdentifier,Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Rendering.IRenderable">
            <summary>
            Represents a renderable instance that can be used for rendering, providing with base data structure to be used by drawing APIs.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.IRenderable.Conclusions">
            <summary>
            Indicates the conclusions that the step can be eliminated or assigned to.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.IRenderable.Views">
            <summary>
            Indicates the views of the step that may be displayed onto the screen using pictures.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.BabaGroupViewNode">
            <summary>
            Defines a view node that highlights for a Baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Utf8Char,System.Int16)">
            <summary>
            Defines a view node that highlights for a Baba group.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell used.</param>
            <param name="digitsMask">Indicates a mask that hold digits used.</param>
            <param name="unknownValueChar">Indicates the character that represents the baba group name.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.DigitsMaskString">
            <summary>
            Indicates the digits mask string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@,System.Utf8Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@,System.Int16@,System.Utf8Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.UnknownValueChar">
            <summary>
            The generated property declaration for parameter <c>unknownValueChar</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.DigitsMask">
            <summary>
            The generated property declaration for parameter <c>digitsMask</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.BasicViewNode">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BasicViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CandidateViewNode">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="candidate">Indicates the candidate highlighted.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CandidateViewNode.CandidateString">
            <summary>
            Indicates the candidate string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CandidateViewNode.Candidate">
            <summary>
            The generated property declaration for parameter <c>candidate</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CellViewNode">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="cell">Indicates the cell highlighted.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.RenderingMode">
            <summary>
            Indicates the mode that the bound view node will be displayed.
            The default value is <see cref="F:Sudoku.Rendering.RenderingMode.PencilmarkModeOnly"/>, which means only pencilmark mode the node will be displayed.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.ChuteViewNode">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="chuteIndex">Indicates the chute index. The value can be between 0 and 5.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.IsRow">
            <summary>
            Indicates whether the chute is in a row.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.HousesMask">
            <summary>
            <para>
            Indicates a <see cref="T:System.Int32"/> bits that represents for the houses used.
            The result mask is a 27-bit digit that represents every possible houses using cases.
            </para>
            <para>
            Please note that the first 9-bit always keep the zero value because they is reserved bits
            for block houses, but all chutes don't use them.
            </para>
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.ChuteIndex">
            <summary>
            The generated property declaration for parameter <c>chuteIndex</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CircleViewNode">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CircleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CircleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.DiamondViewNode">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.DiamondViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.DiamondViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.HeartViewNode">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HeartViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HeartViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.HouseViewNode">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="house">Indicates the house highlighted.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.HouseViewNode.House">
            <summary>
            The generated property declaration for parameter <c>house</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.IconViewNode">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.IconViewNode.Cell">
            <summary>
            The generated property declaration for parameter <c>cell</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.LinkViewNode">
            <summary>
            Defines a view node that highlights for a link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="inference">Indicates the inference type.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,Sudoku.Concepts.LockedTarget,Sudoku.Concepts.LockedTarget,Sudoku.Concepts.Inference)">
            <summary>
            Defines a view node that highlights for a link.
            </summary>
            <param name="identifier"><inheritdoc/></param>
            <param name="start">Indicates the start point.</param>
            <param name="end">Indicates the end point.</param>
            <param name="inference">Indicates the inference type.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.Inference@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.Start">
            <summary>
            The generated property declaration for parameter <c>start</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.End">
            <summary>
            The generated property declaration for parameter <c>end</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.Inference">
            <summary>
            The generated property declaration for parameter <c>inference</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.SquareViewNode">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.SquareViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.SquareViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.StarViewNode">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.StarViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.StarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.TriangleViewNode">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.TriangleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.TriangleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.PaletteIdColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.#ctor(System.Int32)">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.PaletteIdColorIdentifier.Value">
            <summary>
            The generated property declaration for parameter <c>value</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.RenderingMode">
            <summary>
            Represents a kind of the rendering mode.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.None">
            <summary>
            Indicates never displays the current node.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.DirectModeOnly">
            <summary>
            Indicates the view node is only displayed in direct mode. In the direct mode, candidates will be never displayed.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.PencilmarkModeOnly">
            <summary>
            Indicates the view node is only displayed in pencilmark mode. In the pencilmark mode, candidates will be displayed.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.BothDirectAndPencilmark">
            <summary>
            Indicates the view node will be displayed in both direct and pencilmark mode.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.View">
            <summary>
            Provides with a data structure that displays a view for basic information.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.BasicNodes">
            <summary>
            Indicates the basic nodes that the current data type stores.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.FigureNodes">
            <summary>
            Indicates icon nodes that the current data type stores.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.View.Add(Sudoku.Rendering.ViewNode)">
            <summary>
            Appends a new <see cref="T:Sudoku.Rendering.ViewNode"/> into the current collection if the specified argument isn't <see langword="null"/>.
            </summary>
            <param name="node">A possible node to be appended. If the value is <see langword="null"/>, it will be ignored.</param>
            <remarks>
            The reason why the parameter <paramref name="node"/> is nullable is that C# 12 feature "Collection Literals" use this method
            to append elements.
            </remarks>
        </member>
        <member name="M:Sudoku.Rendering.View.AddRange(System.Collections.Generic.IEnumerable{Sudoku.Rendering.ViewNode})">
            <summary>
            Adds a list of <see cref="T:Sudoku.Rendering.ViewNode"/>s into the collection.
            </summary>
            <param name="nodes">A list of <see cref="T:Sudoku.Rendering.ViewNode"/> instance.</param>
        </member>
        <member name="M:Sudoku.Rendering.View.Find(System.Predicate{Sudoku.Rendering.ViewNode})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the first occurrence within the entire <see cref="T:Sudoku.Rendering.View"/>.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1"/> delegate that defines the conditions of the element to search for.</param>
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found; otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfType``1">
            <summary>
            Filters the view nodes, only returns nodes of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the node.</typeparam>
            <returns>The target collection of element type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.View.OfTypeEnumerator`1">
            <summary>
            Represents an enumerator that iterates for <typeparamref name="T"/>-typed instances.
            </summary>
            <typeparam name="T">The type of the element node.</typeparam>
            <param name="view">The internal nodes.</param>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.#ctor(Sudoku.Rendering.View)">
            <summary>
            Represents an enumerator that iterates for <typeparamref name="T"/>-typed instances.
            </summary>
            <typeparam name="T">The type of the element node.</typeparam>
            <param name="view">The internal nodes.</param>
        </member>
        <member name="F:Sudoku.Rendering.View.OfTypeEnumerator`1._count">
            <summary>
            The total number of elements.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.View.OfTypeEnumerator`1._enumerator">
            <summary>
            The internal enumerator.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.OfTypeEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.Any(System.Predicate{`0})">
            <summary>
            Determines whether the collection of elements of type <typeparamref name="T"/> contains at least one element
            satisfying the specified condition.
            </summary>
            <param name="predicate">The condition.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.GetEnumerator">
            <summary>
            Creates an <see cref="T:Sudoku.Rendering.View.OfTypeEnumerator`1"/> instance.
            </summary>
            <returns>An <see cref="T:Sudoku.Rendering.View.OfTypeEnumerator`1"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.ToArray">
            <summary>
            Casts the iterator, enumerating all elements and converting into an array.
            </summary>
            <returns>An array of elements.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="T:Sudoku.Rendering.ViewNode">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Rendering.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier"><inheritdoc cref="P:Sudoku.Rendering.ViewNode.Identifier" path="/summary"/></param>
        </member>
        <member name="P:Sudoku.Rendering.ViewNode.Identifier">
            <summary>
            Indicates an instance providing with data for describing coloring.
            </summary>
            <remarks><b>
            We cannot change this property into a primary constructor parameter because here attribute <c>[StringMember]</c>
            is not supported by derived types, meaning derived types cannot detect this attribute
            because it's in primary constructor declaration by a base type.
            </b></remarks>
        </member>
        <member name="P:Sudoku.Rendering.ViewNode.TypeIdentifier">
            <summary>
            Indicates the inner identifier to distinct the different types that is derived from <see cref="T:Sudoku.Rendering.ViewNode"/>.
            </summary>
            <seealso cref="T:Sudoku.Rendering.ViewNode"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.op_Equality(Sudoku.Rendering.ViewNode,Sudoku.Rendering.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.op_Inequality(Sudoku.Rendering.ViewNode,Sudoku.Rendering.ViewNode)">
            <inheritdoc cref="M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)"/>
        </member>
        <member name="T:Sudoku.Rendering.WellKnownColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.#ctor(Sudoku.Rendering.WellKnownColorIdentifierKind)">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Normal">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Normal"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Auxiliary1">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary1"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Auxiliary2">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary2"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Auxiliary3">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary3"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Assignment">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Assignment"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.OverlappedAssignment">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.OverlappedAssignment"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Elimination">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Elimination"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Cannibalism">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Cannibalism"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Exofin">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Exofin"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Endofin">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Endofin"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Link">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Link"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet1">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet1"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet2">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet2"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet3">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet3"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet4">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet4"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet5">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet5"/>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="P:Sudoku.Rendering.WellKnownColorIdentifier.Kind">
            <summary>
            The generated property declaration for parameter <c>kind</c>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.WellKnownColorIdentifierKind">
            <summary>
            Represents a kind of well-known <see cref="T:Sudoku.Rendering.ColorIdentifier"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Rendering.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Normal">
            <summary>
            Indicates the normal color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary1">
            <summary>
            Indicates the first auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary2">
            <summary>
            Indicates the second auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary3">
            <summary>
            Indicates the third auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Assignment">
            <summary>
            Indicates the assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.OverlappedAssignment">
            <summary>
            Indicates the overlapped assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Elimination">
            <summary>
            Indicates the elimination color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Exofin">
            <summary>
            Indicates the exo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Endofin">
            <summary>
            Indicates the endo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Cannibalism">
            <summary>
            Indicates the cannibalism color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Link">
            <summary>
            Indicates the link color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet1">
            <summary>
            Indicates the first ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet2">
            <summary>
            Indicates the second ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet3">
            <summary>
            Indicates the third ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet4">
            <summary>
            Indicates the fourth ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet5">
            <summary>
            Indicates the fifth ALS recorded.
            </summary>
        </member>
    </members>
</doc>

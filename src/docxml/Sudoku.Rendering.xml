<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sudoku.Rendering</name>
    </assembly>
    <members>
        <member name="T:Sudoku.Rendering.ColorColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses color value (like type <c>System.Drawing.Color</c>) to distinct with colors.
            </summary>
            <param name="a">Indicates the color alpha raw values to be assigned.</param>
            <param name="r">Indicates the color red raw values to be assigned.</param>
            <param name="g">Indicates the color green raw values to be assigned.</param>
            <param name="b">Indicates the color blue raw values to be assigned.</param>
        </member>
        <member name="P:Sudoku.Rendering.ColorColorIdentifier.RawValue">
            <summary>
            Indicates the raw value.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Deconstruct(System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.ColorIdentifier">
            <summary>
            Represents an identifier that is used for describing target rendering item.
            </summary>
            <completionlist cref="T:Sudoku.Rendering.WellKnownColorIdentifier"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Equality(Sudoku.Rendering.ColorIdentifier,Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Inequality(Sudoku.Rendering.ColorIdentifier,Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Implicit(System.Int32)~Sudoku.Rendering.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/> to <see cref="T:Sudoku.Rendering.ColorIdentifier"/>.
            </summary>
            <param name="paletteId">The <see cref="T:System.Int32"/> instance indicating the palette ID.</param>
        </member>
        <member name="M:Sudoku.Rendering.ColorIdentifier.op_Implicit(Sudoku.Rendering.WellKnownColorIdentifierKind)~Sudoku.Rendering.ColorIdentifier">
            <summary>
            Implicit cast from <see cref="T:Sudoku.Rendering.WellKnownColorIdentifierKind"/> to <see cref="T:Sudoku.Rendering.ColorIdentifier"/>.
            </summary>
            <param name="kind">The <see cref="T:Sudoku.Rendering.WellKnownColorIdentifierKind"/> instance.</param>
        </member>
        <member name="T:Sudoku.Rendering.IRenderable">
            <summary>
            Represents a renderable instance that can be used for rendering, providing with base data structure to be used by drawing APIs.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.IRenderable.Conclusions">
            <summary>
            Indicates the conclusions that the step can be eliminated or assigned to.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.IRenderable.Views">
            <summary>
            Indicates the views of the step that may be displayed onto the screen using pictures.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.BabaGroupViewNode">
            <summary>
            Defines a view node that highlights for a Baba group.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.Cell">
            <summary>
            Indicates the cell used.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.DigitsMask">
            <summary>
            Indicates the digits used.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.UnknownValueChar">
            <summary>
            Indicates the character that represents the unknown range.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.BabaGroupViewNode.DigitsMaskString">
            <summary>
            Indicates the digits mask string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@,System.Utf8Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@,System.Int16@,System.Utf8Char@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BabaGroupViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.BasicViewNode">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.BasicViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a basic view node type that provides with basic displaying elements from a grid.
            </summary>
            <param name="identifier"><inheritdoc/></param>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CandidateViewNode">
            <summary>
            Defines a view node that highlights for a candidate.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CandidateViewNode.Candidate">
            <summary>
            Indicates the candidate highlighted.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CandidateViewNode.CandidateString">
            <summary>
            Indicates the candidate string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CandidateViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CellViewNode">
            <summary>
            Defines a view node that highlights for a cell.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.RenderingMode">
            <summary>
            Indicates the mode that the bound view node will be displayed.
            The default value is <see cref="F:Sudoku.Rendering.RenderingMode.PencilmarkModeOnly"/>, which means only pencilmark mode the node will be displayed.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.Cell">
            <summary>
            Indicates the cell highlighted.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.CellViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CellViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.ChuteViewNode">
            <summary>
            Defines a view node that highlights for a chute (i.e. 3 houses that is in a three blocks in a line).
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.IsRow">
            <summary>
            Indicates whether the chute is in a row.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.ChuteIndex">
            <summary>
            Indicates the chute index. The value can be between 0 and 5.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.ChuteViewNode.HousesMask">
            <summary>
            <para>
            Indicates a <see cref="T:System.Int32"/> bits that represents for the houses used.
            The result mask is a 27-bit digit that represents every possible houses using cases.
            </para>
            <para>
            Please note that the first 9-bit always keep the zero value because they is reserved bits
            for block houses, but all chutes don't use them.
            </para>
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.ChuteViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.CircleViewNode">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CircleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a circle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.CircleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.DiamondViewNode">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.DiamondViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a diamond view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.DiamondViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Grouped.CapsuleViewNode">
            <summary>
            Defines a capsule view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.CapsuleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Boolean)">
            <summary>
            Defines a capsule view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Grouped.CapsuleViewNode.IsHorizontal">
            <summary>
            Indicates whether the view node is horizontal.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.CapsuleViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.CapsuleViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.CapsuleViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.CapsuleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Grouped.DiagonalLinesViewNode">
            <summary>
            Defines a diagonal line pair view node. The node can only contain one in a <see cref="T:Sudoku.Rendering.View"/> because it is special.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.DiagonalLinesViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a diagonal line pair view node. The node can only contain one in a <see cref="T:Sudoku.Rendering.View"/> because it is special.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.DiagonalLinesViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.DiagonalLinesViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.DiagonalLinesViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.DiagonalLinesViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Grouped.GroupedViewNode">
            <summary>
            Defines a grouped view node.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="headCell">The head cell.</param>
            <param name="cells">The cells.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.GroupedViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Collections.Immutable.ImmutableArray{System.Int32})">
            <summary>
            Defines a grouped view node.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="headCell">The head cell.</param>
            <param name="cells">The cells.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Grouped.GroupedViewNode.HeadCell">
            <summary>
            Indicates the head cell. If the node does not use this property, assign -1.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Grouped.GroupedViewNode.Cells">
            <summary>
            Indicates the cells used. If the node does not use this property, assign <see cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>.
            </summary>
            <seealso cref="F:System.Collections.Immutable.ImmutableArray`1.Empty"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.GroupedViewNode.Deconstruct(System.Int32@,System.Collections.Immutable.ImmutableArray{System.Int32}@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Grouped.LeverViewNode">
            <summary>
            Defines a lever view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.LeverViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32,System.Int32)">
            <summary>
            Defines a lever view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Grouped.LeverViewNode.TailCell">
            <summary>
            Indicates the tail cell.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Grouped.LeverViewNode.CenterCell">
            <summary>
            Indicates the center cell.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.LeverViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.LeverViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.LeverViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.LeverViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Grouped.ObliqueLineViewNode">
            <summary>
            Defines an oblique line view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.ObliqueLineViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32)">
            <summary>
            Defines an oblique line view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Grouped.ObliqueLineViewNode.TailCell">
            <summary>
            Indicates the last cell.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.ObliqueLineViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.ObliqueLineViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.ObliqueLineViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.ObliqueLineViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Grouped.PyramidViewNode">
            <summary>
            Defines a pyramid view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.PyramidViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a pyramid view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.PyramidViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.PyramidViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.PyramidViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.PyramidViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Grouped.WindokuViewNode">
            <summary>
            Defines a windoku view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.WindokuViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a windoku view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.WindokuViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.WindokuViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.WindokuViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Grouped.WindokuViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.HeartViewNode">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HeartViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a heart view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HeartViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.HouseViewNode">
            <summary>
            Defines a view node that highlights for a house.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.HouseViewNode.House">
            <summary>
            Indicates the house highlighted.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.HouseViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.IconViewNode">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines an icon view node that applies to a cell, indicating the icon of the cell. The icons can be used on some sudoku variants.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)"/></param>
            <param name="cell">The cell.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.IconViewNode.Cell">
            <summary>
            Indicates the cell used.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.Deconstruct(System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.IconViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.LinkViewNode">
            <summary>
            Defines a view node that highlights for a link.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.Start">
            <summary>
            Indicates the start point.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.End">
            <summary>
            Indicates the end point.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.LinkViewNode.Inference">
            <summary>
            Indicates the inference type.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Deconstruct(Sudoku.Rendering.ColorIdentifier@,Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.LockedTarget@,Sudoku.Concepts.Inference@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.LinkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode">
            <summary>
            Represents a view node that describes a shape that is a mark, displayed between two adjacent cells.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32)">
            <summary>
            Represents a view node that describes a shape that is a mark, displayed between two adjacent cells.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.IsRow">
            <summary>
            Indicates whether two cells <see cref="P:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.Cell1"/> and <see cref="P:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.Cell2"/> are adjacent by row.
            If <see langword="true"/>, row; otherwise, column.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.Cell1">
            <summary>
            Indicates the first cell used.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.Cell2">
            <summary>
            Indicates the second cell used. This cell should be adjacent with <see cref="P:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.Cell1"/>.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.Deconstruct(System.Int32@,System.Int32@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AdjacentCellMarkViewNode.Deconstruct(System.Int32@,System.Int32@,System.Boolean@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.AverageBarViewNode">
            <summary>
            Defines an average bar view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AverageBarViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Boolean)">
            <summary>
            Defines an average bar view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.AverageBarViewNode.IsHorizontal">
            <summary>
            Indicates whether the view node is for horizontal one.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AverageBarViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AverageBarViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AverageBarViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.AverageBarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode">
            <summary>
            Defines a battenburg view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,Sudoku.Concepts.CellMap@)">
            <summary>
            Defines a battenburg view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Initializes a <see cref="T:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode"/> instance via the specified values.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="topLeftCell">The top-left cell used.</param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BattenburgViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode">
            <summary>
            Defines a view node that displays as a bar on shared border line of two adjacent cells.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32)">
            <summary>
            Defines a view node that displays as a bar on shared border line of two adjacent cells.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode.Cell1String">
            <summary>
            Indicates the cell 1 string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode.Cell2String">
            <summary>
            Indicates the cell 2 string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.BorderBarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.CellArrowViewNode">
            <summary>
            Defines a cell arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellArrowViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines a cell arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellArrowViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellArrowViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellArrowViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellArrowViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.CellCornerArrowViewNode">
            <summary>
            Defines a cell corner arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerArrowViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines a cell corner arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerArrowViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerArrowViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerArrowViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerArrowViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.CellCornerTriangleViewNode">
            <summary>
            Defines a triangle view node that is used in a cell.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerTriangleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines a triangle view node that is used in a cell.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerTriangleViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.CellCornerTriangleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode">
            <summary>
            Defines a clockface dot view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,Sudoku.Concepts.CellMap@,System.Boolean)">
            <summary>
            Defines a clockface dot view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Boolean)">
            <summary>
            Initializes a <see cref="T:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode"/> instance via the specified values.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="topLeftCell">The top-left cell.</param>
            <param name="isClockwise">Indicates whether the dot is marked as clockwise.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode.IsClockwise">
            <summary>
            Indicates whether the dot is marked as clockwise. If <see langword="true"/>, clockwise; otherwise, counterclockwise.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.ClockfaceDotViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.Direction">
            <summary>
            Defines a direction. This type provides both 4-direction values and 8-direction values.
            If you want to use by 4-direction notation, just use values:
            <list type="bullet">
            <item><see cref="F:Sudoku.Rendering.Nodes.Shapes.Direction.Up"/></item>
            <item><see cref="F:Sudoku.Rendering.Nodes.Shapes.Direction.Down"/></item>
            <item><see cref="F:Sudoku.Rendering.Nodes.Shapes.Direction.Left"/></item>
            <item><see cref="F:Sudoku.Rendering.Nodes.Shapes.Direction.Right"/></item>
            </list>
            Others are provided and used by 8-direction notation.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.None">
            <summary>
            Indicates the direction is none.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.TopLeft">
            <summary>
            Indicates the direction is top-left.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.TopCenter">
            <summary>
            Indicates the direction is top-center.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.Up">
            <summary>
            Indicates the up direction.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.TopRight">
            <summary>
            Indicates the direction is top-right.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.MiddleLeft">
            <summary>
            Indicates the direction is middle-left.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.Left">
            <summary>
            Indicates the left direction.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.MiddleRight">
            <summary>
            Indicates the direction is middle-right.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.Right">
            <summary>
            Indicates the right direction.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.BottomLeft">
            <summary>
            Indicates the direction is bottom-left.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.BottomCenter">
            <summary>
            Indicates the direction is bottom-center.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.Down">
            <summary>
            Indicates the down direction.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.Nodes.Shapes.Direction.BottomRight">
            <summary>
            Indicates the direction is bottom-right.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.DirectionExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Rendering.Nodes.Shapes.Direction"/>.
            </summary>
            <seealso cref="T:Sudoku.Rendering.Nodes.Shapes.Direction"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.DirectionExtensions.GetRotatingAngle(Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Gets the rotating angle. The result value is described using degrees.
            </summary>
            <param name="this">The direction.</param>
            <returns>The rotating angle (degrees).</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws when the value is not defined or <see cref="F:Sudoku.Rendering.Nodes.Shapes.Direction.None"/>.</exception>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.EmbeddedSkyscraperArrowViewNode">
            <summary>
            Defines an embedded skyscraper arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.EmbeddedSkyscraperArrowViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines an embedded skyscraper arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.EmbeddedSkyscraperArrowViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.EmbeddedSkyscraperArrowViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode">
            <summary>
            Represents with a greater-than sign view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Represents with a greater-than sign view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.IsGreaterThan">
            <summary>
            Indicates whether the current sign is a greater-than sign.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.Cell1String">
            <summary>
            Indicates the cell 1 string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.Cell2String">
            <summary>
            Indicates the cell 2 string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.GreaterThanSignViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode">
            <summary>
            Represents with a Kropki dot view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Represents with a Kropki dot view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.IsSolid">
            <summary>
            Indicates whether the dot will be displayed as solid one.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.Cell1String">
            <summary>
            Indicates the cell 1 string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.Cell2String">
            <summary>
            Indicates the cell 2 string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.KropkiDotViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode">
            <summary>
            Defines a neighbor sign view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Boolean)">
            <summary>
            Defines a neighbor sign view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode.IsFourDirections">
            <summary>
            Indicates whether the sign only records for 4 directions (top-left, top-right, bottom-left and bottom-right).
            If <see langword="true"/>, 4 directions; otherwise, 8 directions.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NeighborSignViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode">
            <summary>
            Defines a number label view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32,System.String)">
            <summary>
            Defines a number label view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.Label">
            <summary>
            Indicates the target value you want to display.
            </summary>
            <remarks><i>
            Please note that the target value is a <see cref="T:System.String"/> value. We don't limit you only input numbers <b>on purpose</b>.
            You can use instances of the current type to display what you want to display.
            </i></remarks>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.Cell1String">
            <summary>
            Indicates the cell 1 string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.Cell2String">
            <summary>
            Indicates the cell 2 string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.NumberLabelViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.PencilMarkViewNode">
            <summary>
            Defines a pencil-mark view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.PencilMarkViewNode.#ctor(System.Int32,System.String)">
            <summary>
            Defines a pencil-mark view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.PencilMarkViewNode.Notation">
            <summary>
            Indicates the notation.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.PencilMarkViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.PencilMarkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.PencilMarkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.PencilMarkViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.QuadrupleCellMarkViewNode">
            <summary>
            Defines a quadruple cell mark view node that lies on a 2x2 squared cells.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleCellMarkViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,Sudoku.Concepts.CellMap@)">
            <summary>
            Defines a quadruple cell mark view node that lies on a 2x2 squared cells.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleCellMarkViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Assigns properties with target values.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.Shapes.ShapeViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)" path="/param[@name='identifier']"/></param>
            <param name="topLeftCell">The top-left cell.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.QuadrupleCellMarkViewNode.Cells">
            <summary>
            Indicates the cells used.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode">
            <summary>
            Defines a quadruple hint view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,Sudoku.Concepts.CellMap@,System.String)">
            <summary>
            Defines a quadruple hint view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.String)">
            <summary>
            Initializes a <see cref="T:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode"/> instance via the specified values.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="topLeftCell">The top-left cell.</param>
            <param name="s">The string.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode.Hint">
            <summary>
            The hint string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleHintViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode">
            <summary>
            Defines a quadruple max arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,Sudoku.Concepts.CellMap@,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines a quadruple max arrow view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Initializes a <see cref="T:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode"/> instance via the specified values.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="topLeftCell">The top-left cell.</param>
            <param name="arrowDirection">The arrow direction.</param>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode.ArrowDirection">
            <summary>
            Indicates the arrow direction.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.QuadrupleMaxArrowViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.ShapeViewNode">
            <summary>
            Defines a shape view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.ShapeViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a shape view node.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode">
            <summary>
            Defines a single-cell mark view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines a single-cell mark view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode.Cell">
            <summary>
            Indicates the cell used.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode.Directions">
            <summary>
            Indicates the directions that the current mark points to. <see cref="F:Sudoku.Rendering.Nodes.Shapes.Direction.None"/> is for default case.
            Use <see cref="T:Sudoku.Rendering.Nodes.Shapes.Direction"/>.<see langword="operator"/> |(<see cref="T:Sudoku.Rendering.Nodes.Shapes.Direction"/>, <see cref="T:Sudoku.Rendering.Nodes.Shapes.Direction"/>)
            to combine multiple directions.
            </summary>
            <seealso cref="F:Sudoku.Rendering.Nodes.Shapes.Direction.None"/>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode.Deconstruct(System.Int32@,Sudoku.Rendering.Nodes.Shapes.Direction@)">
            <target name="method">
				<summary>
					Deconstruct the current instance into multiple values, which means you can use
					the value-tuple syntax to define your own deconstruction logic.
				</summary>
				<remarks>
					<para>
						For example, if you have defined a <see langword="static" /> deconstruction method <c>Deconstruct</c>
						in a <see langword="static class" />, without any return value:
						<code>
<![CDATA[
public static void Deconstruct(out string name, out int age)
{
    name = Name;
    age = Age;
}
]]>
						</code>
						The following code will be legal.
						<code>
<![CDATA[
// Use explicitly typed variables to get a deconstruction.
(string name, int age) = student;

// Or use the type inferring to omit the type of each variable having been deconstructed.
var (name, age) = student;

// Of course, you can also use the invocation to get values.
student.Deconstruct(out string name, out int age);
]]>
						</code>
					</para>
					<para>
						Deconstruction methods also allow you using deconstruction patterns, like this:
						<code>
<![CDATA[
if (student is (name: var name, age: >= 18))
{
    Console.WriteLine(name);
}
]]>
						</code>
					</para>
				</remarks>
			</target>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.SingleCellMarkViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.StarProductStarViewNode">
            <summary>
            Defines a star view node used by star product.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.StarProductStarViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines a star view node used by star product.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.StarProductStarViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.StarProductStarViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.StarProductStarViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.StarProductStarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.TriangleSumViewNode">
            <summary>
            Defines a triangle-sum view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.TriangleSumViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,Sudoku.Rendering.Nodes.Shapes.Direction)">
            <summary>
            Defines a triangle-sum view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.TriangleSumViewNode.IsComplement">
            <summary>
            Determines whether the shape is full complement.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.TriangleSumViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.TriangleSumViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.TriangleSumViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.TriangleSumViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.WheelViewNode">
            <summary>
            Defines a wheel view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.WheelViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.String)">
            <summary>
            Defines a wheel view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.WheelViewNode.DigitString">
            <summary>
            The digit string. The string is of length 4, as a four-number digit,
            describing 4 digits surrounding with the target cell in clockwise order.
            The first one is displayed on the top cell.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.WheelViewNode.CellString">
            <summary>
            Indicates the cell string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.WheelViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.WheelViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.WheelViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.WheelViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode">
            <summary>
            Defines a XV sign view node.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Defines a XV sign view node.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.IsX">
            <summary>
            Indicates whether the mark is <c>X</c>. If <see langword="true"/>, <c>X</c>; otherwise, <c>V</c>.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.Cell1String">
            <summary>
            Indicates the cell 1 string.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.Cell2String">
            <summary>
            Indicates the cell 2 string.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.Shapes.XvSignViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.SquareViewNode">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.SquareViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a square view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.SquareViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.StarViewNode">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.StarViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a star view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.StarViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.Nodes.TriangleViewNode">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.TriangleViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)">
            <summary>
            Defines a triangle view node.
            </summary>
            <param name="identifier"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='identifier']"/></param>
            <param name="cell"><inheritdoc cref="M:Sudoku.Rendering.Nodes.IconViewNode.#ctor(Sudoku.Rendering.ColorIdentifier,System.Int32)" path="/param[@name='cell']"/></param>
        </member>
        <member name="M:Sudoku.Rendering.Nodes.TriangleViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.PaletteIdColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses palette ID value to distinct with colors.
            </summary>
            <param name="value">The palette color ID value to be assigned. The color palette requires implementation of target projects.</param>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.PaletteIdColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.RenderingMode">
            <summary>
            Represents a kind of the rendering mode.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.None">
            <summary>
            Indicates never displays the current node.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.DirectModeOnly">
            <summary>
            Indicates the view node is only displayed in direct mode. In the direct mode, candidates will be never displayed.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.PencilmarkModeOnly">
            <summary>
            Indicates the view node is only displayed in pencilmark mode. In the pencilmark mode, candidates will be displayed.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.RenderingMode.BothDirectAndPencilmark">
            <summary>
            Indicates the view node will be displayed in both direct and pencilmark mode.
            </summary>
        </member>
        <member name="T:Sudoku.Rendering.View">
            <summary>
            Provides with a data structure that displays a view for basic information.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.View.#ctor">
            <summary>
            Creates an empty <see cref="T:Sudoku.Rendering.View"/> instance.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.View.#ctor(System.Collections.Generic.HashSet{Sudoku.Rendering.ViewNode})">
            <summary>
            Initializes a <see cref="T:Sudoku.Rendering.View"/> instance via the specified list as the raw value.
            </summary>
            <param name="nodes">The list as the raw value.</param>
        </member>
        <member name="P:Sudoku.Rendering.View.BasicNodes">
            <summary>
            Indicates the basic nodes that the current data type stores.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.FigureNodes">
            <summary>
            Indicates icon nodes that the current data type stores.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.ShapeViewNodes">
            <summary>
            Indicates the shape view nodes.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.GroupedViewNodes">
            <summary>
            Indicates the grouped view nodes.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.Empty">
            <summary>
            Indicates the empty instance.
            </summary>
        </member>
        <member name="M:Sudoku.Rendering.View.AddRange(System.Collections.Generic.IEnumerable{Sudoku.Rendering.ViewNode})">
            <summary>
            Adds a list of <see cref="T:Sudoku.Rendering.ViewNode"/>s into the collection.
            </summary>
            <param name="nodes">A list of <see cref="T:Sudoku.Rendering.ViewNode"/> instance.</param>
        </member>
        <member name="M:Sudoku.Rendering.View.Find(System.Predicate{Sudoku.Rendering.ViewNode})">
            <summary>
            Searches for an element that matches the conditions defined by the specified predicate,
            and returns the first occurrence within the entire <see cref="T:Sudoku.Rendering.View"/>.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1"/> delegate that defines the conditions of the element to search for.</param>
            <returns>
            The first element that matches the conditions defined by the specified predicate, if found; otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfType``1">
            <summary>
            Filters the view nodes, only returns nodes of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of the node.</typeparam>
            <returns>The target collection of element type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.View.op_BitwiseOr(Sudoku.Rendering.View,Sudoku.Rendering.ViewNode)">
            <summary>
            Adds a new node into the collection.
            </summary>
            <param name="originalView">The original view.</param>
            <param name="newNode">The new item to be added.</param>
            <returns>The reference that is same as the argument <paramref name="originalView"/>.</returns>
            <remarks>
            Please note that the operator is mutable one, which means the appending operation
            is based on the argument <paramref name="originalView"/>.
            </remarks>
        </member>
        <member name="M:Sudoku.Rendering.View.op_BitwiseOr(Sudoku.Rendering.View,Sudoku.Rendering.ViewNode[])">
            <inheritdoc cref="M:Sudoku.Rendering.View.op_BitwiseOr(Sudoku.Rendering.View,System.Collections.Generic.IEnumerable{Sudoku.Rendering.ViewNode})"/>
        </member>
        <member name="M:Sudoku.Rendering.View.op_BitwiseOr(Sudoku.Rendering.View,System.Collections.Generic.IEnumerable{Sudoku.Rendering.ViewNode})">
            <summary>
            Adds a serial of view nodes into the collection.
            </summary>
            <param name="originalView">The original view.</param>
            <param name="highlightedItems">The highlighted items.</param>
            <returns>The reference that is same as the argument <paramref name="originalView"/>.</returns>
            <remarks>
            Please note that the operator is mutable one, which means the appending operation
            is based on the argument <paramref name="originalView"/>.
            </remarks>
        </member>
        <member name="T:Sudoku.Rendering.View.OfTypeEnumerator`1">
            <summary>
            Represents an enumerator that iterates for <typeparamref name="T"/>-typed instances.
            </summary>
            <typeparam name="T">The type of the element node.</typeparam>
            <param name="view">The internal nodes.</param>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.#ctor(Sudoku.Rendering.View)">
            <summary>
            Represents an enumerator that iterates for <typeparamref name="T"/>-typed instances.
            </summary>
            <typeparam name="T">The type of the element node.</typeparam>
            <param name="view">The internal nodes.</param>
        </member>
        <member name="F:Sudoku.Rendering.View.OfTypeEnumerator`1._count">
            <summary>
            The total number of elements.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.View.OfTypeEnumerator`1._enumerator">
            <summary>
            The internal enumerator.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.View.OfTypeEnumerator`1.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current"/>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.Any(System.Predicate{`0})">
            <summary>
            Determines whether the collection of elements of type <typeparamref name="T"/> contains at least one element
            satisfying the specified condition.
            </summary>
            <param name="predicate">The condition.</param>
            <returns>A <see cref="T:System.Boolean"/> result indicating that.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.GetEnumerator">
            <summary>
            Creates an <see cref="T:Sudoku.Rendering.View.OfTypeEnumerator`1"/> instance.
            </summary>
            <returns>An <see cref="T:Sudoku.Rendering.View.OfTypeEnumerator`1"/> instance.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.ToArray">
            <summary>
            Casts the iterator, enumerating all elements and converting into an array.
            </summary>
            <returns>An array of elements.</returns>
        </member>
        <member name="M:Sudoku.Rendering.View.OfTypeEnumerator`1.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext"/>
        </member>
        <member name="T:Sudoku.Rendering.ViewExtensions">
            <summary>
            Provides with extension methods on <see cref="T:Sudoku.Rendering.View"/>.
            </summary>
            <seealso cref="T:Sudoku.Rendering.View"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewExtensions.UnknownOverlaps(Sudoku.Rendering.View,System.Int32)">
            <summary>
            Determines whether the specified <see cref="T:Sudoku.Rendering.View"/> stores several <see cref="T:Sudoku.Rendering.Nodes.BabaGroupViewNode"/>s,
            and at least one of it overlaps the specified cell.
            </summary>
            <param name="this">The view instance.</param>
            <param name="cell">The cell.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether being overlapped.</returns>
        </member>
        <member name="T:Sudoku.Rendering.ViewNode">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier">The <see cref="T:Sudoku.Rendering.ColorIdentifier"/> instance.</param>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.#ctor(Sudoku.Rendering.ColorIdentifier)">
            <summary>
            Defines a view node.
            </summary>
            <param name="identifier">The <see cref="T:Sudoku.Rendering.ColorIdentifier"/> instance.</param>
        </member>
        <member name="P:Sudoku.Rendering.ViewNode.Identifier">
            <summary>
            Indicates the identifier used.
            </summary>
        </member>
        <member name="P:Sudoku.Rendering.ViewNode.TypeIdentifier">
            <summary>
            Indicates the inner identifier to distinct the different types that is derived from <see cref="T:Sudoku.Rendering.ViewNode"/>.
            </summary>
            <seealso cref="T:Sudoku.Rendering.ViewNode"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Equals(System.Object)">
            <inheritdoc cref="M:System.Object.Equals(System.Object)"/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Equals(Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.op_Equality(Sudoku.Rendering.ViewNode,Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.ViewNode.op_Inequality(Sudoku.Rendering.ViewNode,Sudoku.Rendering.ViewNode)">
            <inheritdoc/>
        </member>
        <member name="T:Sudoku.Rendering.WellKnownColorIdentifier">
            <summary>
            Defines a <see cref="T:Sudoku.Rendering.ColorIdentifier"/> derived type that uses well-known kinds to distinct with colors.
            </summary>
            <param name="kind">The well-known identifier kind to be assigned.</param>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Normal">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Normal"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Auxiliary1">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary1"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Auxiliary2">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary2"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Auxiliary3">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary3"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Assignment">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Assignment"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.OverlappedAssignment">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.OverlappedAssignment"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Elimination">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Elimination"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Cannibalism">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Cannibalism"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Exofin">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Exofin"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Endofin">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Endofin"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.Link">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Link"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet1">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet1"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet2">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet2"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet3">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet3"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet4">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet4"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifier.AlmostLockedSet5">
            <inheritdoc cref="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet5"/>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.Equals(Sudoku.Rendering.ColorIdentifier)">
            <inheritdoc/>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Sudoku.Rendering.WellKnownColorIdentifier.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="T:Sudoku.Rendering.WellKnownColorIdentifierKind">
            <summary>
            Represents a kind of well-known <see cref="T:Sudoku.Rendering.ColorIdentifier"/> instance.
            </summary>
            <seealso cref="T:Sudoku.Rendering.ColorIdentifier"/>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Normal">
            <summary>
            Indicates the normal color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary1">
            <summary>
            Indicates the first auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary2">
            <summary>
            Indicates the second auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Auxiliary3">
            <summary>
            Indicates the third auxiliary color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Assignment">
            <summary>
            Indicates the assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.OverlappedAssignment">
            <summary>
            Indicates the overlapped assignment color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Elimination">
            <summary>
            Indicates the elimination color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Exofin">
            <summary>
            Indicates the exo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Endofin">
            <summary>
            Indicates the endo-fin color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Cannibalism">
            <summary>
            Indicates the cannibalism color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.Link">
            <summary>
            Indicates the link color.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet1">
            <summary>
            Indicates the first ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet2">
            <summary>
            Indicates the second ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet3">
            <summary>
            Indicates the third ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet4">
            <summary>
            Indicates the fourth ALS recorded.
            </summary>
        </member>
        <member name="F:Sudoku.Rendering.WellKnownColorIdentifierKind.AlmostLockedSet5">
            <summary>
            Indicates the fifth ALS recorded.
            </summary>
        </member>
    </members>
</doc>

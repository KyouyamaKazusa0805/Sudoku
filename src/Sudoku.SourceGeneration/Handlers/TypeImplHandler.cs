namespace Sudoku.SourceGeneration.Handlers;

internal static class TypeImplHandler
{
	private const string IsLargeStructurePropertyName = "IsLargeStructure";

	private const string OtherModifiersOnEqualsPropertyName = "OtherModifiersOnEquals";


	public static List<string>? Transform(GeneratorAttributeSyntaxContext gasc, CancellationToken _)
	{
		var typeSources = new List<string>();
		if (Object_Equals(gasc) is { } source)
		{
			typeSources.Add(source);
		}
		return typeSources;
	}

	public static void Output(SourceProductionContext spc, ImmutableArray<List<string>> value)
		=> spc.AddSource(
			"TypeImpl.g.cs",
			$"""
			{Banner.AutoGenerated}

			#nullable enable
			
			{string.Join("\r\n\r\n", from element in value from nested in element select nested)}
			"""
		);

	private static string? Object_Equals(GeneratorAttributeSyntaxContext gasc)
	{
		if (gasc is not
			{
				Attributes: [{ ConstructorArguments: [{ Value: int ctorArg }] } attribute],
				TargetSymbol: INamedTypeSymbol
				{
					TypeKind: var kind and (TypeKind.Struct or TypeKind.Class),
					Name: var typeName,
					IsRecord: false, // Records cannot manually overrides 'Equals' method.
					IsReadOnly: var isReadOnly,
					IsRefLikeType: var isRefStruct,
					TypeParameters: var typeParameters,
					ContainingNamespace: var @namespace,
					ContainingType: null // Must be top-level type.
				} type,
				SemanticModel.Compilation: var compilation
			})
		{
			return null;
		}

		if (!((TypeImplFlag)ctorArg).HasFlag(TypeImplFlag.Object_Equals))
		{
			return null;
		}

		var isLargeStructure = attribute.GetNamedArgument(IsLargeStructurePropertyName, false);
		var namespaceString = @namespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)["global::".Length..];
		var behavior = attribute.GetNamedArgument("EqualsBehavior", 0) switch
		{
			0 => (isRefStruct, kind) switch
			{
				(true, _) => EqualsBehavior.ReturnFalse,
				(_, TypeKind.Struct) => EqualsBehavior.IsCast,
				(_, TypeKind.Class) => EqualsBehavior.AsCast,
				_ => throw new InvalidOperationException("Invalid state.")
			},
			1 => EqualsBehavior.Throw,
			2 => EqualsBehavior.MakeAbstract,
			_ => throw new InvalidOperationException("Invalid state.")
		};
		var otherModifiers = attribute.GetNamedArgument<string>(OtherModifiersOnEqualsPropertyName) switch
		{
			{ } str => str.Split([' '], StringSplitOptions.RemoveEmptyEntries),
			_ => []
		};
		var typeArgumentsString = typeParameters is []
			? string.Empty
			: $"<{string.Join(", ", from typeParameter in typeParameters select typeParameter.Name)}>";
		var typeNameString = $"{typeName}{typeArgumentsString}";
		var fullTypeNameString = $"global::{namespaceString}.{typeNameString}";
		var typeKindString = kind switch
		{
			TypeKind.Class => "class",
			TypeKind.Struct => "struct",
			_ => throw new InvalidOperationException("Invalid state.")
		};
		var otherModifiersString = otherModifiers.Length == 0 ? string.Empty : $"{string.Join(" ", otherModifiers)} ";
		if (behavior == EqualsBehavior.MakeAbstract)
		{
			return $$"""
				namespace {{namespaceString}}
				{
					partial {{typeKindString}} {{typeNameString}}
					{
						/// <inheritdoc cref="object.Equals(object?)"/>
						public {{otherModifiersString}}abstract override bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? obj);
					}
				}
				""";
		}
		else
		{
			var inKeyword = isLargeStructure ? "in " : string.Empty;
			var expressionString = behavior switch
			{
				EqualsBehavior.ReturnFalse => "false",
				EqualsBehavior.IsCast => $"obj is {fullTypeNameString} comparer && Equals({inKeyword}comparer)",
				EqualsBehavior.AsCast => $"Equals(obj as {fullTypeNameString})",
				EqualsBehavior.Throw => """throw new global::System.NotSupportedException("This method is not supported or disallowed by author.")""",
				_ => throw new InvalidOperationException("Invalid state.")
			};
			var attributesMarked = isRefStruct
				? behavior == EqualsBehavior.ReturnFalse
					? """
					[global::System.ObsoleteAttribute("Calling this method is unexpected because author disallow you call this method on purpose.", true)]
					"""
					: """
					[global::System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute]
							[global::System.ObsoleteAttribute("Calling this method is unexpected because author disallow you call this method on purpose.", true)]
					"""
				: """
				[global::System.Runtime.CompilerServices.MethodImplAttribute(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
				""";
			var readOnlyModifier = kind == TypeKind.Struct && !isReadOnly ? "readonly " : string.Empty;
			var isDeprecated = attributesMarked.Contains("ObsoleteAttribute");
			var suppress0809 = isDeprecated ? "#pragma warning disable CS0809\r\n\t" : "\t";
			var enable0809 = isDeprecated ? "#pragma warning restore CS0809\r\n\t" : string.Empty;
			return $$"""
				namespace {{namespaceString}}
				{
				{{suppress0809}}partial {{typeKindString}} {{typeNameString}}
					{
						/// <inheritdoc cref="object.Equals(object?)"/>
						{{attributesMarked}}
						[global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{typeof(TypeImplHandler).FullName}}", "{{Value}}")]
						[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
						public {{otherModifiersString}}override {{readOnlyModifier}}bool Equals([global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? obj)
							=> {{expressionString}};
					}
				{{enable0809}}}
				""";
		}
	}
}

/// <summary>
/// Indicates the implementation flags.
/// </summary>
[Flags]
file enum TypeImplFlag
{
	Object_Equals = 1 << 0,
	Object_GetHashCode = 1 << 1,
	Object_ToString = 1 << 2,
	EqualityOperators = 1 << 3,
	ComparisonOperators = 1 << 4
}

/// <summary>
/// Represents a behavior for generating <see cref="object.Equals(object)"/> method.
/// </summary>
/// <see cref="object.Equals(object)"/>
file enum EqualsBehavior
{
	ReturnFalse,
	IsCast,
	AsCast,
	Throw,
	MakeAbstract
}

namespace Sudoku.SourceGeneration.Handlers;

/// <summary>
/// The generator handler for implicit fields.
/// </summary>
internal sealed class ImplicitFieldHandler : IIncrementalGeneratorAttributeHandler<ImplicitFieldCollectedResult>
{
	/// <inheritdoc/>
	public void Output(SourceProductionContext spc, ImmutableArray<ImplicitFieldCollectedResult> values)
	{
		var types = new List<string>();
		foreach (var group in values.GroupBy(static value => value.ContainingType, (IEqualityComparer<ITypeSymbol>)SymbolEqualityComparer.Default))
		{
			var type = group.Key;
			var @namespace = type.ContainingNamespace;
			var fieldDeclarations = new List<string>();
			foreach (var (_, property, readOnlyModifier) in group)
			{
				var readOnlyKeyword = readOnlyModifier ? "readonly " : string.Empty;
				fieldDeclarations.Add(
					$$"""
					/// <summary>
							/// Indicates the backing field of property <see cref="{{property.Name}}"/>.
							/// </summary>
							/// <seealso cref="{{property.Name}}"/>
							private {{readOnlyKeyword}}{{property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{property.Name.ToCamelCase()}};
					"""
				);
			}

			var typeKindString = type switch
			{
				{ TypeKind: TypeKind.Class, IsRecord: true } => "record",
				{ TypeKind: TypeKind.Class } => "class",
				{ TypeKind: TypeKind.Struct, IsRecord: true } => "record struct",
				{ TypeKind: TypeKind.Struct } => "struct",
				{ TypeKind: TypeKind.Interface } => "interface"
			};
			types.Add(
				$$"""
				namespace {{@namespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)["global::".Length..]}}
				{
					partial {{typeKindString}} {{type.Name}}
					{
						{{string.Join("\r\n\r\n\t\t", fieldDeclarations)}}
					}
				}
				"""
			);
		}

		spc.AddSource(
			"ImplicitField.g.cs",
			$$"""
			// <auto-generated/>

			#nullable enable

			{{string.Join("\r\n\r\n", types)}}
			"""
		);
	}

	/// <inheritdoc/>
	public ImplicitFieldCollectedResult? Transform(GeneratorAttributeSyntaxContext gasc, CancellationToken cancellationToken)
	{
		if (gasc is not
			{
				TargetSymbol: IPropertySymbol { ContainingType: var containingType } property,
				Attributes: [{ NamedArguments: var namedArgs }],
				TargetNode: PropertyDeclarationSyntax { Parent: TypeDeclarationSyntax { Modifiers: var modifiers and not [] } }
			})
		{
			return null;
		}

		if (!modifiers.Any(SyntaxKind.PartialKeyword))
		{
			return null;
		}

		var readOnlyKeyword = namedArgs.TryGetValueOrDefault<bool>("RequiredReadOnlyModifier", out var r) && r;
		return new(containingType, property, readOnlyKeyword);
	}
}

/// <include file='../../global-doc-comments.xml' path='g/csharp11/feature[@name="file-local"]/target[@name="class" and @when="extension"]'/>
file static class Extensions
{
	/// <summary>
	/// Converts the current instance into its camel casing.
	/// </summary>
	/// <param name="this">The string.</param>
	/// <returns>The camel-cased string.</returns>
	public static string ToCamelCase(this string @this) => $"_{char.ToLower(@this[0])}{@this[1..]}";
}

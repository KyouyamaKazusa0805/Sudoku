---
description: Direct Locked Candidates
---

# 直观区块

接着，我们要学习的技巧是区块。这里需要注意一点。区块的英文名 Locked Candidates 是自带复数形式的。就是说，它的名字自身就是以复数形式表示。

## 宫区块（Pointing） <a href="#pointing" id="pointing"></a>

<figure><img src="../.gitbook/assets/image (6) (1) (1) (1).png" alt="" width="375"><figcaption><p>宫区块 + 行排除</p></figcaption></figure>

如图所示，我们可以看到，`b5` 此时只有两个空格。很明显我们能够知道的是，虽然我们并不能确定 8 究竟是 `r4c5` 填入，还是 `r5c5` 填入，但是由于它们俩同一列，所以 `c5` 填 8 的机会一定给到了 `r4c5` 和 `r5c5` 里的其一。

> 我们可以把 `r4c5` 和 `r5c5` 简写为 `r45c5`，即将 `r` 部分和 `c` 部分里一致的内容提出来，然后合并另一组的所有元素。同理，如果是 `r6c8` 和 `r6c9`，则可以合并为 `r6c89`。

而正是因为 `r45c5` 里有一个 8，所以 `r7c5` 肯定是不能填 8 的。换言之，如果 `r7c5` 是 8 之后，它会直接使得 `r45c5` 两个单元格都不能填 8（毕竟同一列），进而造成 `b5` 没有机会填 8，产生矛盾。

那么，我们记住这个结论。下面我们接着看 `r7`。`r7` 里此时还有三个空格尚未填入数字。首先，`r7c2` 不能是 8（上面有一个 8），其次是 `r7c5` 不能填 8。为啥不能填 8？因为刚才我们得到了它不是 8 的结论。这样一来，8 就只能填在 `r7c1` 了。所以，`r7c1 = 8` 是本题的结论。

这个技巧仍然是行排除。不过，它和一般的行排除有所不同：它用到了一处比较隐晦的临时推出结论——`r7c5` 不能是 8，也可以记作 `r7c5 <> 8`。

我们把其中 `r45c5` 的数字 8 称为关于数字 8 的**宫区块**（Pointing）。这个结构叫做区块，而宫区块的“宫”表示的是它是通过 `b5` 而得到的。

可以从结构里发现，它比较容易观察，所以和宫排除一样，我优先讲了宫区块。下面我们来看另外一则宫区块的例子，希望你自己理解它。

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1).png" alt="" width="375"><figcaption><p>宫区块 + 列排除</p></figcaption></figure>

这个例子稍微麻烦一些。

> 宫区块在外国也叫**区块类型 1**（Locked Candidates Type 1）。

## 行列区块（Claiming） <a href="#claiming" id="claiming"></a>

下面我们来看一则利用**行列区块**（Claiming）的例子。

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1).png" alt="" width="375"><figcaption><p>行列区块 + 列排除</p></figcaption></figure>

这是一则比较难以理解的例子。

如图所示。我们优先可以得到的是，`r1` 里能填入 8 的位置只有 `r1c23`。这回我们把宫区块的思维反过来。因为 `r1` 里能填入 8 的位置只有 `r1c23`，而它俩刚好位于同一个宫里，所以 `b1` 的其他任何位置都没有机会填入 8。

没错，我指的是 `r3c3` 这个单元格。当我们得到这个结论时，我们可以利用它，配合 `r5c1` 和 `r7c7` 的数字 8 来判别得到 `c3` 填入 8 的唯一位置：`r1c3`。所以，`r1c3 = 8` 是本题的结论。

在这个例子里，`r1c23` 的数字 8 就可以被我们称为行列区块。具体一点，它是下在 `r1` 的区块，所以叫**行区块**。

> “`r1c23` 的数字 8”可以简单记作 `r1c23(8)`，使用小括号来表示我们结构里要表达的那个数字。
>
> 另外，行列区块在外国也叫**区块类型 2**（Locked Candidates Type 2）。

下面我们再来看另外一个例子。和前面的例子都不同，这次我们不借用排除填数，而是唯一余数。

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt="" width="375"><figcaption><p>行列区块 + 唯一余数</p></figcaption></figure>

如图所示。我们优先可以得到的是 `r1c45(4)` 形成行区块，并得到 `r3c5 <> 4` 的结论。得到这一点后，我们通过唯一余数技巧，针对于 `r3c5` 进行数数操作。最终我们可以发现，2 是唯一一个可以填入的可能，所以 `r3c5 = 2` 便是这个技巧的结论。

这是配合唯一余数的使用方式。不论是从推理上来说，还是观察上来说，都会稍微有点难度一些。

## 组合区块（Cascading Locked Candidates） <a href="#cascading-locked-candidates" id="cascading-locked-candidates"></a>

有些时候，行列区块并不是很容易看到，所以我们可能会使用两个宫区块来代替。下面我们来看一个例子。

<figure><img src="../.gitbook/assets/image (7) (1).png" alt="" width="375"><figcaption><p>引例</p></figcaption></figure>

如图所示。这是一个行区块。我们暂且忽略它后面的逻辑。

我们可以试着看下右边两个宫里数字 7 的分布。使用宫排除的思路看 `b8` 和 `b9` 填入 7 的位置，我们发现它刚好构成了一个这样的形式：

<figure><img src="../.gitbook/assets/image (8) (1).png" alt="" width="375"><figcaption><p>组合区块</p></figcaption></figure>

我们使用排除，可以得到 7 的可填位置在 `b8` 和 `b9` 里只有这四处位置。按照排列组合的思维，我们可以知道的是，7 只有两种排列：

* `r7c5` 和 `r9c7` 同时是 7；
* `r7c7` 和 `r9c5` 同时是 7。

只有这两种情况。于是我们就知道，在 `r7` 和 `r9` 这两行里，7 的位置一定落在绿色的四个 7 里，所以别处无法填 7，于是这三处位置照样是可以去掉 7 的。

我们把这个图里使用的逻辑称为**组合区块**（Cascading Locked Candidates）。行列排除在部分情况下可以被组合区块所代替。当然，不能代替的情况也是存在的，因为它依赖的是边上的两个宫。如果边上这两个宫不能构成这样的形状的话，理解上就比较棘手了。

这个技巧只提供一种观察视角，专门用来代替找一些复杂的行列区块。当你找不着的时候，可以试试这个技巧；但是一般情况下，这个技巧都并不是很实用，所以只提供给你思维上的拓展。

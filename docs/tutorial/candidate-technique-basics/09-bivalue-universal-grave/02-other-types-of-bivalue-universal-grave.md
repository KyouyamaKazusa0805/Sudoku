---
description: Other Types of Bi-value Universal Grave
---

# 全双值格致死解法的其他类型

下面我们针对于全双值格致死解法的逻辑进行推广。

## 类型 2 <a href="#type-2" id="type-2"></a>

<figure><img src="../../.gitbook/assets/image (87).png" alt="" width="375"><figcaption><p>类型 2 例子</p></figcaption></figure>

如图所示。这次我们把前文一个三值格的规矩给破坏了。这回倒好，直接一连给了仨。

这里我们就不能单纯通过数格子数量和出现次数来决定了。可以看到，例如 `c5` 里数字 7 一共出现了四次（位于 `r1369c5` 四个单元格里）。按照这个技巧的推理逻辑，我们是要保证数字只能行列宫出现恰好两次的。四次未免太多了点；而且，单独看行的话，比如 `r1` 里，数字 7 又只有三个（即 `r1c356` 三个单元格）。这比较容易陷入误区导致无法继续。

在这里我们需要让思维灵活起来。我们不是想让最终形态称为行列宫两次吗？那么我们不妨把这些“异常的”数字 7 全给拿掉，再来看看是不是真的会产生矛盾。有一个很好的消息是，当我们去掉了 `{r16c5, r3c4}(7)` 后，似乎 7 的异常状态消失了：这些 7 会影响到 `r136`、`c45` 和 `b25` 这七个区域。而恰好的是，这七个区域下，当我们干掉了他们仨之后，数字 7 的出现次数恰好均变为了两次。

这非常好。因为后续的矛盾需要依赖这两个特征。而删除了这三个位置的 7 确实引发了两个特征的形成，所以后续造成的矛盾也会正常得出。也就是说，假设这三个单元格都没有候选数 7 时，矛盾会得到。因此，这三个单元格里必须有一个位置是填 7 的。

那么，我们仍旧借用类似 XYZ-Wing、唯一矩形类型 5 那般的删数方式，可以得到这个题的结论是 `r3c5 <> 7` 的结论。

由于它用到的是前文类似唯一矩形类型 2 的逻辑，所以我们也约定俗成把他叫做类型 2。

这里要提及一个术语。我们把这三个候选数（全部去掉后会造成如此矛盾的候选数）称为**真数**（True Candidate）。不过需要注意的是，真数的定义指的是他们不可同时全部去掉，所以其中至少会产出一个数是“真”的，并不是说他们全都为“真”；当然，真数也适用于前面一篇文章里的那个类型（类型 1）。那个类型里只有一个真数：那个对的数字就是真数。

## 类型 3 <a href="#type-3" id="type-3"></a>

下面我们来看类型 3 的内容。

稍微需要说的是，由于这个技巧产生的真数可能形状非常特殊，因此它并不完全和之前介绍的唯一矩形这些技巧一样那么像。在理解上，这个技巧的类型 3 会更加抽象一些。所以我会尽量解释得比较清楚一些。

### 显性数组 <a href="#with-naked-subset" id="with-naked-subset"></a>

先来看显性数组的部分。

<figure><img src="../../.gitbook/assets/image (88).png" alt="" width="375"><figcaption><p>类型 3 例子</p></figcaption></figure>

如图所示。因为是开胃菜，所以这个例子还是很像的。

显然，这个题里一共有两个真数：`r2c7(7)` 和 `r6c7(8)`，而且还在同一个列上。第一次见到这种情况，会不会觉得有些神奇？

按照前面给的那么多次重复的推理，这个题肯定也不例外的是，他们不能同时从盘面里消失；因此必须要拿出一个数，和 `r7c7` 配对形成显性数对。因此，`c7` 里的任何其他的单元格都不能再填 7 或 8。于是这个题的结论就是 `r1c7 <> 7` 和 `r5c7 <> 8` 了。

这还是很简单的。我们再来看一个例子。

<figure><img src="../../.gitbook/assets/image (89).png" alt="" width="375"><figcaption><p>第二个类型 3 的例子</p></figcaption></figure>

如图所示。这次也只是把显性数对变成了显性三数组而已，真数仍旧只有两个，于是配合 `r6c19` 形成关于 1、4、6 的显性三数组。

于是删数也就有了：`r6c2 <> 6` 和 `r6c6 <> 4`。

最后我们再来看一个我说得比较抽象的例子。

<figure><img src="../../.gitbook/assets/image (90).png" alt="" width="375"><figcaption><p>第三个类型 3 的例子</p></figcaption></figure>

如图所示。这个题很明显长得就很抽象。真数有三个：俩 4 和一个 2。比较容易想到的是，三个真数肯定不能同时消失，因此至少有一个数是对的。在我们得到这一点后，2 和 4 具体填什么就显得没那么重要了。虽然看着很奇怪，但是我们注意到，`r6c5` 这个单元格只有候选数 2 和 4，它好像在诉说着什么。

是的，这三个真数肯定会拿出一个数字和这个单元格配合形成显性数对。不论是 2 也好，还是 4 也罢，最终填的数字也只能有 2 或 4 的身影，这便促成了和 `r6c5` 配对的效果。

于是，同行上的其余单元格都不能填 2 或 4，所以这个题的结论就是 `r6c1 <> 2` 和 `r6c2 <> 4`。

### 隐性数组 <a href="#with-hidden-subset" id="with-hidden-subset"></a>

下面我们来看隐性的版本。

<figure><img src="../../.gitbook/assets/image (91).png" alt="" width="375"><figcaption><p>第四个类型 3 的例子</p></figcaption></figure>

如图所示。这回我们倒过来看。

可以看到，`c3` 里，数字 3 和 9 总体只能出现在 `r367c3` 里。因为真数要占用单元格，又为了确保 3 和 9 能填到 `c3` 之中，那么不论怎么填写，`r3c3` 都不可能有填 4 的任何机会。为什么呢？因为我们要确保 3 和 9 填写得当，那么 `r367c3` 必须要留出两个空格填他们俩。而真数也是必不可少的，所以至少真数也需要占用一个 `r67c3` 的其中一个单元格。

那还能说什么呢？最低最极限的情况也得必须是三个单元格肯定会被用完，根本轮不到 `r3c3` 填 4。所以，结论就直接出现了：`r3c3 <> 4`。

这看起来并不像是隐性数组。但是只看 3 和 9 的话，你可以把他理解为这样：真数只能出一个，然后剩下两个单元格构成隐性数对结构。

下面我们再来看一个例子。

<figure><img src="../../.gitbook/assets/image (92).png" alt="" width="375"><figcaption><p>第五个类型 3 的例子</p></figcaption></figure>

如图所示。我们也把规格搞成三数组来看看有什么不一样的地方。

这个题的真数有三个，不过其中两个比较特殊：他们位于同一个单元格里。这是可以的，因为我们最终确保的是矛盾的出现，即所有数字在行列宫里出现两次即可；如果一个格子有四个候选数的话，只要这个题确实存在真数的模式引发矛盾，那么我们就有正常的取数逻辑把其中的两个给拿出来。

我们确保三个真数后，我们发现，数字 1、6、8 只能填在 `r5c1367` 四个单元格里，而且其中有两个单元格还得放真数。我们为了确保 1、6、8 正常填入 `r5`，那么必须要拿出其中三个单元格填 1、6、8；而剩下的那个单元格必须是真数。所以真数单元格的两个的其一必须是真数，另外一个单元格会配合 `r5c16` 形成关于 1、6、8 的隐性三数组。

那么，`r5c6` 就没有机会填别的数字了。因此，`r5c6 <> 9`。

不得不说，这个技巧的隐性数组的推理模式略显别扭。不过事实是，类型 3 在实战做题之中出现频次也极低（甚至比四阶鱼还要低），因此就当图个乐学习一下就好。

## 类型 4 <a href="#type-4" id="type-4"></a>

下面我们来看类型 4。

<figure><img src="../../.gitbook/assets/image (93).png" alt="" width="375"><figcaption><p>类型 4 例子</p></figcaption></figure>

如图所示。类型 4 和类型 3 也一样，因为长相特殊所以极为罕见。这个题有 4 个真数。分布的位置也极为特殊：`r12c7` 两个单元格里分别有俩真数安插在里面；然后还有一个关于数字 9 的共轭对。

很显然，共轭对代表了两个单元格必须填一个 9；而另外一个单元格呢？必须填真数。因为四个真数必须有至少一个是正确的填数，否则会引发矛盾。所以，这两个单元格要么共轭对要么真数，根本就轮不到其他数字的填写。因此，这个题的结论就是 `r1c7 <> 4` 和 `r2c7 <> 1`。

## 全双值格致死解法 + n <a href="#bug-plus-n" id="bug-plus-n"></a>

因为这个技巧涉及的是全盘所有单元格，所以真数可能位于全盘的任意位置。因此，真数一旦至少存在两个，就可能位于盘面的任意位置。在前面的例子里，我们看到的均是在同一个行列宫里的情况（当然，类型 2 除外；不过类型 2 比较简单，所以就算不在同行列宫看起来也容易，毕竟只用得上同一种数字）。

下面我们来看的是，将类型 2 推广成不同数字，却仍旧可以按类型 2 引发删数的特殊例子。

### 全双值格致死解法 + 2 <a href="#bug-plus-2" id="bug-plus-2"></a>

<figure><img src="../../.gitbook/assets/image (94).png" alt="" width="375"><figcaption><p>BUG + 2</p></figcaption></figure>

如图所示。先来看最基础的例子。这个题有两个真数，两个真数位于同一个行（也可以说是同一个宫），但是，一边是 5 一边是 9，数字不相同。

> 有人问，这俩真数是怎么得到的？为什么不能是选取左边的 9 右边的 5？如果你知道我之前说的，删掉才引发矛盾的这个意思的话，你就会知道，我们这里看的是最终引发矛盾的形态需要怎么选取数字组合才能出现。显然左边选取 5 才是合理的：因为左边的单元格 `r6c4` 里，数字 5 在列上有三个，9 只有两个。如果选取 9 的话必然形不成矛盾（去掉之后 9 就剩一个了）。

那么，这里的两个删数结论是怎么来的呢？先看左边 `r6c4 <> 9` 的结论。因为真数的结论是至少有一个是正确的填数，那么我们干脆就列举一下两个真数最终的填数形态。

* 如果 `r6c4 = 5`，则因为这个单元格已经填了数字，所以 `r6c4 <> 9` 客观成立；
* 如果 `r6c6 = 9`，则因为同行上不能填入相同数字，所以 `r6c4 <> 9` 仍然成立。

我们并不关心最终真数有几个填写进去了，但是这样列举出来肯定是能保证至少有一个成立就能得到删数结论的。所以，`r6c4 <> 9` 是正确的删数。同理，`r6c6 <> 5` 也是一样的。

我们把这种类似类型 2 但是因为数字种类不相同的情况，在这个技巧里有个特殊的叫法：“+ n 逻辑”。有多少个真数，我们就往这个技巧的技巧名上加上数字几。比如这个题我们就叫“全双值格致死解法 + 2”。当然，我们之前说过它的简称是 BUG，所以也可以记作 BUG + 2。

当然，类型 1 按照这个命名规则也可以记作 BUG + 1。只是说就一个真数也谈不上类似于类型 2 了。这个理解方式还是得看人。

下面我们再来看一个 BUG + 2 的例子。

<figure><img src="../../.gitbook/assets/image (95).png" alt="" width="375"><figcaption><p>真数全在一个单元格的 BUG + 2</p></figcaption></figure>

这次我们再特殊一些。真数的数字不同，但在同一个单元格里。

这非常特殊。删数的话就肯定是这个单元格里其他不是真数的全部数字了。因为两个真数必须有一个是正确的填数。既然在同一个单元格里，就轮不到填入别的数字。所以 `r5c4 <> 45` 是这个题的结论。

### 全双值格致死解法 + 3 <a href="#bug-plus-3" id="bug-plus-3"></a>

有 + 2 就肯定有 + 3。甚至更多。既然不缺例子，那么我们干脆就多看点例子。虽然他们的推理完全和前面的一样。

<figure><img src="../../.gitbook/assets/image (96).png" alt="" width="375"><figcaption><p>BUG + 3</p></figcaption></figure>

如图所示。我们列举一下三个真数的填数情况：

* 如果 `r4c8 = 1`，则由于同列不能填入重复数字，所以 `r7c8 <> 1` 成立；
* 如果 `r7c8 = 6`，则由于同一个单元格已经填入数字，所以 `r7c8 <> 1` 显然成立；
* 如果 `r7c9 = 1`，则由于同行上不能填入重复数字，所以 `r7c8 <> 1` 仍然成立。

所以，所有的三种情况都能得到相同的结论，因此，`r7c8 <> 1` 是成立的。

### 全双值格致死解法 + 4 <a href="#bug-plus-4" id="bug-plus-4"></a>

<figure><img src="../../.gitbook/assets/image (97).png" alt="" width="375"><figcaption><p>BUG + 4</p></figcaption></figure>

如图所示。这个例子也是一样的，所以就不推理了，自己看下吧。

### 全双值格致死解法 + 5 <a href="#bug-plus-5" id="bug-plus-5"></a>

对于真数过多的情况，一般的题就很少能遇得到了。所以和前面一样，图个乐。看一下就行。

<figure><img src="../../.gitbook/assets/image (98).png" alt="" width="375"><figcaption><p>BUG + 5</p></figcaption></figure>

如图所示。这个题有 5 个真数。

### 全双值格致死解法 + 6 <a href="#bug-plus-6" id="bug-plus-6"></a>

<figure><img src="../../.gitbook/assets/image (99).png" alt="" width="375"><figcaption><p>BUG + 6</p></figcaption></figure>

如图所示。这个题有 6 个真数，其中有两个真数位于同一个单元格里。

### 全双值格致死解法 + 7 <a href="#bug-plus-7" id="bug-plus-7"></a>

<figure><img src="../../.gitbook/assets/image (100).png" alt="" width="375"><figcaption><p>BUG + 7</p></figcaption></figure>

如图所示。这个题有 7 个真数，已经达到了比较极限的地步了。

在我目前本地的题库里，7 个真数已经算是非常极限的存在了。我没有 8 个及以上数量的真数、还能引发删数的例子了。但是，理论上他们是应该存在的。

## 全双值格致死解法 XZ 逻辑 <a href="#bug-xz" id="bug-xz"></a>

下面我们来看一个前面技巧都不曾提及的一种类型：**全双值格致死解法 XZ 逻辑**（Bi-value Universal Grave XZ Rule，简称 BUG-XZ）。

<figure><img src="../../.gitbook/assets/image (101).png" alt="" width="375"><figcaption><p>BUG-XZ 例子</p></figcaption></figure>

如图所示。这个题相较于前面各种牛鬼蛇神来说，它反而比较纯粹：它就两个真数。只不过比较特殊的是，这两个真数数字不一样，而且也不在同一个行列宫（互相都看不见对方）。

这也能构成删数吗？是的。不过这里我们要借用一个额外的辅助双值格来完成这个事情：`r1c8`。这个单元格位于其中一个真数的所在列上，且这个双值格只有 2 和 4，恰好跟真数用到的这两个数字是一样的。

如果我们把思路串起来，就能简单得到类似于 XY-Wing 那般的逻辑：

* 如果 `r4c1 = 2`，则删数 `r1c1 <> 2` 直接成立；
* 如果 `r2c8 = 4`，则由于同列的 `r1c8` 仅存在两个候选数 2 和 4，所以 `r1c8 = 2`，照样可以得到 `r1c1 <> 2` 的结论。

也就是说，它迂回了一个步骤，即延长了 `r2c8(4)` 这个真数填写的逻辑。这个题的结论是 `r1c1 <> 2`。比较容易理解。我们再来看一个例子。

<figure><img src="../../.gitbook/assets/image (102).png" alt="" width="375"><figcaption><p>另外一个 BUG-XZ 的例子</p></figcaption></figure>

如图所示。和前面的推理是一样的，这里就不解释了。

## 一些极限问题 <a href="#questions-about-extremum-values" id="questions-about-extremum-values"></a>

最后在结束这篇文章之前，我们先来看两个理论层面的问题。

### 问题 1：这个技巧最少由多少个单元格构成？ <a href="#question-1" id="question-1"></a>

我直接说答案吧。全双值格致死解法最少需要 11 个单元格构成。这个数比较难以从数字本身上猜出来，因为它非常不像是一些常见常数那样容易被“触发”到。

下面我们来看一个例子，只有 11 个真数的情况。

<figure><img src="../../.gitbook/assets/image (103).png" alt="" width="375"><figcaption><p>只有 11 个单元格的情况</p></figcaption></figure>

如图所示。

另外，如果想问最多需要多少个单元格构成的话，很抱歉的是，这个结果我也不清楚。这个结果可能需要借助一下计算机的计算或复杂的理论证明才能得到。这个问题就交由给读者自己思考了。不过目前来看，似乎这个数会比较大，我甚至遇到过二三十个空格的情况。下面给的这个例子具有 32 个空格，也可以使用这个技巧；不过它需要一些特殊手段删掉一些候选数才能走到这里。

<figure><img src="../../.gitbook/assets/image (104).png" alt="" width="375"><figcaption><p>有 32 个空格的大型 BUG 类型 1</p></figcaption></figure>

### 问题 2：这个技巧最多可以有多少个真数构成？ <a href="#question-2" id="question-2"></a>

这个也很抱歉。这个我也不清楚。如果你要问的是可以提供删数的，那么目前发现的是 7 个；8 个及以上的暂时没有验证过，它应该理论是存在的，只不过因为极为罕见的缘故很难被我们遇到。我曾使用计算机跑了一周，得到了若干题目里，其中只有三道 BUG + 7 的题目，暂时没有更大的情况。

不过要注意的是，如果真数存在且能提供删数的盘面状态下，也可能存在其他技巧，例如 XY-Wing 什么的。如果你使用了他们，甚至可能会绕过这个技巧的使用，上述我提及的三个例子都是不能绕过的，或者需要不是当前学到的知识点的、更复杂的技巧才能绕过。

另外，如果你只是想挑战下极限，单纯想看看这个技巧可以有多少个真数，而并不要求真数是否生效，也不考虑是否被其他技巧所代替的话（就单纯想看看真数的最大情况），这个数虽然我也不清楚它的精确值，但它目前发现到的最大值，也比 7 大，甚至大很多。

下面给各位展示的是一个 BUG + 94 的例子。

<figure><img src="../../.gitbook/assets/image (105).png" alt="" width="375"><figcaption><p>BUG + 94 例子</p></figcaption></figure>

我依稀记得我还有一个 BUG + 106 的例子，但是我怎么找都找不到了。等我找到了我再来替换掉这个例子吧。

至此，这个技巧的内容也就全部结束了。下面我们将进入到新的技巧学习之中去。
